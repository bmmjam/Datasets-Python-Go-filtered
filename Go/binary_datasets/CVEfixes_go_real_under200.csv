code,cwe_id,num_lines,is_vul
"
BEGIN {
	FS = ""\t""
	if (!iso_table) iso_table = ""iso3166.tab""
	if (!zone_table) zone_table = ""zone.tab""
	if (!want_warnings) want_warnings = -1
	while (getline <iso_table) {
		iso_NR++
		if ($0 ~ /^
		if (NF != 2) {
			printf ""%s:%d: wrong number of columns\n"", \
				iso_table, iso_NR >>""/dev/stderr""
			status = 1
		}
		cc = $1
		name = $2
		if (cc !~ /^[A-Z][A-Z]$/) {
			printf ""%s:%d: invalid country code `%s'\n"", \
				iso_table, iso_NR, cc >>""/dev/stderr""
			status = 1
		}
		if (cc <= cc0) {
			if (cc == cc0) {
				s = ""duplicate"";
			} else {
				s = ""out of order"";
			}
			printf ""%s:%d: country code `%s' is %s\n"", \
				iso_table, iso_NR, cc, s \
				>>""/dev/stderr""
			status = 1
		}
		cc0 = cc
		if (name2cc[name]) {
			printf ""%s:%d: `%s' and `%s' have the sname name\n"", \
				iso_table, iso_NR, name2cc[name], cc \
				>>""/dev/stderr""
			status = 1
		}
		name2cc[name] = cc
		cc2name[cc] = name
		cc2NR[cc] = iso_NR
	}
	zone_table = ""zone.tab""
	cc0 = """"
	while (getline <zone_table) {
		zone_NR++
		if ($0 ~ /^
		if (NF != 3 && NF != 4) {
			printf ""%s:%d: wrong number of columns\n"", \
				zone_table, zone_NR >>""/dev/stderr""
			status = 1
		}
		cc = $1
		coordinates = $2
		tz = $3
		comments = $4
		if (cc < cc0) {
			printf ""%s:%d: country code `%s' is out of order\n"", \
				zone_table, zone_NR, cc >>""/dev/stderr""
			status = 1
		}
		cc0 = cc
		if (tz2cc[tz]) {
			printf ""%s:%d: %s: duplicate TZ column\n"", \
				zone_table, zone_NR, tz >>""/dev/stderr""
			status = 1
		}
		tz2cc[tz] = cc
		tz2comments[tz] = comments
		tz2NR[tz] = zone_NR
		if (cc2name[cc]) {
			cc_used[cc]++
		} else {
			printf ""%s:%d: %s: unknown country code\n"", \
				zone_table, zone_NR, cc >>""/dev/stderr""
			status = 1
		}
		if (coordinates !~ /^[-+][0-9][0-9][0-5][0-9][-+][01][0-9][0-9][0-5][0-9]$/ \
		    && coordinates !~ /^[-+][0-9][0-9][0-5][0-9][0-5][0-9][-+][01][0-9][0-9][0-5][0-9][0-5][0-9]$/) {
			printf ""%s:%d: %s: invalid coordinates\n"", \
				zone_table, zone_NR, coordinates >>""/dev/stderr""
			status = 1
		}
	}
	for (tz in tz2cc) {
		if (cc_used[tz2cc[tz]] == 1) {
			if (tz2comments[tz]) {
				printf ""%s:%d: unnecessary comment `%s'\n"", \
					zone_table, tz2NR[tz], tz2comments[tz] \
					>>""/dev/stderr""
				status = 1
			}
		} else {
			if (!tz2comments[tz]) {
				printf ""%s:%d: missing comment\n"", \
					zone_table, tz2NR[tz] >>""/dev/stderr""
				status = 1
			}
		}
	}
	FS = "" ""
}
{
	tz = """"
	if ($1 == ""Zone"") tz = $2
	if ($1 == ""Link"") {
		
		
		src = $2
		dst = $3
		while ((i = index(src, ""/""))) src = substr(src, i+1)
		while ((i = index(dst, ""/""))) dst = substr(dst, i+1)
		if (src != dst) tz = $3
	}
	if (tz && tz ~ /\//) {
		if (!tz2cc[tz]) {
			printf ""%s: no data for `%s'\n"", zone_table, tz \
				>>""/dev/stderr""
			status = 1
		}
		zoneSeen[tz] = 1
	}
}
END {
	for (tz in tz2cc) {
		if (!zoneSeen[tz]) {
			printf ""%s:%d: no Zone table for `%s'\n"", \
				zone_table, tz2NR[tz], tz >>""/dev/stderr""
			status = 1
		}
	}
	if (0 < want_warnings) {
		for (cc in cc2name) {
			if (!cc_used[cc]) {
				printf ""%s:%d: warning:"" \
					""no Zone entries for %s (%s)\n"", \
					iso_table, cc2NR[cc], cc, cc2name[cc]
			}
		}
	}
	exit status
}
",CWE-252,160.0,1
"Linux ACPI Custom Control Method How To
=======================================
Written by Zhang Rui <rui.zhang@intel.com>
Linux supports customizing ACPI control methods at runtime.
Users can use this to
1. override an existing method which may not work correctly,
   or just for debugging purposes.
2. insert a completely new method in order to create a missing
   method such as _OFF, _ON, _STA, _INI, etc.
For these cases, it is far simpler to dynamically install a single
control method rather than override the entire DSDT, because kernel
rebuild/reboot is not needed and test result can be got in minutes.
Note: Only ACPI METHOD can be overridden, any other object types like
      ""Device"", ""OperationRegion"", are not recognized.
Note: The same ACPI control method can be overridden for many times,
      and it's always the latest one that used by Linux/kernel.
Note: To get the ACPI debug object output (Store (AAAA, Debug)),
      please run ""echo 1 > /sys/module/acpi/parameters/aml_debug_output"".
1. override an existing method
   a) get the ACPI table via ACPI sysfs I/F. e.g. to get the DSDT,
      just run ""cat /sys/firmware/acpi/tables/DSDT > /tmp/dsdt.dat""
   b) disassemble the table by running ""iasl -d dsdt.dat"".
   c) rewrite the ASL code of the method and save it in a new file,
   d) package the new file (psr.asl) to an ACPI table format.
      Here is an example of a customized \_SB._AC._PSR method,
      DefinitionBlock ("""", ""SSDT"", 1, """", """", 0x20080715)
      {
	External (ACON)
	Method (\_SB_.AC._PSR, 0, NotSerialized)
	{
		Store (""In AC _PSR"", Debug)
		Return (ACON)
	}
      }
      Note that the full pathname of the method in ACPI namespace
      should be used.
      And remember to use ""External"" to declare external objects.
   e) assemble the file to generate the AML code of the method.
      e.g. ""iasl psr.asl"" (psr.aml is generated as a result)
   f) mount debugfs by ""mount -t debugfs none /sys/kernel/debug""
   g) override the old method via the debugfs by running
      ""cat /tmp/psr.aml > /sys/kernel/debug/acpi/custom_method""
2. insert a new method
   This is easier than overriding an existing method.
   We just need to create the ASL code of the method we want to
   insert and then follow the step c) ~ g) in section 1.
3. undo your changes
   The ""undo"" operation is not supported for a new inserted method
   right now, i.e. we can not remove a method currently.
   For an overrided method, in order to undo your changes, please
   save a copy of the method original ASL code in step c) section 1,
   and redo step c) ~ g) to override the method with the original one.
Note: We can use a kernel with multiple custom ACPI method running,
      But each individual write to debugfs can implement a SINGLE
      method override. i.e. if we want to insert/override multiple
      ACPI methods, we need to redo step c) ~ g) for multiple times.
",CWE-264,69.0,1
"// Transport Security Layer (TLS)
// Copyright (c) 2003-2004 Carlos Guzman Alvarez
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
// 
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
using System;
using System.Globalization;
using System.IO;
using Mono.Security.Protocol.Tls.Handshake;
using Mono.Security.Protocol.Tls.Handshake.Server;
namespace Mono.Security.Protocol.Tls
{
	internal class ServerRecordProtocol : RecordProtocol
	{
		
		public ServerRecordProtocol(
			Stream			innerStream, 
			ServerContext	context) : base(innerStream, context)
		{
		}
		
		
		public override HandshakeMessage GetMessage(HandshakeType type)
		{
			// Create and process the record message
			HandshakeMessage msg = this.createServerHandshakeMessage(type);
			return msg;
		}
		
		
		protected override void ProcessHandshakeMessage(TlsStream handMsg)
		{
			HandshakeType		handshakeType	= (HandshakeType)handMsg.ReadByte();
			HandshakeMessage	message			= null;
			// Read message length
			int length = handMsg.ReadInt24();
			// Read message data
			byte[] data = new byte[length];
			handMsg.Read(data, 0, length);
			// Create and process the server message
			message = this.createClientHandshakeMessage(handshakeType, data);
			message.Process();
			// Update the last handshake message
			this.Context.LastHandshakeMsg = handshakeType;
			// Update session
			if (message != null)
			{
				message.Update();
				this.Context.HandshakeMessages.WriteByte ((byte) handshakeType);
				this.Context.HandshakeMessages.WriteInt24 (length);
				this.Context.HandshakeMessages.Write (data, 0, data.Length);
			}
		}
		
		
		private HandshakeMessage createClientHandshakeMessage(
			HandshakeType type, byte[] buffer)
		{
			switch (type)
			{
				case HandshakeType.ClientHello:
					return new TlsClientHello(this.context, buffer);
				case HandshakeType.Certificate:
					return new TlsClientCertificate(this.context, buffer);
				case HandshakeType.ClientKeyExchange:
					return new TlsClientKeyExchange(this.context, buffer);
				case HandshakeType.CertificateVerify:
					return new TlsClientCertificateVerify(this.context, buffer);
				case HandshakeType.Finished:
					return new TlsClientFinished(this.context, buffer);
				default:
					throw new TlsException(
						AlertDescription.UnexpectedMessage,
						String.Format(CultureInfo.CurrentUICulture,
							""Unknown server handshake message received ({0})"", 
							type.ToString()));
			}
		}
		private HandshakeMessage createServerHandshakeMessage(
			HandshakeType type)
		{
			switch (type)
			{
				case HandshakeType.HelloRequest:
					this.SendRecord(HandshakeType.ClientHello);
					return null;
				case HandshakeType.ServerHello:
					return new TlsServerHello(this.context);
				case HandshakeType.Certificate:
					return new TlsServerCertificate(this.context);
				case HandshakeType.ServerKeyExchange:
					return new TlsServerKeyExchange(this.context);
				case HandshakeType.CertificateRequest:
					return new TlsServerCertificateRequest(this.context);
				case HandshakeType.ServerHelloDone:
					return new TlsServerHelloDone(this.context);
				case HandshakeType.Finished:
					return new TlsServerFinished(this.context);
				default:
					throw new InvalidOperationException(""Unknown server handshake message type: "" + type.ToString() );					
			}
		}
		
	}
}
",CWE-295,157.0,1
"// Transport Security Layer (TLS)
// Copyright (c) 2003-2004 Carlos Guzman Alvarez
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
// 
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
using System;
using System.Globalization;
using System.IO;
using Mono.Security.Protocol.Tls.Handshake;
using Mono.Security.Protocol.Tls.Handshake.Client;
namespace Mono.Security.Protocol.Tls
{
	internal class ClientRecordProtocol : RecordProtocol
	{
		
		public ClientRecordProtocol(
			Stream			innerStream, 
			ClientContext	context) : base(innerStream, context)
		{
		}
		
		
		public override HandshakeMessage GetMessage(HandshakeType type)
		{
			HandshakeMessage msg = this.createClientHandshakeMessage(type);
			return msg;
		}
		
		
		protected override void ProcessHandshakeMessage(TlsStream handMsg)
		{
			HandshakeType		handshakeType	= (HandshakeType)handMsg.ReadByte();
			HandshakeMessage	message			= null;
			DebugHelper.WriteLine("">>>> Processing Handshake record ({0})"", handshakeType);
			// Read message length
			int length = handMsg.ReadInt24();
			// Read message data
			byte[] data = null;
			if (length > 0)
			{
				data = new byte[length];
				handMsg.Read (data, 0, length);
			}
			// Create and process the server message
			message = this.createServerHandshakeMessage(handshakeType, data);
			if (message != null)
			{
				message.Process();
			}
			// Update the last handshake message
			this.Context.LastHandshakeMsg = handshakeType;
			// Update session
			if (message != null)
			{
				message.Update();
				this.Context.HandshakeMessages.WriteByte ((byte) handshakeType);
				this.Context.HandshakeMessages.WriteInt24 (length);
				if (length > 0) 
				{
					this.Context.HandshakeMessages.Write (data, 0, data.Length);
				}
			}
		}
		
		
		private HandshakeMessage createClientHandshakeMessage(HandshakeType type)
		{
			switch (type)
			{
				case HandshakeType.ClientHello:
					return new TlsClientHello(this.context);
				case HandshakeType.Certificate:
					return new TlsClientCertificate(this.context);
				case HandshakeType.ClientKeyExchange:
					return new TlsClientKeyExchange(this.context);
				case HandshakeType.CertificateVerify:
					return new TlsClientCertificateVerify(this.context);
				case HandshakeType.Finished:
					return new TlsClientFinished(this.context);
				default:
					throw new InvalidOperationException(""Unknown client handshake message type: "" + type.ToString() );
			}
		}
		private HandshakeMessage createServerHandshakeMessage(
			HandshakeType type, byte[] buffer)
		{
			ClientContext context = (ClientContext)this.context;
			var last = context.LastHandshakeMsg;
			switch (type)
			{
				case HandshakeType.HelloRequest:
					if (context.HandshakeState != HandshakeState.Started)
					{
						context.HandshakeState = HandshakeState.None;
						// re-negotiation will occur at next read/write
						// (i.e. not during an existing encode/decode op)
					}
					else
					{
						this.SendAlert(
							AlertLevel.Warning,
							AlertDescription.NoRenegotiation);
					}
					return null;
				case HandshakeType.ServerHello:
					if (last != HandshakeType.HelloRequest)
						break;
					return new TlsServerHello(this.context, buffer);
					// Optional
				case HandshakeType.Certificate:
					if (last != HandshakeType.ServerHello)
						break;
					return new TlsServerCertificate(this.context, buffer);
					// Optional
				case HandshakeType.ServerKeyExchange:
					// only for RSA_EXPORT
					if (last == HandshakeType.Certificate && context.Current.Cipher.IsExportable)
						return new TlsServerKeyExchange(this.context, buffer);
					break;
					// Optional
				case HandshakeType.CertificateRequest:
					if (last == HandshakeType.ServerKeyExchange || last == HandshakeType.Certificate)
						return new TlsServerCertificateRequest(this.context, buffer);
					break;
				case HandshakeType.ServerHelloDone:
					if (last == HandshakeType.CertificateRequest || last == HandshakeType.Certificate || last == HandshakeType.ServerHello)
						return new TlsServerHelloDone(this.context, buffer);
					break;
				case HandshakeType.Finished:
					// depends if a full (ServerHelloDone) or an abbreviated handshake (ServerHello) is being done
					bool check = context.AbbreviatedHandshake ? (last == HandshakeType.ServerHello) : (last == HandshakeType.ServerHelloDone);
					// ChangeCipherSpecDone is not an handshake message (it's a content type) but still needs to be happens before finished
					if (check && context.ChangeCipherSpecDone) {
						context.ChangeCipherSpecDone = false;
						return new TlsServerFinished (this.context, buffer);
					}
					break;
					
				default:
					throw new TlsException(
						AlertDescription.UnexpectedMessage,
						String.Format(CultureInfo.CurrentUICulture,
							""Unknown server handshake message received ({0})"", 
							type.ToString()));
			}
			throw new TlsException (AlertDescription.HandshakeFailiure, String.Format (""Protocol error, unexpected protocol transition from {0} to {1}"", last, type));
		}
		
	}
}
",CWE-295,203.0,1
"// Copyright 2012 Samuel Stauffer. All rights reserved.
// Use of this source code is governed by a 3-clause BSD
// license that can be found in the LICENSE file.
package socks
import (
	""net""
	""time""
)
type proxiedConn struct {
	conn       net.Conn
	remoteAddr *proxiedAddr
	boundAddr  *proxiedAddr
}
func (c *proxiedConn) Read(b []byte) (int, error) {
	return c.conn.Read(b)
}
func (c *proxiedConn) Write(b []byte) (int, error) {
	return c.conn.Write(b)
}
func (c *proxiedConn) Close() error {
	return c.conn.Close()
}
func (c *proxiedConn) LocalAddr() net.Addr {
	if c.boundAddr != nil {
		return c.boundAddr
	}
	return c.LocalAddr()
}
func (c *proxiedConn) RemoteAddr() net.Addr {
	if c.remoteAddr != nil {
		return c.remoteAddr
	}
	return c.RemoteAddr()
}
func (c *proxiedConn) SetDeadline(t time.Time) error {
	return c.conn.SetDeadline(t)
}
func (c *proxiedConn) SetReadDeadline(t time.Time) error {
	return c.conn.SetReadDeadline(t)
}
func (c *proxiedConn) SetWriteDeadline(t time.Time) error {
	return c.conn.SetWriteDeadline(t)
}
",CWE-835,55.0,1
"package lz4
// 
// 
// 
import ""C""
import (
	""fmt""
	""unsafe""
)
// p gets a char pointer to the first byte of a []byte slice
func p(in []byte) *C.char {
	if len(in) == 0 {
		return (*C.char)(unsafe.Pointer(nil))
	}
	return (*C.char)(unsafe.Pointer(&in[0]))
}
// clen gets the length of a []byte slice as a char *
func clen(s []byte) C.int {
	return C.int(len(s))
}
// Uncompress with a known output size. len(out) should be equal to
// the length of the uncompressed out.
func Uncompress(in, out []byte) (err error) {
	read := int(C.LZ4_uncompress(p(in), p(out), clen(out)))
	if read != len(in) {
		err = fmt.Errorf(""uncompress read %d bytes should have read %d"",
			read, len(in))
	}
	return
}
// CompressBound calculates the size of the output buffer needed by
// Compress. This is based on the following macro:
//
// 
//      ((unsigned int)(isize) > (unsigned int)LZ4_MAX_INPUT_SIZE ? 0 : (isize) + ((isize)/255) + 16)
func CompressBound(in []byte) int {
	return len(in) + ((len(in) / 255) + 16)
}
// Compress compresses in and puts the content in out. len(out)
// should have enough space for the compressed data (use CompressBound
// to calculate). Returns the number of bytes in the out slice.
func Compress(in, out []byte) (outSize int, err error) {
	outSize = int(C.LZ4_compress_limitedOutput(p(in), p(out), clen(in), clen(out)))
	if outSize == 0 {
		err = fmt.Errorf(""insufficient space for compression"")
	}
	return
}
",CWE-787,57.0,1
"package scrypt
import (
	""bytes""
	""crypto/rand""
	""crypto/sha256""
	""encoding/binary""
	""log""
	""code.google.com/p/go.crypto/scrypt""
)
// EncryptPassphrase returns a keylen_bytes+60 bytes of encrypted text
// from the input passphrase.
// It runs the scrypt function for this.
func EncryptPassphrase(passphrase string, keylen_bytes int) (key []byte, err error) {
	// Generate salt
	salt := generateSalt()
	// Set params
	var N int32 = 16384
	var r int32 = 8
	var p int32 = 1
	// Generate key
	key, err = scrypt.Key([]byte(passphrase),
		salt,
		int(N), // Must be a power of 2 greater than 1
		int(r),
		int(p), // r*p must be < 2^30
		keylen_bytes)
	if err != nil {
		log.Fatalf(""Error in encrypting passphrase: %s\n"", err)
		return
	}
	// Appending the salt
	key = append(key, salt...)
	// Encoding the params to be stored
	buf := new(bytes.Buffer)
	for _, elem := range [3]int32{N, r, p} {
		err = binary.Write(buf, binary.LittleEndian, elem)
		if err != nil {
			log.Fatalf(""binary.Write failed: %s\n"", err)
			return
		}
		key = append(key, buf.Bytes()...)
		buf.Reset()
	}
	// appending the sha-256 of the entire header at the end
	hash_digest := sha256.New()
	hash_digest.Write(key)
	if err != nil {
		log.Fatalf(""hash_digest.Write failed: %s\n"", err)
		return
	}
	hash := hash_digest.Sum(nil)
	key = append(key, hash...)
	return
}
// VerifyPassphrase takes the passphrase and the target_key to match against.
// And returns a boolean result whether it matched or not
func VerifyPassphrase(passphrase string, keylen_bytes int, target_key []byte) (result bool, err error) {
	// Get the master_key
	target_master_key := target_key[:keylen_bytes]
	// Get the salt
	salt := target_key[keylen_bytes:48]
	// Get the params
	var N, r, p int32
	err = binary.Read(bytes.NewReader(target_key[48:52]), // byte 48:52 for N
		binary.LittleEndian,
		&N)
	if err != nil {
		log.Fatalf(""binary.Read failed for N: %s\n"", err)
		return
	}
	err = binary.Read(bytes.NewReader(target_key[52:56]), // byte 52:56 for r
		binary.LittleEndian,
		&r)
	if err != nil {
		log.Fatalf(""binary.Read failed for r: %s\n"", err)
		return
	}
	err = binary.Read(bytes.NewReader(target_key[56:60]), // byte 56:60 for p
		binary.LittleEndian,
		&p)
	if err != nil {
		log.Fatalf(""binary.Read failed for p: %s\n"", err)
		return
	}
	var source_master_key []byte
	source_master_key, err = scrypt.Key([]byte(passphrase),
		salt,
		int(N), // Must be a power of 2 greater than 1
		int(r),
		int(p), // r*p must be < 2^30
		keylen_bytes)
	if err != nil {
		log.Fatalf(""Error in encrypting passphrase: %s\n"", err)
		return
	}
	target_hash := target_key[60:]
	// Doing the sha-256 checksum at the last because we want the attacker
	// to spend as much time possible cracking
	hash_digest := sha256.New()
	_, err = hash_digest.Write(target_key[:60])
	if err != nil {
		log.Fatalf(""hash_digest.Write failed: %s\n"", err)
		return
	}
	source_hash := hash_digest.Sum(nil)
	result = bytes.Equal(source_master_key, target_master_key) &&
		bytes.Equal(target_hash, source_hash)
	return
}
func generateSalt() (salt []byte) {
	salt = make([]byte, 16)
	_, err := rand.Read(salt)
	if err != nil {
		log.Fatalf(""Error in generating salt: %s\n"", err)
		return
	}
	return
}
",CWE-208,134.0,1
"$Id: Changelog.txt,v 1.43 2015/08/06 14:05:49 nanard Exp $
VERSION 1.5:
2016/01/13:
	add ""notification"" mode (command 5)
2015/08/06:
	disable multicast loop
	add -f command line option to filter for a specific device type
VERSION 1.4:
2015/08/06:
	added command 0 (version)
2015/07/21:
	set multicast TTL to 2 by default and configurable
2015/05/27:
	support larger buffer size (useful for type 3 requests)
VERSION 1.3:
2014/12/05:
	clean up select call()
	fix non blocking write to sockets
2014/12/04:
	Fixes removing of devices on ssdp:byebye
	handle ssdp:update messages
2014/11/28:
	revert ""listen on only 1 IPv4 if only 1 interface is specified""
	because it prevents broadcast messages to be received
	Change the list of LAN addresses/interfaces (code taken from miniupnpd)
	Check that the peer is from a LAN for each SSDP packet
2014/11/06:
	listen on only 1 IPv4 if only 1 interface is specified
	also when ENABLE_IPV6 is not defined
2014/09/06:
	freebsd-glue for Debian/kFreeBSD
	use LDFLAGS when linking binary
2014/05/01:
	listen on only 1 IPv4 if only 1 interface is specified
2014/02/03:
	silently ignore EAGAIN, EWOULDBLOCK, EINTR of recv calls
	Discover devices on the network at startup
2013/08/19:
	Translate README in english
2012/09/27:
	Rename all include guards to not clash with C99
	(7.1.3 Reserved identifiers).
VERSION 1.2:
2012/05/21:
	Clean signal handling
	Set sockets non blocking
2012/05/18:
	Improve ProcessInterfaceWatch() under BSD.
2012/05/15:
	Improve ProcessInterfaceWatch() under linux.
2012/05/02:
	Clean CLFAGS in Makefile.
	Remove a few signed/unsigned compares
2012/04/09:
	Added -ansi to compilation flags.
	Handle ssdp:update messages and update logging
2012/01/02:
	Install manpage. Fix installation under Mac OS X.
2011/10/07:
	unlink unix socket before binding.
	set SO_REUSEADDR on SSDP socket.
	daemonize after init
VERSION 1.1:
2011/07/30:
	fixes. More overflow checks
2011/07/29:
	added a lot of buffer overflow checks. Check malloc() failure, etc.
	Better cleanup in case of crash at start.
	network interface watch to add/drop multicast membership when the interface get live.
2011/06/18:
	Starting to add support for UPnP Device Architecture v1.1
2011/05/23:
	Added IPv6 support.
	-i option now understands interface names as well as addresses.
VERSION 1.0:
2008/10/07:
	added codelength.h
	Fixing response to M-SEARCH
	Doc update
2008/10/06:
	UPnP server support (answering M-SEARCH)
2008/10/04:
	listening on several interfaces.
2008/10/01:
	use of daemon() instead of home made daemonize.
2007/12/19:
	added uuid in responses
	3 types of requests supported.
	preventing buffer overflow
2007/12/18:
	It is now possible to change the location of both pid file and
	unix socket.
2007/10/08:
	Added a man page
2007/09/27:
	Support for install in different location $ PREFIX=... make install
2007/09/23:
	added a script for use in /etc/init.d
	improved Makefile
	creating /var/run/minissdpd.pid
	adding synthetic messages for new devices/removed devices
2007/09/19:
	Take SSDP announce packets lifetime into account.
",CWE-125,146.0,1
"// +build go1.2
// Copyright 2014 The Gogs Authors. All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.
// Gogs(Go Git Service) is a painless self-hosted Git Service written in Go.
package main
import (
	""os""
	""runtime""
	""github.com/codegangsta/cli""
	""github.com/gogits/gogs/cmd""
	""github.com/gogits/gogs/modules/setting""
)
const APP_VER = ""0.5.6.1024 Beta""
func init() {
	runtime.GOMAXPROCS(runtime.NumCPU())
	setting.AppVer = APP_VER
}
func main() {
	app := cli.NewApp()
	app.Name = ""Gogs""
	app.Usage = ""Go Git Service""
	app.Version = APP_VER
	app.Commands = []cli.Command{
		cmd.CmdWeb,
		cmd.CmdServ,
		cmd.CmdUpdate,
		cmd.CmdFix,
		cmd.CmdDump,
		cmd.CmdCert,
	}
	app.Flags = append(app.Flags, []cli.Flag{}...)
	app.Run(os.Args)
}
",CWE-89,43.0,1
"// Copyright 2014 The Gogs Authors. All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.
package v1
import (
	""fmt""
	""path""
	""strings""
	""github.com/Unknwon/com""
	""github.com/gogits/gogs/models""
	""github.com/gogits/gogs/modules/auth""
	""github.com/gogits/gogs/modules/log""
	""github.com/gogits/gogs/modules/middleware""
)
type repo struct {
	RepoLink string `json:""repolink""`
}
func SearchRepos(ctx *middleware.Context) {
	opt := models.SearchOption{
		Keyword: path.Base(ctx.Query(""q"")),
		Uid:     com.StrTo(ctx.Query(""uid"")).MustInt64(),
		Limit:   com.StrTo(ctx.Query(""limit"")).MustInt(),
	}
	if opt.Limit == 0 {
		opt.Limit = 10
	}
	repos, err := models.SearchRepositoryByName(opt)
	if err != nil {
		ctx.JSON(500, map[string]interface{}{
			""ok"":    false,
			""error"": err.Error(),
		})
		return
	}
	results := make([]*repo, len(repos))
	for i := range repos {
		if err = repos[i].GetOwner(); err != nil {
			ctx.JSON(500, map[string]interface{}{
				""ok"":    false,
				""error"": err.Error(),
			})
			return
		}
		results[i] = &repo{
			RepoLink: path.Join(repos[i].Owner.Name, repos[i].Name),
		}
	}
	ctx.Render.JSON(200, map[string]interface{}{
		""ok"":   true,
		""data"": results,
	})
}
func Migrate(ctx *middleware.Context, form auth.MigrateRepoForm) {
	u, err := models.GetUserByName(ctx.Query(""username""))
	if err != nil {
		ctx.JSON(500, map[string]interface{}{
			""ok"":    false,
			""error"": err.Error(),
		})
		return
	}
	if !u.ValidtePassword(ctx.Query(""password"")) {
		ctx.JSON(500, map[string]interface{}{
			""ok"":    false,
			""error"": ""username or password is not correct"",
		})
		return
	}
	ctxUser := u
	// Not equal means current user is an organization.
	if form.Uid != u.Id {
		org, err := models.GetUserById(form.Uid)
		if err != nil {
			ctx.JSON(500, map[string]interface{}{
				""ok"":    false,
				""error"": err.Error(),
			})
			return
		}
		ctxUser = org
	}
	if ctx.HasError() {
		ctx.JSON(500, map[string]interface{}{
			""ok"":    false,
			""error"": ctx.GetErrMsg(),
		})
		return
	}
	if ctxUser.IsOrganization() {
		// Check ownership of organization.
		if !ctxUser.IsOrgOwner(u.Id) {
			ctx.JSON(403, map[string]interface{}{
				""ok"":    false,
				""error"": ""given user is not owner of organization"",
			})
			return
		}
	}
	authStr := strings.Replace(fmt.Sprintf(""://%s:%s"",
		form.AuthUserName, form.AuthPasswd), ""@"", ""%40"", -1)
	url := strings.Replace(form.HttpsUrl, ""://"", authStr+""@"", 1)
	repo, err := models.MigrateRepository(ctxUser, form.RepoName, form.Description, form.Private,
		form.Mirror, url)
	if err == nil {
		log.Trace(""Repository migrated: %s/%s"", ctxUser.Name, form.RepoName)
		ctx.JSON(200, map[string]interface{}{
			""ok"":   true,
			""data"": ""/"" + ctxUser.Name + ""/"" + form.RepoName,
		})
		return
	}
	if repo != nil {
		if errDelete := models.DeleteRepository(ctxUser.Id, repo.Id, ctxUser.Name); errDelete != nil {
			log.Error(4, ""DeleteRepository: %v"", errDelete)
		}
	}
	ctx.JSON(500, map[string]interface{}{
		""ok"":    false,
		""error"": err.Error(),
	})
}
",CWE-89,138.0,1
"// +build go1.2
// Copyright 2014 The Gogs Authors. All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.
// Gogs(Go Git Service) is a painless self-hosted Git Service written in Go.
package main
import (
	""os""
	""runtime""
	""github.com/codegangsta/cli""
	""github.com/gogits/gogs/cmd""
	""github.com/gogits/gogs/modules/setting""
)
const APP_VER = ""0.5.6.1102 Beta""
func init() {
	runtime.GOMAXPROCS(runtime.NumCPU())
	setting.AppVer = APP_VER
}
func main() {
	app := cli.NewApp()
	app.Name = ""Gogs""
	app.Usage = ""Go Git Service""
	app.Version = APP_VER
	app.Commands = []cli.Command{
		cmd.CmdWeb,
		cmd.CmdServ,
		cmd.CmdUpdate,
		cmd.CmdFix,
		cmd.CmdDump,
		cmd.CmdCert,
	}
	app.Flags = append(app.Flags, []cli.Flag{}...)
	app.Run(os.Args)
}
",CWE-89,43.0,1
"package main
import (
	""database/sql""
	""fmt""
	""log""
	""net/http""
	""github.com/gorilla/mux""
	_ ""github.com/lib/pq""
)
var servport = "":6862""
func failOnError(err error, msg string) {
	if err != nil {
		log.Fatalf(""[X] %s, %s"", msg, err)
		panic(fmt.Sprintf(""%s, %s"", msg, err))
	}
}
func main() {
	log.Println(""[i] Server started"")
	// Connect to DB
	db, err := sql.Open(""postgres"", ""user=appread dbname='quantifiedSelf' sslmode=disable"")
	failOnError(err, ""Error connecting to database"")
	defer db.Close()
	http.HandleFunc(""/data/all/"", func(w http.ResponseWriter, r *http.Request) {
		// TODO: Allow filtering via URL
		// Get rows from DB
		var output string
		err := db.QueryRow(`SELECT json_agg(r) FROM (SELECT * FROM trello.cards) r;`).Scan(&output)
		if err != nil {
			log.Println(""Error retriving from DB, "", err)
			w.WriteHeader(http.StatusInternalServerError)
			fmt.Fprintln(w, ""Error retriving from DB, "", err)
			return
		}
		// Print out returned
		fmt.Fprint(w, output)
	})
	// Restful handler
	r := mux.NewRouter()
	r.HandleFunc(""/api"", func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintln(w, ""dla;jfkdlsajflkdsa;jfk;ldsajfklds;a"")
	})
	r.HandleFunc(""/api/totals/last/{num}"", func(w http.ResponseWriter, r *http.Request) {
		// Grab vars
		vars := mux.Vars(r)
		var output string
		// This is bad... don't do this.... omg
		query := fmt.Sprintf(`SELECT json_agg(r) FROM (select EXTRACT(epoch FROM day) as day, end_of_day_total from trello.dailytallies order by day DESC limit %s) r;`, vars[""num""])
		err := db.QueryRow(query).Scan(&output)
		if err != nil {
			log.Println(""Error retriving from DB, "", err)
			w.WriteHeader(http.StatusInternalServerError)
			fmt.Fprintln(w, ""Error retriving from DB, "", err)
			return
		}
		// Print out returned
		w.Header().Set(""Content-Type"", ""application/json"")
		fmt.Fprint(w, output)
	})
	r.HandleFunc(""/api/diffs/last/{num}"", func(w http.ResponseWriter, r *http.Request) {
		// Grab vars
		vars := mux.Vars(r)
		var output string
		// This is bad... don't do this.... omg
		query := fmt.Sprintf(`SELECT json_agg(r) FROM (select EXTRACT(epoch FROM day) as day, up_count, down_count, finished_count from trello.dailytallies order by day DESC limit %s) r;`, vars[""num""])
		err := db.QueryRow(query).Scan(&output)
		if err != nil {
			log.Println(""Error retriving from DB, "", err)
			w.WriteHeader(http.StatusInternalServerError)
			fmt.Fprintln(w, ""Error retriving from DB, "", err)
			return
		}
		// Print out returned
		w.Header().Set(""Content-Type"", ""application/json"")
		fmt.Fprint(w, output)
	})
	r.PathPrefix(""/"").Handler(http.FileServer(http.Dir(""../ui"")))
	http.Handle(""/"", r)
	// Die gracefully
	// killchan := make(chan os.Signal)
	// signal.Notify(killchan, os.Interrupt, os.Kill)
	log.Println(""[i] Serving on "", servport, ""\n\tWaiting..."")
	log.Fatal(http.ListenAndServe(servport, nil))
	// <-killchan
	log.Println(""[i] Shutting down..."")
}
",CWE-89,107.0,1
"package content
import (
	""io""
	""os""
	""path""
	""github.com/hoffie/larasync/helpers/atomic""
)
const (
	// default permissions
	defaultFilePerms = 0600
	defaultDirPerms  = 0700
)
// FileStorage is the basic implementation of the Storage
// implementation which stores the data into the file system.
type FileStorage struct {
	path string
}
// NewFileStorage generates a file content storage with the
// given path.
func NewFileStorage(path string) *FileStorage {
	return &FileStorage{
		path: path,
	}
}
// CreateDir ensures that the file blob storage directory exists.
func (f *FileStorage) CreateDir() error {
	err := os.Mkdir(f.path, defaultDirPerms)
	if err != nil && !os.IsExist(err) {
		return err
	}
	return nil
}
// storagePathFor returns the storage path for the data entry.
func (f *FileStorage) storagePathFor(contentID string) string {
	return path.Join(f.path, contentID)
}
// Get returns the file handle for the given contentID.
// If there is no data stored for the Id it should return a
// os.ErrNotExists error.
func (f *FileStorage) Get(contentID string) (io.ReadCloser, error) {
	if f.Exists(contentID) {
		return os.Open(f.storagePathFor(contentID))
	}
	return nil, os.ErrNotExist
}
// Set sets the data of the given contentID in the blob storage.
func (f *FileStorage) Set(contentID string, reader io.Reader) error {
	blobStoragePath := f.storagePathFor(contentID)
	writer, err := atomic.NewStandardWriter(blobStoragePath, defaultFilePerms)
	if err != nil {
		return err
	}
	_, err = io.Copy(writer, reader)
	if err != nil {
		writer.Abort()
		writer.Close()
		return err
	}
	err = writer.Close()
	if err != nil {
		return err
	}
	return nil
}
// Exists checks if the given entry is stored in the database.
func (f *FileStorage) Exists(contentID string) bool {
	_, err := os.Stat(f.storagePathFor(contentID))
	if err != nil {
		return !os.IsNotExist(err)
	}
	return true
}
// Delete removes the data with the given contentID from the store.
func (f *FileStorage) Delete(contentID string) error {
	return os.Remove(f.storagePathFor(contentID))
}
",CWE-22,93.0,1
"package content
import (
	""bytes""
	""crypto/sha256""
	""encoding/hex""
	""io""
	""io/ioutil""
	""os""
	""path""
	. ""gopkg.in/check.v1""
)
type FileStorageTests struct {
	dir     string
	storage *FileStorage
	data    []byte
}
var _ = Suite(&FileStorageTests{})
func (t *FileStorageTests) SetUpTest(c *C) {
	t.dir = c.MkDir()
	t.storage = NewFileStorage(t.dir)
	t.data = []byte(""This is a test blob storage file input."")
}
func (t *FileStorageTests) blobID() string {
	blobIDBytes := sha256.New().Sum(t.data)
	return hex.EncodeToString(blobIDBytes[:])
}
func (t *FileStorageTests) blobPath() string {
	return path.Join(t.dir, t.blobID())
}
func (t *FileStorageTests) testReader() io.Reader {
	return bytes.NewReader(t.data)
}
func (t *FileStorageTests) setData() error {
	return t.storage.Set(t.blobID(), t.testReader())
}
func (t *FileStorageTests) TestSet(c *C) {
	err := t.setData()
	c.Assert(err, IsNil)
	_, err = os.Stat(t.blobPath())
	c.Assert(err, IsNil)
}
func (t *FileStorageTests) TestSetInputData(c *C) {
	t.setData()
	file, _ := os.Open(t.blobPath())
	fileData, _ := ioutil.ReadAll(file)
	c.Assert(fileData[:], DeepEquals, t.data[:])
}
func (t *FileStorageTests) TestExistsNegative(c *C) {
	c.Assert(t.storage.Exists(t.blobID()), Equals, false)
}
func (t *FileStorageTests) TestExistsPositive(c *C) {
	t.setData()
	c.Assert(t.storage.Exists(t.blobID()), Equals, true)
}
func (t *FileStorageTests) TestGet(c *C) {
	t.storage.Set(t.blobID(), t.testReader())
	_, err := t.storage.Get(t.blobID())
	c.Assert(err, IsNil)
}
func (t *FileStorageTests) TestGetData(c *C) {
	t.setData()
	file, _ := t.storage.Get(t.blobID())
	fileData, _ := ioutil.ReadAll(file)
	c.Assert(fileData[:], DeepEquals, t.data)
}
func (t *FileStorageTests) TestGetError(c *C) {
	_, err := t.storage.Get(t.blobID())
	c.Assert(err, NotNil)
}
func (t *FileStorageTests) TestSetError(c *C) {
	os.RemoveAll(t.dir)
	err := t.storage.Set(t.blobID(),
		t.testReader())
	c.Assert(err, NotNil)
}
func (t *FileStorageTests) TestDelete(c *C) {
	t.setData()
	err := t.storage.Delete(t.blobID())
	c.Assert(err, IsNil)
	c.Assert(t.storage.Exists(t.blobID()), Equals, false)
}
func (t *FileStorageTests) TestDeleteError(c *C) {
	err := t.storage.Delete(t.blobID())
	c.Assert(err, NotNil)
}
",CWE-22,106.0,1
"/* no Credentials management needed
 * Credentials are stored at user side using secure cookies
 *
 * credits:
 * http://www.mschoebel.info/2014/03/09/snippet-golang-webapp-login-logout.html
 */
package main
import (
	""github.com/gorilla/securecookie""
	""net/http""
)
var cookieHandler = securecookie.New(
	securecookie.GenerateRandomKey(64),
	securecookie.GenerateRandomKey(32))
func getCredentials(request *http.Request) (userName string, password string) {
	if cookie, err := request.Cookie(""Credentials""); err == nil {
		cookieValue := make(map[string]string)
		if err = cookieHandler.Decode(""Credentials"", cookie.Value, &cookieValue); err == nil {
			userName = cookieValue[""user""]
			password = cookieValue[""passwd""]
		}
	}
	return userName, password
}
func setCredentials(userName string, pw string, w http.ResponseWriter) {
	value := map[string]string{
		""user"":   userName,
		""passwd"": pw,
	}
	if encoded, err := cookieHandler.Encode(""Credentials"", value); err == nil {
		cookie := &http.Cookie{
			Name:  ""Credentials"",
			Value: encoded,
			Path:  ""/"",
		}
		http.SetCookie(w, cookie)
	}
}
func clearCredentials(w http.ResponseWriter) {
	cookie := &http.Cookie{
		Name:   ""Credentials"",
		Value:  """",
		Path:   ""/"",
		MaxAge: -1,
	}
	http.SetCookie(w, cookie)
}
func loginHandler(w http.ResponseWriter, request *http.Request) {
	user := request.FormValue(""user"")
	pass := request.FormValue(""password"")
	if user != """" && pass != """" {
		setCredentials(user, pass, w)
	}
	http.Redirect(w, request, ""/"", 302)
}
func logoutHandler(w http.ResponseWriter, request *http.Request) {
	clearCredentials(w)
	http.Redirect(w, request, ""/"", 302)
}
const loginPage = `
<h1>Login</h1>
<form method=""post"" action=""/login"">
   <label for=""user"">User name</label><input type=""text"" id=""user"" name=""user"">
   <label for=""password"">Password</label><input type=""password"" id=""password"" name=""password"">
   <button type=""submit"">Login</button>
</form>
`
",CWE-89,77.0,1
"package main
import (
	""fmt""
	""net/http""
	""os""
	""strings""
)
// simple error checker
func checkY(err error) {
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
}
// will create a link into one level deeper
func linkDeeper(cwd string, link string, name string) string {
	return ""<a href=\"""" + cwd + ""/"" + link + ""\"">"" + name + ""</a>""
}
// Compose dataSourceName from components and globals
func dsn(user string, pw string, db string) string {
	return user + "":"" + pw + ""@tcp("" + host + "":"" + port + "")/"" + db
}
// Converts an URL into an array of strings
func url2array(r *http.Request) []string {
	path := r.URL.Path
	path = strings.TrimSpace(path)
	if strings.HasPrefix(path, ""/"") {
		path = path[1:]
	}
	if strings.HasSuffix(path, ""/"") {
		path = path[:len(path)-1]
	}
	return strings.Split(path, ""/"")
}
",CWE-89,40.0,1
"package main
/* TODO
 * turn into generic functions
 */
import (
	""database/sql""
	""fmt""
	_ ""github.com/go-sql-driver/mysql""
	""net/http""
	""strconv""
	""strings""
)
// Shows selection of databases at top level
func home(w http.ResponseWriter, r *http.Request) {
	user, pw := getCredentials(r)
	conn, err := sql.Open(""mysql"", dsn(user, pw, database))
	checkY(err)
	defer conn.Close()
	statement, err := conn.Prepare(""show databases"")
	checkY(err)
	rows, err := statement.Query()
	checkY(err)
	defer rows.Close()
	var n int = 1
	for rows.Next() {
		var field string
		rows.Scan(&field)
		fmt.Fprint(w, linkDeeper("""", field, ""DB[""+strconv.Itoa(n)+""]""))
		fmt.Fprintln(w, "" "", field, ""<br>"")
		n = n + 1
	}
}
//  Dump all tables of a database
func dumpdb(w http.ResponseWriter, r *http.Request, parray []string) {
	user, pw := getCredentials(r)
	database := parray[0]
	conn, err := sql.Open(""mysql"", dsn(user, pw, database))
	checkY(err)
	defer conn.Close()
	statement, err := conn.Prepare(""show tables"")
	checkY(err)
	rows, err := statement.Query()
	checkY(err)
	defer rows.Close()
	var n int = 1
	for rows.Next() {
		var field string
		rows.Scan(&field)
		fmt.Fprint(w, linkDeeper(r.URL.Path, field, ""T[""+strconv.Itoa(n)+""]""))
		fmt.Fprintln(w, ""  "", field, ""<br>"")
		n = n + 1
	}
}
//  Dump all records of a table, one per line
func dumptable(w http.ResponseWriter, r *http.Request, parray []string) {
	user, pw := getCredentials(r)
	database := parray[0]
	table := parray[1]
	conn, err := sql.Open(""mysql"", dsn(user, pw, database))
	checkY(err)
	defer conn.Close()
	statement, err := conn.Prepare(""select * from ?"")
	checkY(err)
	rows, err := statement.Query(table)
	checkY(err)
	defer rows.Close()
	cols, err := rows.Columns()
	checkY(err)
	fmt.Fprintln(w, ""<p>""+""
	/*  credits:
	 * 	http://stackoverflow.com/questions/19991541/dumping-mysql-tables-to-json-with-golang
	 * 	http://go-database-sql.org/varcols.html
	 */
	raw := make([]interface{}, len(cols))
	val := make([]interface{}, len(cols))
	for i := range val {
		raw[i] = &val[i]
	}
	var n int = 1
	for rows.Next() {
		fmt.Fprint(w, linkDeeper(r.URL.Path, strconv.Itoa(n), strconv.Itoa(n)))
		err = rows.Scan(raw...)
		checkY(err)
		for _, col := range val {
			if col != nil {
				fmt.Fprintf(w, ""%s "", string(col.([]byte)))
			}
		}
		fmt.Fprintln(w, ""<br>"")
		n = n + 1
	}
}
// Dump all fields of a record, one column per line
func dumprecord(w http.ResponseWriter, r *http.Request, parray []string) {
	database := parray[0]
	table := parray[1]
	rec, err := strconv.Atoi(parray[2])
	checkY(err)
	user, pw := getCredentials(r)
	conn, err := sql.Open(""mysql"", dsn(user, pw, database))
	checkY(err)
	defer conn.Close()
	statement, err := conn.Prepare(""select * from ?"")
	checkY(err)
	rows, err := statement.Query(table)
	checkY(err)
	defer rows.Close()
	columns, err := rows.Columns()
	checkY(err)
	raw := make([]interface{}, len(columns))
	val := make([]interface{}, len(columns))
	for i := range val {
		raw[i] = &val[i]
	}
	var n int = 1
rowLoop:
	for rows.Next() {
		// unfortunately we have to iterate up to row of interest
		if n == rec {
			err = rows.Scan(raw...)
			checkY(err)
			fmt.Fprintln(w, ""<p>"")
			for i, col := range val {
				if col != nil {
					fmt.Fprintln(w, columns[i], "":"", string(col.([]byte)), ""<br>"")
				}
			}
			fmt.Fprintln(w, ""</p>"")
			break rowLoop
		}
		n = n + 1
	}
}
",CWE-89,170.0,1
"package main
import (
	""fmt""
	_ ""github.com/go-sql-driver/mysql""
	""net/http""
)
var base_url = ""http://localhost""
var host = ""localhost""
var port = ""3306""
var database = ""information_schema""
func faviconHandler(w http.ResponseWriter, r *http.Request) {
	http.StatusText(404)
}
func loginPageHandler(w http.ResponseWriter, request *http.Request) {
	fmt.Fprintf(w, loginPage)
}
func pathHandler(w http.ResponseWriter, r *http.Request) {
	if r.URL.Path == ""/"" {
		home(w, r)
	} else {
		parray := url2array(r)
		switch len(parray) {
		case 1:
			dumpdb(w, r, parray)
		case 2:
			dumptable(w, r, parray)
		case 3:
			dumprecord(w, r, parray)
		}
	}
}
func indexHandler(w http.ResponseWriter, r *http.Request) {
	u, _ := getCredentials(r)
	if u != """" {
		fmt.Fprintln(w, ""<h1>"", u, ""</h1>"")
		pathHandler(w, r)
	} else {
		loginPageHandler(w, r)
	}
}
func main() {
	http.HandleFunc(""/favicon.ico"", faviconHandler)
	http.HandleFunc(""/login"", loginHandler)
	http.HandleFunc(""/logout"", logoutHandler)
	http.HandleFunc(""/"", indexHandler)
	fmt.Println(""Listening at localhost:8080"")
	http.ListenAndServe("":8080"", nil)
}
",CWE-89,61.0,1
"﻿using IcepayRestClient.Classes.Refund;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
namespace IcepayRestClient
{
    public class Refund : ServiceBase
    {
        public Refund(int merchantID, string merchantSecret) : base(merchantID, merchantSecret) { }
        public RequestRefundResponse Checkout(RequestRefundRequest request)
        {
            return IcepayRestClient.Classes.RestClient.SendAndReceive<RequestRefundRequest, RequestRefundResponse>(""Refund"", ""RequestRefund"", request, this.MerchantID, this.MerchantSecret);
        }
        public CancelRefundResponse Checkout(CancelRefundRequest request)
        {
            return IcepayRestClient.Classes.RestClient.SendAndReceive<CancelRefundRequest, CancelRefundResponse>(""Refund"", ""CancelRefund"", request, this.MerchantID, this.MerchantSecret);
        }
        public GetPaymentRefundsResponse Checkout(GetPaymentRefundsRequest request)
        {
            return IcepayRestClient.Classes.RestClient.SendAndReceive<GetPaymentRefundsRequest, GetPaymentRefundsResponse>(""Refund"", ""GetPaymentRefunds"", request, this.MerchantID, this.MerchantSecret);
        }
    }
}
",CWE-354,30.0,1
"package main
import (
	""fmt""
	""log""
	""net/http""
	""time""
	""github.com/deis/workflow-manager/config""
	""github.com/deis/workflow-manager/data""
	""github.com/deis/workflow-manager/handlers""
	""github.com/deis/workflow-manager/jobs""
	""github.com/deis/workflow-manager/k8s""
	""github.com/gorilla/mux""
	kcl ""k8s.io/kubernetes/pkg/client/unversioned""
)
func main() {
	kubeClient, err := kcl.NewInCluster()
	if err != nil {
		log.Fatalf(""Error creating new Kubernetes client (%s)"", err)
	}
	apiClient, err := config.GetSwaggerClient(config.Spec.VersionsAPIURL)
	if err != nil {
		log.Fatalf(""Error creating new swagger api client (%s)"", err)
	}
	deisK8sResources := k8s.NewResourceInterfaceNamespaced(kubeClient, config.Spec.DeisNamespace)
	clusterID := data.NewClusterIDFromPersistentStorage(deisK8sResources.Secrets())
	installedDeisData := data.NewInstalledDeisData(deisK8sResources)
	availableVersion := data.NewAvailableVersionsFromAPI(
		apiClient,
		config.Spec.VersionsAPIURL,
	)
	availableComponentVersion := data.NewLatestReleasedComponent(deisK8sResources, availableVersion)
	pollDur := time.Duration(config.Spec.Polling) * time.Second
	// we want to do the following jobs according to our remote API interval:
	// 1. get latest stable deis component versions
	// 2. send diagnostic data, if appropriate
	glvdPeriodic := jobs.NewGetLatestVersionDataPeriodic(
		installedDeisData,
		clusterID,
		availableVersion,
		availableComponentVersion,
		pollDur,
	)
	svPeriodic := jobs.NewSendVersionsPeriodic(
		apiClient,
		deisK8sResources,
		availableVersion,
		pollDur,
	)
	toDo := []jobs.Periodic{glvdPeriodic, svPeriodic}
	log.Printf(""Starting periodic jobs at interval %s"", pollDur)
	ch := jobs.DoPeriodic(toDo)
	defer close(ch)
	// Get a new router, with handler functions
	r := handlers.RegisterRoutes(mux.NewRouter(), availableVersion, deisK8sResources)
	// Bind to a port and pass our router in
	hostStr := fmt.Sprintf("":%s"", config.Spec.Port)
	log.Printf(""Serving on %s"", hostStr)
	if err := http.ListenAndServe(hostStr, r); err != nil {
		close(ch)
		log.Println(""Unable to open up TLS listener"")
		log.Fatal(""ListenAndServe: "", err)
	}
}
",CWE-362,70.0,1
"package data
import (
	""sync""
	""github.com/deis/workflow-manager/k8s""
	""github.com/satori/go.uuid""
	""k8s.io/kubernetes/pkg/api""
	apierrors ""k8s.io/kubernetes/pkg/api/errors""
)
// ClusterID is an interface for managing cluster ID data
type ClusterID interface {
	// will have a Get method to retrieve the cluster ID
	Get() (string, error)
	// Cached returns the internal cache of the cluster ID. returns the empty string on a miss
	Cached() string
	// StoreInCache stores the given string in the internal cluster ID cache
	StoreInCache(string)
}
// GetID gets the cluster ID from the cache. on a cache miss, uses the k8s API to get it
func GetID(id ClusterID) (string, error) {
	// First, check to see if we have an in-memory copy
	data := id.Cached()
	// If we haven't yet cached the ID in memory, invoke the passed-in getter
	if data == """" {
		d, err := id.Get()
		if err != nil {
			return """", err
		}
		data = d
	}
	return data, nil
}
type clusterIDFromPersistentStorage struct {
	rwm                 *sync.RWMutex
	cache               string
	secretGetterCreator k8s.KubeSecretGetterCreator
}
// NewClusterIDFromPersistentStorage returns a new ClusterID implementation that uses the kubernetes API to get its cluster information
func NewClusterIDFromPersistentStorage(sgc k8s.KubeSecretGetterCreator) ClusterID {
	return &clusterIDFromPersistentStorage{
		rwm:                 new(sync.RWMutex),
		cache:               """",
		secretGetterCreator: sgc,
	}
}
// Get is the ClusterID interface implementation
func (c clusterIDFromPersistentStorage) Get() (string, error) {
	secret, err := c.secretGetterCreator.Get(wfmSecretName)
	//If we don't have the secret we shouldn't be returning error and instead a create a new one
	if err != nil && !apierrors.IsNotFound(err) {
		return """", err
	}
	// if we don't have secret data for the cluster ID we assume a new cluster
	// and create a new secret
	if secret.Data[clusterIDSecretKey] == nil {
		newSecret := new(api.Secret)
		newSecret.Name = wfmSecretName
		newSecret.Data = make(map[string][]byte)
		newSecret.Data[clusterIDSecretKey] = []byte(uuid.NewV4().String())
		fromAPI, err := c.secretGetterCreator.Create(newSecret)
		if err != nil {
			return """", err
		}
		secret = fromAPI
	}
	return string(secret.Data[clusterIDSecretKey]), nil
}
// StoreInCache is the ClusterID interface implementation
func (c *clusterIDFromPersistentStorage) StoreInCache(cid string) {
	c.rwm.Lock()
	defer c.rwm.Unlock()
	c.cache = cid
}
// Cached is the ClusterID interface implementation
func (c clusterIDFromPersistentStorage) Cached() string {
	c.rwm.RLock()
	defer c.rwm.RUnlock()
	return c.cache
}
",CWE-362,88.0,1
"package jobs
import (
	""log""
	""time""
	""github.com/deis/workflow-manager/config""
	""github.com/deis/workflow-manager/data""
	""github.com/deis/workflow-manager/k8s""
	apiclient ""github.com/deis/workflow-manager/pkg/swagger/client""
	""github.com/deis/workflow-manager/pkg/swagger/client/operations""
)
// Periodic is an interface for managing periodic job invocation
type Periodic interface {
	// Do begins the periodic job. It starts the first execution of the job, and then is
	// repsonsible for executing it every Frequency() thereafter
	Do() error
	Frequency() time.Duration
}
// SendVersions fulfills the Periodic interface
type sendVersions struct {
	k8sResources      *k8s.ResourceInterfaceNamespaced
	apiClient         *apiclient.WorkflowManager
	availableVersions data.AvailableVersions
	frequency         time.Duration
}
// NewSendVersionsPeriodic creates a new SendVersions using sgc and rcl as the the secret getter / creator and replication controller lister implementations (respectively)
func NewSendVersionsPeriodic(
	apiClient *apiclient.WorkflowManager,
	ri *k8s.ResourceInterfaceNamespaced,
	availableVersions data.AvailableVersions,
	frequency time.Duration,
) Periodic {
	return &sendVersions{
		k8sResources:      ri,
		apiClient:         apiClient,
		availableVersions: availableVersions,
		frequency:         frequency,
	}
}
// Do is the Periodic interface implementation
func (s sendVersions) Do() error {
	if config.Spec.CheckVersions {
		err := sendVersionsImpl(s.apiClient, s.k8sResources, s.availableVersions)
		if err != nil {
			return err
		}
	}
	return nil
}
// Frequency is the Periodic interface implementation
func (s sendVersions) Frequency() time.Duration {
	return s.frequency
}
type getLatestVersionData struct {
	vsns                  data.AvailableVersions
	installedData         data.InstalledData
	clusterID             data.ClusterID
	availableComponentVsn data.AvailableComponentVersion
	k8sResources          k8s.ResourceInterfaceNamespaced
	frequency             time.Duration
}
// NewGetLatestVersionDataPeriodic creates a new periodic implementation that gets latest version data. It uses sgc and rcl as the secret getter/creator and replication controller lister implementations (respectively)
func NewGetLatestVersionDataPeriodic(
	installedData data.InstalledData,
	clusterID data.ClusterID,
	availVsn data.AvailableVersions,
	availCompVsn data.AvailableComponentVersion,
	frequency time.Duration,
) Periodic {
	return &getLatestVersionData{
		vsns:                  availVsn,
		installedData:         installedData,
		clusterID:             clusterID,
		availableComponentVsn: availCompVsn,
		frequency:             frequency,
	}
}
// Do is the Periodic interface implementation
func (u *getLatestVersionData) Do() error {
	cluster, err := data.GetCluster(u.installedData, u.clusterID, u.availableComponentVsn)
	if err != nil {
		return err
	}
	if _, err := u.vsns.Refresh(cluster); err != nil {
		return err
	}
	return nil
}
// Frequency is the Periodic interface implementation
func (u getLatestVersionData) Frequency() time.Duration {
	return u.frequency
}
// DoPeriodic calls p.Do() once, and then again every p.Frequency() on each element p in pSlice.
// For each p in pSlice, a new goroutine is started, and the returned channel can be closed
// to stop all of the goroutines.
func DoPeriodic(pSlice []Periodic) chan<- struct{} {
	doneCh := make(chan struct{})
	for _, p := range pSlice {
		go func(p Periodic) {
			// execute once at the beginning
			err := p.Do()
			if err != nil {
				log.Printf(""periodic job ran and returned error (%s)"", err)
			}
			ticker := time.NewTicker(p.Frequency())
			for {
				select {
				case <-ticker.C:
					err := p.Do()
					if err != nil {
						log.Printf(""periodic job ran and returned error (%s)"", err)
					}
				case <-doneCh:
					ticker.Stop()
					return
				}
			}
		}(p)
	}
	return doneCh
}
//  sendVersions sends cluster version data
func sendVersionsImpl(
	apiClient *apiclient.WorkflowManager,
	k8sResources *k8s.ResourceInterfaceNamespaced,
	availableVersions data.AvailableVersions,
) error {
	cluster, err := data.GetCluster(
		data.NewInstalledDeisData(k8sResources),
		data.NewClusterIDFromPersistentStorage(k8sResources.Secrets()),
		data.NewLatestReleasedComponent(k8sResources, availableVersions),
	)
	if err != nil {
		log.Println(""error getting installed components data"")
		return err
	}
	_, err = apiClient.Operations.CreateClusterDetails(&operations.CreateClusterDetailsParams{Body: &cluster})
	if err != nil {
		log.Println(""error sending diagnostic data"")
		return err
	}
	return nil
}
",CWE-362,158.0,1
"package utils
import (
	""encoding/binary""
	""encoding/json""
	""io""
	""os""
	""path/filepath""
	""strings""
	""unsafe""
	""golang.org/x/sys/unix""
)
const (
	exitSignalOffset = 128
)
// NativeEndian is the native byte order of the host system.
var NativeEndian binary.ByteOrder
func init() {
	// Copied from <golang.org/x/net/internal/socket/sys.go>.
	i := uint32(1)
	b := (*[4]byte)(unsafe.Pointer(&i))
	if b[0] == 1 {
		NativeEndian = binary.LittleEndian
	} else {
		NativeEndian = binary.BigEndian
	}
}
// ResolveRootfs ensures that the current working directory is
// not a symlink and returns the absolute path to the rootfs
func ResolveRootfs(uncleanRootfs string) (string, error) {
	rootfs, err := filepath.Abs(uncleanRootfs)
	if err != nil {
		return """", err
	}
	return filepath.EvalSymlinks(rootfs)
}
// ExitStatus returns the correct exit status for a process based on if it
// was signaled or exited cleanly
func ExitStatus(status unix.WaitStatus) int {
	if status.Signaled() {
		return exitSignalOffset + int(status.Signal())
	}
	return status.ExitStatus()
}
// WriteJSON writes the provided struct v to w using standard json marshaling
func WriteJSON(w io.Writer, v interface{}) error {
	data, err := json.Marshal(v)
	if err != nil {
		return err
	}
	_, err = w.Write(data)
	return err
}
// CleanPath makes a path safe for use with filepath.Join. This is done by not
// only cleaning the path, but also (if the path is relative) adding a leading
// '/' and cleaning it (then removing the leading '/'). This ensures that a
// path resulting from prepending another path will always resolve to lexically
// be a subdirectory of the prefixed path. This is all done lexically, so paths
// that include symlinks won't be safe as a result of using CleanPath.
func CleanPath(path string) string {
	// Deal with empty strings nicely.
	if path == """" {
		return """"
	}
	// Ensure that all paths are cleaned (especially problematic ones like
	// ""/../../../../../"" which can cause lots of issues).
	path = filepath.Clean(path)
	// If the path isn't absolute, we need to do more processing to fix paths
	// such as ""../../../../<etc>/some/path"". We also shouldn't convert absolute
	// paths to relative ones.
	if !filepath.IsAbs(path) {
		path = filepath.Clean(string(os.PathSeparator) + path)
		// This can't fail, as (by definition) all paths are relative to root.
		path, _ = filepath.Rel(string(os.PathSeparator), path)
	}
	// Clean the path again for good measure.
	return filepath.Clean(path)
}
// SearchLabels searches a list of key-value pairs for the provided key and
// returns the corresponding value. The pairs must be separated with '='.
func SearchLabels(labels []string, query string) string {
	for _, l := range labels {
		parts := strings.SplitN(l, ""="", 2)
		if len(parts) < 2 {
			continue
		}
		if parts[0] == query {
			return parts[1]
		}
	}
	return """"
}
// Annotations returns the bundle path and user defined annotations from the
// libcontainer state.  We need to remove the bundle because that is a label
// added by libcontainer.
func Annotations(labels []string) (bundle string, userAnnotations map[string]string) {
	userAnnotations = make(map[string]string)
	for _, l := range labels {
		parts := strings.SplitN(l, ""="", 2)
		if len(parts) < 2 {
			continue
		}
		if parts[0] == ""bundle"" {
			bundle = parts[1]
		} else {
			userAnnotations[parts[0]] = parts[1]
		}
	}
	return
}
",CWE-362,124.0,1
"package utils
import (
	""bytes""
	""os""
	""path/filepath""
	""testing""
	""golang.org/x/sys/unix""
)
var labelTest = []struct {
	labels        []string
	query         string
	expectedValue string
}{
	{[]string{""bundle=/path/to/bundle""}, ""bundle"", ""/path/to/bundle""},
	{[]string{""test=a"", ""test=b""}, ""bundle"", """"},
	{[]string{""bundle=a"", ""test=b"", ""bundle=c""}, ""bundle"", ""a""},
	{[]string{"""", ""test=a"", ""bundle=b""}, ""bundle"", ""b""},
	{[]string{""test"", ""bundle=a""}, ""bundle"", ""a""},
	{[]string{""test=a"", ""bundle=""}, ""bundle"", """"},
}
func TestSearchLabels(t *testing.T) {
	for _, tt := range labelTest {
		if v := SearchLabels(tt.labels, tt.query); v != tt.expectedValue {
			t.Errorf(""expected value '%s' for query '%s'; got '%s'"", tt.expectedValue, tt.query, v)
		}
	}
}
func TestResolveRootfs(t *testing.T) {
	dir := ""rootfs""
	if err := os.Mkdir(dir, 0600); err != nil {
		t.Fatal(err)
	}
	defer os.Remove(dir)
	path, err := ResolveRootfs(dir)
	if err != nil {
		t.Fatal(err)
	}
	pwd, err := os.Getwd()
	if err != nil {
		t.Fatal(err)
	}
	if path != pwd+""/rootfs"" {
		t.Errorf(""expected rootfs to be abs and was %s"", path)
	}
}
func TestResolveRootfsWithSymlink(t *testing.T) {
	dir := ""rootfs""
	tmpDir, _ := filepath.EvalSymlinks(os.TempDir())
	if err := os.Symlink(tmpDir, dir); err != nil {
		t.Fatal(err)
	}
	defer os.Remove(dir)
	path, err := ResolveRootfs(dir)
	if err != nil {
		t.Fatal(err)
	}
	if path != tmpDir {
		t.Errorf(""expected rootfs to be the real path %s and was %s"", path, os.TempDir())
	}
}
func TestResolveRootfsWithNonExistingDir(t *testing.T) {
	_, err := ResolveRootfs(""foo"")
	if err == nil {
		t.Error(""expected error to happen but received nil"")
	}
}
func TestExitStatus(t *testing.T) {
	status := unix.WaitStatus(0)
	ex := ExitStatus(status)
	if ex != 0 {
		t.Errorf(""expected exit status to equal 0 and received %d"", ex)
	}
}
func TestExitStatusSignaled(t *testing.T) {
	status := unix.WaitStatus(2)
	ex := ExitStatus(status)
	if ex != 130 {
		t.Errorf(""expected exit status to equal 130 and received %d"", ex)
	}
}
func TestWriteJSON(t *testing.T) {
	person := struct {
		Name string
		Age  int
	}{
		Name: ""Alice"",
		Age:  30,
	}
	var b bytes.Buffer
	err := WriteJSON(&b, person)
	if err != nil {
		t.Fatal(err)
	}
	expected := `{""Name"":""Alice"",""Age"":30}`
	if b.String() != expected {
		t.Errorf(""expected to write %s but was %s"", expected, b.String())
	}
}
func TestCleanPath(t *testing.T) {
	path := CleanPath("""")
	if path != """" {
		t.Errorf(""expected to receive empty string and received %s"", path)
	}
	path = CleanPath(""rootfs"")
	if path != ""rootfs"" {
		t.Errorf(""expected to receive 'rootfs' and received %s"", path)
	}
	path = CleanPath(""../../../var"")
	if path != ""var"" {
		t.Errorf(""expected to receive 'var' and received %s"", path)
	}
	path = CleanPath(""/../../../var"")
	if path != ""/var"" {
		t.Errorf(""expected to receive '/var' and received %s"", path)
	}
	path = CleanPath(""/foo/bar/"")
	if path != ""/foo/bar"" {
		t.Errorf(""expected to receive '/foo/bar' and received %s"", path)
	}
	path = CleanPath(""/foo/bar/../"")
	if path != ""/foo"" {
		t.Errorf(""expected to receive '/foo' and received %s"", path)
	}
}
",CWE-362,146.0,1
"package configs
const (
	// EXT_COPYUP is a directive to copy up the contents of a directory when
	// a tmpfs is mounted over it.
	EXT_COPYUP = 1 << iota //nolint:golint // ignore ""don't use ALL_CAPS"" warning
)
type Mount struct {
	// Source path for the mount.
	Source string `json:""source""`
	// Destination path for the mount inside the container.
	Destination string `json:""destination""`
	// Device the mount is for.
	Device string `json:""device""`
	// Mount flags.
	Flags int `json:""flags""`
	// Propagation Flags
	PropagationFlags []int `json:""propagation_flags""`
	// Mount data applied to the mount.
	Data string `json:""data""`
	// Relabel source if set, ""z"" indicates shared, ""Z"" indicates unshared.
	Relabel string `json:""relabel""`
	// Extensions are additional flags that are specific to runc.
	Extensions int `json:""extensions""`
	// Optional Command to be run before Source is mounted.
	PremountCmds []Command `json:""premount_cmds""`
	// Optional Command to be run after Source is mounted.
	PostmountCmds []Command `json:""postmount_cmds""`
}
",CWE-190,40.0,1
"package libcontainer
import (
	""github.com/vishvananda/netlink/nl""
	""golang.org/x/sys/unix""
)
// list of known message types we want to send to bootstrap program
// The number is randomly chosen to not conflict with known netlink types
const (
	InitMsg          uint16 = 62000
	CloneFlagsAttr   uint16 = 27281
	NsPathsAttr      uint16 = 27282
	UidmapAttr       uint16 = 27283
	GidmapAttr       uint16 = 27284
	SetgroupAttr     uint16 = 27285
	OomScoreAdjAttr  uint16 = 27286
	RootlessEUIDAttr uint16 = 27287
	UidmapPathAttr   uint16 = 27288
	GidmapPathAttr   uint16 = 27289
)
type Int32msg struct {
	Type  uint16
	Value uint32
}
// Serialize serializes the message.
// Int32msg has the following representation
// | nlattr len | nlattr type |
// | uint32 value             |
func (msg *Int32msg) Serialize() []byte {
	buf := make([]byte, msg.Len())
	native := nl.NativeEndian()
	native.PutUint16(buf[0:2], uint16(msg.Len()))
	native.PutUint16(buf[2:4], msg.Type)
	native.PutUint32(buf[4:8], msg.Value)
	return buf
}
func (msg *Int32msg) Len() int {
	return unix.NLA_HDRLEN + 4
}
// Bytemsg has the following representation
// | nlattr len | nlattr type |
// | value              | pad |
type Bytemsg struct {
	Type  uint16
	Value []byte
}
func (msg *Bytemsg) Serialize() []byte {
	l := msg.Len()
	buf := make([]byte, (l+unix.NLA_ALIGNTO-1) & ^(unix.NLA_ALIGNTO-1))
	native := nl.NativeEndian()
	native.PutUint16(buf[0:2], uint16(l))
	native.PutUint16(buf[2:4], msg.Type)
	copy(buf[4:], msg.Value)
	return buf
}
func (msg *Bytemsg) Len() int {
	return unix.NLA_HDRLEN + len(msg.Value) + 1 // null-terminated
}
type Boolmsg struct {
	Type  uint16
	Value bool
}
func (msg *Boolmsg) Serialize() []byte {
	buf := make([]byte, msg.Len())
	native := nl.NativeEndian()
	native.PutUint16(buf[0:2], uint16(msg.Len()))
	native.PutUint16(buf[2:4], msg.Type)
	if msg.Value {
		native.PutUint32(buf[4:8], uint32(1))
	} else {
		native.PutUint32(buf[4:8], uint32(0))
	}
	return buf
}
func (msg *Boolmsg) Len() int {
	return unix.NLA_HDRLEN + 4 // alignment
}
",CWE-190,88.0,1
"package libcontainer
import (
	""github.com/vishvananda/netlink/nl""
	""golang.org/x/sys/unix""
)
// list of known message types we want to send to bootstrap program
// The number is randomly chosen to not conflict with known netlink types
const (
	InitMsg          uint16 = 62000
	CloneFlagsAttr   uint16 = 27281
	NsPathsAttr      uint16 = 27282
	UidmapAttr       uint16 = 27283
	GidmapAttr       uint16 = 27284
	SetgroupAttr     uint16 = 27285
	OomScoreAdjAttr  uint16 = 27286
	RootlessEUIDAttr uint16 = 27287
	UidmapPathAttr   uint16 = 27288
	GidmapPathAttr   uint16 = 27289
	MountSourcesAttr uint16 = 27290
)
type Int32msg struct {
	Type  uint16
	Value uint32
}
// Serialize serializes the message.
// Int32msg has the following representation
// | nlattr len | nlattr type |
// | uint32 value             |
func (msg *Int32msg) Serialize() []byte {
	buf := make([]byte, msg.Len())
	native := nl.NativeEndian()
	native.PutUint16(buf[0:2], uint16(msg.Len()))
	native.PutUint16(buf[2:4], msg.Type)
	native.PutUint32(buf[4:8], msg.Value)
	return buf
}
func (msg *Int32msg) Len() int {
	return unix.NLA_HDRLEN + 4
}
// Bytemsg has the following representation
// | nlattr len | nlattr type |
// | value              | pad |
type Bytemsg struct {
	Type  uint16
	Value []byte
}
func (msg *Bytemsg) Serialize() []byte {
	l := msg.Len()
	buf := make([]byte, (l+unix.NLA_ALIGNTO-1) & ^(unix.NLA_ALIGNTO-1))
	native := nl.NativeEndian()
	native.PutUint16(buf[0:2], uint16(l))
	native.PutUint16(buf[2:4], msg.Type)
	copy(buf[4:], msg.Value)
	return buf
}
func (msg *Bytemsg) Len() int {
	return unix.NLA_HDRLEN + len(msg.Value) + 1 // null-terminated
}
type Boolmsg struct {
	Type  uint16
	Value bool
}
func (msg *Boolmsg) Serialize() []byte {
	buf := make([]byte, msg.Len())
	native := nl.NativeEndian()
	native.PutUint16(buf[0:2], uint16(msg.Len()))
	native.PutUint16(buf[2:4], msg.Type)
	if msg.Value {
		native.PutUint32(buf[4:8], uint32(1))
	} else {
		native.PutUint32(buf[4:8], uint32(0))
	}
	return buf
}
func (msg *Boolmsg) Len() int {
	return unix.NLA_HDRLEN + 4 // alignment
}
",CWE-190,89.0,1
"/*-
 * Copyright 2014 Square Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package josecipher
import (
	""bytes""
	""crypto/cipher""
	""crypto/hmac""
	""crypto/sha256""
	""crypto/sha512""
	""crypto/subtle""
	""encoding/binary""
	""errors""
	""hash""
)
const (
	nonceBytes = 16
)
// NewCBCHMAC instantiates a new AEAD based on CBC+HMAC.
func NewCBCHMAC(key []byte, newBlockCipher func([]byte) (cipher.Block, error)) (cipher.AEAD, error) {
	keySize := len(key) / 2
	integrityKey := key[:keySize]
	encryptionKey := key[keySize:]
	blockCipher, err := newBlockCipher(encryptionKey)
	if err != nil {
		return nil, err
	}
	var hash func() hash.Hash
	switch keySize {
	case 16:
		hash = sha256.New
	case 24:
		hash = sha512.New384
	case 32:
		hash = sha512.New
	}
	return &cbcAEAD{
		hash:         hash,
		blockCipher:  blockCipher,
		authtagBytes: keySize,
		integrityKey: integrityKey,
	}, nil
}
// An AEAD based on CBC+HMAC
type cbcAEAD struct {
	hash         func() hash.Hash
	authtagBytes int
	integrityKey []byte
	blockCipher  cipher.Block
}
func (ctx *cbcAEAD) NonceSize() int {
	return nonceBytes
}
func (ctx *cbcAEAD) Overhead() int {
	// Maximum overhead is block size (for padding) plus auth tag length, where
	// the length of the auth tag is equivalent to the key size.
	return ctx.blockCipher.BlockSize() + ctx.authtagBytes
}
// Seal encrypts and authenticates the plaintext.
func (ctx *cbcAEAD) Seal(dst, nonce, plaintext, data []byte) []byte {
	// Output buffer -- must take care not to mangle plaintext input.
	ciphertext := make([]byte, len(plaintext)+ctx.Overhead())[:len(plaintext)]
	copy(ciphertext, plaintext)
	ciphertext = padBuffer(ciphertext, ctx.blockCipher.BlockSize())
	cbc := cipher.NewCBCEncrypter(ctx.blockCipher, nonce)
	cbc.CryptBlocks(ciphertext, ciphertext)
	authtag := ctx.computeAuthTag(data, nonce, ciphertext)
	ret, out := resize(dst, len(dst)+len(ciphertext)+len(authtag))
	copy(out, ciphertext)
	copy(out[len(ciphertext):], authtag)
	return ret
}
// Open decrypts and authenticates the ciphertext.
func (ctx *cbcAEAD) Open(dst, nonce, ciphertext, data []byte) ([]byte, error) {
	if len(ciphertext) < ctx.authtagBytes {
		return nil, errors.New(""square/go-jose: invalid ciphertext (too short)"")
	}
	offset := len(ciphertext) - ctx.authtagBytes
	expectedTag := ctx.computeAuthTag(data, nonce, ciphertext[:offset])
	match := subtle.ConstantTimeCompare(expectedTag, ciphertext[offset:])
	if match != 1 {
		return nil, errors.New(""square/go-jose: invalid ciphertext (auth tag mismatch)"")
	}
	cbc := cipher.NewCBCDecrypter(ctx.blockCipher, nonce)
	// Make copy of ciphertext buffer, don't want to modify in place
	buffer := append([]byte{}, []byte(ciphertext[:offset])...)
	if len(buffer)%ctx.blockCipher.BlockSize() > 0 {
		return nil, errors.New(""square/go-jose: invalid ciphertext (invalid length)"")
	}
	cbc.CryptBlocks(buffer, buffer)
	// Remove padding
	plaintext, err := unpadBuffer(buffer, ctx.blockCipher.BlockSize())
	if err != nil {
		return nil, err
	}
	ret, out := resize(dst, len(dst)+len(plaintext))
	copy(out, plaintext)
	return ret, nil
}
// Compute an authentication tag
func (ctx *cbcAEAD) computeAuthTag(aad, nonce, ciphertext []byte) []byte {
	buffer := make([]byte, len(aad)+len(nonce)+len(ciphertext)+8)
	n := 0
	n += copy(buffer, aad)
	n += copy(buffer[n:], nonce)
	n += copy(buffer[n:], ciphertext)
	binary.BigEndian.PutUint64(buffer[n:], uint64(len(aad)*8))
	// According to documentation, Write() on hash.Hash never fails.
	hmac := hmac.New(ctx.hash, ctx.integrityKey)
	_, _ = hmac.Write(buffer)
	return hmac.Sum(nil)[:ctx.authtagBytes]
}
// resize ensures the the given slice has a capacity of at least n bytes.
// If the capacity of the slice is less than n, a new slice is allocated
// and the existing data will be copied.
func resize(in []byte, n int) (head, tail []byte) {
	if cap(in) >= n {
		head = in[:n]
	} else {
		head = make([]byte, n)
		copy(head, in)
	}
	tail = head[len(in):]
	return
}
// Apply padding
func padBuffer(buffer []byte, blockSize int) []byte {
	missing := blockSize - (len(buffer) % blockSize)
	ret, out := resize(buffer, len(buffer)+missing)
	padding := bytes.Repeat([]byte{byte(missing)}, missing)
	copy(out, padding)
	return ret
}
// Remove padding
func unpadBuffer(buffer []byte, blockSize int) ([]byte, error) {
	if len(buffer)%blockSize != 0 {
		return nil, errors.New(""square/go-jose: invalid padding"")
	}
	last := buffer[len(buffer)-1]
	count := int(last)
	if count == 0 || count > blockSize || count > len(buffer) {
		return nil, errors.New(""square/go-jose: invalid padding"")
	}
	padding := bytes.Repeat([]byte{last}, count)
	if !bytes.HasSuffix(buffer, padding) {
		return nil, errors.New(""square/go-jose: invalid padding"")
	}
	return buffer[:len(buffer)-count], nil
}
",CWE-190,197.0,1
"/*-
 * Copyright 2014 Square Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package josecipher
import (
	""crypto""
	""encoding/binary""
	""hash""
	""io""
)
type concatKDF struct {
	z, info []byte
	i       uint32
	cache   []byte
	hasher  hash.Hash
}
// NewConcatKDF builds a KDF reader based on the given inputs.
func NewConcatKDF(hash crypto.Hash, z, algID, ptyUInfo, ptyVInfo, supPubInfo, supPrivInfo []byte) io.Reader {
	buffer := make([]byte, len(algID)+len(ptyUInfo)+len(ptyVInfo)+len(supPubInfo)+len(supPrivInfo))
	n := 0
	n += copy(buffer, algID)
	n += copy(buffer[n:], ptyUInfo)
	n += copy(buffer[n:], ptyVInfo)
	n += copy(buffer[n:], supPubInfo)
	copy(buffer[n:], supPrivInfo)
	hasher := hash.New()
	return &concatKDF{
		z:      z,
		info:   buffer,
		hasher: hasher,
		cache:  []byte{},
		i:      1,
	}
}
func (ctx *concatKDF) Read(out []byte) (int, error) {
	copied := copy(out, ctx.cache)
	ctx.cache = ctx.cache[copied:]
	for copied < len(out) {
		ctx.hasher.Reset()
		// Write on a hash.Hash never fails
		_ = binary.Write(ctx.hasher, binary.BigEndian, ctx.i)
		_, _ = ctx.hasher.Write(ctx.z)
		_, _ = ctx.hasher.Write(ctx.info)
		hash := ctx.hasher.Sum(nil)
		chunkCopied := copy(out[copied:], hash)
		copied += chunkCopied
		ctx.cache = hash[chunkCopied:]
		ctx.i++
	}
	return copied, nil
}
",CWE-190,76.0,1
"/*-
 * Copyright 2014 Square Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package josecipher
import (
	""crypto""
	""crypto/ecdsa""
	""encoding/binary""
)
// DeriveECDHES derives a shared encryption key using ECDH/ConcatKDF as described in JWE/JWA.
// It is an error to call this function with a private/public key that are not on the same
// curve. Callers must ensure that the keys are valid before calling this function.
func DeriveECDHES(alg string, apuData, apvData []byte, priv *ecdsa.PrivateKey, pub *ecdsa.PublicKey, size int) []byte {
	// algId, partyUInfo, partyVInfo inputs must be prefixed with the length
	algID := lengthPrefixed([]byte(alg))
	ptyUInfo := lengthPrefixed(apuData)
	ptyVInfo := lengthPrefixed(apvData)
	// suppPubInfo is the encoded length of the output size in bits
	supPubInfo := make([]byte, 4)
	binary.BigEndian.PutUint32(supPubInfo, uint32(size)*8)
	if !priv.PublicKey.Curve.IsOnCurve(pub.X, pub.Y) {
		panic(""public key not on same curve as private key"")
	}
	z, _ := priv.PublicKey.Curve.ScalarMult(pub.X, pub.Y, priv.D.Bytes())
	reader := NewConcatKDF(crypto.SHA256, z.Bytes(), algID, ptyUInfo, ptyVInfo, supPubInfo, []byte{})
	key := make([]byte, size)
	// Read on the KDF will never fail
	_, _ = reader.Read(key)
	return key
}
func lengthPrefixed(data []byte) []byte {
	out := make([]byte, len(data)+4)
	binary.BigEndian.PutUint32(out, uint32(len(data)))
	copy(out[4:], data)
	return out
}
",CWE-190,58.0,1
"<meta name=""render:status_code"" content=""401"">
<meta name=""render:status_code"" content=""402"">",CWE-79,2.0,1
"<meta name=""render:status_code"" content=""401"">
<meta name=""render:status_code"" content=""402"">",CWE-22,2.0,1
"<meta name=""render:status_code"" content=""401"">
<meta name=""render:status_code"" content=""402"">",CWE-200,2.0,1
"<meta name=""render:status_code"" content=""400"">",CWE-79,1.0,1
"<meta name=""render:status_code"" content=""400"">",CWE-22,1.0,1
"<meta name=""render:status_code"" content=""400"">",CWE-200,1.0,1
"// Sandstorm - Personal Cloud Sandbox
// Copyright (c) 2016 Sandstorm Development Group, Inc. and contributors
// All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
ACCOUNT_DELETION_SUSPENSION_TIME = 7 * 60 * 60 * 24 * 1000; // 7 days in ms
export { ACCOUNT_DELETION_SUSPENSION_TIME };
",CWE-918,20.0,1
"/*
 * Minio Cloud Storage, (C) 2017 Minio, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package hash
import (
	""bytes""
	""crypto/md5""
	""encoding/base64""
	""encoding/hex""
	""errors""
	""hash""
	""io""
	sha256 ""github.com/minio/sha256-simd""
)
var errNestedReader = errors.New(""Nesting of Reader detected, not allowed"")
// Reader writes what it reads from an io.Reader to an MD5 and SHA256 hash.Hash.
// Reader verifies that the content of the io.Reader matches the expected checksums.
type Reader struct {
	src  io.Reader
	size int64
	md5sum, sha256sum   []byte // Byte values of md5sum, sha256sum of client sent values.
	md5Hash, sha256Hash hash.Hash
}
// NewReader returns a new hash Reader which computes the MD5 sum and
// SHA256 sum (if set) of the provided io.Reader at EOF.
func NewReader(src io.Reader, size int64, md5Hex, sha256Hex string) (*Reader, error) {
	if _, ok := src.(*Reader); ok {
		return nil, errNestedReader
	}
	sha256sum, err := hex.DecodeString(sha256Hex)
	if err != nil {
		return nil, SHA256Mismatch{}
	}
	md5sum, err := hex.DecodeString(md5Hex)
	if err != nil {
		return nil, BadDigest{}
	}
	var sha256Hash hash.Hash
	if len(sha256sum) != 0 {
		sha256Hash = sha256.New()
	}
	return &Reader{
		md5sum:     md5sum,
		sha256sum:  sha256sum,
		src:        io.LimitReader(src, size),
		size:       size,
		md5Hash:    md5.New(),
		sha256Hash: sha256Hash,
	}, nil
}
func (r *Reader) Read(p []byte) (n int, err error) {
	n, err = r.src.Read(p)
	if n > 0 {
		r.md5Hash.Write(p[:n])
		if r.sha256Hash != nil {
			r.sha256Hash.Write(p[:n])
		}
	}
	// At io.EOF verify if the checksums are right.
	if err == io.EOF {
		if cerr := r.Verify(); cerr != nil {
			return 0, cerr
		}
	}
	return
}
// Size returns the absolute number of bytes the Reader
// will return during reading. It returns -1 for unlimited
// data.
func (r *Reader) Size() int64 { return r.size }
// MD5 - returns byte md5 value
func (r *Reader) MD5() []byte {
	return r.md5sum
}
// MD5Current - returns byte md5 value of the current state
// of the md5 hash after reading the incoming content.
// NOTE: Calling this function multiple times might yield
// different results if they are intermixed with Reader.
func (r *Reader) MD5Current() []byte {
	return r.md5Hash.Sum(nil)
}
// SHA256 - returns byte sha256 value
func (r *Reader) SHA256() []byte {
	return r.sha256sum
}
// MD5HexString returns hex md5 value.
func (r *Reader) MD5HexString() string {
	return hex.EncodeToString(r.md5sum)
}
// MD5Base64String returns base64 encoded MD5sum value.
func (r *Reader) MD5Base64String() string {
	return base64.StdEncoding.EncodeToString(r.md5sum)
}
// SHA256HexString returns hex sha256 value.
func (r *Reader) SHA256HexString() string {
	return hex.EncodeToString(r.sha256sum)
}
// Verify verifies if the computed MD5 sum and SHA256 sum are
// equal to the ones specified when creating the Reader.
func (r *Reader) Verify() error {
	if r.sha256Hash != nil && len(r.sha256sum) > 0 {
		if sum := r.sha256Hash.Sum(nil); !bytes.Equal(r.sha256sum, sum) {
			return SHA256Mismatch{hex.EncodeToString(r.sha256sum), hex.EncodeToString(sum)}
		}
	}
	if len(r.md5sum) > 0 {
		if sum := r.md5Hash.Sum(nil); !bytes.Equal(r.md5sum, sum) {
			return BadDigest{hex.EncodeToString(r.md5sum), hex.EncodeToString(sum)}
		}
	}
	return nil
}
",CWE-774,147.0,1
"package archiver
import (
	""fmt""
	""io""
	""log""
	""os""
	""path/filepath""
	""runtime""
)
// Archiver represent a archive format
type Archiver interface {
	// Match checks supported files
	Match(filename string) bool
	// Make makes an archive file on disk.
	Make(destination string, sources []string) error
	// Open extracts an archive file on disk.
	Open(source, destination string) error
	// Write writes an archive to a Writer.
	Write(output io.Writer, sources []string) error
	// Read reads an archive from a Reader.
	Read(input io.Reader, destination string) error
}
// SupportedFormats contains all supported archive formats
var SupportedFormats = map[string]Archiver{}
// RegisterFormat adds a supported archive format
func RegisterFormat(name string, format Archiver) {
	if _, ok := SupportedFormats[name]; ok {
		log.Printf(""Format %s already exists, skip!\n"", name)
		return
	}
	SupportedFormats[name] = format
}
// MatchingFormat returns the first archive format that matches
// the given file, or nil if there is no match
func MatchingFormat(fpath string) Archiver {
	for _, fmt := range SupportedFormats {
		if fmt.Match(fpath) {
			return fmt
		}
	}
	return nil
}
func writeNewFile(fpath string, in io.Reader, fm os.FileMode) error {
	err := os.MkdirAll(filepath.Dir(fpath), 0755)
	if err != nil {
		return fmt.Errorf(""%s: making directory for file: %v"", fpath, err)
	}
	out, err := os.Create(fpath)
	if err != nil {
		return fmt.Errorf(""%s: creating new file: %v"", fpath, err)
	}
	defer out.Close()
	err = out.Chmod(fm)
	if err != nil && runtime.GOOS != ""windows"" {
		return fmt.Errorf(""%s: changing file mode: %v"", fpath, err)
	}
	_, err = io.Copy(out, in)
	if err != nil {
		return fmt.Errorf(""%s: writing file: %v"", fpath, err)
	}
	return nil
}
func writeNewSymbolicLink(fpath string, target string) error {
	err := os.MkdirAll(filepath.Dir(fpath), 0755)
	if err != nil {
		return fmt.Errorf(""%s: making directory for file: %v"", fpath, err)
	}
	err = os.Symlink(target, fpath)
	if err != nil {
		return fmt.Errorf(""%s: making symbolic link for: %v"", fpath, err)
	}
	return nil
}
func writeNewHardLink(fpath string, target string) error {
	err := os.MkdirAll(filepath.Dir(fpath), 0755)
	if err != nil {
		return fmt.Errorf(""%s: making directory for file: %v"", fpath, err)
	}
	err = os.Link(target, fpath)
	if err != nil {
		return fmt.Errorf(""%s: making hard link for: %v"", fpath, err)
	}
	return nil
}
func mkdir(dirPath string) error {
	err := os.MkdirAll(dirPath, 0755)
	if err != nil {
		return fmt.Errorf(""%s: making directory: %v"", dirPath, err)
	}
	return nil
}
",CWE-22,108.0,1
"package main
import (
	""fmt""
	""os""
	""github.com/mholt/archiver""
)
func main() {
	if len(os.Args) < 3 {
		fatal(usage)
	}
	cmd, filename := os.Args[1], os.Args[2]
	ff := archiver.MatchingFormat(filename)
	if ff == nil {
		fatalf(""%s: Unsupported file extension"", filename)
	}
	var err error
	switch cmd {
	case ""make"":
		if len(os.Args) < 4 {
			fatal(usage)
		}
		err = ff.Make(filename, os.Args[3:])
	case ""open"":
		dest := """"
		if len(os.Args) == 4 {
			dest = os.Args[3]
		} else if len(os.Args) > 4 {
			fatal(usage)
		}
		err = ff.Open(filename, dest)
	default:
		fatal(usage)
	}
	if err != nil {
		fatal(err)
	}
}
func fatal(v ...interface{}) {
	fmt.Fprintln(os.Stderr, v...)
	os.Exit(1)
}
func fatalf(s string, v ...interface{}) {
	fmt.Fprintf(os.Stderr, s+""\n"", v...)
	os.Exit(1)
}
const usage = `Usage: archiver {make|open} <archive file> [files...]
  make
    Create a new archive file. List the files/folders
    to include in the archive; at least one required.
  open
    Extract an archive file. Give only the archive to
    open and the destination folder to extract into.
  Specifying archive format:
    The format of the archive is determined by its
    file extension. Supported extensions:
      .zip
      .tar
      .tar.gz
      .tgz
      .tar.bz2
      .tbz2
      .tar.xz
      .txz
      .tar.lz4
      .tlz4
      .tar.sz
      .tsz
      .rar (open only)
  Existing files:
    When creating an archive file that already exists,
    archiver will overwrite the existing file. When
    extracting files, archiver will NOT overwrite files
    that already exist in the destination path; this
    is treated as an error and extraction will abort.`
",CWE-22,86.0,1
"package archiver
import (
	""bytes""
	""fmt""
	""io""
	""os""
	""path/filepath""
	""strings""
	""github.com/nwaples/rardecode""
)
// Rar is for RAR archive format
var Rar rarFormat
func init() {
	RegisterFormat(""Rar"", Rar)
}
type rarFormat struct{}
func (rarFormat) Match(filename string) bool {
	return strings.HasSuffix(strings.ToLower(filename), "".rar"") || isRar(filename)
}
// isRar checks the file has the RAR 1.5 or 5.0 format signature by reading its
// beginning bytes and matching it
func isRar(rarPath string) bool {
	f, err := os.Open(rarPath)
	if err != nil {
		return false
	}
	defer f.Close()
	buf := make([]byte, 8)
	if n, err := f.Read(buf); err != nil || n < 8 {
		return false
	}
	return bytes.Equal(buf[:7], []byte(""Rar!\x1a\x07\x00"")) || // ver 1.5
		bytes.Equal(buf, []byte(""Rar!\x1a\x07\x01\x00"")) // ver 5.0
}
// Write outputs a .rar archive, but this is not implemented because
// RAR is a proprietary format. It is here only for symmetry with
// the other archive formats in this package.
func (rarFormat) Write(output io.Writer, filePaths []string) error {
	return fmt.Errorf(""write: RAR not implemented (proprietary format)"")
}
// Make makes a .rar archive, but this is not implemented because
// RAR is a proprietary format. It is here only for symmetry with
// the other archive formats in this package.
func (rarFormat) Make(rarPath string, filePaths []string) error {
	return fmt.Errorf(""make %s: RAR not implemented (proprietary format)"", rarPath)
}
// Read extracts the RAR file read from input and puts the contents
// into destination.
func (rarFormat) Read(input io.Reader, destination string) error {
	rr, err := rardecode.NewReader(input, """")
	if err != nil {
		return fmt.Errorf(""read: failed to create reader: %v"", err)
	}
	for {
		header, err := rr.Next()
		if err == io.EOF {
			break
		} else if err != nil {
			return err
		}
		if header.IsDir {
			err = mkdir(filepath.Join(destination, header.Name))
			if err != nil {
				return err
			}
			continue
		}
		// if files come before their containing folders, then we must
		// create their folders before writing the file
		err = mkdir(filepath.Dir(filepath.Join(destination, header.Name)))
		if err != nil {
			return err
		}
		err = writeNewFile(filepath.Join(destination, header.Name), rr, header.Mode())
		if err != nil {
			return err
		}
	}
	return nil
}
// Open extracts the RAR file at source and puts the contents
// into destination.
func (rarFormat) Open(source, destination string) error {
	rf, err := os.Open(source)
	if err != nil {
		return fmt.Errorf(""%s: failed to open file: %v"", source, err)
	}
	defer rf.Close()
	return Rar.Read(rf, destination)
}
",CWE-22,110.0,1
"// +build go1.7
// Copyright 2014 The Gogs Authors. All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.
// Gogs is a painless self-hosted Git Service.
package main
import (
	""os""
	""github.com/urfave/cli""
	""github.com/gogs/gogs/cmd""
	""github.com/gogs/gogs/pkg/setting""
)
const APP_VER = ""0.11.81.1217""
func init() {
	setting.AppVer = APP_VER
}
func main() {
	app := cli.NewApp()
	app.Name = ""Gogs""
	app.Usage = ""A painless self-hosted Git service""
	app.Version = APP_VER
	app.Commands = []cli.Command{
		cmd.Web,
		cmd.Serv,
		cmd.Hook,
		cmd.Cert,
		cmd.Admin,
		cmd.Import,
		cmd.Backup,
		cmd.Restore,
	}
	app.Run(os.Args)
}
",CWE-22,42.0,1
"// Copyright 2018 The Gogs Authors. All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.
package tool
import (
	""strings""
)
// IsSameSiteURLPath returns true if the URL path belongs to the same site, false otherwise.
// False: //url, http://url, /\url
// True: /url
func IsSameSiteURLPath(url string) bool {
	return len(url) >= 2 && url[0] == '/' && url[1] != '/' && url[1] != '\\'
}
// SanitizePath sanitizes user-defined file paths to prevent remote code execution.
func SanitizePath(path string) string {
	return strings.TrimLeft(path, ""./"")
}
",CWE-22,22.0,1
"// Copyright 2018 The Gogs Authors. All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.
package tool
import (
	""testing""
	. ""github.com/smartystreets/goconvey/convey""
)
func Test_IsSameSiteURLPath(t *testing.T) {
	Convey(""Check if a path belongs to the same site"", t, func() {
		testCases := []struct {
			url    string
			expect bool
		}{
			{""//github.com"", false},
			{""http://github.com"", false},
			{""https://github.com"", false},
			{""/\\github.com"", false},
			{""/admin"", true},
			{""/user/repo"", true},
		}
		for _, tc := range testCases {
			So(IsSameSiteURLPath(tc.url), ShouldEqual, tc.expect)
		}
	})
}
func Test_SanitizePath(t *testing.T) {
	Convey(""Sanitize malicious user-defined path"", t, func() {
		testCases := []struct {
			path   string
			expect string
		}{
			{""../../../../../../../../../data/gogs/data/sessions/a/9/a9f0ab6c3ef63dd8"", ""data/gogs/data/sessions/a/9/a9f0ab6c3ef63dd8""},
			{""data/sessions/a/9/a9f0ab6c3ef63dd8"", ""data/sessions/a/9/a9f0ab6c3ef63dd8""},
		}
		for _, tc := range testCases {
			So(SanitizePath(tc.path), ShouldEqual, tc.expect)
		}
	})
}
",CWE-22,49.0,1
"// Copyright 2022 The Gogs Authors. All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.
package netutil
import (
	""fmt""
	""net""
)
var localCIDRs []*net.IPNet
func init() {
	// Parsing hardcoded CIDR strings should never fail, if in case it does, let's
	// fail it at start.
	rawCIDRs := []string{
		// https://datatracker.ietf.org/doc/html/rfc5735:
		""127.0.0.0/8"",        // Loopback
		""0.0.0.0/8"",          // ""This"" network
		""100.64.0.0/10"",      // Shared address space
		""169.254.0.0/16"",     // Link local
		""172.16.0.0/12"",      // Private-use networks
		""192.0.0.0/24"",       // IETF Protocol assignments
		""192.0.2.0/24"",       // TEST-NET-1
		""192.88.99.0/24"",     // 6to4 Relay anycast
		""192.168.0.0/16"",     // Private-use networks
		""198.18.0.0/15"",      // Network interconnect
		""198.51.100.0/24"",    // TEST-NET-2
		""203.0.113.0/24"",     // TEST-NET-3
		""255.255.255.255/32"", // Limited broadcast
		// https://datatracker.ietf.org/doc/html/rfc1918:
		""10.0.0.0/8"", // Private-use networks
		// https://datatracker.ietf.org/doc/html/rfc6890:
		""::1/128"",   // Loopback
		""FC00::/7"",  // Unique local address
		""FE80::/10"", // Multicast address
	}
	for _, raw := range rawCIDRs {
		_, cidr, err := net.ParseCIDR(raw)
		if err != nil {
			panic(fmt.Sprintf(""parse CIDR %q: %v"", raw, err))
		}
		localCIDRs = append(localCIDRs, cidr)
	}
}
// IsLocalHostname returns true if given hostname is resolved to local network
// address, except exempted from the allowlist.
func IsLocalHostname(hostname string, allowlist []string) bool {
	for _, allow := range allowlist {
		if hostname == allow {
			return false
		}
	}
	ips, err := net.LookupIP(hostname)
	if err != nil {
		return true
	}
	for _, ip := range ips {
		for _, cidr := range localCIDRs {
			if cidr.Contains(ip) {
				return true
			}
		}
	}
	return false
}
",CWE-918,72.0,1
"// Copyright 2022 The Gogs Authors. All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.
package netutil
import (
	""testing""
	""github.com/stretchr/testify/assert""
)
func TestIsLocalHostname(t *testing.T) {
	tests := []struct {
		hostname  string
		allowlist []string
		want      bool
	}{
		{hostname: ""localhost"", want: true},       // 
		{hostname: ""127.0.0.1"", want: true},       // 
		{hostname: ""::1"", want: true},             // 
		{hostname: ""0:0:0:0:0:0:0:1"", want: true}, // 
		{hostname: ""fuf.me"", want: true},          // 
		{hostname: ""127.0.0.95"", want: true},      // 
		{hostname: ""0.0.0.0"", want: true},         // 
		{hostname: ""192.168.123.45"", want: true},  // 
		{hostname: ""gogs.io"", want: false},         // 
		{hostname: ""google.com"", want: false},      // 
		{hostname: ""165.232.140.255"", want: false}, // 
		{hostname: ""192.168.123.45"", allowlist: []string{""10.0.0.17""}, want: true}, // 
		{hostname: ""gogs.local"", allowlist: []string{""gogs.local""}, want: false},   // 
	}
	for _, test := range tests {
		t.Run("""", func(t *testing.T) {
			assert.Equal(t, test.want, IsLocalHostname(test.hostname, test.allowlist))
		})
	}
}
",CWE-918,41.0,1
"// Copyright 2020 The Gogs Authors. All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.
package repo
import (
	""testing""
	""github.com/stretchr/testify/assert""
	""gogs.io/gogs/internal/db""
	""gogs.io/gogs/internal/mocks""
)
func Test_validateWebhook(t *testing.T) {
	l := &mocks.Locale{
		MockLang: ""en"",
		MockTr: func(s string, _ ...interface{}) string {
			return s
		},
	}
	tests := []struct {
		name     string
		actor    *db.User
		webhook  *db.Webhook
		expField string
		expMsg   string
		expOK    bool
	}{
		{
			name:    ""admin bypass local address check"",
			actor:   &db.User{IsAdmin: true},
			webhook: &db.Webhook{URL: ""http://localhost:3306""},
			expOK:   true,
		},
		{
			name:     ""local address not allowed"",
			actor:    &db.User{},
			webhook:  &db.Webhook{URL: ""http://localhost:3306""},
			expField: ""PayloadURL"",
			expMsg:   ""repo.settings.webhook.err_cannot_use_local_addresses"",
			expOK:    false,
		},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			field, msg, ok := validateWebhook(test.actor, l, test.webhook)
			assert.Equal(t, test.expOK, ok)
			assert.Equal(t, test.expMsg, msg)
			assert.Equal(t, test.expField, field)
		})
	}
}
",CWE-918,57.0,1
"// Copyright 2018 The Gogs Authors. All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.
package db
import (
	""path/filepath""
	""testing""
	""github.com/stretchr/testify/assert""
)
func Test_isRepositoryGitPath(t *testing.T) {
	tests := []struct {
		path    string
		wantVal bool
	}{
		{path: filepath.Join(""."", "".git""), wantVal: true},
		{path: filepath.Join(""."", "".git"", """"), wantVal: true},
		{path: filepath.Join(""."", "".git"", ""hooks"", ""pre-commit""), wantVal: true},
		{path: filepath.Join("".git"", ""hooks""), wantVal: true},
		{path: filepath.Join(""dir"", "".git""), wantVal: true},
		{path: filepath.Join(""."", "".git.""), wantVal: true},
		{path: filepath.Join(""."", "".git."", """"), wantVal: true},
		{path: filepath.Join(""."", "".git."", ""hooks"", ""pre-commit""), wantVal: true},
		{path: filepath.Join("".git."", ""hooks""), wantVal: true},
		{path: filepath.Join(""dir"", "".git.""), wantVal: true},
		{path: filepath.Join("".gitignore""), wantVal: false},
		{path: filepath.Join(""dir"", "".gitkeep""), wantVal: false},
	}
	for _, test := range tests {
		t.Run("""", func(t *testing.T) {
			assert.Equal(t, test.wantVal, isRepositoryGitPath(test.path))
		})
	}
}
",CWE-78,40.0,1
"// Copyright 2020 The Gogs Authors. All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.
package pathutil
import (
	""path""
	""strings""
)
// Clean cleans up given path and returns a relative path that goes straight down.
func Clean(p string) string {
	return strings.Trim(path.Clean(""/""+p), ""/"")
}
",CWE-22,16.0,1
"// Copyright 2020 The Gogs Authors. All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.
package pathutil
import (
	""testing""
	""github.com/stretchr/testify/assert""
)
func TestClean(t *testing.T) {
	tests := []struct {
		path   string
		expVal string
	}{
		{
			path:   ""../../../readme.txt"",
			expVal: ""readme.txt"",
		},
		{
			path:   ""a/../../../readme.txt"",
			expVal: ""readme.txt"",
		},
		{
			path:   ""/../a/b/../c/../readme.txt"",
			expVal: ""a/readme.txt"",
		},
		{
			path:   ""/a/readme.txt"",
			expVal: ""a/readme.txt"",
		},
		{
			path:   ""/"",
			expVal: """",
		},
		{
			path:   ""/a/b/c/readme.txt"",
			expVal: ""a/b/c/readme.txt"",
		},
	}
	for _, test := range tests {
		t.Run("""", func(t *testing.T) {
			assert.Equal(t, test.expVal, Clean(test.path))
		})
	}
}
",CWE-22,50.0,1
"// Copyright 2020 The Gogs Authors. All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.
package pathutil
import (
	""testing""
	""github.com/stretchr/testify/assert""
)
func TestClean(t *testing.T) {
	tests := []struct {
		path    string
		wantVal string
	}{
		{
			path:    ""../../../readme.txt"",
			wantVal: ""readme.txt"",
		},
		{
			path:    ""a/../../../readme.txt"",
			wantVal: ""readme.txt"",
		},
		{
			path:    ""/../a/b/../c/../readme.txt"",
			wantVal: ""a/readme.txt"",
		},
		{
			path:    ""/a/readme.txt"",
			wantVal: ""a/readme.txt"",
		},
		{
			path:    ""/"",
			wantVal: """",
		},
		{
			path:    ""/a/b/c/readme.txt"",
			wantVal: ""a/b/c/readme.txt"",
		},
		// Windows-specific
		{
			path:    `..\..\..\readme.txt`,
			wantVal: ""readme.txt"",
		},
		{
			path:    `a\..\..\..\readme.txt`,
			wantVal: ""readme.txt"",
		},
		{
			path:    `\..\a\b\..\c\..\readme.txt`,
			wantVal: ""a/readme.txt"",
		},
		{
			path:    `\a\readme.txt`,
			wantVal: ""a/readme.txt"",
		},
		{
			path:    `..\..\..\../README.md`,
			wantVal: ""README.md"",
		},
		{
			path:    `\`,
			wantVal: """",
		},
		{
			path:    `\a\b\c\readme.txt`,
			wantVal: `a/b/c/readme.txt`,
		},
	}
	for _, test := range tests {
		t.Run(test.path, func(t *testing.T) {
			assert.Equal(t, test.wantVal, Clean(test.path))
		})
	}
}
",CWE-22,81.0,1
"// Copyright 2018 The Gogs Authors. All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.
package db
import (
	""testing""
	""github.com/stretchr/testify/assert""
)
func Test_isRepositoryGitPath(t *testing.T) {
	tests := []struct {
		path    string
		wantVal bool
	}{
		{path: "".git"", wantVal: true},
		{path: ""./.git"", wantVal: true},
		{path: "".git/hooks/pre-commit"", wantVal: true},
		{path: "".git/hooks"", wantVal: true},
		{path: ""dir/.git"", wantVal: true},
		{path: "".gitignore"", wantVal: false},
		{path: ""dir/.gitkeep"", wantVal: false},
		// Windows-specific
		{path: `.git\`, wantVal: true},
		{path: `.git\hooks\pre-commit`, wantVal: true},
		{path: `.git\hooks`, wantVal: true},
		{path: `dir\.git`, wantVal: true},
		{path: `.\.git.`, wantVal: true},
		{path: `.\.git.\`, wantVal: true},
		{path: `.git.\hooks\pre-commit`, wantVal: true},
		{path: `.git.\hooks`, wantVal: true},
		{path: `dir\.git.`, wantVal: true},
		{path: ""./.git."", wantVal: true},
		{path: ""./.git./"", wantVal: true},
		{path: "".git./hooks/pre-commit"", wantVal: true},
		{path: "".git./hooks"", wantVal: true},
		{path: ""dir/.git."", wantVal: true},
		{path: `dir\.gitkeep`, wantVal: false},
	}
	for _, test := range tests {
		t.Run(test.path, func(t *testing.T) {
			assert.Equal(t, test.wantVal, isRepositoryGitPath(test.path))
		})
	}
}
",CWE-78,53.0,1
"package extractor
import (
	""archive/tar""
	""compress/gzip""
	""fmt""
	""io""
	""os""
	""os/exec""
	""path/filepath""
)
type tgzExtractor struct{}
func NewTgz() Extractor {
	return &tgzExtractor{}
}
func (e *tgzExtractor) Extract(src, dest string) error {
	srcType, err := mimeType(src)
	if err != nil {
		return err
	}
	switch srcType {
	case ""application/x-gzip"":
		err := extractTgz(src, dest)
		if err != nil {
			return err
		}
	default:
		return fmt.Errorf(""%s is not a tgz archive: %s"", src, srcType)
	}
	return nil
}
func extractTgz(src, dest string) error {
	tarPath, err := exec.LookPath(""tar"")
	if err == nil {
		err := os.MkdirAll(dest, 0755)
		if err != nil {
			return err
		}
		return exec.Command(tarPath, ""pzxf"", src, ""-C"", dest).Run()
	}
	fd, err := os.Open(src)
	if err != nil {
		return err
	}
	defer fd.Close()
	gReader, err := gzip.NewReader(fd)
	if err != nil {
		return err
	}
	defer gReader.Close()
	tarReader := tar.NewReader(gReader)
	return extractTarArchive(tarReader, dest)
}
func extractTarArchive(tarReader *tar.Reader, dest string) error {
	for {
		hdr, err := tarReader.Next()
		if err == io.EOF {
			break
		}
		if err != nil {
			return err
		}
		if hdr.Name == ""."" {
			continue
		}
		err = extractTarArchiveFile(hdr, dest, tarReader)
		if err != nil {
			return err
		}
	}
	return nil
}
func extractTarArchiveFile(header *tar.Header, dest string, input io.Reader) error {
	filePath := filepath.Join(dest, header.Name)
	fileInfo := header.FileInfo()
	if fileInfo.IsDir() {
		return os.MkdirAll(filePath, fileInfo.Mode())
	}
	err := os.MkdirAll(filepath.Dir(filePath), 0755)
	if err != nil {
		return err
	}
	if fileInfo.Mode()&os.ModeSymlink != 0 {
		return os.Symlink(header.Linkname, filePath)
	}
	fileCopy, err := os.OpenFile(filePath, os.O_RDWR|os.O_CREATE|os.O_TRUNC, fileInfo.Mode())
	if err != nil {
		return err
	}
	defer fileCopy.Close()
	_, err = io.Copy(fileCopy, input)
	return err
}
",CWE-22,116.0,1
"package extractor
import (
	""archive/zip""
	""fmt""
	""io""
	""io/ioutil""
	""os""
	""os/exec""
	""path/filepath""
)
type zipExtractor struct{}
func NewZip() Extractor {
	return &zipExtractor{}
}
func (e *zipExtractor) Extract(src, dest string) error {
	srcType, err := mimeType(src)
	if err != nil {
		return err
	}
	switch srcType {
	case ""application/zip"":
		err := extractZip(src, dest)
		if err != nil {
			return err
		}
	default:
		return fmt.Errorf(""%s is not a zip archive: %s"", src, srcType)
	}
	return nil
}
func extractZip(src, dest string) error {
	path, err := exec.LookPath(""unzip"")
	if err == nil {
		err := os.MkdirAll(dest, 0755)
		if err != nil {
			return err
		}
		unzipCmd := exec.Command(path, src)
		unzipCmd.Dir = dest
		return unzipCmd.Run()
	} else {
		files, err := zip.OpenReader(src)
		if err != nil {
			return err
		}
		defer files.Close()
		for _, file := range files.File {
			err = func() error {
				readCloser, err := file.Open()
				if err != nil {
					return err
				}
				defer readCloser.Close()
				return extractZipArchiveFile(file, dest, readCloser)
			}()
			if err != nil {
				return err
			}
		}
		return nil
	}
}
func extractZipArchiveFile(file *zip.File, dest string, input io.Reader) error {
	filePath := filepath.Join(dest, file.Name)
	fileInfo := file.FileInfo()
	if fileInfo.IsDir() {
		err := os.MkdirAll(filePath, fileInfo.Mode())
		if err != nil {
			return err
		}
	} else {
		err := os.MkdirAll(filepath.Dir(filePath), 0755)
		if err != nil {
			return err
		}
		if fileInfo.Mode()&os.ModeSymlink != 0 {
			linkName, err := ioutil.ReadAll(input)
			if err != nil {
				return err
			}
			return os.Symlink(string(linkName), filePath)
		}
		fileCopy, err := os.OpenFile(filePath, os.O_RDWR|os.O_CREATE|os.O_TRUNC, fileInfo.Mode())
		if err != nil {
			return err
		}
		defer fileCopy.Close()
		_, err = io.Copy(fileCopy, input)
		if err != nil {
			return err
		}
	}
	return nil
}
",CWE-22,116.0,1
"/*
 * Copyright 2019-present Facebook, Inc.
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package thrift
import (
	""testing""
)
func TestReadWriteBinaryProtocol(t *testing.T) {
	ReadWriteProtocolTest(t, NewBinaryProtocolFactoryDefault())
}
",CWE-755,30.0,1
"/*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package thrift
import (
	""strings""
	""testing""
	""time""
)
func TestReadWriteBinaryProtocol(t *testing.T) {
	ReadWriteProtocolTest(t, NewBinaryProtocolFactoryDefault())
}
func TestSkipUnknownTypeBinaryProtocol(t *testing.T) {
	var m MyTestStruct
	d := NewDeserializer()
	f := NewBinaryProtocolFactoryDefault()
	d.Protocol = f.GetProtocol(d.Transport)
	// skip over a map with invalid key/value type and 1.7B entries
	data := []byte(""\n\x10\rO\t6\x03\n\n\n\x10\r\n\tslice\x00"")
	start := time.Now()
	err := d.Read(&m, data)
	if err == nil {
		t.Fatalf(""Parsed invalid message correctly"")
	} else if !strings.Contains(err.Error(), ""unknown type"") {
		t.Fatalf(""Failed for reason besides unknown type"")
	}
	if time.Now().Sub(start).Seconds() > 5 {
		t.Fatalf(""It should not take seconds to parse a small message"")
	}
}
",CWE-770,48.0,1
"/*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package thrift
import (
	""bytes""
	""testing""
)
func TestReadWriteCompactProtocol(t *testing.T) {
	ReadWriteProtocolTest(t, NewCompactProtocolFactory())
	// CompactProtocol is capable of reading and writing in different goroutines.
	ReadWriteProtocolParallelTest(t, NewCompactProtocolFactory())
	transports := []Transport{
		NewMemoryBuffer(),
		NewStreamTransportRW(bytes.NewBuffer(make([]byte, 0, 16384))),
		NewFramedTransport(NewMemoryBuffer()),
	}
	for _, trans := range transports {
		p := NewCompactProtocol(trans)
		ReadWriteBool(t, p, trans)
		p = NewCompactProtocol(trans)
		ReadWriteByte(t, p, trans)
		p = NewCompactProtocol(trans)
		ReadWriteI16(t, p, trans)
		p = NewCompactProtocol(trans)
		ReadWriteI32(t, p, trans)
		p = NewCompactProtocol(trans)
		ReadWriteI64(t, p, trans)
		p = NewCompactProtocol(trans)
		ReadWriteDouble(t, p, trans)
		p = NewCompactProtocol(trans)
		ReadWriteFloat(t, p, trans)
		p = NewCompactProtocol(trans)
		ReadWriteString(t, p, trans)
		p = NewCompactProtocol(trans)
		ReadWriteBinary(t, p, trans)
		p = NewCompactProtocol(trans)
		ReadWriteStruct(t, p, trans)
		trans.Close()
	}
}
",CWE-770,57.0,1
"
STUB_SOURCE = \
	tests/stub_CacheDigest.cc \
	tests/stub_CachePeer.cc \
	tests/stub_CollapsedForwarding.cc \
	tests/stub_CommIO.cc \
	tests/stub_DelayId.cc \
	tests/stub_ETag.cc \
	tests/stub_EventLoop.cc \
	tests/stub_HelperChildConfig.cc \
	tests/stub_HttpControlMsg.cc \
	tests/stub_HttpHeader.cc \
	tests/stub_HttpReply.cc \
	tests/stub_HttpRequest.cc \
	tests/stub_HttpUpgradeProtocolAccess.cc \
	tests/stub_IpcIoFile.cc \
	tests/stub_MemBuf.cc \
	tests/stub_MemObject.cc \
	tests/stub_MemStore.cc \
	tests/stub_Port.cc \
	tests/stub_SBuf.cc \
	tests/stub_StatHist.cc \
	tests/stub_UdsOp.cc \
	tests/stub_access_log.cc \
	tests/stub_acl.cc \
	tests/stub_cache_cf.cc \
	tests/stub_cache_manager.cc \
	tests/stub_carp.cc \
	tests/stub_cbdata.cc \
	tests/stub_client_db.cc \
	tests/stub_client_side.cc \
	tests/stub_client_side_request.cc \
	tests/stub_comm.cc \
	tests/stub_debug.cc \
	tests/stub_errorpage.cc \
	tests/stub_event.cc \
	tests/stub_external_acl.cc \
	tests/stub_fatal.cc \
	tests/stub_fd.cc \
	tests/stub_fqdncache.cc \
	tests/stub_gopher.cc \
	tests/stub_helper.cc \
	tests/stub_http.cc \
	tests/stub_icp.cc \
	tests/stub_internal.cc \
	tests/stub_ipc.cc \
	tests/stub_ipc_Forwarder.cc \
	tests/stub_ipc_TypedMsgHdr.cc \
	tests/stub_ipcache.cc \
	tests/stub_libanyp.cc \
	tests/stub_libauth.cc \
	tests/stub_libauth_acls.cc \
	tests/stub_libcomm.cc \
	tests/stub_libdiskio.cc \
	tests/stub_liberror.cc \
	tests/stub_libeui.cc \
	tests/stub_libformat.cc \
	tests/stub_libhttp.cc \
	tests/stub_libicmp.cc \
	tests/stub_libip.cc \
	tests/stub_liblog.cc \
	tests/stub_libmem.cc \
	tests/stub_libmgr.cc \
	tests/stub_libsecurity.cc \
	tests/stub_libsslsquid.cc \
	tests/stub_libstore.cc \
	tests/stub_libtime.cc \
	tests/stub_main_cc.cc \
	tests/stub_mem_node.cc \
	tests/stub_mime.cc \
	tests/stub_neighbors.cc \
	tests/stub_pconn.cc \
	tests/stub_redirect.cc \
	tests/stub_stat.cc \
	tests/stub_stmem.cc \
	tests/stub_store.cc \
	tests/stub_store_client.cc \
	tests/stub_store_digest.cc \
	tests/stub_store_rebuild.cc \
	tests/stub_store_stats.cc \
	tests/stub_tools.cc \
	tests/stub_tunnel.cc \
	tests/stub_wccp2.cc \
	tests/stub_whois.cc \
	tests/stub_wordlist.cc
",CWE-476,95.0,1
"package proxyprotocol
import (
	""bufio""
	""bytes""
	""io""
	""net""
	""testing""
	""github.com/stretchr/testify/assert""
)
func TestHeaderV2(t *testing.T) {
	type section struct {
		name  string
		value []byte
	}
	check := func(name string, h HeaderV2, exp []section) {
		t.Run(name+""_WriteTo"", func(t *testing.T) {
			var buf bytes.Buffer
			_, err := h.WriteTo(&buf)
			assert.NoError(t, err)
			for _, s := range exp {
				cmp := make([]byte, len(s.value))
				_, err := io.ReadFull(&buf, cmp)
				assert.NoError(t, err)
				assert.Equal(t, s.value, cmp, s.name)
			}
		})
		t.Run(name+""_Parse"", func(t *testing.T) {
			var buf bytes.Buffer
			for _, s := range exp {
				buf.Write(s.value)
			}
			hdr, err := Parse(bufio.NewReader(&buf))
			assert.NoError(t, err)
			assert.IsType(t, &HeaderV2{}, hdr, ""Header Type"")
			p := hdr.(*HeaderV2)
			assert.Equal(t, h.Command, p.Command, ""Command"")
			if h.Src != nil {
				assert.NotNil(t, p.Src)
				assert.Equal(t, h.Src.String(), p.Src.String(), ""SrcAddr"")
			} else {
				assert.Nil(t, p.Src)
			}
			if h.Dest != nil {
				assert.NotNil(t, p.Dest)
				assert.Equal(t, h.Dest.String(), p.Dest.String(), ""DestAddr"")
			} else {
				assert.Nil(t, p.Dest)
			}
		})
	}
	check(""local"", HeaderV2{},
		[]section{
			{name: ""Signature"", value: sigV2},
			{name: ""Version"", value: []byte{0x20}},   // v2, Local
			{name: ""Fam/Proto"", value: []byte{0x00}}, // unspec, unspec
			{name: ""Length"", value: []byte{0, 0}},    // zero length
		},
	)
	check(""tcp-ipv4"", HeaderV2{
		Command: CmdProxy,
		Src:     &net.TCPAddr{IP: net.ParseIP(""192.168.0.1""), Port: 80},
		Dest:    &net.TCPAddr{IP: net.ParseIP(""192.168.0.2""), Port: 90},
	},
		[]section{
			{name: ""Signature"", value: sigV2},
			{name: ""Version"", value: []byte{0x21}},   // v2, Proxy
			{name: ""Fam/Proto"", value: []byte{0x11}}, // INET, STREAM
			{name: ""Length"", value: []byte{0, 12}},   // length=12
			{name: ""SrcAddr"", value: []byte{192, 168, 0, 1}},
			{name: ""DestAddr"", value: []byte{192, 168, 0, 2}},
			{name: ""SrcPort"", value: []byte{0, 80}},
			{name: ""DstPort"", value: []byte{0, 90}},
		},
	)
	check(""udp-ipv4"", HeaderV2{
		Command: CmdProxy,
		Src:     &net.UDPAddr{IP: net.ParseIP(""192.168.0.1""), Port: 80},
		Dest:    &net.UDPAddr{IP: net.ParseIP(""192.168.0.2""), Port: 90},
	},
		[]section{
			{name: ""Signature"", value: sigV2},
			{name: ""Version"", value: []byte{0x21}},   // v2, Proxy
			{name: ""Fam/Proto"", value: []byte{0x12}}, // INET, DGRAM
			{name: ""Length"", value: []byte{0, 12}},   // length=12
			{name: ""SrcAddr"", value: []byte{192, 168, 0, 1}},
			{name: ""DestAddr"", value: []byte{192, 168, 0, 2}},
			{name: ""SrcPort"", value: []byte{0, 80}},
			{name: ""DstPort"", value: []byte{0, 90}},
		},
	)
	check(""udp-ipv6"", HeaderV2{
		Command: CmdProxy,
		Src:     &net.UDPAddr{IP: net.ParseIP(""2001::1""), Port: 80},
		Dest:    &net.UDPAddr{IP: net.ParseIP(""2002::2""), Port: 90},
	},
		[]section{
			{name: ""Signature"", value: sigV2},
			{name: ""Version"", value: []byte{0x21}},   // v2, Proxy
			{name: ""Fam/Proto"", value: []byte{0x22}}, // INET6, DGRAM
			{name: ""Length"", value: []byte{0, 36}},   // length=36
			{name: ""SrcAddr"", value: []byte{0x20, 0x01, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x01}},
			{name: ""DestAddr"", value: []byte{0x20, 0x02, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x02}},
			{name: ""SrcPort"", value: []byte{0, 80}},
			{name: ""DstPort"", value: []byte{0, 90}},
		},
	)
	check(""unixstream"", HeaderV2{
		Command: CmdProxy,
		Src:     &net.UnixAddr{Net: ""unix"", Name: ""foo""},
		Dest:    &net.UnixAddr{Net: ""unix"", Name: ""bar""},
	},
		[]section{
			{name: ""Signature"", value: sigV2},
			{name: ""Version"", value: []byte{0x21}},   // v2, Proxy
			{name: ""Fam/Proto"", value: []byte{0x31}}, // UNIX, STREAM
			{name: ""Length"", value: []byte{0, 216}},  // length=216
			{name: ""SrcAddr"", value: append([]byte(""foo""), make([]byte, 105)...)},
			{name: ""DestAddr"", value: append([]byte(""bar""), make([]byte, 105)...)},
		},
	)
	check(""unixgram"", HeaderV2{
		Command: CmdProxy,
		Src:     &net.UnixAddr{Net: ""unixgram"", Name: ""foo""},
		Dest:    &net.UnixAddr{Net: ""unixgram"", Name: ""bar""},
	},
		[]section{
			{name: ""Signature"", value: sigV2},
			{name: ""Version"", value: []byte{0x21}},   // v2, Proxy
			{name: ""Fam/Proto"", value: []byte{0x32}}, // UNIX, DGRAM
			{name: ""Length"", value: []byte{0, 216}},  // length=216
			{name: ""SrcAddr"", value: append([]byte(""foo""), make([]byte, 105)...)},
			{name: ""DestAddr"", value: append([]byte(""bar""), make([]byte, 105)...)},
		},
	)
}
",CWE-20,154.0,1
"package install
import (
	""errors""
	""fmt""
	""github.com/cnlh/nps/lib/common""
	""io""
	""log""
	""os""
	""path/filepath""
	""strings""
)
func InstallNps() {
	path := common.GetInstallPath()
	if common.FileExists(path) {
		log.Fatalf(""the path %s has exist, does not support install"", path)
	}
	MkidrDirAll(path, ""conf"", ""web/static"", ""web/views"")
	//复制文件到对应目录
	if err := CopyDir(filepath.Join(common.GetAppPath(), ""web"", ""views""), filepath.Join(path, ""web"", ""views"")); err != nil {
		log.Fatalln(err)
	}
	if err := CopyDir(filepath.Join(common.GetAppPath(), ""web"", ""static""), filepath.Join(path, ""web"", ""static"")); err != nil {
		log.Fatalln(err)
	}
	if err := CopyDir(filepath.Join(common.GetAppPath(), ""conf""), filepath.Join(path, ""conf"")); err != nil {
		log.Fatalln(err)
	}
	if !common.IsWindows() {
		if _, err := copyFile(filepath.Join(common.GetAppPath(), ""nps""), ""/usr/bin/nps""); err != nil {
			if _, err := copyFile(filepath.Join(common.GetAppPath(), ""nps""), ""/usr/local/bin/nps""); err != nil {
				log.Fatalln(err)
			} else {
				os.Chmod(""/usr/local/bin/nps"", 0777)
				log.Println(""Executable files have been copied to"", ""/usr/local/bin/nps"")
			}
		} else {
			os.Chmod(""/usr/bin/nps"", 0777)
			log.Println(""Executable files have been copied to"", ""/usr/bin/nps"")
		}
	}
	log.Println(""install ok!"")
	log.Println(""Static files and configuration files in the current directory will be useless"")
	log.Println(""The new configuration file is located in"", path, ""you can edit them"")
	if !common.IsWindows() {
		log.Println(""You can start with nps test|start|stop|restart|status anywhere"")
	} else {
		log.Println(""You can copy executable files to any directory and start working with nps.exe test|start|stop|restart|status"")
	}
}
func MkidrDirAll(path string, v ...string) {
	for _, item := range v {
		if err := os.MkdirAll(filepath.Join(path, item), 0755); err != nil {
			log.Fatalf(""Failed to create directory %s error:%s"", path, err.Error())
		}
	}
}
func CopyDir(srcPath string, destPath string) error {
	//检测目录正确性
	if srcInfo, err := os.Stat(srcPath); err != nil {
		fmt.Println(err.Error())
		return err
	} else {
		if !srcInfo.IsDir() {
			e := errors.New(""SrcPath is not the right directory!"")
			return e
		}
	}
	if destInfo, err := os.Stat(destPath); err != nil {
		return err
	} else {
		if !destInfo.IsDir() {
			e := errors.New(""DestInfo is not the right directory!"")
			return e
		}
	}
	err := filepath.Walk(srcPath, func(path string, f os.FileInfo, err error) error {
		if f == nil {
			return err
		}
		if !f.IsDir() {
			destNewPath := strings.Replace(path, srcPath, destPath, -1)
			log.Println(""copy file ::"" + path + "" to "" + destNewPath)
			copyFile(path, destNewPath)
		}
		return nil
	})
	return err
}
//生成目录并拷贝文件
func copyFile(src, dest string) (w int64, err error) {
	srcFile, err := os.Open(src)
	if err != nil {
		return
	}
	defer srcFile.Close()
	//分割path目录
	destSplitPathDirs := strings.Split(dest, string(filepath.Separator))
	//检测时候存在目录
	destSplitPath := """"
	for index, dir := range destSplitPathDirs {
		if index < len(destSplitPathDirs)-1 {
			destSplitPath = destSplitPath + dir + string(filepath.Separator)
			b, _ := pathExists(destSplitPath)
			if b == false {
				log.Println(""mkdir:"" + destSplitPath)
				//创建目录
				err := os.Mkdir(destSplitPath, os.ModePerm)
				if err != nil {
					log.Fatalln(err)
				}
			}
		}
	}
	dstFile, err := os.Create(dest)
	if err != nil {
		return
	}
	defer dstFile.Close()
	return io.Copy(dstFile, srcFile)
}
//检测文件夹路径时候存在
func pathExists(path string) (bool, error) {
	_, err := os.Stat(path)
	if err == nil {
		return true, nil
	}
	if os.IsNotExist(err) {
		return false, nil
	}
	return false, err
}
",CWE-732,141.0,1
"-----BEGIN CERTIFICATE-----
MIIEiTCCA3GgAwIBAgIUT9Wze0Fvw/pMvqAmPJjlD7HNjZAwDQYJKoZIhvcNAQEL
BQAwdjELMAkGA1UEBhMCVVMxEzARBgNVBAgMCkNhbGlmb3JuaWExFjAUBgNVBAcM
DVNhbiBGcmFuY2lzY28xDTALBgNVBAoMBEx5ZnQxGTAXBgNVBAsMEEx5ZnQgRW5n
aW5lZXJpbmcxEDAOBgNVBAMMB1Rlc3QgQ0EwHhcNMjIwNDA3MTY0NjM1WhcNMjQw
NDA2MTY0NjM1WjCBqDELMAkGA1UEBhMCVVMxEzARBgNVBAgMCkNhbGlmb3JuaWEx
FjAUBgNVBAcMDVNhbiBGcmFuY2lzY28xDTALBgNVBAoMBEx5ZnQxGTAXBgNVBAsM
EEx5ZnQgRW5naW5lZXJpbmcxGzAZBgNVBAMMElRlc3QgRnJvbnRlbmQgVGVhbTEl
MCMGCSqGSIb3DQEJARYWZnJvbnRlbmQtdGVhbUBseWZ0LmNvbTCCASIwDQYJKoZI
hvcNAQEBBQADggEPADCCAQoCggEBAOwOQ96U2nYcA+lV5eFmHqwkUVH/b5wn/FXg
ALBfT2qSn2pzMmqj3RHebqN4I7uiRGPmk7eVHxktW/ytFDdk+AwbGEOP8vWl9zR7
3pveKchHVSdSNJ4RkXpgDLZYDDDj/JQxNzDwPD43eIUw9SKj+Mw9nTRv0hm39hhh
hjBmvOfbdWjQPMsuSDqEAPGE06PpirTdwZNSsuBjfvo6zdnJxTgzd/Cf1KINda4P
xklw9M9CuKQMeLwVfwMDNeI2uJ7kn1dpsOhSDBU7LEleSWGGAlcycDzLuy/5/rKc
dON9MKUK+82rJ+cME6I+DYqS1Nz+wY9t8farXLuGK41n0G4qr1MCAwEAAaOB2zCB
2DAMBgNVHRMBAf8EAjAAMAsGA1UdDwQEAwIF4DAdBgNVHSUEFjAUBggrBgEFBQcD
AgYIKwYBBQUHAwEwXAYDVR0RBFUwU4Yfc3BpZmZlOi8vbHlmdC5jb20vZnJvbnRl
bmQtdGVhbYYYaHR0cDovL2Zyb250ZW5kLmx5ZnQuY29tgghseWZ0LmNvbYIMd3d3
Lmx5ZnQuY29tMB0GA1UdDgQWBBROWpBWXFbgQUweTJcDDdEtGxJ6wzAfBgNVHSME
GDAWgBQdDTmYdOz7TqwMpoOli3Dmj78ygjANBgkqhkiG9w0BAQsFAAOCAQEALyDC
CJ2V30VRqf/vHnv4hocaNvkbg2XqSczsNsXQB9Oh15y2nrTu8nIlktJeMCwgYKB3
tyuIYADw2c0HKmFshOiNM3P1taM+Gljx/OeyhMq/dgKTF0rX7w3vOoWrvW7o0cDJ
gBzDAmPJegrIlAqfb97MOcLtBlk9vjh7ukh8BSRI+5Hdj5Gb8Y6tQvmiqzm5yx5L
Swz7im1BIGwk4Hq82JO20egDYCn9zhmuDIEJGtRbl0ymcfdaC4oKqiqU/CrynaAo
SkNXfca8Sqk1tvbfDzNkOAnLN572vkbhUnLfcqcfouRXlUl2DYmG+dCoYuWw4/co
ahwsslCKM3xGY4ax9Q==
-----END CERTIFICATE-----
",CWE-755,28.0,1
"// Copyright 2016 Documize Inc. <legal@documize.com>. All rights reserved.
//
// This software (Documize Community Edition) is licensed under
// GNU AGPL v3 http://www.gnu.org/licenses/agpl-3.0.en.html
//
// You can operate outside the AGPL restrictions by purchasing
// Documize Enterprise Edition and obtaining a commercial license
// by contacting <sales@documize.com>.
//
// https://documize.com
package markdown
import (
	""net/http""
	""github.com/documize/blackfriday""
	""github.com/documize/community/core/env""
	""github.com/documize/community/domain/section/provider""
	""github.com/documize/community/domain/store""
)
// Provider represents Markdown
type Provider struct {
	Runtime *env.Runtime
	Store   *store.Store
}
// Meta describes us
func (*Provider) Meta() provider.TypeMeta {
	section := provider.TypeMeta{}
	section.ID = ""1470bb4a-36c6-4a98-a443-096f5658378b""
	section.Title = ""Markdown""
	section.Description = ""CommonMark based content""
	section.ContentType = ""markdown""
	section.PageType = ""section""
	section.Order = 9998
	return section
}
// Command stub.
func (*Provider) Command(ctx *provider.Context, w http.ResponseWriter, r *http.Request) {
	provider.WriteEmpty(w)
}
// Render converts markdown data into HTML suitable for browser rendering.
func (*Provider) Render(ctx *provider.Context, config, data string) string {
	result := blackfriday.Run([]byte(data))
	return string(result)
}
// Refresh just sends back data as-is.
func (*Provider) Refresh(ctx *provider.Context, config, data string) string {
	return data
}
",CWE-79,59.0,1
"module github.com/documize/community
go 1.13
require (
	github.com/BurntSushi/toml v0.3.1
	github.com/andygrunwald/go-jira v1.10.0
	github.com/codegangsta/negroni v0.3.0
	github.com/denisenkom/go-mssqldb v0.0.0-20190806190131-db2462fef53b
	github.com/dgrijalva/jwt-go v3.1.0+incompatible
	github.com/documize/blackfriday v2.0.0+incompatible
	github.com/documize/glick v0.0.0-20160503134043-a8ccbef88237
	github.com/documize/html-diff v0.0.0-20160503140253-f61c192c7796
	github.com/documize/slug v1.1.1
	github.com/elazarl/go-bindata-assetfs v1.0.0
	github.com/go-sql-driver/mysql v1.4.1
	github.com/google/go-github v17.0.0+incompatible
	github.com/google/go-querystring v1.0.0 // indirect
	github.com/gorilla/handlers v1.4.0
	github.com/gorilla/mux v1.6.2
	github.com/jmoiron/sqlx v1.2.0
	github.com/jteeuwen/go-bindata v3.0.7+incompatible // indirect
	github.com/kr/pretty v0.1.0 // indirect
	github.com/lib/pq v1.2.0
	github.com/mb0/diff v0.0.0-20131118162322-d8d9a906c24d // indirect
	github.com/nu7hatch/gouuid v0.0.0-20131221200532-179d4d0c4d8d
	github.com/pkg/errors v0.8.0
	github.com/rainycape/unidecode v0.0.0-20150907023854-cb7f23ec59be // indirect
	github.com/shurcooL/sanitized_anchor_name v0.0.0-20170918181015-86672fcb3f95 // indirect
	golang.org/x/crypto v0.0.0-20190426145343-a29dc8fdc734
	golang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3
	golang.org/x/oauth2 v0.0.0-20190226205417-e64efc72b421
	gopkg.in/alexcesaro/quotedprintable.v3 v3.0.0-20150716171945-2caba252f4dc
	gopkg.in/asn1-ber.v1 v1.0.0-20170511165959-379148ca0225 // indirect
	gopkg.in/cas.v2 v2.1.0
	gopkg.in/ldap.v3 v3.0.3
)
",CWE-79,38.0,1
"package dtls
import (
	""github.com/pion/dtls/v2/pkg/protocol""
	""github.com/pion/dtls/v2/pkg/protocol/handshake""
	""github.com/pion/dtls/v2/pkg/protocol/recordlayer""
)
type fragment struct {
	recordLayerHeader recordlayer.Header
	handshakeHeader   handshake.Header
	data              []byte
}
type fragmentBuffer struct {
	// map of MessageSequenceNumbers that hold slices of fragments
	cache map[uint16][]*fragment
	currentMessageSequenceNumber uint16
}
func newFragmentBuffer() *fragmentBuffer {
	return &fragmentBuffer{cache: map[uint16][]*fragment{}}
}
// Attempts to push a DTLS packet to the fragmentBuffer
// when it returns true it means the fragmentBuffer has inserted and the buffer shouldn't be handled
// when an error returns it is fatal, and the DTLS connection should be stopped
func (f *fragmentBuffer) push(buf []byte) (bool, error) {
	frag := new(fragment)
	if err := frag.recordLayerHeader.Unmarshal(buf); err != nil {
		return false, err
	}
	// fragment isn't a handshake, we don't need to handle it
	if frag.recordLayerHeader.ContentType != protocol.ContentTypeHandshake {
		return false, nil
	}
	for buf = buf[recordlayer.HeaderSize:]; len(buf) != 0; frag = new(fragment) {
		if err := frag.handshakeHeader.Unmarshal(buf); err != nil {
			return false, err
		}
		if _, ok := f.cache[frag.handshakeHeader.MessageSequence]; !ok {
			f.cache[frag.handshakeHeader.MessageSequence] = []*fragment{}
		}
		// end index should be the length of handshake header but if the handshake
		// was fragmented, we should keep them all
		end := int(handshake.HeaderLength + frag.handshakeHeader.Length)
		if size := len(buf); end > size {
			end = size
		}
		// Discard all headers, when rebuilding the packet we will re-build
		frag.data = append([]byte{}, buf[handshake.HeaderLength:end]...)
		f.cache[frag.handshakeHeader.MessageSequence] = append(f.cache[frag.handshakeHeader.MessageSequence], frag)
		buf = buf[end:]
	}
	return true, nil
}
func (f *fragmentBuffer) pop() (content []byte, epoch uint16) {
	frags, ok := f.cache[f.currentMessageSequenceNumber]
	if !ok {
		return nil, 0
	}
	// Go doesn't support recursive lambdas
	var appendMessage func(targetOffset uint32) bool
	rawMessage := []byte{}
	appendMessage = func(targetOffset uint32) bool {
		for _, f := range frags {
			if f.handshakeHeader.FragmentOffset == targetOffset {
				fragmentEnd := (f.handshakeHeader.FragmentOffset + f.handshakeHeader.FragmentLength)
				if fragmentEnd != f.handshakeHeader.Length {
					if !appendMessage(fragmentEnd) {
						return false
					}
				}
				rawMessage = append(f.data, rawMessage...)
				return true
			}
		}
		return false
	}
	// Recursively collect up
	if !appendMessage(0) {
		return nil, 0
	}
	firstHeader := frags[0].handshakeHeader
	firstHeader.FragmentOffset = 0
	firstHeader.FragmentLength = firstHeader.Length
	rawHeader, err := firstHeader.Marshal()
	if err != nil {
		return nil, 0
	}
	messageEpoch := frags[0].recordLayerHeader.Epoch
	delete(f.cache, f.currentMessageSequenceNumber)
	f.currentMessageSequenceNumber++
	return append(rawHeader, rawMessage...), messageEpoch
}
",CWE-835,112.0,1
"package dtls
import (
	""reflect""
	""testing""
)
func TestFragmentBuffer(t *testing.T) {
	for _, test := range []struct {
		Name     string
		In       [][]byte
		Expected [][]byte
		Epoch    uint16
	}{
		{
			Name: ""Single Fragment"",
			In: [][]byte{
				{0x16, 0xfe, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfe, 0xff, 0x00},
			},
			Expected: [][]byte{
				{0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfe, 0xff, 0x00},
			},
			Epoch: 0,
		},
		{
			Name: ""Single Fragment Epoch 3"",
			In: [][]byte{
				{0x16, 0xfe, 0xff, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfe, 0xff, 0x00},
			},
			Expected: [][]byte{
				{0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfe, 0xff, 0x00},
			},
			Epoch: 3,
		},
		{
			Name: ""Multiple Fragments"",
			In: [][]byte{
				{0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x0b, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x01, 0x02, 0x03, 0x04},
				{0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x0b, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x05, 0x05, 0x06, 0x07, 0x08, 0x09},
				{0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x0b, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x05, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E},
			},
			Expected: [][]byte{
				{0x0b, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e},
			},
			Epoch: 0,
		},
		{
			Name: ""Multiple Unordered Fragments"",
			In: [][]byte{
				{0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x0b, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x01, 0x02, 0x03, 0x04},
				{0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x0b, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x05, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E},
				{0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x81, 0x0b, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x05, 0x05, 0x06, 0x07, 0x08, 0x09},
			},
			Expected: [][]byte{
				{0x0b, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e},
			},
			Epoch: 0,
		},
		{
			Name: ""Multiple Handshakes in Signle Fragment"",
			In: [][]byte{
				{
					0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x30, /* record header */
					0x03, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x01, 0x01, /*handshake msg 1*/
					0x03, 0x00, 0x00, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x01, 0x01, /*handshake msg 2*/
					0x03, 0x00, 0x00, 0x04, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x01, 0x01, /*handshake msg 3*/
				},
			},
			Expected: [][]byte{
				{0x03, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x01, 0x01},
				{0x03, 0x00, 0x00, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x01, 0x01},
				{0x03, 0x00, 0x00, 0x04, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x01, 0x01},
			},
			Epoch: 0,
		},
	} {
		fragmentBuffer := newFragmentBuffer()
		for _, frag := range test.In {
			status, err := fragmentBuffer.push(frag)
			if err != nil {
				t.Error(err)
			} else if !status {
				t.Errorf(""fragmentBuffer didn't accept fragments for '%s'"", test.Name)
			}
		}
		for _, expected := range test.Expected {
			out, epoch := fragmentBuffer.pop()
			if !reflect.DeepEqual(out, expected) {
				t.Errorf(""fragmentBuffer '%s' push/pop: got % 02x, want % 02x"", test.Name, out, expected)
			}
			if epoch != test.Epoch {
				t.Errorf(""fragmentBuffer returned wrong epoch: got %d, want %d"", epoch, test.Epoch)
			}
		}
		if frag, _ := fragmentBuffer.pop(); frag != nil {
			t.Errorf(""fragmentBuffer popped single buffer multiple times for '%s'"", test.Name)
		}
	}
}
",CWE-835,102.0,1
"package dtls
import (
	""context""
	""errors""
	""fmt""
	""io""
	""net""
	""os""
	""github.com/pion/dtls/v2/pkg/protocol""
	""github.com/pion/dtls/v2/pkg/protocol/alert""
)
// Typed errors
var (
	ErrConnClosed = &FatalError{Err: errors.New(""conn is closed"")} //nolint:goerr113
	errDeadlineExceeded   = &TimeoutError{Err: fmt.Errorf(""read/write timeout: %w"", context.DeadlineExceeded)}
	errInvalidContentType = &TemporaryError{Err: errors.New(""invalid content type"")} //nolint:goerr113
	errBufferTooSmall               = &TemporaryError{Err: errors.New(""buffer is too small"")}                                        //nolint:goerr113
	errContextUnsupported           = &TemporaryError{Err: errors.New(""context is not supported for ExportKeyingMaterial"")}          //nolint:goerr113
	errHandshakeInProgress          = &TemporaryError{Err: errors.New(""handshake is in progress"")}                                   //nolint:goerr113
	errReservedExportKeyingMaterial = &TemporaryError{Err: errors.New(""ExportKeyingMaterial can not be used with a reserved label"")} //nolint:goerr113
	errApplicationDataEpochZero     = &TemporaryError{Err: errors.New(""ApplicationData with epoch of 0"")}                            //nolint:goerr113
	errUnhandledContextType         = &TemporaryError{Err: errors.New(""unhandled contentType"")}                                      //nolint:goerr113
	errCertificateVerifyNoCertificate    = &FatalError{Err: errors.New(""client sent certificate verify but we have no certificate to verify"")}                      //nolint:goerr113
	errCipherSuiteNoIntersection         = &FatalError{Err: errors.New(""client+server do not support any shared cipher suites"")}                                    //nolint:goerr113
	errClientCertificateNotVerified      = &FatalError{Err: errors.New(""client sent certificate but did not verify it"")}                                            //nolint:goerr113
	errClientCertificateRequired         = &FatalError{Err: errors.New(""server required client verification, but got none"")}                                        //nolint:goerr113
	errClientNoMatchingSRTPProfile       = &FatalError{Err: errors.New(""server responded with SRTP Profile we do not support"")}                                     //nolint:goerr113
	errClientRequiredButNoServerEMS      = &FatalError{Err: errors.New(""client required Extended Master Secret extension, but server does not support it"")}         //nolint:goerr113
	errCookieMismatch                    = &FatalError{Err: errors.New(""client+server cookie does not match"")}                                                      //nolint:goerr113
	errIdentityNoPSK                     = &FatalError{Err: errors.New(""PSK Identity Hint provided but PSK is nil"")}                                                //nolint:goerr113
	errInvalidCertificate                = &FatalError{Err: errors.New(""no certificate provided"")}                                                                  //nolint:goerr113
	errInvalidCipherSuite                = &FatalError{Err: errors.New(""invalid or unknown cipher suite"")}                                                          //nolint:goerr113
	errInvalidECDSASignature             = &FatalError{Err: errors.New(""ECDSA signature contained zero or negative values"")}                                        //nolint:goerr113
	errInvalidPrivateKey                 = &FatalError{Err: errors.New(""invalid private key type"")}                                                                 //nolint:goerr113
	errInvalidSignatureAlgorithm         = &FatalError{Err: errors.New(""invalid signature algorithm"")}                                                              //nolint:goerr113
	errKeySignatureMismatch              = &FatalError{Err: errors.New(""expected and actual key signature do not match"")}                                           //nolint:goerr113
	errNilNextConn                       = &FatalError{Err: errors.New(""Conn can not be created with a nil nextConn"")}                                              //nolint:goerr113
	errNoAvailableCipherSuites           = &FatalError{Err: errors.New(""connection can not be created, no CipherSuites satisfy this Config"")}                       //nolint:goerr113
	errNoAvailablePSKCipherSuite         = &FatalError{Err: errors.New(""connection can not be created, pre-shared key present but no compatible CipherSuite"")}      //nolint:goerr113
	errNoAvailableCertificateCipherSuite = &FatalError{Err: errors.New(""connection can not be created, certificate present but no compatible CipherSuite"")}         //nolint:goerr113
	errNoAvailableSignatureSchemes       = &FatalError{Err: errors.New(""connection can not be created, no SignatureScheme satisfy this Config"")}                    //nolint:goerr113
	errNoCertificates                    = &FatalError{Err: errors.New(""no certificates configured"")}                                                               //nolint:goerr113
	errNoConfigProvided                  = &FatalError{Err: errors.New(""no config provided"")}                                                                       //nolint:goerr113
	errNoSupportedEllipticCurves         = &FatalError{Err: errors.New(""client requested zero or more elliptic curves that are not supported by the server"")}       //nolint:goerr113
	errUnsupportedProtocolVersion        = &FatalError{Err: errors.New(""unsupported protocol version"")}                                                             //nolint:goerr113
	errPSKAndIdentityMustBeSetForClient  = &FatalError{Err: errors.New(""PSK and PSK Identity Hint must both be set for client"")}                                    //nolint:goerr113
	errRequestedButNoSRTPExtension       = &FatalError{Err: errors.New(""SRTP support was requested but server did not respond with use_srtp extension"")}            //nolint:goerr113
	errServerNoMatchingSRTPProfile       = &FatalError{Err: errors.New(""client requested SRTP but we have no matching profiles"")}                                   //nolint:goerr113
	errServerRequiredButNoClientEMS      = &FatalError{Err: errors.New(""server requires the Extended Master Secret extension, but the client does not support it"")} //nolint:goerr113
	errVerifyDataMismatch                = &FatalError{Err: errors.New(""expected and actual verify data does not match"")}                                           //nolint:goerr113
	errInvalidFlight                     = &InternalError{Err: errors.New(""invalid flight number"")}                           //nolint:goerr113
	errKeySignatureGenerateUnimplemented = &InternalError{Err: errors.New(""unable to generate key signature, unimplemented"")} //nolint:goerr113
	errKeySignatureVerifyUnimplemented   = &InternalError{Err: errors.New(""unable to verify key signature, unimplemented"")}   //nolint:goerr113
	errLengthMismatch                    = &InternalError{Err: errors.New(""data length and declared length do not match"")}    //nolint:goerr113
	errSequenceNumberOverflow            = &InternalError{Err: errors.New(""sequence number overflow"")}                        //nolint:goerr113
	errInvalidFSMTransition              = &InternalError{Err: errors.New(""invalid state machine transition"")}                //nolint:goerr113
	errFailedToAccessPoolReadBuffer      = &InternalError{Err: errors.New(""failed to access pool read buffer"")}               //nolint:goerr113
)
// FatalError indicates that the DTLS connection is no longer available.
// It is mainly caused by wrong configuration of server or client.
type FatalError = protocol.FatalError
// InternalError indicates and internal error caused by the implementation, and the DTLS connection is no longer available.
// It is mainly caused by bugs or tried to use unimplemented features.
type InternalError = protocol.InternalError
// TemporaryError indicates that the DTLS connection is still available, but the request was failed temporary.
type TemporaryError = protocol.TemporaryError
// TimeoutError indicates that the request was timed out.
type TimeoutError = protocol.TimeoutError
// HandshakeError indicates that the handshake failed.
type HandshakeError = protocol.HandshakeError
// errInvalidCipherSuite indicates an attempt at using an unsupported cipher suite.
type invalidCipherSuiteError struct {
	id CipherSuiteID
}
func (e *invalidCipherSuiteError) Error() string {
	return fmt.Sprintf(""CipherSuite with id(%d) is not valid"", e.id)
}
func (e *invalidCipherSuiteError) Is(err error) bool {
	var other *invalidCipherSuiteError
	if errors.As(err, &other) {
		return e.id == other.id
	}
	return false
}
// errAlert wraps DTLS alert notification as an error
type alertError struct {
	*alert.Alert
}
func (e *alertError) Error() string {
	return fmt.Sprintf(""alert: %s"", e.Alert.String())
}
func (e *alertError) IsFatalOrCloseNotify() bool {
	return e.Level == alert.Fatal || e.Description == alert.CloseNotify
}
func (e *alertError) Is(err error) bool {
	var other *alertError
	if errors.As(err, &other) {
		return e.Level == other.Level && e.Description == other.Description
	}
	return false
}
// netError translates an error from underlying Conn to corresponding net.Error.
func netError(err error) error {
	switch {
	case errors.Is(err, io.EOF), errors.Is(err, context.Canceled), errors.Is(err, context.DeadlineExceeded):
		// Return io.EOF and context errors as is.
		return err
	}
	var (
		ne      net.Error
		opError *net.OpError
		se      *os.SyscallError
	)
	if errors.As(err, &opError) {
		if errors.As(opError, &se) {
			if se.Timeout() {
				return &TimeoutError{Err: err}
			}
			if isOpErrorTemporary(se) {
				return &TemporaryError{Err: err}
			}
		}
	}
	if errors.As(err, &ne) {
		return err
	}
	return &FatalError{Err: err}
}
",CWE-120,153.0,1
"package dtls
import (
	""github.com/pion/dtls/v2/pkg/protocol""
	""github.com/pion/dtls/v2/pkg/protocol/handshake""
	""github.com/pion/dtls/v2/pkg/protocol/recordlayer""
)
type fragment struct {
	recordLayerHeader recordlayer.Header
	handshakeHeader   handshake.Header
	data              []byte
}
type fragmentBuffer struct {
	// map of MessageSequenceNumbers that hold slices of fragments
	cache map[uint16][]*fragment
	currentMessageSequenceNumber uint16
}
func newFragmentBuffer() *fragmentBuffer {
	return &fragmentBuffer{cache: map[uint16][]*fragment{}}
}
// Attempts to push a DTLS packet to the fragmentBuffer
// when it returns true it means the fragmentBuffer has inserted and the buffer shouldn't be handled
// when an error returns it is fatal, and the DTLS connection should be stopped
func (f *fragmentBuffer) push(buf []byte) (bool, error) {
	frag := new(fragment)
	if err := frag.recordLayerHeader.Unmarshal(buf); err != nil {
		return false, err
	}
	// fragment isn't a handshake, we don't need to handle it
	if frag.recordLayerHeader.ContentType != protocol.ContentTypeHandshake {
		return false, nil
	}
	for buf = buf[recordlayer.HeaderSize:]; len(buf) != 0; frag = new(fragment) {
		if err := frag.handshakeHeader.Unmarshal(buf); err != nil {
			return false, err
		}
		if _, ok := f.cache[frag.handshakeHeader.MessageSequence]; !ok {
			f.cache[frag.handshakeHeader.MessageSequence] = []*fragment{}
		}
		// end index should be the length of handshake header but if the handshake
		// was fragmented, we should keep them all
		end := int(handshake.HeaderLength + frag.handshakeHeader.Length)
		if size := len(buf); end > size {
			end = size
		}
		// Discard all headers, when rebuilding the packet we will re-build
		frag.data = append([]byte{}, buf[handshake.HeaderLength:end]...)
		f.cache[frag.handshakeHeader.MessageSequence] = append(f.cache[frag.handshakeHeader.MessageSequence], frag)
		buf = buf[end:]
	}
	return true, nil
}
func (f *fragmentBuffer) pop() (content []byte, epoch uint16) {
	frags, ok := f.cache[f.currentMessageSequenceNumber]
	if !ok {
		return nil, 0
	}
	// Go doesn't support recursive lambdas
	var appendMessage func(targetOffset uint32) bool
	rawMessage := []byte{}
	appendMessage = func(targetOffset uint32) bool {
		for _, f := range frags {
			if f.handshakeHeader.FragmentOffset == targetOffset {
				fragmentEnd := (f.handshakeHeader.FragmentOffset + f.handshakeHeader.FragmentLength)
				if fragmentEnd != f.handshakeHeader.Length && f.handshakeHeader.FragmentLength != 0 {
					if !appendMessage(fragmentEnd) {
						return false
					}
				}
				rawMessage = append(f.data, rawMessage...)
				return true
			}
		}
		return false
	}
	// Recursively collect up
	if !appendMessage(0) {
		return nil, 0
	}
	firstHeader := frags[0].handshakeHeader
	firstHeader.FragmentOffset = 0
	firstHeader.FragmentLength = firstHeader.Length
	rawHeader, err := firstHeader.Marshal()
	if err != nil {
		return nil, 0
	}
	messageEpoch := frags[0].recordLayerHeader.Epoch
	delete(f.cache, f.currentMessageSequenceNumber)
	f.currentMessageSequenceNumber++
	return append(rawHeader, rawMessage...), messageEpoch
}
",CWE-120,112.0,1
"package dtls
import (
	""reflect""
	""testing""
)
func TestFragmentBuffer(t *testing.T) {
	for _, test := range []struct {
		Name     string
		In       [][]byte
		Expected [][]byte
		Epoch    uint16
	}{
		{
			Name: ""Single Fragment"",
			In: [][]byte{
				{0x16, 0xfe, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfe, 0xff, 0x00},
			},
			Expected: [][]byte{
				{0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfe, 0xff, 0x00},
			},
			Epoch: 0,
		},
		{
			Name: ""Single Fragment Epoch 3"",
			In: [][]byte{
				{0x16, 0xfe, 0xff, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfe, 0xff, 0x00},
			},
			Expected: [][]byte{
				{0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfe, 0xff, 0x00},
			},
			Epoch: 3,
		},
		{
			Name: ""Multiple Fragments"",
			In: [][]byte{
				{0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x0b, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x01, 0x02, 0x03, 0x04},
				{0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x0b, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x05, 0x05, 0x06, 0x07, 0x08, 0x09},
				{0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x0b, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x05, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E},
			},
			Expected: [][]byte{
				{0x0b, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e},
			},
			Epoch: 0,
		},
		{
			Name: ""Multiple Unordered Fragments"",
			In: [][]byte{
				{0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x0b, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x01, 0x02, 0x03, 0x04},
				{0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x0b, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x05, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E},
				{0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x81, 0x0b, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x05, 0x05, 0x06, 0x07, 0x08, 0x09},
			},
			Expected: [][]byte{
				{0x0b, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e},
			},
			Epoch: 0,
		},
		{
			Name: ""Multiple Handshakes in Signle Fragment"",
			In: [][]byte{
				{
					0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x30, /* record header */
					0x03, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x01, 0x01, /*handshake msg 1*/
					0x03, 0x00, 0x00, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x01, 0x01, /*handshake msg 2*/
					0x03, 0x00, 0x00, 0x04, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x01, 0x01, /*handshake msg 3*/
				},
			},
			Expected: [][]byte{
				{0x03, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x01, 0x01},
				{0x03, 0x00, 0x00, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x01, 0x01},
				{0x03, 0x00, 0x00, 0x04, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x01, 0x01},
			},
			Epoch: 0,
		},
		// Assert that a zero length fragment doesn't cause the fragmentBuffer to enter an infinite loop
		{
			Name: ""Zero Length Fragment"",
			In: [][]byte{
				{
					0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00,
					0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				},
			},
			Expected: [][]byte{
				{0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00},
			},
			Epoch: 0,
		},
	} {
		fragmentBuffer := newFragmentBuffer()
		for _, frag := range test.In {
			status, err := fragmentBuffer.push(frag)
			if err != nil {
				t.Error(err)
			} else if !status {
				t.Errorf(""fragmentBuffer didn't accept fragments for '%s'"", test.Name)
			}
		}
		for _, expected := range test.Expected {
			out, epoch := fragmentBuffer.pop()
			if !reflect.DeepEqual(out, expected) {
				t.Errorf(""fragmentBuffer '%s' push/pop: got % 02x, want % 02x"", test.Name, out, expected)
			}
			if epoch != test.Epoch {
				t.Errorf(""fragmentBuffer returned wrong epoch: got %d, want %d"", epoch, test.Epoch)
			}
		}
		if frag, _ := fragmentBuffer.pop(); frag != nil {
			t.Errorf(""fragmentBuffer popped single buffer multiple times for '%s'"", test.Name)
		}
	}
}
",CWE-120,116.0,1
"package state
import (
	""github.com/tendermint/tendermint/types""
)
//------------------------------------------------------
// blockchain services types
// NOTE: Interfaces used by RPC must be thread safe!
//------------------------------------------------------
//------------------------------------------------------
// blockstore
// BlockStore defines the interface used by the ConsensusState.
type BlockStore interface {
	Base() int64
	Height() int64
	Size() int64
	LoadBaseMeta() *types.BlockMeta
	LoadBlockMeta(height int64) *types.BlockMeta
	LoadBlock(height int64) *types.Block
	SaveBlock(block *types.Block, blockParts *types.PartSet, seenCommit *types.Commit)
	PruneBlocks(height int64) (uint64, error)
	LoadBlockByHash(hash []byte) *types.Block
	LoadBlockPart(height int64, index int) *types.Part
	LoadBlockCommit(height int64) *types.Commit
	LoadSeenCommit(height int64) *types.Commit
}
//-----------------------------------------------------------------------------
// evidence pool
//go:generate mockery --case underscore --name EvidencePool
// EvidencePool defines the EvidencePool interface used by State.
type EvidencePool interface {
	PendingEvidence(maxBytes int64) (ev []types.Evidence, size int64)
	AddEvidence(types.Evidence) error
	Update(State, types.EvidenceList)
	CheckEvidence(types.EvidenceList) error
}
// EmptyEvidencePool is an empty implementation of EvidencePool, useful for testing. It also complies
// to the consensus evidence pool interface
type EmptyEvidencePool struct{}
func (EmptyEvidencePool) PendingEvidence(maxBytes int64) (ev []types.Evidence, size int64) {
	return nil, 0
}
func (EmptyEvidencePool) AddEvidence(types.Evidence) error              { return nil }
func (EmptyEvidencePool) Update(State, types.EvidenceList)              {}
func (EmptyEvidencePool) CheckEvidence(evList types.EvidenceList) error { return nil }
func (EmptyEvidencePool) AddEvidenceFromConsensus(evidence types.Evidence) error {
	return nil
}
",CWE-400,62.0,1
"module github.com/ory/hydra
require (
	github.com/dgrijalva/jwt-go v3.2.0+incompatible
	github.com/go-sql-driver/mysql v1.4.0
	github.com/gobuffalo/packd v0.0.0-20181029140631-cf76bd87a5a6 // indirect
	github.com/gobwas/glob v0.2.3
	github.com/golang/mock v1.1.1
	github.com/gorilla/context v1.1.1
	github.com/gorilla/securecookie v0.0.0-20160422134519-667fe4e3466a
	github.com/gorilla/sessions v0.0.0-20160922145804-ca9ada445741
	github.com/gtank/cryptopasta v0.0.0-20170601214702-1f550f6f2f69
	github.com/imdario/mergo v0.0.0-20171009183408-7fe0c75c13ab
	github.com/jmoiron/sqlx v0.0.0-20180614180643-0dae4fefe7c0
	github.com/julienschmidt/httprouter v0.0.0-20180715161854-348b672cd90d
	github.com/lib/pq v1.0.0
	github.com/meatballhat/negroni-logrus v0.0.0-20170801195057-31067281800f
	github.com/mendsley/gojwk v0.0.0-20141217222730-4d5ec6e58103
	github.com/mohae/deepcopy v0.0.0-20170929034955-c48cc78d4826
	github.com/oleiade/reflections v1.0.0
	github.com/opentracing/opentracing-go v1.0.2
	github.com/ory/dockertest v3.3.2+incompatible
	github.com/ory/fosite v0.28.0
	github.com/ory/go-convenience v0.1.0
	github.com/ory/graceful v0.1.0
	github.com/ory/herodot v0.4.1
	github.com/ory/sqlcon v0.0.7
	github.com/ory/x v0.0.32
	github.com/pborman/uuid v1.2.0
	github.com/phayes/freeport v0.0.0-20171002181615-b8543db493a5
	github.com/pkg/errors v0.8.0
	github.com/prometheus/client_golang v0.8.0
	github.com/rs/cors v1.6.0
	github.com/rubenv/sql-migrate v0.0.0-20180704111356-ba2c6a7295c59448dbc195cef2f41df5163b3892
	github.com/sirupsen/logrus v1.1.1
	github.com/spf13/cobra v0.0.3
	github.com/spf13/viper v1.2.1
	github.com/stretchr/testify v1.2.2
	github.com/toqueteos/webbrowser v0.0.0-20150720201625-21fc9f95c834
	github.com/uber-go/atomic v1.3.2 // indirect
	github.com/uber/jaeger-client-go v2.15.0+incompatible
	github.com/urfave/negroni v1.0.0
	github.com/ziutek/mymysql v1.5.4 // indirect
	go.uber.org/atomic v1.3.2 // indirect
	golang.org/x/crypto v0.0.0-20181001203147-e3636079e1a4
	golang.org/x/net v0.0.0-20181029044818-c44066c5c816 // indirect
	golang.org/x/oauth2 v0.0.0-20181003184128-c57b0facaced
	gopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127 // indirect
	gopkg.in/resty.v1 v1.9.1
	gopkg.in/square/go-jose.v2 v2.1.9
	gopkg.in/yaml.v1 v1.0.0-20140924161607-9f9df34309c0
)
",CWE-79,53.0,1
"/*
 * Copyright © 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @author		Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @copyright 	2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @license 	Apache-2.0
 */
package oauth2
import (
	""fmt""
	""net/http""
	""github.com/julienschmidt/httprouter""
)
func (h *Handler) DefaultConsentHandler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
	h.L.Warnln(""It looks like no consent/login URL was set. All OAuth2 flows except client credentials will fail."")
	h.L.Warnln(""A client requested the default login & consent URL, environment variable OAUTH2_CONSENT_URL or OAUTH2_LOGIN_URL or both are probably not set."")
	w.Write([]byte(`
<html>
<head>
	<title>Misconfigured consent/login URL</title>
</head>
<body>
<p>
	It looks like you forgot to set the consent/login provider url, which can be set using the <code>OAUTH2_CONSENT_URL</code> and <code>OAUTH2_LOGIN_URL</code>
	environment variable.
</p>
<p>
	If you are an administrator, please read <a href=""https://www.ory.sh/docs"">
	the guide</a> to understand what you need to do. If you are a user, please contact the administrator.
</p>
</body>
</html>
`))
}
func (h *Handler) DefaultErrorHandler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
	h.L.Warnln(""A client requested the default error URL, environment variable OAUTH2_ERROR_URL is probably not set."")
	fmt.Fprintf(w, `
<html>
<head>
	<title>An OAuth 2.0 Error Occurred</title>
</head>
<body>
<h1>
	The OAuth2 request resulted in an error.
</h1>
<ul>
	<li>Error: %s</li>
	<li>Description: %s</li>
	<li>Hint: %s</li>
	<li>Debug: %s</li>
</ul>
<p>
	You are seeing this default error page because the administrator has not set a dedicated error URL (environment variable <code>OAUTH2_ERROR_URL</code> is not set). 
	If you are an administrator, please read <a href=""https://www.ory.sh/docs"">the guide</a> to understand what you
	need to do. If you are a user, please contact the administrator.
</p>
</body>
</html>
`, r.URL.Query().Get(""error""), r.URL.Query().Get(""error_description""), r.URL.Query().Get(""error_hint""), r.URL.Query().Get(""error_debug""))
}
func (h *Handler) DefaultLogoutHandler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
	h.L.Warnln(""A client requested the default logout URL, environment variable OAUTH2_LOGOUT_REDIRECT_URL is probably not set."")
	fmt.Fprintf(w, `
<html>
<head>
	<title>You logged out successfully</title>
</head>
<body>
<h1>
	You logged out successfully!
</h1>
<p>
	You are seeing this default page because the administrator did not specify a redirect URL (environment variable <code>OAUTH2_LOGOUT_REDIRECT_URL</code> is not set). 
	If you are an administrator, please read <a href=""https://www.ory.sh/docs"">the guide</a> to understand what you
	need to do. If you are a user, please contact the administrator.
</p>
</body>
</html>
`)
}
",CWE-79,102.0,1
"/*
 * Copyright © 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @author		Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @copyright 	2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @license 	Apache-2.0
 */
package client
import (
	""context""
	""github.com/ory/fosite""
)
var _, _ Manager = new(SQLManager), new(MemoryManager)
type Manager interface {
	Storage
	Authenticate(ctx context.Context, id string, secret []byte) (*Client, error)
}
type Storage interface {
	fosite.Storage
	CreateClient(ctx context.Context, c *Client) error
	UpdateClient(ctx context.Context, c *Client) error
	DeleteClient(ctx context.Context, id string) error
	GetClients(ctx context.Context, limit, offset int) ([]Client, error)
	CountClients(ctx context.Context) (int, error)
	GetConcreteClient(ctx context.Context, id string) (*Client, error)
}
",CWE-294,52.0,1
"package configuration
import (
	""fmt""
	""io/ioutil""
	""net/http""
	""os""
	""strings""
	""testing""
	""github.com/ory/hydra/x""
	""github.com/ory/viper""
	""github.com/ory/x/logrusx""
	""github.com/rs/cors""
	""github.com/sirupsen/logrus""
	""github.com/stretchr/testify/assert""
	""github.com/stretchr/testify/require""
)
func setupEnv(env map[string]string) func(t *testing.T) (func(), func()) {
	return func(t *testing.T) (setup func(), clean func()) {
		setup = func() {
			for k, v := range env {
				require.NoError(t, os.Setenv(k, v))
			}
		}
		clean = func() {
			for k := range env {
				require.NoError(t, os.Unsetenv(k))
			}
		}
		return
	}
}
func TestSubjectTypesSupported(t *testing.T) {
	for k, tc := range []struct {
		d   string
		env func(t *testing.T) (func(), func())
		e   []string
	}{
		{
			d: ""Load legacy environment variable in legacy format"",
			env: setupEnv(map[string]string{
				strings.ToUpper(strings.Replace(ViperKeySubjectTypesSupported, ""."", ""_"", -1)): ""public,pairwise,foobar"",
			}),
			e: []string{""public"", ""pairwise""},
		},
		{
			d: ""Load legacy environment variable in legacy format"",
			env: setupEnv(map[string]string{
				strings.ToUpper(strings.Replace(ViperKeySubjectTypesSupported, ""."", ""_"", -1)): ""public,pairwise,foobar"",
				strings.ToUpper(strings.Replace(ViperKeyAccessTokenStrategy, ""."", ""_"", -1)):   ""jwt"",
			}),
			e: []string{""public""},
		},
	} {
		t.Run(fmt.Sprintf(""case=%d/description=%s"", k, tc.d), func(t *testing.T) {
			setup, clean := tc.env(t)
			setup()
			p := NewViperProvider(logrus.New(), false, nil)
			viper.Set(ViperKeySubjectIdentifierAlgorithmSalt, ""00000000"")
			assert.EqualValues(t, tc.e, p.SubjectTypesSupported())
			clean()
		})
	}
}
func TestWellKnownKeysUnique(t *testing.T) {
	p := NewViperProvider(logrus.New(), false, nil)
	assert.EqualValues(t, []string{x.OAuth2JWTKeyName, x.OpenIDConnectKeyName}, p.WellKnownKeys(x.OAuth2JWTKeyName, x.OpenIDConnectKeyName, x.OpenIDConnectKeyName))
}
func TestCORSOptions(t *testing.T) {
	p := NewViperProvider(logrus.New(), false, nil)
	viper.Set(""serve.public.cors.enabled"", true)
	assert.EqualValues(t, cors.Options{
		AllowedOrigins:     []string{},
		AllowedMethods:     []string{""GET"", ""POST"", ""PUT"", ""PATCH"", ""DELETE""},
		AllowedHeaders:     []string{""Authorization"", ""Content-Type""},
		ExposedHeaders:     []string{""Content-Type""},
		AllowCredentials:   true,
		OptionsPassthrough: false,
		MaxAge:             0,
		Debug:              false,
	}, p.CORSOptions(""public""))
}
func TestViperProvider_AdminDisableHealthAccessLog(t *testing.T) {
	l := logrusx.New()
	l.SetOutput(ioutil.Discard)
	p := NewViperProvider(l, false, nil)
	value := p.AdminDisableHealthAccessLog()
	assert.Equal(t, false, value)
	viper.Set(ViperKeyAdminDisableHealthAccessLog, ""true"")
	value = p.AdminDisableHealthAccessLog()
	assert.Equal(t, true, value)
}
func TestViperProvider_PublicDisableHealthAccessLog(t *testing.T) {
	l := logrusx.New()
	l.SetOutput(ioutil.Discard)
	p := NewViperProvider(l, false, nil)
	value := p.PublicDisableHealthAccessLog()
	assert.Equal(t, false, value)
	viper.Set(ViperKeyPublicDisableHealthAccessLog, ""true"")
	value = p.PublicDisableHealthAccessLog()
	assert.Equal(t, true, value)
}
func TestViperProvider_IssuerURL(t *testing.T) {
	l := logrusx.New()
	l.SetOutput(ioutil.Discard)
	viper.Set(ViperKeyIssuerURL, ""http://hydra.localhost"")
	p := NewViperProvider(l, false, nil)
	assert.Equal(t, ""http://hydra.localhost/"", p.IssuerURL().String())
	viper.Set(ViperKeyIssuerURL, ""http://hydra.localhost/"")
	p2 := NewViperProvider(l, false, nil)
	assert.Equal(t, ""http://hydra.localhost/"", p2.IssuerURL().String())
}
func TestViperProvider_CookieSameSiteMode(t *testing.T) {
	l := logrusx.New()
	l.SetOutput(ioutil.Discard)
	p := NewViperProvider(l, false, nil)
	assert.Equal(t, http.SameSiteDefaultMode, p.CookieSameSiteMode())
	viper.Set(ViperKeyCookieSameSiteMode, ""none"")
	assert.Equal(t, http.SameSiteNoneMode, p.CookieSameSiteMode())
}
",CWE-294,143.0,1
"module github.com/ory/hydra
go 1.14
require (
	github.com/dgrijalva/jwt-go v3.2.0+incompatible
	github.com/go-bindata/go-bindata v3.1.1+incompatible
	github.com/go-openapi/errors v0.19.3
	github.com/go-openapi/runtime v0.19.11
	github.com/go-openapi/strfmt v0.19.4
	github.com/go-openapi/swag v0.19.7
	github.com/go-openapi/validate v0.19.6
	github.com/go-sql-driver/mysql v1.4.1
	github.com/go-swagger/go-swagger v0.22.1-0.20200306221957-4aad3a5f78b8
	github.com/gobuffalo/packr v1.24.0
	github.com/gobwas/glob v0.2.3
	github.com/golang/mock v1.3.1
	github.com/google/uuid v1.1.1
	github.com/gorilla/sessions v1.1.4-0.20181208214519-12bd4761fc66
	github.com/gtank/cryptopasta v0.0.0-20170601214702-1f550f6f2f69
	github.com/jackc/pgx/v4 v4.4.1
	github.com/jmoiron/sqlx v1.2.0
	github.com/julienschmidt/httprouter v1.2.0
	github.com/mattn/go-runewidth v0.0.4 // indirect
	github.com/mohae/deepcopy v0.0.0-20170929034955-c48cc78d4826
	github.com/oleiade/reflections v1.0.0
	github.com/olekukonko/tablewriter v0.0.1
	github.com/opentracing/opentracing-go v1.1.1-0.20190913142402-a7454ce5950e
	github.com/ory/fosite v0.30.6
	github.com/ory/go-acc v0.2.1
	github.com/ory/graceful v0.1.1
	github.com/ory/herodot v0.7.0
	github.com/ory/sdk/swagutil v0.0.0-20200219090358-f796db673877
	github.com/ory/viper v1.7.3
	github.com/ory/x v0.0.108
	github.com/pborman/uuid v1.2.0
	github.com/phayes/freeport v0.0.0-20171002181615-b8543db493a5
	github.com/pkg/errors v0.9.1
	github.com/pkg/profile v1.3.0 // indirect
	github.com/prometheus/client_golang v1.1.0
	github.com/rs/cors v1.6.0
	github.com/rubenv/sql-migrate v0.0.0-20190212093014-1007f53448d7
	github.com/sawadashota/encrypta v0.0.2
	github.com/segmentio/analytics-go v3.1.0+incompatible
	github.com/segmentio/backo-go v0.0.0-20200129164019-23eae7c10bd3 // indirect
	github.com/sirupsen/logrus v1.4.2
	github.com/spf13/cobra v0.0.6
	github.com/sqs/goreturns v0.0.0-20181028201513-538ac6014518
	github.com/stretchr/testify v1.4.0
	github.com/tidwall/gjson v1.6.0
	github.com/tidwall/pretty v1.0.1 // indirect
	github.com/toqueteos/webbrowser v1.2.0
	github.com/uber/jaeger-client-go v2.22.1+incompatible
	github.com/urfave/negroni v1.0.0
	go.opentelemetry.io/otel v0.2.1
	golang.org/x/crypto v0.0.0-20200320181102-891825fb96df
	golang.org/x/lint v0.0.0-20200302205851-738671d3881b // indirect
	golang.org/x/oauth2 v0.0.0-20200107190931-bf48bf16ab8d
	golang.org/x/tools v0.0.0-20200313205530-4303120df7d8
	gopkg.in/square/go-jose.v2 v2.4.1
)
",CWE-294,62.0,1
"package oauth2_test
import (
	""context""
	""fmt""
	""testing""
	""github.com/jmoiron/sqlx""
	""github.com/stretchr/testify/require""
	""github.com/ory/fosite""
	""github.com/ory/hydra/client""
	""github.com/ory/hydra/consent""
	""github.com/ory/hydra/internal""
	""github.com/ory/hydra/oauth2""
	""github.com/ory/hydra/x""
	""github.com/ory/x/dbal""
	""github.com/ory/x/dbal/migratest""
)
func TestXXMigrations(t *testing.T) {
	if testing.Short() {
		t.SkipNow()
		return
	}
	migratest.RunPackrMigrationTests(
		t,
		migratest.MigrationSchemas{client.Migrations, consent.Migrations, oauth2.Migrations},
		migratest.MigrationSchemas{nil, nil, dbal.FindMatchingTestMigrations(""migrations/sql/tests/"", oauth2.Migrations, oauth2.AssetNames(), oauth2.Asset)},
		x.CleanSQL,
		x.CleanSQL,
		func(t *testing.T, dbName string, db *sqlx.DB, m, k, steps int) {
			t.Run(fmt.Sprintf(""poll=%d"", k), func(t *testing.T) {
				conf := internal.NewConfigurationWithDefaults()
				reg := internal.NewRegistrySQL(conf, db)
				if m != 2 {
					t.Skip(""Skipping polling unless it's the last migration schema"")
					return
				}
				s := reg.OAuth2Storage().(*oauth2.FositeSQLStore)
				if dbName == ""cockroach"" {
					k += 8
				}
				sig := fmt.Sprintf(""%d-sig"", k+1)
				if k < 8 {
					// With migration 8, all previous test data has been removed because the client is non-existent.
					_, err := s.GetAccessTokenSession(context.Background(), sig, oauth2.NewSession(""""))
					require.Error(t, err)
					return
				}
				_, err := s.GetAccessTokenSession(context.Background(), sig, oauth2.NewSession(""""))
				require.NoError(t, err)
				_, err = s.GetRefreshTokenSession(context.Background(), sig, oauth2.NewSession(""""))
				require.NoError(t, err)
				_, err = s.GetAuthorizeCodeSession(context.Background(), sig, oauth2.NewSession(""""))
				require.NoError(t, err)
				_, err = s.GetOpenIDConnectSession(context.Background(), sig, &fosite.Request{Session: oauth2.NewSession("""")})
				require.NoError(t, err)
				if k > 2 {
					_, err = s.GetPKCERequestSession(context.Background(), sig, oauth2.NewSession(""""))
					require.NoError(t, err)
				}
			})
		},
	)
}
",CWE-294,71.0,1
"package x
import (
	""testing""
	""github.com/jmoiron/sqlx""
)
func CleanSQL(t *testing.T, db *sqlx.DB) {
	t.Logf(""Cleaning up database: %s"", db.DriverName())
	for _, tb := range []string{
		""hydra_oauth2_access"",
		""hydra_oauth2_refresh"",
		""hydra_oauth2_code"",
		""hydra_oauth2_oidc"",
		""hydra_oauth2_pkce"",
		""hydra_oauth2_consent_request_handled"",
		""hydra_oauth2_consent_request"",
		""hydra_oauth2_authentication_request_handled"",
		""hydra_oauth2_authentication_request"",
		""hydra_oauth2_authentication_session"",
		""hydra_oauth2_obfuscated_authentication_session"",
		""hydra_oauth2_logout_request"",
		""hydra_jwk"",
		""hydra_client"",
		// Migrations
		""hydra_oauth2_authentication_consent_migration"",
		""hydra_client_migration"",
		""hydra_oauth2_migration"",
		""hydra_jwk_migration"",
	} {
		if _, err := db.Exec(""DROP TABLE IF EXISTS "" + tb); err != nil {
			t.Logf(`Unable to clean up table ""%s"": %s`, tb, err)
		}
	}
	t.Logf(""Successfully cleaned up database: %s"", db.DriverName())
}
",CWE-294,38.0,1
"package project
import (
	""github.com/argoproj/argo-cd/v2/test/e2e/fixture""
)
// this implements the ""when"" part of given/when/then
//
// none of the func implement error checks, and that is complete intended, you should check for errors
// using the Then()
type Actions struct {
	context      *Context
	lastOutput   string
	lastError    error
	ignoreErrors bool
}
func (a *Actions) IgnoreErrors() *Actions {
	a.ignoreErrors = true
	return a
}
func (a *Actions) DoNotIgnoreErrors() *Actions {
	a.ignoreErrors = false
	return a
}
func (a *Actions) Create(args ...string) *Actions {
	args = a.prepareCreateArgs(args)
	//  are you adding new context values? if you only use them for this func, then use args instead
	a.runCli(args...)
	return a
}
func (a *Actions) Name(name string) *Actions {
	a.context.name = name
	return a
}
func (a *Actions) prepareCreateArgs(args []string) []string {
	a.context.t.Helper()
	args = append([]string{
		""proj"", ""create"", a.context.name,
	}, args...)
	if a.context.destination != """" {
		args = append(args, ""--dest"", a.context.destination)
	}
	return args
}
func (a *Actions) Delete() *Actions {
	a.context.t.Helper()
	a.runCli(""proj"", ""delete"", a.context.name)
	return a
}
func (a *Actions) And(block func()) *Actions {
	a.context.t.Helper()
	block()
	return a
}
func (a *Actions) Then() *Consequences {
	a.context.t.Helper()
	return &Consequences{a.context, a}
}
func (a *Actions) runCli(args ...string) {
	a.context.t.Helper()
	a.lastOutput, a.lastError = fixture.RunCli(args...)
}
",CWE-862,76.0,1
"package application
import (
	""encoding/json""
	""fmt""
	""net/http""
	""sync""
	""time""
	""github.com/gorilla/websocket""
	log ""github.com/sirupsen/logrus""
	""k8s.io/client-go/tools/remotecommand""
)
var upgrader = func() websocket.Upgrader {
	upgrader := websocket.Upgrader{}
	upgrader.HandshakeTimeout = time.Second * 2
	upgrader.CheckOrigin = func(r *http.Request) bool {
		return true
	}
	return upgrader
}()
// terminalSession implements PtyHandler
type terminalSession struct {
	wsConn    *websocket.Conn
	sizeChan  chan remotecommand.TerminalSize
	doneChan  chan struct{}
	tty       bool
	readLock  sync.Mutex
	writeLock sync.Mutex
}
// newTerminalSession create terminalSession
func newTerminalSession(w http.ResponseWriter, r *http.Request, responseHeader http.Header) (*terminalSession, error) {
	conn, err := upgrader.Upgrade(w, r, responseHeader)
	if err != nil {
		return nil, err
	}
	session := &terminalSession{
		wsConn:   conn,
		tty:      true,
		sizeChan: make(chan remotecommand.TerminalSize),
		doneChan: make(chan struct{}),
	}
	return session, nil
}
// Done close the done channel.
func (t *terminalSession) Done() {
	close(t.doneChan)
}
func (t *terminalSession) StartKeepalives(dur time.Duration) {
	ticker := time.NewTicker(dur)
	defer ticker.Stop()
	for {
		select {
		case <-ticker.C:
			err := t.Ping()
			if err != nil {
				log.Errorf(""ping error: %v"", err)
				return
			}
		case <-t.doneChan:
			return
		}
	}
}
// Next called in a loop from remotecommand as long as the process is running
func (t *terminalSession) Next() *remotecommand.TerminalSize {
	select {
	case size := <-t.sizeChan:
		return &size
	case <-t.doneChan:
		return nil
	}
}
// Read called in a loop from remotecommand as long as the process is running
func (t *terminalSession) Read(p []byte) (int, error) {
	t.readLock.Lock()
	_, message, err := t.wsConn.ReadMessage()
	t.readLock.Unlock()
	if err != nil {
		log.Errorf(""read message err: %v"", err)
		return copy(p, EndOfTransmission), err
	}
	var msg TerminalMessage
	if err := json.Unmarshal(message, &msg); err != nil {
		log.Errorf(""read parse message err: %v"", err)
		return copy(p, EndOfTransmission), err
	}
	switch msg.Operation {
	case ""stdin"":
		return copy(p, msg.Data), nil
	case ""resize"":
		t.sizeChan <- remotecommand.TerminalSize{Width: msg.Cols, Height: msg.Rows}
		return 0, nil
	default:
		return copy(p, EndOfTransmission), fmt.Errorf(""unknown message type %s"", msg.Operation)
	}
}
// Ping called periodically to ensure connection stays alive through load balancers
func (t *terminalSession) Ping() error {
	t.writeLock.Lock()
	err := t.wsConn.WriteMessage(websocket.PingMessage, []byte(""ping""))
	t.writeLock.Unlock()
	if err != nil {
		log.Errorf(""ping message err: %v"", err)
	}
	return err
}
// Write called from remotecommand whenever there is any output
func (t *terminalSession) Write(p []byte) (int, error) {
	msg, err := json.Marshal(TerminalMessage{
		Operation: ""stdout"",
		Data:      string(p),
	})
	if err != nil {
		log.Errorf(""write parse message err: %v"", err)
		return 0, err
	}
	t.writeLock.Lock()
	err = t.wsConn.WriteMessage(websocket.TextMessage, msg)
	t.writeLock.Unlock()
	if err != nil {
		log.Errorf(""write message err: %v"", err)
		return 0, err
	}
	return len(p), nil
}
// Close closes websocket connection
func (t *terminalSession) Close() error {
	return t.wsConn.Close()
}
",CWE-613,141.0,1
"// Code generated by mockery v1.0.0. DO NOT EDIT.
package mocks
import (
	helm ""github.com/argoproj/argo-cd/v2/util/helm""
	io ""github.com/argoproj/argo-cd/v2/util/io""
	mock ""github.com/stretchr/testify/mock""
)
// Client is an autogenerated mock type for the Client type
type Client struct {
	mock.Mock
}
// CleanChartCache provides a mock function with given fields: chart, version
func (_m *Client) CleanChartCache(chart string, version string) error {
	ret := _m.Called(chart, version)
	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(chart, version)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}
// ExtractChart provides a mock function with given fields: chart, version
func (_m *Client) ExtractChart(chart string, version string, passCredentials bool) (string, io.Closer, error) {
	ret := _m.Called(chart, version)
	var r0 string
	if rf, ok := ret.Get(0).(func(string, string) string); ok {
		r0 = rf(chart, version)
	} else {
		r0 = ret.Get(0).(string)
	}
	var r1 io.Closer
	if rf, ok := ret.Get(1).(func(string, string) io.Closer); ok {
		r1 = rf(chart, version)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(io.Closer)
		}
	}
	var r2 error
	if rf, ok := ret.Get(2).(func(string, string) error); ok {
		r2 = rf(chart, version)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}
// GetIndex provides a mock function with given fields: noCache
func (_m *Client) GetIndex(noCache bool) (*helm.Index, error) {
	ret := _m.Called(noCache)
	var r0 *helm.Index
	if rf, ok := ret.Get(0).(func(bool) *helm.Index); ok {
		r0 = rf(noCache)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*helm.Index)
		}
	}
	var r1 error
	if rf, ok := ret.Get(1).(func(bool) error); ok {
		r1 = rf(noCache)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}
// GetTags provides a mock function with given fields: noCache
func (_m *Client) GetTags(chart string, noCache bool) (*helm.TagsList, error) {
	ret := _m.Called(chart, noCache)
	var r0 *helm.TagsList
	if rf, ok := ret.Get(0).(func(string, bool) *helm.TagsList); ok {
		r0 = rf(chart, noCache)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*helm.TagsList)
		}
	}
	var r1 error
	if rf, ok := ret.Get(1).(func(string, bool) error); ok {
		r1 = rf(chart, noCache)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}
// TestHelmOCI provides a mock function with given fields:
func (_m *Client) TestHelmOCI() (bool, error) {
	ret := _m.Called()
	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}
	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}
",CWE-400,127.0,1
"package api
import (
	""net/http""
	""github.com/containous/traefik/v2/pkg/log""
	assetfs ""github.com/elazarl/go-bindata-assetfs""
	""github.com/gorilla/mux""
)
// DashboardHandler expose dashboard routes.
type DashboardHandler struct {
	Assets *assetfs.AssetFS
}
// Append add dashboard routes on a router.
func (g DashboardHandler) Append(router *mux.Router) {
	if g.Assets == nil {
		log.WithoutContext().Error(""No assets for dashboard"")
		return
	}
	// Expose dashboard
	router.Methods(http.MethodGet).
		Path(""/"").
		HandlerFunc(func(response http.ResponseWriter, request *http.Request) {
			http.Redirect(response, request, request.Header.Get(""X-Forwarded-Prefix"")+""/dashboard/"", http.StatusFound)
		})
	router.Methods(http.MethodGet).
		PathPrefix(""/dashboard/"").
		Handler(http.StripPrefix(""/dashboard/"", http.FileServer(g.Assets)))
}
",CWE-601,34.0,1
"/*
Copyright The Helm Authors.
Licensed under the Apache License, Version 2.0 (the ""License"");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an ""AS IS"" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package main
import (
	""fmt""
	""io""
	""github.com/spf13/cobra""
	""helm.sh/helm/v3/cmd/helm/require""
	""helm.sh/helm/v3/pkg/plugin""
	""helm.sh/helm/v3/pkg/plugin/installer""
)
type pluginInstallOptions struct {
	source  string
	version string
}
const pluginInstallDesc = `
This command allows you to install a plugin from a url to a VCS repo or a local path.
`
func newPluginInstallCmd(out io.Writer) *cobra.Command {
	o := &pluginInstallOptions{}
	cmd := &cobra.Command{
		Use:     ""install [options] <path|url>..."",
		Short:   ""install one or more Helm plugins"",
		Long:    pluginInstallDesc,
		Aliases: []string{""add""},
		Args:    require.ExactArgs(1),
		ValidArgsFunction: func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {
			if len(args) == 0 {
				// We do file completion, in case the plugin is local
				return nil, cobra.ShellCompDirectiveDefault
			}
			// No more completion once the plugin path has been specified
			return nil, cobra.ShellCompDirectiveNoFileComp
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return o.complete(args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return o.run(out)
		},
	}
	cmd.Flags().StringVar(&o.version, ""version"", """", ""specify a version constraint. If this is not specified, the latest version is installed"")
	return cmd
}
func (o *pluginInstallOptions) complete(args []string) error {
	o.source = args[0]
	return nil
}
func (o *pluginInstallOptions) run(out io.Writer) error {
	installer.Debug = settings.Debug
	i, err := installer.NewForSource(o.source, o.version)
	if err != nil {
		return err
	}
	if err := installer.Install(i); err != nil {
		return err
	}
	debug(""loading plugin from %s"", i.Path())
	p, err := plugin.LoadDir(i.Path())
	if err != nil {
		return err
	}
	if err := runHook(p, plugin.Install); err != nil {
		return err
	}
	fmt.Fprintf(out, ""Installed plugin: %s\n"", p.Metadata.Name)
	return nil
}
",CWE-74,94.0,1
"/*
 * Copyright © 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @author		Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @copyright 	2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @license 	Apache-2.0
 *
 */
package fosite
import ""context""
// ClientManager defines the (persistent) manager interface for clients.
type ClientManager interface {
	// GetClient loads the client by its ID or returns an error
	// if the client does not exist or another error occurred.
	GetClient(ctx context.Context, id string) (Client, error)
}
",CWE-345,32.0,1
"module github.com/ory/fosite
require (
	github.com/asaskevich/govalidator v0.0.0-20180720115003-f9ffefc3facf
	github.com/davecgh/go-spew v1.1.1 // indirect
	github.com/dgrijalva/jwt-go v3.2.0+incompatible
	github.com/elazarl/goproxy v0.0.0-20181003060214-f58a169a71a5 // indirect
	github.com/golang/mock v1.1.1
	github.com/gopherjs/gopherjs v0.0.0-20181004151105-1babbf986f6f // indirect
	github.com/gorilla/context v1.1.1 // indirect
	github.com/gorilla/mux v1.6.2
	github.com/jtolds/gls v4.2.1+incompatible // indirect
	github.com/magiconair/properties v1.8.0
	github.com/mohae/deepcopy v0.0.0-20170929034955-c48cc78d4826
	github.com/moul/http2curl v0.0.0-20170919181001-9ac6cf4d929b // indirect
	github.com/oleiade/reflections v1.0.0
	github.com/ory/go-convenience v0.1.0
	github.com/parnurzeal/gorequest v0.2.15
	github.com/pborman/uuid v1.2.0
	github.com/pkg/errors v0.8.0
	github.com/pmezard/go-difflib v1.0.0 // indirect
	github.com/smartystreets/assertions v0.0.0-20180927180507-b2de0cb4f26d // indirect
	github.com/smartystreets/goconvey v0.0.0-20180222194500-ef6db91d284a // indirect
	github.com/stretchr/testify v1.2.2
	golang.org/x/crypto v0.0.0-20181001203147-e3636079e1a4
	golang.org/x/net v0.0.0-20181005035420-146acd28ed58 // indirect
	golang.org/x/oauth2 v0.0.0-20181003184128-c57b0facaced
	golang.org/x/sync v0.0.0-20180314180146-1d60e4601c6f // indirect
	google.golang.org/appengine v1.2.0 // indirect
	gopkg.in/square/go-jose.v2 v2.1.9
)
go 1.13
",CWE-345,34.0,1
"github.com/asaskevich/govalidator v0.0.0-20180720115003-f9ffefc3facf h1:eg0MeVzsP1G42dRafH3vf+al2vQIJU0YHX+1Tw87oco=
github.com/asaskevich/govalidator v0.0.0-20180720115003-f9ffefc3facf/go.mod h1:lB+ZfQJz7igIIfQNfa7Ml4HSf2uFQQRzpGGRXenZAgY=
github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/dgrijalva/jwt-go v3.2.0+incompatible h1:7qlOGliEKZXTDg6OTjfoBKDXWrumCAMpl/TFQ4/5kLM=
github.com/dgrijalva/jwt-go v3.2.0+incompatible/go.mod h1:E3ru+11k8xSBh+hMPgOLZmtrrCbhqsmaPHjLKYnJCaQ=
github.com/elazarl/goproxy v0.0.0-20181003060214-f58a169a71a5 h1:LCoguo7Zd0MByKMbQbTvcZw7HiBcbvew+MOcwsJVwrY=
github.com/elazarl/goproxy v0.0.0-20181003060214-f58a169a71a5/go.mod h1:/Zj4wYkgs4iZTTu3o/KG3Itv/qCCa8VVMlb3i9OVuzc=
github.com/golang/mock v1.1.1 h1:G5FRp8JnTd7RQH5kemVNlMeyXQAztQ3mOWV95KxsXH8=
github.com/golang/mock v1.1.1/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=
github.com/golang/protobuf v1.2.0 h1:P3YflyNX/ehuJFLhxviNdFxQPkGK5cDcApsge1SqnvM=
github.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=
github.com/google/uuid v1.0.0 h1:b4Gk+7WdP/d3HZH8EJsZpvV7EtDOgaZLtnaNGIu1adA=
github.com/google/uuid v1.0.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
github.com/gopherjs/gopherjs v0.0.0-20181004151105-1babbf986f6f h1:JJ2EP5vV3LAD2U1CxQtD7PTOO15Y96kXmKDz7TjxGHs=
github.com/gopherjs/gopherjs v0.0.0-20181004151105-1babbf986f6f/go.mod h1:wJfORRmW1u3UXTncJ5qlYoELFm8eSnnEO6hX4iZ3EWY=
github.com/gorilla/context v1.1.1 h1:AWwleXJkX/nhcU9bZSnZoi3h/qGYqQAGhq6zZe/aQW8=
github.com/gorilla/context v1.1.1/go.mod h1:kBGZzfjB9CEq2AlWe17Uuf7NDRt0dE0s8S51q0aT7Yg=
github.com/gorilla/mux v1.6.2 h1:Pgr17XVTNXAk3q/r4CpKzC5xBM/qW1uVLV+IhRZpIIk=
github.com/gorilla/mux v1.6.2/go.mod h1:1lud6UwP+6orDFRuTfBEV8e9/aOM/c4fVVCaMa2zaAs=
github.com/jtolds/gls v4.2.1+incompatible h1:fSuqC+Gmlu6l/ZYAoZzx2pyucC8Xza35fpRVWLVmUEE=
github.com/jtolds/gls v4.2.1+incompatible/go.mod h1:QJZ7F/aHp+rZTRtaJ1ow/lLfFfVYBRgL+9YlvaHOwJU=
github.com/magiconair/properties v1.8.0 h1:LLgXmsheXeRoUOBOjtwPQCWIYqM/LU1ayDtDePerRcY=
github.com/magiconair/properties v1.8.0/go.mod h1:PppfXfuXeibc/6YijjN8zIbojt8czPbwD3XqdrwzmxQ=
github.com/mohae/deepcopy v0.0.0-20170929034955-c48cc78d4826 h1:RWengNIwukTxcDr9M+97sNutRR1RKhG96O6jWumTTnw=
github.com/mohae/deepcopy v0.0.0-20170929034955-c48cc78d4826/go.mod h1:TaXosZuwdSHYgviHp1DAtfrULt5eUgsSMsZf+YrPgl8=
github.com/moul/http2curl v0.0.0-20170919181001-9ac6cf4d929b h1:Pip12xNtMvEFUBF4f8/b5yRXj94LLrNdLWELfOr2KcY=
github.com/moul/http2curl v0.0.0-20170919181001-9ac6cf4d929b/go.mod h1:8UbvGypXm98wA/IqH45anm5Y2Z6ep6O31QGOAZ3H0fQ=
github.com/oleiade/reflections v1.0.0 h1:0ir4pc6v8/PJ0yw5AEtMddfXpWBXg9cnG7SgSoJuCgY=
github.com/oleiade/reflections v1.0.0/go.mod h1:RbATFBbKYkVdqmSFtx13Bb/tVhR0lgOBXunWTZKeL4w=
github.com/ory/go-convenience v0.1.0 h1:zouLKfF2GoSGnJwGq+PE/nJAE6dj2Zj5QlTgmMTsTS8=
github.com/ory/go-convenience v0.1.0/go.mod h1:uEY/a60PL5c12nYz4V5cHY03IBmwIAEm8TWB0yn9KNs=
github.com/parnurzeal/gorequest v0.2.15 h1:oPjDCsF5IkD4gUk6vIgsxYNaSgvAnIh1EJeROn3HdJU=
github.com/parnurzeal/gorequest v0.2.15/go.mod h1:3Kh2QUMJoqw3icWAecsyzkpY7UzRfDhbRdTjtNwNiUE=
github.com/pborman/uuid v1.2.0 h1:J7Q5mO4ysT1dv8hyrUGHb9+ooztCXu1D8MY8DZYsu3g=
github.com/pborman/uuid v1.2.0/go.mod h1:X/NO0urCmaxf9VXbdlT7C2Yzkj2IKimNn4k+gtPdI/k=
github.com/pkg/errors v0.8.0 h1:WdK/asTD0HN+q6hsWO3/vpuAkAr+tw6aNJNDFFf0+qw=
github.com/pkg/errors v0.8.0/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=
github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/smartystreets/assertions v0.0.0-20180927180507-b2de0cb4f26d h1:zE9ykElWQ6/NYmHa3jpm/yHnI4xSofP+UP6SpjHcSeM=
github.com/smartystreets/assertions v0.0.0-20180927180507-b2de0cb4f26d/go.mod h1:OnSkiWE9lh6wB0YB77sQom3nweQdgAjqCqsofrRNTgc=
github.com/smartystreets/goconvey v0.0.0-20180222194500-ef6db91d284a h1:JSvGDIbmil4Ui/dDdFBExb7/cmkNjyX5F97oglmvCDo=
github.com/smartystreets/goconvey v0.0.0-20180222194500-ef6db91d284a/go.mod h1:XDJAKZRPZ1CvBcN2aX5YOUTYGHki24fSF0Iv48Ibg0s=
github.com/stretchr/testify v1.2.2 h1:bSDNvY7ZPG5RlJ8otE/7V6gMiyenm9RtJ7IUVIAoJ1w=
github.com/stretchr/testify v1.2.2/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=
golang.org/x/crypto v0.0.0-20181001203147-e3636079e1a4 h1:Vk3wNqEZwyGyei9yq5ekj7frek2u7HUfffJ1/opblzc=
golang.org/x/crypto v0.0.0-20181001203147-e3636079e1a4/go.mod h1:6SG95UA2DQfeDnfUPMdvaQW0Q7yPrPDi9nlGo2tz2b4=
golang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20181005035420-146acd28ed58 h1:otZG8yDCO4LVps5+9bxOeNiCvgmOyt96J3roHTYs7oE=
golang.org/x/net v0.0.0-20181005035420-146acd28ed58/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/oauth2 v0.0.0-20181003184128-c57b0facaced h1:4oqSq7eft7MdPKBGQK11X9WYUxmj6ZLgGTqYIbY1kyw=
golang.org/x/oauth2 v0.0.0-20181003184128-c57b0facaced/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=
golang.org/x/sync v0.0.0-20180314180146-1d60e4601c6f h1:wMNYb4v58l5UBM7MYRLPG6ZhfOqbKu7X5eyFl8ZhKvA=
golang.org/x/sync v0.0.0-20180314180146-1d60e4601c6f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
google.golang.org/appengine v1.2.0 h1:S0iUepdCWODXRvtE+gcRDd15L+k+k1AiHlMiMjefH24=
google.golang.org/appengine v1.2.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=
gopkg.in/square/go-jose.v2 v2.1.9 h1:YCFbL5T2gbmC2sMG12s1x2PAlTK5TZNte3hjZEIcCAg=
gopkg.in/square/go-jose.v2 v2.1.9/go.mod h1:M9dMgbHiYLoDGQrXy7OpJDJWiKiU//h+vD76mk0e1AI=
",CWE-345,61.0,1
"/*
 * Copyright © 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @author		Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @copyright 	2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @license 	Apache-2.0
 *
 */
package oauth2
import (
	""context""
	""fmt""
	""strings""
	""time""
	""github.com/ory/fosite""
	""github.com/ory/fosite/storage""
	""github.com/pkg/errors""
)
type RefreshTokenGrantHandler struct {
	AccessTokenStrategy    AccessTokenStrategy
	RefreshTokenStrategy   RefreshTokenStrategy
	TokenRevocationStorage TokenRevocationStorage
	// AccessTokenLifespan defines the lifetime of an access token.
	AccessTokenLifespan time.Duration
	// RefreshTokenLifespan defines the lifetime of a refresh token.
	RefreshTokenLifespan time.Duration
	ScopeStrategy            fosite.ScopeStrategy
	AudienceMatchingStrategy fosite.AudienceMatchingStrategy
	RefreshTokenScopes       []string
}
// HandleTokenEndpointRequest implements https://tools.ietf.org/html/rfc6749
func (c *RefreshTokenGrantHandler) HandleTokenEndpointRequest(ctx context.Context, request fosite.AccessRequester) error {
	// grant_type REQUIRED.
	// Value MUST be set to ""refresh_token"".
	if !request.GetGrantTypes().ExactOne(""refresh_token"") {
		return errors.WithStack(fosite.ErrUnknownRequest)
	}
	if !request.GetClient().GetGrantTypes().Has(""refresh_token"") {
		return errors.WithStack(fosite.ErrInvalidGrant.WithHint(""The OAuth 2.0 Client is not allowed to use authorization grant \""refresh_token\"".""))
	}
	refresh := request.GetRequestForm().Get(""refresh_token"")
	signature := c.RefreshTokenStrategy.RefreshTokenSignature(refresh)
	originalRequest, err := c.TokenRevocationStorage.GetRefreshTokenSession(ctx, signature, request.GetSession())
	if errors.Cause(err) == fosite.ErrNotFound {
		return errors.WithStack(fosite.ErrInvalidRequest.WithDebug(err.Error()))
	} else if err != nil {
		return errors.WithStack(fosite.ErrServerError.WithDebug(err.Error()))
	} else if err := c.RefreshTokenStrategy.ValidateRefreshToken(ctx, originalRequest, refresh); err != nil {
		// The authorization server MUST ... validate the refresh token.
		// This needs to happen after store retrieval for the session to be hydrated properly
		return errors.WithStack(fosite.ErrInvalidRequest.WithDebug(err.Error()))
	}
	if !(len(c.RefreshTokenScopes) == 0 || originalRequest.GetGrantedScopes().HasOneOf(c.RefreshTokenScopes...)) {
		scopeNames := strings.Join(c.RefreshTokenScopes, "" or "")
		hint := fmt.Sprintf(""The OAuth 2.0 Client was not granted scope %s and may thus not perform the \""refresh_token\"" authorization grant."", scopeNames)
		return errors.WithStack(fosite.ErrScopeNotGranted.WithHint(hint))
	}
	// The authorization server MUST ... and ensure that the refresh token was issued to the authenticated client
	if originalRequest.GetClient().GetID() != request.GetClient().GetID() {
		return errors.WithStack(fosite.ErrInvalidRequest.WithHint(""The OAuth 2.0 Client ID from this request does not match the ID during the initial token issuance.""))
	}
	request.SetSession(originalRequest.GetSession().Clone())
	request.SetRequestedScopes(originalRequest.GetRequestedScopes())
	request.SetRequestedAudience(originalRequest.GetRequestedAudience())
	for _, scope := range originalRequest.GetGrantedScopes() {
		if !c.ScopeStrategy(request.GetClient().GetScopes(), scope) {
			return errors.WithStack(fosite.ErrInvalidScope.WithHintf(""The OAuth 2.0 Client is not allowed to request scope \""%s\""."", scope))
		}
		request.GrantScope(scope)
	}
	if err := c.AudienceMatchingStrategy(request.GetClient().GetAudience(), originalRequest.GetGrantedAudience()); err != nil {
		return err
	}
	for _, audience := range originalRequest.GetGrantedAudience() {
		request.GrantAudience(audience)
	}
	request.GetSession().SetExpiresAt(fosite.AccessToken, time.Now().UTC().Add(c.AccessTokenLifespan).Round(time.Second))
	if c.RefreshTokenLifespan > -1 {
		request.GetSession().SetExpiresAt(fosite.RefreshToken, time.Now().UTC().Add(c.RefreshTokenLifespan).Round(time.Second))
	}
	return nil
}
// PopulateTokenEndpointResponse implements https://tools.ietf.org/html/rfc6749
func (c *RefreshTokenGrantHandler) PopulateTokenEndpointResponse(ctx context.Context, requester fosite.AccessRequester, responder fosite.AccessResponder) error {
	if !requester.GetGrantTypes().ExactOne(""refresh_token"") {
		return errors.WithStack(fosite.ErrUnknownRequest)
	}
	accessToken, accessSignature, err := c.AccessTokenStrategy.GenerateAccessToken(ctx, requester)
	if err != nil {
		return errors.WithStack(fosite.ErrServerError.WithDebug(err.Error()))
	}
	refreshToken, refreshSignature, err := c.RefreshTokenStrategy.GenerateRefreshToken(ctx, requester)
	if err != nil {
		return errors.WithStack(fosite.ErrServerError.WithDebug(err.Error()))
	}
	signature := c.RefreshTokenStrategy.RefreshTokenSignature(requester.GetRequestForm().Get(""refresh_token""))
	ctx, err = storage.MaybeBeginTx(ctx, c.TokenRevocationStorage)
	if err != nil {
		return errors.WithStack(fosite.ErrServerError.WithDebug(err.Error()))
	}
	ts, err := c.TokenRevocationStorage.GetRefreshTokenSession(ctx, signature, nil)
	if err != nil {
		return handleRefreshTokenEndpointResponseStorageError(ctx, true, c.TokenRevocationStorage, err)
	} else if err := c.TokenRevocationStorage.RevokeAccessToken(ctx, ts.GetID()); err != nil {
		return handleRefreshTokenEndpointResponseStorageError(ctx, true, c.TokenRevocationStorage, err)
	} else if err := c.TokenRevocationStorage.RevokeRefreshToken(ctx, ts.GetID()); err != nil {
		return handleRefreshTokenEndpointResponseStorageError(ctx, true, c.TokenRevocationStorage, err)
	}
	storeReq := requester.Sanitize([]string{})
	storeReq.SetID(ts.GetID())
	if err := c.TokenRevocationStorage.CreateAccessTokenSession(ctx, accessSignature, storeReq); err != nil {
		return handleRefreshTokenEndpointResponseStorageError(ctx, true, c.TokenRevocationStorage, err)
	}
	if err := c.TokenRevocationStorage.CreateRefreshTokenSession(ctx, refreshSignature, storeReq); err != nil {
		return handleRefreshTokenEndpointResponseStorageError(ctx, true, c.TokenRevocationStorage, err)
	}
	responder.SetAccessToken(accessToken)
	responder.SetTokenType(""bearer"")
	responder.SetExpiresIn(getExpiresIn(requester, fosite.AccessToken, c.AccessTokenLifespan, time.Now().UTC()))
	responder.SetScopes(requester.GetGrantedScopes())
	responder.SetExtra(""refresh_token"", refreshToken)
	if err := storage.MaybeCommitTx(ctx, c.TokenRevocationStorage); err != nil {
		return handleRefreshTokenEndpointResponseStorageError(ctx, false, c.TokenRevocationStorage, err)
	}
	return nil
}
func handleRefreshTokenEndpointResponseStorageError(ctx context.Context, rollback bool, store TokenRevocationStorage, storageErr error) (err error) {
	defer func() {
		if rollback {
			if rbErr := storage.MaybeRollbackTx(ctx, store); rbErr != nil {
				err = errors.WithStack(fosite.ErrServerError.WithDebug(rbErr.Error()))
			}
		}
	}()
	if errors.Cause(storageErr) == fosite.ErrSerializationFailure {
		return errors.WithStack(fosite.ErrInvalidRequest.
			WithDebugf(storageErr.Error()).
			WithHint(""Failed to refresh token because of multiple concurrent requests using the same token which is not allowed.""))
	}
	if errors.Cause(storageErr) == fosite.ErrNotFound {
		return errors.WithStack(fosite.ErrInvalidRequest.
			WithDebugf(storageErr.Error()).
			WithHint(""Failed to refresh token because of multiple concurrent requests using the same token which is not allowed.""))
	}
	return errors.WithStack(fosite.ErrServerError.WithDebug(storageErr.Error()))
}
",CWE-345,194.0,1
"// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ory/fosite (interfaces: AccessResponder)
// Package internal is a generated GoMock package.
package internal
import (
	reflect ""reflect""
	time ""time""
	gomock ""github.com/golang/mock/gomock""
	fosite ""github.com/ory/fosite""
)
// MockAccessResponder is a mock of AccessResponder interface
type MockAccessResponder struct {
	ctrl     *gomock.Controller
	recorder *MockAccessResponderMockRecorder
}
// MockAccessResponderMockRecorder is the mock recorder for MockAccessResponder
type MockAccessResponderMockRecorder struct {
	mock *MockAccessResponder
}
// NewMockAccessResponder creates a new mock instance
func NewMockAccessResponder(ctrl *gomock.Controller) *MockAccessResponder {
	mock := &MockAccessResponder{ctrl: ctrl}
	mock.recorder = &MockAccessResponderMockRecorder{mock}
	return mock
}
// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockAccessResponder) EXPECT() *MockAccessResponderMockRecorder {
	return m.recorder
}
// GetAccessToken mocks base method
func (m *MockAccessResponder) GetAccessToken() string {
	ret := m.ctrl.Call(m, ""GetAccessToken"")
	ret0, _ := ret[0].(string)
	return ret0
}
// GetAccessToken indicates an expected call of GetAccessToken
func (mr *MockAccessResponderMockRecorder) GetAccessToken() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetAccessToken"", reflect.TypeOf((*MockAccessResponder)(nil).GetAccessToken))
}
// GetExtra mocks base method
func (m *MockAccessResponder) GetExtra(arg0 string) interface{} {
	ret := m.ctrl.Call(m, ""GetExtra"", arg0)
	ret0, _ := ret[0].(interface{})
	return ret0
}
// GetExtra indicates an expected call of GetExtra
func (mr *MockAccessResponderMockRecorder) GetExtra(arg0 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetExtra"", reflect.TypeOf((*MockAccessResponder)(nil).GetExtra), arg0)
}
// GetTokenType mocks base method
func (m *MockAccessResponder) GetTokenType() string {
	ret := m.ctrl.Call(m, ""GetTokenType"")
	ret0, _ := ret[0].(string)
	return ret0
}
// GetTokenType indicates an expected call of GetTokenType
func (mr *MockAccessResponderMockRecorder) GetTokenType() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetTokenType"", reflect.TypeOf((*MockAccessResponder)(nil).GetTokenType))
}
// SetAccessToken mocks base method
func (m *MockAccessResponder) SetAccessToken(arg0 string) {
	m.ctrl.Call(m, ""SetAccessToken"", arg0)
}
// SetAccessToken indicates an expected call of SetAccessToken
func (mr *MockAccessResponderMockRecorder) SetAccessToken(arg0 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""SetAccessToken"", reflect.TypeOf((*MockAccessResponder)(nil).SetAccessToken), arg0)
}
// SetExpiresIn mocks base method
func (m *MockAccessResponder) SetExpiresIn(arg0 time.Duration) {
	m.ctrl.Call(m, ""SetExpiresIn"", arg0)
}
// SetExpiresIn indicates an expected call of SetExpiresIn
func (mr *MockAccessResponderMockRecorder) SetExpiresIn(arg0 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""SetExpiresIn"", reflect.TypeOf((*MockAccessResponder)(nil).SetExpiresIn), arg0)
}
// SetExtra mocks base method
func (m *MockAccessResponder) SetExtra(arg0 string, arg1 interface{}) {
	m.ctrl.Call(m, ""SetExtra"", arg0, arg1)
}
// SetExtra indicates an expected call of SetExtra
func (mr *MockAccessResponderMockRecorder) SetExtra(arg0, arg1 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""SetExtra"", reflect.TypeOf((*MockAccessResponder)(nil).SetExtra), arg0, arg1)
}
// SetScopes mocks base method
func (m *MockAccessResponder) SetScopes(arg0 fosite.Arguments) {
	m.ctrl.Call(m, ""SetScopes"", arg0)
}
// SetScopes indicates an expected call of SetScopes
func (mr *MockAccessResponderMockRecorder) SetScopes(arg0 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""SetScopes"", reflect.TypeOf((*MockAccessResponder)(nil).SetScopes), arg0)
}
// SetTokenType mocks base method
func (m *MockAccessResponder) SetTokenType(arg0 string) {
	m.ctrl.Call(m, ""SetTokenType"", arg0)
}
// SetTokenType indicates an expected call of SetTokenType
func (mr *MockAccessResponderMockRecorder) SetTokenType(arg0 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""SetTokenType"", reflect.TypeOf((*MockAccessResponder)(nil).SetTokenType), arg0)
}
// ToMap mocks base method
func (m *MockAccessResponder) ToMap() map[string]interface{} {
	ret := m.ctrl.Call(m, ""ToMap"")
	ret0, _ := ret[0].(map[string]interface{})
	return ret0
}
// ToMap indicates an expected call of ToMap
func (mr *MockAccessResponderMockRecorder) ToMap() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""ToMap"", reflect.TypeOf((*MockAccessResponder)(nil).ToMap))
}
",CWE-345,136.0,1
"// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ory/fosite/handler/oauth2 (interfaces: AccessTokenStorage)
// Package internal is a generated GoMock package.
package internal
import (
	context ""context""
	reflect ""reflect""
	gomock ""github.com/golang/mock/gomock""
	fosite ""github.com/ory/fosite""
)
// MockAccessTokenStorage is a mock of AccessTokenStorage interface
type MockAccessTokenStorage struct {
	ctrl     *gomock.Controller
	recorder *MockAccessTokenStorageMockRecorder
}
// MockAccessTokenStorageMockRecorder is the mock recorder for MockAccessTokenStorage
type MockAccessTokenStorageMockRecorder struct {
	mock *MockAccessTokenStorage
}
// NewMockAccessTokenStorage creates a new mock instance
func NewMockAccessTokenStorage(ctrl *gomock.Controller) *MockAccessTokenStorage {
	mock := &MockAccessTokenStorage{ctrl: ctrl}
	mock.recorder = &MockAccessTokenStorageMockRecorder{mock}
	return mock
}
// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockAccessTokenStorage) EXPECT() *MockAccessTokenStorageMockRecorder {
	return m.recorder
}
// CreateAccessTokenSession mocks base method
func (m *MockAccessTokenStorage) CreateAccessTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {
	ret := m.ctrl.Call(m, ""CreateAccessTokenSession"", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}
// CreateAccessTokenSession indicates an expected call of CreateAccessTokenSession
func (mr *MockAccessTokenStorageMockRecorder) CreateAccessTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""CreateAccessTokenSession"", reflect.TypeOf((*MockAccessTokenStorage)(nil).CreateAccessTokenSession), arg0, arg1, arg2)
}
// DeleteAccessTokenSession mocks base method
func (m *MockAccessTokenStorage) DeleteAccessTokenSession(arg0 context.Context, arg1 string) error {
	ret := m.ctrl.Call(m, ""DeleteAccessTokenSession"", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}
// DeleteAccessTokenSession indicates an expected call of DeleteAccessTokenSession
func (mr *MockAccessTokenStorageMockRecorder) DeleteAccessTokenSession(arg0, arg1 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""DeleteAccessTokenSession"", reflect.TypeOf((*MockAccessTokenStorage)(nil).DeleteAccessTokenSession), arg0, arg1)
}
// GetAccessTokenSession mocks base method
func (m *MockAccessTokenStorage) GetAccessTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Session) (fosite.Requester, error) {
	ret := m.ctrl.Call(m, ""GetAccessTokenSession"", arg0, arg1, arg2)
	ret0, _ := ret[0].(fosite.Requester)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}
// GetAccessTokenSession indicates an expected call of GetAccessTokenSession
func (mr *MockAccessTokenStorageMockRecorder) GetAccessTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetAccessTokenSession"", reflect.TypeOf((*MockAccessTokenStorage)(nil).GetAccessTokenSession), arg0, arg1, arg2)
}
",CWE-345,75.0,1
"// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ory/fosite/handler/oauth2 (interfaces: AccessTokenStrategy)
// Package internal is a generated GoMock package.
package internal
import (
	context ""context""
	reflect ""reflect""
	gomock ""github.com/golang/mock/gomock""
	fosite ""github.com/ory/fosite""
)
// MockAccessTokenStrategy is a mock of AccessTokenStrategy interface
type MockAccessTokenStrategy struct {
	ctrl     *gomock.Controller
	recorder *MockAccessTokenStrategyMockRecorder
}
// MockAccessTokenStrategyMockRecorder is the mock recorder for MockAccessTokenStrategy
type MockAccessTokenStrategyMockRecorder struct {
	mock *MockAccessTokenStrategy
}
// NewMockAccessTokenStrategy creates a new mock instance
func NewMockAccessTokenStrategy(ctrl *gomock.Controller) *MockAccessTokenStrategy {
	mock := &MockAccessTokenStrategy{ctrl: ctrl}
	mock.recorder = &MockAccessTokenStrategyMockRecorder{mock}
	return mock
}
// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockAccessTokenStrategy) EXPECT() *MockAccessTokenStrategyMockRecorder {
	return m.recorder
}
// AccessTokenSignature mocks base method
func (m *MockAccessTokenStrategy) AccessTokenSignature(arg0 string) string {
	ret := m.ctrl.Call(m, ""AccessTokenSignature"", arg0)
	ret0, _ := ret[0].(string)
	return ret0
}
// AccessTokenSignature indicates an expected call of AccessTokenSignature
func (mr *MockAccessTokenStrategyMockRecorder) AccessTokenSignature(arg0 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""AccessTokenSignature"", reflect.TypeOf((*MockAccessTokenStrategy)(nil).AccessTokenSignature), arg0)
}
// GenerateAccessToken mocks base method
func (m *MockAccessTokenStrategy) GenerateAccessToken(arg0 context.Context, arg1 fosite.Requester) (string, string, error) {
	ret := m.ctrl.Call(m, ""GenerateAccessToken"", arg0, arg1)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(string)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}
// GenerateAccessToken indicates an expected call of GenerateAccessToken
func (mr *MockAccessTokenStrategyMockRecorder) GenerateAccessToken(arg0, arg1 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GenerateAccessToken"", reflect.TypeOf((*MockAccessTokenStrategy)(nil).GenerateAccessToken), arg0, arg1)
}
// ValidateAccessToken mocks base method
func (m *MockAccessTokenStrategy) ValidateAccessToken(arg0 context.Context, arg1 fosite.Requester, arg2 string) error {
	ret := m.ctrl.Call(m, ""ValidateAccessToken"", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}
// ValidateAccessToken indicates an expected call of ValidateAccessToken
func (mr *MockAccessTokenStrategyMockRecorder) ValidateAccessToken(arg0, arg1, arg2 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""ValidateAccessToken"", reflect.TypeOf((*MockAccessTokenStrategy)(nil).ValidateAccessToken), arg0, arg1, arg2)
}
",CWE-345,76.0,1
"// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ory/fosite/handler/oauth2 (interfaces: AuthorizeCodeStorage)
// Package internal is a generated GoMock package.
package internal
import (
	context ""context""
	reflect ""reflect""
	gomock ""github.com/golang/mock/gomock""
	fosite ""github.com/ory/fosite""
)
// MockAuthorizeCodeStorage is a mock of AuthorizeCodeStorage interface
type MockAuthorizeCodeStorage struct {
	ctrl     *gomock.Controller
	recorder *MockAuthorizeCodeStorageMockRecorder
}
// MockAuthorizeCodeStorageMockRecorder is the mock recorder for MockAuthorizeCodeStorage
type MockAuthorizeCodeStorageMockRecorder struct {
	mock *MockAuthorizeCodeStorage
}
// NewMockAuthorizeCodeStorage creates a new mock instance
func NewMockAuthorizeCodeStorage(ctrl *gomock.Controller) *MockAuthorizeCodeStorage {
	mock := &MockAuthorizeCodeStorage{ctrl: ctrl}
	mock.recorder = &MockAuthorizeCodeStorageMockRecorder{mock}
	return mock
}
// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockAuthorizeCodeStorage) EXPECT() *MockAuthorizeCodeStorageMockRecorder {
	return m.recorder
}
// CreateAuthorizeCodeSession mocks base method
func (m *MockAuthorizeCodeStorage) CreateAuthorizeCodeSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {
	ret := m.ctrl.Call(m, ""CreateAuthorizeCodeSession"", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}
// CreateAuthorizeCodeSession indicates an expected call of CreateAuthorizeCodeSession
func (mr *MockAuthorizeCodeStorageMockRecorder) CreateAuthorizeCodeSession(arg0, arg1, arg2 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""CreateAuthorizeCodeSession"", reflect.TypeOf((*MockAuthorizeCodeStorage)(nil).CreateAuthorizeCodeSession), arg0, arg1, arg2)
}
// GetAuthorizeCodeSession mocks base method
func (m *MockAuthorizeCodeStorage) GetAuthorizeCodeSession(arg0 context.Context, arg1 string, arg2 fosite.Session) (fosite.Requester, error) {
	ret := m.ctrl.Call(m, ""GetAuthorizeCodeSession"", arg0, arg1, arg2)
	ret0, _ := ret[0].(fosite.Requester)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}
// GetAuthorizeCodeSession indicates an expected call of GetAuthorizeCodeSession
func (mr *MockAuthorizeCodeStorageMockRecorder) GetAuthorizeCodeSession(arg0, arg1, arg2 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetAuthorizeCodeSession"", reflect.TypeOf((*MockAuthorizeCodeStorage)(nil).GetAuthorizeCodeSession), arg0, arg1, arg2)
}
// InvalidateAuthorizeCodeSession mocks base method
func (m *MockAuthorizeCodeStorage) InvalidateAuthorizeCodeSession(arg0 context.Context, arg1 string) error {
	ret := m.ctrl.Call(m, ""InvalidateAuthorizeCodeSession"", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}
// InvalidateAuthorizeCodeSession indicates an expected call of InvalidateAuthorizeCodeSession
func (mr *MockAuthorizeCodeStorageMockRecorder) InvalidateAuthorizeCodeSession(arg0, arg1 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""InvalidateAuthorizeCodeSession"", reflect.TypeOf((*MockAuthorizeCodeStorage)(nil).InvalidateAuthorizeCodeSession), arg0, arg1)
}
",CWE-345,75.0,1
"// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ory/fosite/handler/oauth2 (interfaces: AuthorizeCodeStrategy)
// Package internal is a generated GoMock package.
package internal
import (
	context ""context""
	reflect ""reflect""
	gomock ""github.com/golang/mock/gomock""
	fosite ""github.com/ory/fosite""
)
// MockAuthorizeCodeStrategy is a mock of AuthorizeCodeStrategy interface
type MockAuthorizeCodeStrategy struct {
	ctrl     *gomock.Controller
	recorder *MockAuthorizeCodeStrategyMockRecorder
}
// MockAuthorizeCodeStrategyMockRecorder is the mock recorder for MockAuthorizeCodeStrategy
type MockAuthorizeCodeStrategyMockRecorder struct {
	mock *MockAuthorizeCodeStrategy
}
// NewMockAuthorizeCodeStrategy creates a new mock instance
func NewMockAuthorizeCodeStrategy(ctrl *gomock.Controller) *MockAuthorizeCodeStrategy {
	mock := &MockAuthorizeCodeStrategy{ctrl: ctrl}
	mock.recorder = &MockAuthorizeCodeStrategyMockRecorder{mock}
	return mock
}
// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockAuthorizeCodeStrategy) EXPECT() *MockAuthorizeCodeStrategyMockRecorder {
	return m.recorder
}
// AuthorizeCodeSignature mocks base method
func (m *MockAuthorizeCodeStrategy) AuthorizeCodeSignature(arg0 string) string {
	ret := m.ctrl.Call(m, ""AuthorizeCodeSignature"", arg0)
	ret0, _ := ret[0].(string)
	return ret0
}
// AuthorizeCodeSignature indicates an expected call of AuthorizeCodeSignature
func (mr *MockAuthorizeCodeStrategyMockRecorder) AuthorizeCodeSignature(arg0 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""AuthorizeCodeSignature"", reflect.TypeOf((*MockAuthorizeCodeStrategy)(nil).AuthorizeCodeSignature), arg0)
}
// GenerateAuthorizeCode mocks base method
func (m *MockAuthorizeCodeStrategy) GenerateAuthorizeCode(arg0 context.Context, arg1 fosite.Requester) (string, string, error) {
	ret := m.ctrl.Call(m, ""GenerateAuthorizeCode"", arg0, arg1)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(string)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}
// GenerateAuthorizeCode indicates an expected call of GenerateAuthorizeCode
func (mr *MockAuthorizeCodeStrategyMockRecorder) GenerateAuthorizeCode(arg0, arg1 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GenerateAuthorizeCode"", reflect.TypeOf((*MockAuthorizeCodeStrategy)(nil).GenerateAuthorizeCode), arg0, arg1)
}
// ValidateAuthorizeCode mocks base method
func (m *MockAuthorizeCodeStrategy) ValidateAuthorizeCode(arg0 context.Context, arg1 fosite.Requester, arg2 string) error {
	ret := m.ctrl.Call(m, ""ValidateAuthorizeCode"", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}
// ValidateAuthorizeCode indicates an expected call of ValidateAuthorizeCode
func (mr *MockAuthorizeCodeStrategyMockRecorder) ValidateAuthorizeCode(arg0, arg1, arg2 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""ValidateAuthorizeCode"", reflect.TypeOf((*MockAuthorizeCodeStrategy)(nil).ValidateAuthorizeCode), arg0, arg1, arg2)
}
",CWE-345,76.0,1
"// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ory/fosite (interfaces: AuthorizeEndpointHandler)
// Package internal is a generated GoMock package.
package internal
import (
	context ""context""
	reflect ""reflect""
	gomock ""github.com/golang/mock/gomock""
	fosite ""github.com/ory/fosite""
)
// MockAuthorizeEndpointHandler is a mock of AuthorizeEndpointHandler interface
type MockAuthorizeEndpointHandler struct {
	ctrl     *gomock.Controller
	recorder *MockAuthorizeEndpointHandlerMockRecorder
}
// MockAuthorizeEndpointHandlerMockRecorder is the mock recorder for MockAuthorizeEndpointHandler
type MockAuthorizeEndpointHandlerMockRecorder struct {
	mock *MockAuthorizeEndpointHandler
}
// NewMockAuthorizeEndpointHandler creates a new mock instance
func NewMockAuthorizeEndpointHandler(ctrl *gomock.Controller) *MockAuthorizeEndpointHandler {
	mock := &MockAuthorizeEndpointHandler{ctrl: ctrl}
	mock.recorder = &MockAuthorizeEndpointHandlerMockRecorder{mock}
	return mock
}
// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockAuthorizeEndpointHandler) EXPECT() *MockAuthorizeEndpointHandlerMockRecorder {
	return m.recorder
}
// HandleAuthorizeEndpointRequest mocks base method
func (m *MockAuthorizeEndpointHandler) HandleAuthorizeEndpointRequest(arg0 context.Context, arg1 fosite.AuthorizeRequester, arg2 fosite.AuthorizeResponder) error {
	ret := m.ctrl.Call(m, ""HandleAuthorizeEndpointRequest"", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}
// HandleAuthorizeEndpointRequest indicates an expected call of HandleAuthorizeEndpointRequest
func (mr *MockAuthorizeEndpointHandlerMockRecorder) HandleAuthorizeEndpointRequest(arg0, arg1, arg2 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""HandleAuthorizeEndpointRequest"", reflect.TypeOf((*MockAuthorizeEndpointHandler)(nil).HandleAuthorizeEndpointRequest), arg0, arg1, arg2)
}
",CWE-345,50.0,1
"// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ory/fosite (interfaces: AuthorizeResponder)
// Package internal is a generated GoMock package.
package internal
import (
	http ""net/http""
	url ""net/url""
	reflect ""reflect""
	gomock ""github.com/golang/mock/gomock""
)
// MockAuthorizeResponder is a mock of AuthorizeResponder interface
type MockAuthorizeResponder struct {
	ctrl     *gomock.Controller
	recorder *MockAuthorizeResponderMockRecorder
}
// MockAuthorizeResponderMockRecorder is the mock recorder for MockAuthorizeResponder
type MockAuthorizeResponderMockRecorder struct {
	mock *MockAuthorizeResponder
}
// NewMockAuthorizeResponder creates a new mock instance
func NewMockAuthorizeResponder(ctrl *gomock.Controller) *MockAuthorizeResponder {
	mock := &MockAuthorizeResponder{ctrl: ctrl}
	mock.recorder = &MockAuthorizeResponderMockRecorder{mock}
	return mock
}
// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockAuthorizeResponder) EXPECT() *MockAuthorizeResponderMockRecorder {
	return m.recorder
}
// AddFragment mocks base method
func (m *MockAuthorizeResponder) AddFragment(arg0, arg1 string) {
	m.ctrl.Call(m, ""AddFragment"", arg0, arg1)
}
// AddFragment indicates an expected call of AddFragment
func (mr *MockAuthorizeResponderMockRecorder) AddFragment(arg0, arg1 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""AddFragment"", reflect.TypeOf((*MockAuthorizeResponder)(nil).AddFragment), arg0, arg1)
}
// AddHeader mocks base method
func (m *MockAuthorizeResponder) AddHeader(arg0, arg1 string) {
	m.ctrl.Call(m, ""AddHeader"", arg0, arg1)
}
// AddHeader indicates an expected call of AddHeader
func (mr *MockAuthorizeResponderMockRecorder) AddHeader(arg0, arg1 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""AddHeader"", reflect.TypeOf((*MockAuthorizeResponder)(nil).AddHeader), arg0, arg1)
}
// AddQuery mocks base method
func (m *MockAuthorizeResponder) AddQuery(arg0, arg1 string) {
	m.ctrl.Call(m, ""AddQuery"", arg0, arg1)
}
// AddQuery indicates an expected call of AddQuery
func (mr *MockAuthorizeResponderMockRecorder) AddQuery(arg0, arg1 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""AddQuery"", reflect.TypeOf((*MockAuthorizeResponder)(nil).AddQuery), arg0, arg1)
}
// GetCode mocks base method
func (m *MockAuthorizeResponder) GetCode() string {
	ret := m.ctrl.Call(m, ""GetCode"")
	ret0, _ := ret[0].(string)
	return ret0
}
// GetCode indicates an expected call of GetCode
func (mr *MockAuthorizeResponderMockRecorder) GetCode() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetCode"", reflect.TypeOf((*MockAuthorizeResponder)(nil).GetCode))
}
// GetFragment mocks base method
func (m *MockAuthorizeResponder) GetFragment() url.Values {
	ret := m.ctrl.Call(m, ""GetFragment"")
	ret0, _ := ret[0].(url.Values)
	return ret0
}
// GetFragment indicates an expected call of GetFragment
func (mr *MockAuthorizeResponderMockRecorder) GetFragment() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetFragment"", reflect.TypeOf((*MockAuthorizeResponder)(nil).GetFragment))
}
// GetHeader mocks base method
func (m *MockAuthorizeResponder) GetHeader() http.Header {
	ret := m.ctrl.Call(m, ""GetHeader"")
	ret0, _ := ret[0].(http.Header)
	return ret0
}
// GetHeader indicates an expected call of GetHeader
func (mr *MockAuthorizeResponderMockRecorder) GetHeader() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetHeader"", reflect.TypeOf((*MockAuthorizeResponder)(nil).GetHeader))
}
// GetQuery mocks base method
func (m *MockAuthorizeResponder) GetQuery() url.Values {
	ret := m.ctrl.Call(m, ""GetQuery"")
	ret0, _ := ret[0].(url.Values)
	return ret0
}
// GetQuery indicates an expected call of GetQuery
func (mr *MockAuthorizeResponderMockRecorder) GetQuery() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetQuery"", reflect.TypeOf((*MockAuthorizeResponder)(nil).GetQuery))
}
",CWE-345,115.0,1
"// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ory/fosite (interfaces: Client)
// Package internal is a generated GoMock package.
package internal
import (
	reflect ""reflect""
	gomock ""github.com/golang/mock/gomock""
	fosite ""github.com/ory/fosite""
)
// MockClient is a mock of Client interface
type MockClient struct {
	ctrl     *gomock.Controller
	recorder *MockClientMockRecorder
}
// MockClientMockRecorder is the mock recorder for MockClient
type MockClientMockRecorder struct {
	mock *MockClient
}
// NewMockClient creates a new mock instance
func NewMockClient(ctrl *gomock.Controller) *MockClient {
	mock := &MockClient{ctrl: ctrl}
	mock.recorder = &MockClientMockRecorder{mock}
	return mock
}
// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockClient) EXPECT() *MockClientMockRecorder {
	return m.recorder
}
// GetAudience mocks base method
func (m *MockClient) GetAudience() fosite.Arguments {
	ret := m.ctrl.Call(m, ""GetAudience"")
	ret0, _ := ret[0].(fosite.Arguments)
	return ret0
}
// GetAudience indicates an expected call of GetAudience
func (mr *MockClientMockRecorder) GetAudience() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetAudience"", reflect.TypeOf((*MockClient)(nil).GetAudience))
}
// GetGrantTypes mocks base method
func (m *MockClient) GetGrantTypes() fosite.Arguments {
	ret := m.ctrl.Call(m, ""GetGrantTypes"")
	ret0, _ := ret[0].(fosite.Arguments)
	return ret0
}
// GetGrantTypes indicates an expected call of GetGrantTypes
func (mr *MockClientMockRecorder) GetGrantTypes() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetGrantTypes"", reflect.TypeOf((*MockClient)(nil).GetGrantTypes))
}
// GetHashedSecret mocks base method
func (m *MockClient) GetHashedSecret() []byte {
	ret := m.ctrl.Call(m, ""GetHashedSecret"")
	ret0, _ := ret[0].([]byte)
	return ret0
}
// GetHashedSecret indicates an expected call of GetHashedSecret
func (mr *MockClientMockRecorder) GetHashedSecret() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetHashedSecret"", reflect.TypeOf((*MockClient)(nil).GetHashedSecret))
}
// GetID mocks base method
func (m *MockClient) GetID() string {
	ret := m.ctrl.Call(m, ""GetID"")
	ret0, _ := ret[0].(string)
	return ret0
}
// GetID indicates an expected call of GetID
func (mr *MockClientMockRecorder) GetID() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetID"", reflect.TypeOf((*MockClient)(nil).GetID))
}
// GetRedirectURIs mocks base method
func (m *MockClient) GetRedirectURIs() []string {
	ret := m.ctrl.Call(m, ""GetRedirectURIs"")
	ret0, _ := ret[0].([]string)
	return ret0
}
// GetRedirectURIs indicates an expected call of GetRedirectURIs
func (mr *MockClientMockRecorder) GetRedirectURIs() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetRedirectURIs"", reflect.TypeOf((*MockClient)(nil).GetRedirectURIs))
}
// GetResponseTypes mocks base method
func (m *MockClient) GetResponseTypes() fosite.Arguments {
	ret := m.ctrl.Call(m, ""GetResponseTypes"")
	ret0, _ := ret[0].(fosite.Arguments)
	return ret0
}
// GetResponseTypes indicates an expected call of GetResponseTypes
func (mr *MockClientMockRecorder) GetResponseTypes() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetResponseTypes"", reflect.TypeOf((*MockClient)(nil).GetResponseTypes))
}
// GetScopes mocks base method
func (m *MockClient) GetScopes() fosite.Arguments {
	ret := m.ctrl.Call(m, ""GetScopes"")
	ret0, _ := ret[0].(fosite.Arguments)
	return ret0
}
// GetScopes indicates an expected call of GetScopes
func (mr *MockClientMockRecorder) GetScopes() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetScopes"", reflect.TypeOf((*MockClient)(nil).GetScopes))
}
// IsPublic mocks base method
func (m *MockClient) IsPublic() bool {
	ret := m.ctrl.Call(m, ""IsPublic"")
	ret0, _ := ret[0].(bool)
	return ret0
}
// IsPublic indicates an expected call of IsPublic
func (mr *MockClientMockRecorder) IsPublic() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""IsPublic"", reflect.TypeOf((*MockClient)(nil).IsPublic))
}
",CWE-345,133.0,1
"// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ory/fosite (interfaces: Hasher)
// Package internal is a generated GoMock package.
package internal
import (
	context ""context""
	reflect ""reflect""
	gomock ""github.com/golang/mock/gomock""
)
// MockHasher is a mock of Hasher interface
type MockHasher struct {
	ctrl     *gomock.Controller
	recorder *MockHasherMockRecorder
}
// MockHasherMockRecorder is the mock recorder for MockHasher
type MockHasherMockRecorder struct {
	mock *MockHasher
}
// NewMockHasher creates a new mock instance
func NewMockHasher(ctrl *gomock.Controller) *MockHasher {
	mock := &MockHasher{ctrl: ctrl}
	mock.recorder = &MockHasherMockRecorder{mock}
	return mock
}
// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockHasher) EXPECT() *MockHasherMockRecorder {
	return m.recorder
}
// Compare mocks base method
func (m *MockHasher) Compare(arg0 context.Context, arg1, arg2 []byte) error {
	ret := m.ctrl.Call(m, ""Compare"", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}
// Compare indicates an expected call of Compare
func (mr *MockHasherMockRecorder) Compare(arg0, arg1, arg2 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""Compare"", reflect.TypeOf((*MockHasher)(nil).Compare), arg0, arg1, arg2)
}
// Hash mocks base method
func (m *MockHasher) Hash(arg0 context.Context, arg1 []byte) ([]byte, error) {
	ret := m.ctrl.Call(m, ""Hash"", arg0, arg1)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}
// Hash indicates an expected call of Hash
func (mr *MockHasherMockRecorder) Hash(arg0, arg1 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""Hash"", reflect.TypeOf((*MockHasher)(nil).Hash), arg0, arg1)
}
",CWE-345,61.0,1
"// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ory/fosite/handler/openid (interfaces: OpenIDConnectTokenStrategy)
// Package internal is a generated GoMock package.
package internal
import (
	context ""context""
	reflect ""reflect""
	gomock ""github.com/golang/mock/gomock""
	fosite ""github.com/ory/fosite""
)
// MockOpenIDConnectTokenStrategy is a mock of OpenIDConnectTokenStrategy interface
type MockOpenIDConnectTokenStrategy struct {
	ctrl     *gomock.Controller
	recorder *MockOpenIDConnectTokenStrategyMockRecorder
}
// MockOpenIDConnectTokenStrategyMockRecorder is the mock recorder for MockOpenIDConnectTokenStrategy
type MockOpenIDConnectTokenStrategyMockRecorder struct {
	mock *MockOpenIDConnectTokenStrategy
}
// NewMockOpenIDConnectTokenStrategy creates a new mock instance
func NewMockOpenIDConnectTokenStrategy(ctrl *gomock.Controller) *MockOpenIDConnectTokenStrategy {
	mock := &MockOpenIDConnectTokenStrategy{ctrl: ctrl}
	mock.recorder = &MockOpenIDConnectTokenStrategyMockRecorder{mock}
	return mock
}
// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockOpenIDConnectTokenStrategy) EXPECT() *MockOpenIDConnectTokenStrategyMockRecorder {
	return m.recorder
}
// GenerateIDToken mocks base method
func (m *MockOpenIDConnectTokenStrategy) GenerateIDToken(arg0 context.Context, arg1 fosite.Requester) (string, error) {
	ret := m.ctrl.Call(m, ""GenerateIDToken"", arg0, arg1)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}
// GenerateIDToken indicates an expected call of GenerateIDToken
func (mr *MockOpenIDConnectTokenStrategyMockRecorder) GenerateIDToken(arg0, arg1 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GenerateIDToken"", reflect.TypeOf((*MockOpenIDConnectTokenStrategy)(nil).GenerateIDToken), arg0, arg1)
}
",CWE-345,51.0,1
"// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ory/fosite (interfaces: TokenIntrospector)
// Package internal is a generated GoMock package.
package internal
import (
	context ""context""
	reflect ""reflect""
	gomock ""github.com/golang/mock/gomock""
	fosite ""github.com/ory/fosite""
)
// MockTokenIntrospector is a mock of TokenIntrospector interface
type MockTokenIntrospector struct {
	ctrl     *gomock.Controller
	recorder *MockTokenIntrospectorMockRecorder
}
// MockTokenIntrospectorMockRecorder is the mock recorder for MockTokenIntrospector
type MockTokenIntrospectorMockRecorder struct {
	mock *MockTokenIntrospector
}
// NewMockTokenIntrospector creates a new mock instance
func NewMockTokenIntrospector(ctrl *gomock.Controller) *MockTokenIntrospector {
	mock := &MockTokenIntrospector{ctrl: ctrl}
	mock.recorder = &MockTokenIntrospectorMockRecorder{mock}
	return mock
}
// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockTokenIntrospector) EXPECT() *MockTokenIntrospectorMockRecorder {
	return m.recorder
}
// IntrospectToken mocks base method
func (m *MockTokenIntrospector) IntrospectToken(arg0 context.Context, arg1 string, arg2 fosite.TokenType, arg3 fosite.AccessRequester, arg4 []string) (fosite.TokenType, error) {
	ret := m.ctrl.Call(m, ""IntrospectToken"", arg0, arg1, arg2, arg3, arg4)
	ret0, _ := ret[0].(fosite.TokenType)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}
// IntrospectToken indicates an expected call of IntrospectToken
func (mr *MockTokenIntrospectorMockRecorder) IntrospectToken(arg0, arg1, arg2, arg3, arg4 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""IntrospectToken"", reflect.TypeOf((*MockTokenIntrospector)(nil).IntrospectToken), arg0, arg1, arg2, arg3, arg4)
}
",CWE-345,51.0,1
"// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ory/fosite/handler/oauth2 (interfaces: ClientCredentialsGrantStorage)
// Package internal is a generated GoMock package.
package internal
import (
	context ""context""
	reflect ""reflect""
	gomock ""github.com/golang/mock/gomock""
	fosite ""github.com/ory/fosite""
)
// MockClientCredentialsGrantStorage is a mock of ClientCredentialsGrantStorage interface
type MockClientCredentialsGrantStorage struct {
	ctrl     *gomock.Controller
	recorder *MockClientCredentialsGrantStorageMockRecorder
}
// MockClientCredentialsGrantStorageMockRecorder is the mock recorder for MockClientCredentialsGrantStorage
type MockClientCredentialsGrantStorageMockRecorder struct {
	mock *MockClientCredentialsGrantStorage
}
// NewMockClientCredentialsGrantStorage creates a new mock instance
func NewMockClientCredentialsGrantStorage(ctrl *gomock.Controller) *MockClientCredentialsGrantStorage {
	mock := &MockClientCredentialsGrantStorage{ctrl: ctrl}
	mock.recorder = &MockClientCredentialsGrantStorageMockRecorder{mock}
	return mock
}
// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockClientCredentialsGrantStorage) EXPECT() *MockClientCredentialsGrantStorageMockRecorder {
	return m.recorder
}
// CreateAccessTokenSession mocks base method
func (m *MockClientCredentialsGrantStorage) CreateAccessTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {
	ret := m.ctrl.Call(m, ""CreateAccessTokenSession"", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}
// CreateAccessTokenSession indicates an expected call of CreateAccessTokenSession
func (mr *MockClientCredentialsGrantStorageMockRecorder) CreateAccessTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""CreateAccessTokenSession"", reflect.TypeOf((*MockClientCredentialsGrantStorage)(nil).CreateAccessTokenSession), arg0, arg1, arg2)
}
// DeleteAccessTokenSession mocks base method
func (m *MockClientCredentialsGrantStorage) DeleteAccessTokenSession(arg0 context.Context, arg1 string) error {
	ret := m.ctrl.Call(m, ""DeleteAccessTokenSession"", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}
// DeleteAccessTokenSession indicates an expected call of DeleteAccessTokenSession
func (mr *MockClientCredentialsGrantStorageMockRecorder) DeleteAccessTokenSession(arg0, arg1 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""DeleteAccessTokenSession"", reflect.TypeOf((*MockClientCredentialsGrantStorage)(nil).DeleteAccessTokenSession), arg0, arg1)
}
// GetAccessTokenSession mocks base method
func (m *MockClientCredentialsGrantStorage) GetAccessTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Session) (fosite.Requester, error) {
	ret := m.ctrl.Call(m, ""GetAccessTokenSession"", arg0, arg1, arg2)
	ret0, _ := ret[0].(fosite.Requester)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}
// GetAccessTokenSession indicates an expected call of GetAccessTokenSession
func (mr *MockClientCredentialsGrantStorageMockRecorder) GetAccessTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetAccessTokenSession"", reflect.TypeOf((*MockClientCredentialsGrantStorage)(nil).GetAccessTokenSession), arg0, arg1, arg2)
}
",CWE-345,75.0,1
"// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ory/fosite/handler/oauth2 (interfaces: ResourceOwnerPasswordCredentialsGrantStorage)
// Package internal is a generated GoMock package.
package internal
import (
	context ""context""
	reflect ""reflect""
	gomock ""github.com/golang/mock/gomock""
	fosite ""github.com/ory/fosite""
)
// MockResourceOwnerPasswordCredentialsGrantStorage is a mock of ResourceOwnerPasswordCredentialsGrantStorage interface
type MockResourceOwnerPasswordCredentialsGrantStorage struct {
	ctrl     *gomock.Controller
	recorder *MockResourceOwnerPasswordCredentialsGrantStorageMockRecorder
}
// MockResourceOwnerPasswordCredentialsGrantStorageMockRecorder is the mock recorder for MockResourceOwnerPasswordCredentialsGrantStorage
type MockResourceOwnerPasswordCredentialsGrantStorageMockRecorder struct {
	mock *MockResourceOwnerPasswordCredentialsGrantStorage
}
// NewMockResourceOwnerPasswordCredentialsGrantStorage creates a new mock instance
func NewMockResourceOwnerPasswordCredentialsGrantStorage(ctrl *gomock.Controller) *MockResourceOwnerPasswordCredentialsGrantStorage {
	mock := &MockResourceOwnerPasswordCredentialsGrantStorage{ctrl: ctrl}
	mock.recorder = &MockResourceOwnerPasswordCredentialsGrantStorageMockRecorder{mock}
	return mock
}
// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockResourceOwnerPasswordCredentialsGrantStorage) EXPECT() *MockResourceOwnerPasswordCredentialsGrantStorageMockRecorder {
	return m.recorder
}
// Authenticate mocks base method
func (m *MockResourceOwnerPasswordCredentialsGrantStorage) Authenticate(arg0 context.Context, arg1, arg2 string) error {
	ret := m.ctrl.Call(m, ""Authenticate"", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}
// Authenticate indicates an expected call of Authenticate
func (mr *MockResourceOwnerPasswordCredentialsGrantStorageMockRecorder) Authenticate(arg0, arg1, arg2 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""Authenticate"", reflect.TypeOf((*MockResourceOwnerPasswordCredentialsGrantStorage)(nil).Authenticate), arg0, arg1, arg2)
}
// CreateAccessTokenSession mocks base method
func (m *MockResourceOwnerPasswordCredentialsGrantStorage) CreateAccessTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {
	ret := m.ctrl.Call(m, ""CreateAccessTokenSession"", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}
// CreateAccessTokenSession indicates an expected call of CreateAccessTokenSession
func (mr *MockResourceOwnerPasswordCredentialsGrantStorageMockRecorder) CreateAccessTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""CreateAccessTokenSession"", reflect.TypeOf((*MockResourceOwnerPasswordCredentialsGrantStorage)(nil).CreateAccessTokenSession), arg0, arg1, arg2)
}
// CreateRefreshTokenSession mocks base method
func (m *MockResourceOwnerPasswordCredentialsGrantStorage) CreateRefreshTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {
	ret := m.ctrl.Call(m, ""CreateRefreshTokenSession"", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}
// CreateRefreshTokenSession indicates an expected call of CreateRefreshTokenSession
func (mr *MockResourceOwnerPasswordCredentialsGrantStorageMockRecorder) CreateRefreshTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""CreateRefreshTokenSession"", reflect.TypeOf((*MockResourceOwnerPasswordCredentialsGrantStorage)(nil).CreateRefreshTokenSession), arg0, arg1, arg2)
}
// DeleteAccessTokenSession mocks base method
func (m *MockResourceOwnerPasswordCredentialsGrantStorage) DeleteAccessTokenSession(arg0 context.Context, arg1 string) error {
	ret := m.ctrl.Call(m, ""DeleteAccessTokenSession"", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}
// DeleteAccessTokenSession indicates an expected call of DeleteAccessTokenSession
func (mr *MockResourceOwnerPasswordCredentialsGrantStorageMockRecorder) DeleteAccessTokenSession(arg0, arg1 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""DeleteAccessTokenSession"", reflect.TypeOf((*MockResourceOwnerPasswordCredentialsGrantStorage)(nil).DeleteAccessTokenSession), arg0, arg1)
}
// DeleteRefreshTokenSession mocks base method
func (m *MockResourceOwnerPasswordCredentialsGrantStorage) DeleteRefreshTokenSession(arg0 context.Context, arg1 string) error {
	ret := m.ctrl.Call(m, ""DeleteRefreshTokenSession"", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}
// DeleteRefreshTokenSession indicates an expected call of DeleteRefreshTokenSession
func (mr *MockResourceOwnerPasswordCredentialsGrantStorageMockRecorder) DeleteRefreshTokenSession(arg0, arg1 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""DeleteRefreshTokenSession"", reflect.TypeOf((*MockResourceOwnerPasswordCredentialsGrantStorage)(nil).DeleteRefreshTokenSession), arg0, arg1)
}
// GetAccessTokenSession mocks base method
func (m *MockResourceOwnerPasswordCredentialsGrantStorage) GetAccessTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Session) (fosite.Requester, error) {
	ret := m.ctrl.Call(m, ""GetAccessTokenSession"", arg0, arg1, arg2)
	ret0, _ := ret[0].(fosite.Requester)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}
// GetAccessTokenSession indicates an expected call of GetAccessTokenSession
func (mr *MockResourceOwnerPasswordCredentialsGrantStorageMockRecorder) GetAccessTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetAccessTokenSession"", reflect.TypeOf((*MockResourceOwnerPasswordCredentialsGrantStorage)(nil).GetAccessTokenSession), arg0, arg1, arg2)
}
// GetRefreshTokenSession mocks base method
func (m *MockResourceOwnerPasswordCredentialsGrantStorage) GetRefreshTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Session) (fosite.Requester, error) {
	ret := m.ctrl.Call(m, ""GetRefreshTokenSession"", arg0, arg1, arg2)
	ret0, _ := ret[0].(fosite.Requester)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}
// GetRefreshTokenSession indicates an expected call of GetRefreshTokenSession
func (mr *MockResourceOwnerPasswordCredentialsGrantStorageMockRecorder) GetRefreshTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetRefreshTokenSession"", reflect.TypeOf((*MockResourceOwnerPasswordCredentialsGrantStorage)(nil).GetRefreshTokenSession), arg0, arg1, arg2)
}
",CWE-345,124.0,1
"// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ory/fosite/handler/oauth2 (interfaces: TokenRevocationStorage)
// Package internal is a generated GoMock package.
package internal
import (
	context ""context""
	reflect ""reflect""
	gomock ""github.com/golang/mock/gomock""
	fosite ""github.com/ory/fosite""
)
// MockTokenRevocationStorage is a mock of TokenRevocationStorage interface
type MockTokenRevocationStorage struct {
	ctrl     *gomock.Controller
	recorder *MockTokenRevocationStorageMockRecorder
}
// MockTokenRevocationStorageMockRecorder is the mock recorder for MockTokenRevocationStorage
type MockTokenRevocationStorageMockRecorder struct {
	mock *MockTokenRevocationStorage
}
// NewMockTokenRevocationStorage creates a new mock instance
func NewMockTokenRevocationStorage(ctrl *gomock.Controller) *MockTokenRevocationStorage {
	mock := &MockTokenRevocationStorage{ctrl: ctrl}
	mock.recorder = &MockTokenRevocationStorageMockRecorder{mock}
	return mock
}
// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockTokenRevocationStorage) EXPECT() *MockTokenRevocationStorageMockRecorder {
	return m.recorder
}
// CreateAccessTokenSession mocks base method
func (m *MockTokenRevocationStorage) CreateAccessTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {
	ret := m.ctrl.Call(m, ""CreateAccessTokenSession"", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}
// CreateAccessTokenSession indicates an expected call of CreateAccessTokenSession
func (mr *MockTokenRevocationStorageMockRecorder) CreateAccessTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""CreateAccessTokenSession"", reflect.TypeOf((*MockTokenRevocationStorage)(nil).CreateAccessTokenSession), arg0, arg1, arg2)
}
// CreateRefreshTokenSession mocks base method
func (m *MockTokenRevocationStorage) CreateRefreshTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {
	ret := m.ctrl.Call(m, ""CreateRefreshTokenSession"", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}
// CreateRefreshTokenSession indicates an expected call of CreateRefreshTokenSession
func (mr *MockTokenRevocationStorageMockRecorder) CreateRefreshTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""CreateRefreshTokenSession"", reflect.TypeOf((*MockTokenRevocationStorage)(nil).CreateRefreshTokenSession), arg0, arg1, arg2)
}
// DeleteAccessTokenSession mocks base method
func (m *MockTokenRevocationStorage) DeleteAccessTokenSession(arg0 context.Context, arg1 string) error {
	ret := m.ctrl.Call(m, ""DeleteAccessTokenSession"", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}
// DeleteAccessTokenSession indicates an expected call of DeleteAccessTokenSession
func (mr *MockTokenRevocationStorageMockRecorder) DeleteAccessTokenSession(arg0, arg1 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""DeleteAccessTokenSession"", reflect.TypeOf((*MockTokenRevocationStorage)(nil).DeleteAccessTokenSession), arg0, arg1)
}
// DeleteRefreshTokenSession mocks base method
func (m *MockTokenRevocationStorage) DeleteRefreshTokenSession(arg0 context.Context, arg1 string) error {
	ret := m.ctrl.Call(m, ""DeleteRefreshTokenSession"", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}
// DeleteRefreshTokenSession indicates an expected call of DeleteRefreshTokenSession
func (mr *MockTokenRevocationStorageMockRecorder) DeleteRefreshTokenSession(arg0, arg1 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""DeleteRefreshTokenSession"", reflect.TypeOf((*MockTokenRevocationStorage)(nil).DeleteRefreshTokenSession), arg0, arg1)
}
// GetAccessTokenSession mocks base method
func (m *MockTokenRevocationStorage) GetAccessTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Session) (fosite.Requester, error) {
	ret := m.ctrl.Call(m, ""GetAccessTokenSession"", arg0, arg1, arg2)
	ret0, _ := ret[0].(fosite.Requester)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}
// GetAccessTokenSession indicates an expected call of GetAccessTokenSession
func (mr *MockTokenRevocationStorageMockRecorder) GetAccessTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetAccessTokenSession"", reflect.TypeOf((*MockTokenRevocationStorage)(nil).GetAccessTokenSession), arg0, arg1, arg2)
}
// GetRefreshTokenSession mocks base method
func (m *MockTokenRevocationStorage) GetRefreshTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Session) (fosite.Requester, error) {
	ret := m.ctrl.Call(m, ""GetRefreshTokenSession"", arg0, arg1, arg2)
	ret0, _ := ret[0].(fosite.Requester)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}
// GetRefreshTokenSession indicates an expected call of GetRefreshTokenSession
func (mr *MockTokenRevocationStorageMockRecorder) GetRefreshTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetRefreshTokenSession"", reflect.TypeOf((*MockTokenRevocationStorage)(nil).GetRefreshTokenSession), arg0, arg1, arg2)
}
// RevokeAccessToken mocks base method
func (m *MockTokenRevocationStorage) RevokeAccessToken(arg0 context.Context, arg1 string) error {
	ret := m.ctrl.Call(m, ""RevokeAccessToken"", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}
// RevokeAccessToken indicates an expected call of RevokeAccessToken
func (mr *MockTokenRevocationStorageMockRecorder) RevokeAccessToken(arg0, arg1 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""RevokeAccessToken"", reflect.TypeOf((*MockTokenRevocationStorage)(nil).RevokeAccessToken), arg0, arg1)
}
// RevokeRefreshToken mocks base method
func (m *MockTokenRevocationStorage) RevokeRefreshToken(arg0 context.Context, arg1 string) error {
	ret := m.ctrl.Call(m, ""RevokeRefreshToken"", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}
// RevokeRefreshToken indicates an expected call of RevokeRefreshToken
func (mr *MockTokenRevocationStorageMockRecorder) RevokeRefreshToken(arg0, arg1 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""RevokeRefreshToken"", reflect.TypeOf((*MockTokenRevocationStorage)(nil).RevokeRefreshToken), arg0, arg1)
}
",CWE-345,136.0,1
"// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ory/fosite/handler/oauth2 (interfaces: CoreStorage)
// Package internal is a generated GoMock package.
package internal
import (
	context ""context""
	reflect ""reflect""
	gomock ""github.com/golang/mock/gomock""
	fosite ""github.com/ory/fosite""
)
// MockCoreStorage is a mock of CoreStorage interface
type MockCoreStorage struct {
	ctrl     *gomock.Controller
	recorder *MockCoreStorageMockRecorder
}
// MockCoreStorageMockRecorder is the mock recorder for MockCoreStorage
type MockCoreStorageMockRecorder struct {
	mock *MockCoreStorage
}
// NewMockCoreStorage creates a new mock instance
func NewMockCoreStorage(ctrl *gomock.Controller) *MockCoreStorage {
	mock := &MockCoreStorage{ctrl: ctrl}
	mock.recorder = &MockCoreStorageMockRecorder{mock}
	return mock
}
// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockCoreStorage) EXPECT() *MockCoreStorageMockRecorder {
	return m.recorder
}
// CreateAccessTokenSession mocks base method
func (m *MockCoreStorage) CreateAccessTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {
	ret := m.ctrl.Call(m, ""CreateAccessTokenSession"", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}
// CreateAccessTokenSession indicates an expected call of CreateAccessTokenSession
func (mr *MockCoreStorageMockRecorder) CreateAccessTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""CreateAccessTokenSession"", reflect.TypeOf((*MockCoreStorage)(nil).CreateAccessTokenSession), arg0, arg1, arg2)
}
// CreateAuthorizeCodeSession mocks base method
func (m *MockCoreStorage) CreateAuthorizeCodeSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {
	ret := m.ctrl.Call(m, ""CreateAuthorizeCodeSession"", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}
// CreateAuthorizeCodeSession indicates an expected call of CreateAuthorizeCodeSession
func (mr *MockCoreStorageMockRecorder) CreateAuthorizeCodeSession(arg0, arg1, arg2 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""CreateAuthorizeCodeSession"", reflect.TypeOf((*MockCoreStorage)(nil).CreateAuthorizeCodeSession), arg0, arg1, arg2)
}
// CreateRefreshTokenSession mocks base method
func (m *MockCoreStorage) CreateRefreshTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {
	ret := m.ctrl.Call(m, ""CreateRefreshTokenSession"", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}
// CreateRefreshTokenSession indicates an expected call of CreateRefreshTokenSession
func (mr *MockCoreStorageMockRecorder) CreateRefreshTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""CreateRefreshTokenSession"", reflect.TypeOf((*MockCoreStorage)(nil).CreateRefreshTokenSession), arg0, arg1, arg2)
}
// DeleteAccessTokenSession mocks base method
func (m *MockCoreStorage) DeleteAccessTokenSession(arg0 context.Context, arg1 string) error {
	ret := m.ctrl.Call(m, ""DeleteAccessTokenSession"", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}
// DeleteAccessTokenSession indicates an expected call of DeleteAccessTokenSession
func (mr *MockCoreStorageMockRecorder) DeleteAccessTokenSession(arg0, arg1 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""DeleteAccessTokenSession"", reflect.TypeOf((*MockCoreStorage)(nil).DeleteAccessTokenSession), arg0, arg1)
}
// DeleteRefreshTokenSession mocks base method
func (m *MockCoreStorage) DeleteRefreshTokenSession(arg0 context.Context, arg1 string) error {
	ret := m.ctrl.Call(m, ""DeleteRefreshTokenSession"", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}
// DeleteRefreshTokenSession indicates an expected call of DeleteRefreshTokenSession
func (mr *MockCoreStorageMockRecorder) DeleteRefreshTokenSession(arg0, arg1 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""DeleteRefreshTokenSession"", reflect.TypeOf((*MockCoreStorage)(nil).DeleteRefreshTokenSession), arg0, arg1)
}
// GetAccessTokenSession mocks base method
func (m *MockCoreStorage) GetAccessTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Session) (fosite.Requester, error) {
	ret := m.ctrl.Call(m, ""GetAccessTokenSession"", arg0, arg1, arg2)
	ret0, _ := ret[0].(fosite.Requester)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}
// GetAccessTokenSession indicates an expected call of GetAccessTokenSession
func (mr *MockCoreStorageMockRecorder) GetAccessTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetAccessTokenSession"", reflect.TypeOf((*MockCoreStorage)(nil).GetAccessTokenSession), arg0, arg1, arg2)
}
// GetAuthorizeCodeSession mocks base method
func (m *MockCoreStorage) GetAuthorizeCodeSession(arg0 context.Context, arg1 string, arg2 fosite.Session) (fosite.Requester, error) {
	ret := m.ctrl.Call(m, ""GetAuthorizeCodeSession"", arg0, arg1, arg2)
	ret0, _ := ret[0].(fosite.Requester)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}
// GetAuthorizeCodeSession indicates an expected call of GetAuthorizeCodeSession
func (mr *MockCoreStorageMockRecorder) GetAuthorizeCodeSession(arg0, arg1, arg2 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetAuthorizeCodeSession"", reflect.TypeOf((*MockCoreStorage)(nil).GetAuthorizeCodeSession), arg0, arg1, arg2)
}
// GetRefreshTokenSession mocks base method
func (m *MockCoreStorage) GetRefreshTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Session) (fosite.Requester, error) {
	ret := m.ctrl.Call(m, ""GetRefreshTokenSession"", arg0, arg1, arg2)
	ret0, _ := ret[0].(fosite.Requester)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}
// GetRefreshTokenSession indicates an expected call of GetRefreshTokenSession
func (mr *MockCoreStorageMockRecorder) GetRefreshTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetRefreshTokenSession"", reflect.TypeOf((*MockCoreStorage)(nil).GetRefreshTokenSession), arg0, arg1, arg2)
}
// InvalidateAuthorizeCodeSession mocks base method
func (m *MockCoreStorage) InvalidateAuthorizeCodeSession(arg0 context.Context, arg1 string) error {
	ret := m.ctrl.Call(m, ""InvalidateAuthorizeCodeSession"", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}
// InvalidateAuthorizeCodeSession indicates an expected call of InvalidateAuthorizeCodeSession
func (mr *MockCoreStorageMockRecorder) InvalidateAuthorizeCodeSession(arg0, arg1 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""InvalidateAuthorizeCodeSession"", reflect.TypeOf((*MockCoreStorage)(nil).InvalidateAuthorizeCodeSession), arg0, arg1)
}
",CWE-345,149.0,1
"// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ory/fosite/handler/oauth2 (interfaces: CoreStrategy)
// Package internal is a generated GoMock package.
package internal
import (
	context ""context""
	reflect ""reflect""
	gomock ""github.com/golang/mock/gomock""
	fosite ""github.com/ory/fosite""
)
// MockCoreStrategy is a mock of CoreStrategy interface
type MockCoreStrategy struct {
	ctrl     *gomock.Controller
	recorder *MockCoreStrategyMockRecorder
}
// MockCoreStrategyMockRecorder is the mock recorder for MockCoreStrategy
type MockCoreStrategyMockRecorder struct {
	mock *MockCoreStrategy
}
// NewMockCoreStrategy creates a new mock instance
func NewMockCoreStrategy(ctrl *gomock.Controller) *MockCoreStrategy {
	mock := &MockCoreStrategy{ctrl: ctrl}
	mock.recorder = &MockCoreStrategyMockRecorder{mock}
	return mock
}
// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockCoreStrategy) EXPECT() *MockCoreStrategyMockRecorder {
	return m.recorder
}
// AccessTokenSignature mocks base method
func (m *MockCoreStrategy) AccessTokenSignature(arg0 string) string {
	ret := m.ctrl.Call(m, ""AccessTokenSignature"", arg0)
	ret0, _ := ret[0].(string)
	return ret0
}
// AccessTokenSignature indicates an expected call of AccessTokenSignature
func (mr *MockCoreStrategyMockRecorder) AccessTokenSignature(arg0 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""AccessTokenSignature"", reflect.TypeOf((*MockCoreStrategy)(nil).AccessTokenSignature), arg0)
}
// AuthorizeCodeSignature mocks base method
func (m *MockCoreStrategy) AuthorizeCodeSignature(arg0 string) string {
	ret := m.ctrl.Call(m, ""AuthorizeCodeSignature"", arg0)
	ret0, _ := ret[0].(string)
	return ret0
}
// AuthorizeCodeSignature indicates an expected call of AuthorizeCodeSignature
func (mr *MockCoreStrategyMockRecorder) AuthorizeCodeSignature(arg0 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""AuthorizeCodeSignature"", reflect.TypeOf((*MockCoreStrategy)(nil).AuthorizeCodeSignature), arg0)
}
// GenerateAccessToken mocks base method
func (m *MockCoreStrategy) GenerateAccessToken(arg0 context.Context, arg1 fosite.Requester) (string, string, error) {
	ret := m.ctrl.Call(m, ""GenerateAccessToken"", arg0, arg1)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(string)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}
// GenerateAccessToken indicates an expected call of GenerateAccessToken
func (mr *MockCoreStrategyMockRecorder) GenerateAccessToken(arg0, arg1 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GenerateAccessToken"", reflect.TypeOf((*MockCoreStrategy)(nil).GenerateAccessToken), arg0, arg1)
}
// GenerateAuthorizeCode mocks base method
func (m *MockCoreStrategy) GenerateAuthorizeCode(arg0 context.Context, arg1 fosite.Requester) (string, string, error) {
	ret := m.ctrl.Call(m, ""GenerateAuthorizeCode"", arg0, arg1)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(string)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}
// GenerateAuthorizeCode indicates an expected call of GenerateAuthorizeCode
func (mr *MockCoreStrategyMockRecorder) GenerateAuthorizeCode(arg0, arg1 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GenerateAuthorizeCode"", reflect.TypeOf((*MockCoreStrategy)(nil).GenerateAuthorizeCode), arg0, arg1)
}
// GenerateRefreshToken mocks base method
func (m *MockCoreStrategy) GenerateRefreshToken(arg0 context.Context, arg1 fosite.Requester) (string, string, error) {
	ret := m.ctrl.Call(m, ""GenerateRefreshToken"", arg0, arg1)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(string)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}
// GenerateRefreshToken indicates an expected call of GenerateRefreshToken
func (mr *MockCoreStrategyMockRecorder) GenerateRefreshToken(arg0, arg1 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GenerateRefreshToken"", reflect.TypeOf((*MockCoreStrategy)(nil).GenerateRefreshToken), arg0, arg1)
}
// RefreshTokenSignature mocks base method
func (m *MockCoreStrategy) RefreshTokenSignature(arg0 string) string {
	ret := m.ctrl.Call(m, ""RefreshTokenSignature"", arg0)
	ret0, _ := ret[0].(string)
	return ret0
}
// RefreshTokenSignature indicates an expected call of RefreshTokenSignature
func (mr *MockCoreStrategyMockRecorder) RefreshTokenSignature(arg0 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""RefreshTokenSignature"", reflect.TypeOf((*MockCoreStrategy)(nil).RefreshTokenSignature), arg0)
}
// ValidateAccessToken mocks base method
func (m *MockCoreStrategy) ValidateAccessToken(arg0 context.Context, arg1 fosite.Requester, arg2 string) error {
	ret := m.ctrl.Call(m, ""ValidateAccessToken"", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}
// ValidateAccessToken indicates an expected call of ValidateAccessToken
func (mr *MockCoreStrategyMockRecorder) ValidateAccessToken(arg0, arg1, arg2 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""ValidateAccessToken"", reflect.TypeOf((*MockCoreStrategy)(nil).ValidateAccessToken), arg0, arg1, arg2)
}
// ValidateAuthorizeCode mocks base method
func (m *MockCoreStrategy) ValidateAuthorizeCode(arg0 context.Context, arg1 fosite.Requester, arg2 string) error {
	ret := m.ctrl.Call(m, ""ValidateAuthorizeCode"", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}
// ValidateAuthorizeCode indicates an expected call of ValidateAuthorizeCode
func (mr *MockCoreStrategyMockRecorder) ValidateAuthorizeCode(arg0, arg1, arg2 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""ValidateAuthorizeCode"", reflect.TypeOf((*MockCoreStrategy)(nil).ValidateAuthorizeCode), arg0, arg1, arg2)
}
// ValidateRefreshToken mocks base method
func (m *MockCoreStrategy) ValidateRefreshToken(arg0 context.Context, arg1 fosite.Requester, arg2 string) error {
	ret := m.ctrl.Call(m, ""ValidateRefreshToken"", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}
// ValidateRefreshToken indicates an expected call of ValidateRefreshToken
func (mr *MockCoreStrategyMockRecorder) ValidateRefreshToken(arg0, arg1, arg2 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""ValidateRefreshToken"", reflect.TypeOf((*MockCoreStrategy)(nil).ValidateRefreshToken), arg0, arg1, arg2)
}
",CWE-345,152.0,1
"// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ory/fosite/handler/openid (interfaces: OpenIDConnectRequestStorage)
// Package internal is a generated GoMock package.
package internal
import (
	context ""context""
	reflect ""reflect""
	gomock ""github.com/golang/mock/gomock""
	fosite ""github.com/ory/fosite""
)
// MockOpenIDConnectRequestStorage is a mock of OpenIDConnectRequestStorage interface
type MockOpenIDConnectRequestStorage struct {
	ctrl     *gomock.Controller
	recorder *MockOpenIDConnectRequestStorageMockRecorder
}
// MockOpenIDConnectRequestStorageMockRecorder is the mock recorder for MockOpenIDConnectRequestStorage
type MockOpenIDConnectRequestStorageMockRecorder struct {
	mock *MockOpenIDConnectRequestStorage
}
// NewMockOpenIDConnectRequestStorage creates a new mock instance
func NewMockOpenIDConnectRequestStorage(ctrl *gomock.Controller) *MockOpenIDConnectRequestStorage {
	mock := &MockOpenIDConnectRequestStorage{ctrl: ctrl}
	mock.recorder = &MockOpenIDConnectRequestStorageMockRecorder{mock}
	return mock
}
// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockOpenIDConnectRequestStorage) EXPECT() *MockOpenIDConnectRequestStorageMockRecorder {
	return m.recorder
}
// CreateOpenIDConnectSession mocks base method
func (m *MockOpenIDConnectRequestStorage) CreateOpenIDConnectSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {
	ret := m.ctrl.Call(m, ""CreateOpenIDConnectSession"", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}
// CreateOpenIDConnectSession indicates an expected call of CreateOpenIDConnectSession
func (mr *MockOpenIDConnectRequestStorageMockRecorder) CreateOpenIDConnectSession(arg0, arg1, arg2 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""CreateOpenIDConnectSession"", reflect.TypeOf((*MockOpenIDConnectRequestStorage)(nil).CreateOpenIDConnectSession), arg0, arg1, arg2)
}
// DeleteOpenIDConnectSession mocks base method
func (m *MockOpenIDConnectRequestStorage) DeleteOpenIDConnectSession(arg0 context.Context, arg1 string) error {
	ret := m.ctrl.Call(m, ""DeleteOpenIDConnectSession"", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}
// DeleteOpenIDConnectSession indicates an expected call of DeleteOpenIDConnectSession
func (mr *MockOpenIDConnectRequestStorageMockRecorder) DeleteOpenIDConnectSession(arg0, arg1 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""DeleteOpenIDConnectSession"", reflect.TypeOf((*MockOpenIDConnectRequestStorage)(nil).DeleteOpenIDConnectSession), arg0, arg1)
}
// GetOpenIDConnectSession mocks base method
func (m *MockOpenIDConnectRequestStorage) GetOpenIDConnectSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) (fosite.Requester, error) {
	ret := m.ctrl.Call(m, ""GetOpenIDConnectSession"", arg0, arg1, arg2)
	ret0, _ := ret[0].(fosite.Requester)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}
// GetOpenIDConnectSession indicates an expected call of GetOpenIDConnectSession
func (mr *MockOpenIDConnectRequestStorageMockRecorder) GetOpenIDConnectSession(arg0, arg1, arg2 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetOpenIDConnectSession"", reflect.TypeOf((*MockOpenIDConnectRequestStorage)(nil).GetOpenIDConnectSession), arg0, arg1, arg2)
}
",CWE-345,75.0,1
"// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ory/fosite/handler/pkce (interfaces: PKCERequestStorage)
// Package internal is a generated GoMock package.
package internal
import (
	context ""context""
	reflect ""reflect""
	gomock ""github.com/golang/mock/gomock""
	fosite ""github.com/ory/fosite""
)
// MockPKCERequestStorage is a mock of PKCERequestStorage interface
type MockPKCERequestStorage struct {
	ctrl     *gomock.Controller
	recorder *MockPKCERequestStorageMockRecorder
}
// MockPKCERequestStorageMockRecorder is the mock recorder for MockPKCERequestStorage
type MockPKCERequestStorageMockRecorder struct {
	mock *MockPKCERequestStorage
}
// NewMockPKCERequestStorage creates a new mock instance
func NewMockPKCERequestStorage(ctrl *gomock.Controller) *MockPKCERequestStorage {
	mock := &MockPKCERequestStorage{ctrl: ctrl}
	mock.recorder = &MockPKCERequestStorageMockRecorder{mock}
	return mock
}
// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockPKCERequestStorage) EXPECT() *MockPKCERequestStorageMockRecorder {
	return m.recorder
}
// CreatePKCERequestSession mocks base method
func (m *MockPKCERequestStorage) CreatePKCERequestSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {
	ret := m.ctrl.Call(m, ""CreatePKCERequestSession"", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}
// CreatePKCERequestSession indicates an expected call of CreatePKCERequestSession
func (mr *MockPKCERequestStorageMockRecorder) CreatePKCERequestSession(arg0, arg1, arg2 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""CreatePKCERequestSession"", reflect.TypeOf((*MockPKCERequestStorage)(nil).CreatePKCERequestSession), arg0, arg1, arg2)
}
// DeletePKCERequestSession mocks base method
func (m *MockPKCERequestStorage) DeletePKCERequestSession(arg0 context.Context, arg1 string) error {
	ret := m.ctrl.Call(m, ""DeletePKCERequestSession"", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}
// DeletePKCERequestSession indicates an expected call of DeletePKCERequestSession
func (mr *MockPKCERequestStorageMockRecorder) DeletePKCERequestSession(arg0, arg1 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""DeletePKCERequestSession"", reflect.TypeOf((*MockPKCERequestStorage)(nil).DeletePKCERequestSession), arg0, arg1)
}
// GetPKCERequestSession mocks base method
func (m *MockPKCERequestStorage) GetPKCERequestSession(arg0 context.Context, arg1 string, arg2 fosite.Session) (fosite.Requester, error) {
	ret := m.ctrl.Call(m, ""GetPKCERequestSession"", arg0, arg1, arg2)
	ret0, _ := ret[0].(fosite.Requester)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}
// GetPKCERequestSession indicates an expected call of GetPKCERequestSession
func (mr *MockPKCERequestStorageMockRecorder) GetPKCERequestSession(arg0, arg1, arg2 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetPKCERequestSession"", reflect.TypeOf((*MockPKCERequestStorage)(nil).GetPKCERequestSession), arg0, arg1, arg2)
}
",CWE-345,75.0,1
"// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ory/fosite/handler/oauth2 (interfaces: RefreshTokenStrategy)
// Package internal is a generated GoMock package.
package internal
import (
	context ""context""
	reflect ""reflect""
	gomock ""github.com/golang/mock/gomock""
	fosite ""github.com/ory/fosite""
)
// MockRefreshTokenStrategy is a mock of RefreshTokenStrategy interface
type MockRefreshTokenStrategy struct {
	ctrl     *gomock.Controller
	recorder *MockRefreshTokenStrategyMockRecorder
}
// MockRefreshTokenStrategyMockRecorder is the mock recorder for MockRefreshTokenStrategy
type MockRefreshTokenStrategyMockRecorder struct {
	mock *MockRefreshTokenStrategy
}
// NewMockRefreshTokenStrategy creates a new mock instance
func NewMockRefreshTokenStrategy(ctrl *gomock.Controller) *MockRefreshTokenStrategy {
	mock := &MockRefreshTokenStrategy{ctrl: ctrl}
	mock.recorder = &MockRefreshTokenStrategyMockRecorder{mock}
	return mock
}
// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockRefreshTokenStrategy) EXPECT() *MockRefreshTokenStrategyMockRecorder {
	return m.recorder
}
// GenerateRefreshToken mocks base method
func (m *MockRefreshTokenStrategy) GenerateRefreshToken(arg0 context.Context, arg1 fosite.Requester) (string, string, error) {
	ret := m.ctrl.Call(m, ""GenerateRefreshToken"", arg0, arg1)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(string)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}
// GenerateRefreshToken indicates an expected call of GenerateRefreshToken
func (mr *MockRefreshTokenStrategyMockRecorder) GenerateRefreshToken(arg0, arg1 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GenerateRefreshToken"", reflect.TypeOf((*MockRefreshTokenStrategy)(nil).GenerateRefreshToken), arg0, arg1)
}
// RefreshTokenSignature mocks base method
func (m *MockRefreshTokenStrategy) RefreshTokenSignature(arg0 string) string {
	ret := m.ctrl.Call(m, ""RefreshTokenSignature"", arg0)
	ret0, _ := ret[0].(string)
	return ret0
}
// RefreshTokenSignature indicates an expected call of RefreshTokenSignature
func (mr *MockRefreshTokenStrategyMockRecorder) RefreshTokenSignature(arg0 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""RefreshTokenSignature"", reflect.TypeOf((*MockRefreshTokenStrategy)(nil).RefreshTokenSignature), arg0)
}
// ValidateRefreshToken mocks base method
func (m *MockRefreshTokenStrategy) ValidateRefreshToken(arg0 context.Context, arg1 fosite.Requester, arg2 string) error {
	ret := m.ctrl.Call(m, ""ValidateRefreshToken"", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}
// ValidateRefreshToken indicates an expected call of ValidateRefreshToken
func (mr *MockRefreshTokenStrategyMockRecorder) ValidateRefreshToken(arg0, arg1, arg2 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""ValidateRefreshToken"", reflect.TypeOf((*MockRefreshTokenStrategy)(nil).ValidateRefreshToken), arg0, arg1, arg2)
}
",CWE-345,76.0,1
"// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ory/fosite (interfaces: RevocationHandler)
// Package internal is a generated GoMock package.
package internal
import (
	context ""context""
	reflect ""reflect""
	gomock ""github.com/golang/mock/gomock""
	fosite ""github.com/ory/fosite""
)
// MockRevocationHandler is a mock of RevocationHandler interface
type MockRevocationHandler struct {
	ctrl     *gomock.Controller
	recorder *MockRevocationHandlerMockRecorder
}
// MockRevocationHandlerMockRecorder is the mock recorder for MockRevocationHandler
type MockRevocationHandlerMockRecorder struct {
	mock *MockRevocationHandler
}
// NewMockRevocationHandler creates a new mock instance
func NewMockRevocationHandler(ctrl *gomock.Controller) *MockRevocationHandler {
	mock := &MockRevocationHandler{ctrl: ctrl}
	mock.recorder = &MockRevocationHandlerMockRecorder{mock}
	return mock
}
// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockRevocationHandler) EXPECT() *MockRevocationHandlerMockRecorder {
	return m.recorder
}
// RevokeToken mocks base method
func (m *MockRevocationHandler) RevokeToken(arg0 context.Context, arg1 string, arg2 fosite.TokenType, arg3 fosite.Client) error {
	ret := m.ctrl.Call(m, ""RevokeToken"", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(error)
	return ret0
}
// RevokeToken indicates an expected call of RevokeToken
func (mr *MockRevocationHandlerMockRecorder) RevokeToken(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""RevokeToken"", reflect.TypeOf((*MockRevocationHandler)(nil).RevokeToken), arg0, arg1, arg2, arg3)
}
",CWE-345,50.0,1
"// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ory/fosite (interfaces: Storage)
// Package internal is a generated GoMock package.
package internal
import (
	context ""context""
	reflect ""reflect""
	gomock ""github.com/golang/mock/gomock""
	fosite ""github.com/ory/fosite""
)
// MockStorage is a mock of Storage interface
type MockStorage struct {
	ctrl     *gomock.Controller
	recorder *MockStorageMockRecorder
}
// MockStorageMockRecorder is the mock recorder for MockStorage
type MockStorageMockRecorder struct {
	mock *MockStorage
}
// NewMockStorage creates a new mock instance
func NewMockStorage(ctrl *gomock.Controller) *MockStorage {
	mock := &MockStorage{ctrl: ctrl}
	mock.recorder = &MockStorageMockRecorder{mock}
	return mock
}
// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockStorage) EXPECT() *MockStorageMockRecorder {
	return m.recorder
}
// GetClient mocks base method
func (m *MockStorage) GetClient(arg0 context.Context, arg1 string) (fosite.Client, error) {
	ret := m.ctrl.Call(m, ""GetClient"", arg0, arg1)
	ret0, _ := ret[0].(fosite.Client)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}
// GetClient indicates an expected call of GetClient
func (mr *MockStorageMockRecorder) GetClient(arg0, arg1 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetClient"", reflect.TypeOf((*MockStorage)(nil).GetClient), arg0, arg1)
}
",CWE-345,51.0,1
"// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ory/fosite (interfaces: TokenEndpointHandler)
// Package internal is a generated GoMock package.
package internal
import (
	context ""context""
	reflect ""reflect""
	gomock ""github.com/golang/mock/gomock""
	fosite ""github.com/ory/fosite""
)
// MockTokenEndpointHandler is a mock of TokenEndpointHandler interface
type MockTokenEndpointHandler struct {
	ctrl     *gomock.Controller
	recorder *MockTokenEndpointHandlerMockRecorder
}
// MockTokenEndpointHandlerMockRecorder is the mock recorder for MockTokenEndpointHandler
type MockTokenEndpointHandlerMockRecorder struct {
	mock *MockTokenEndpointHandler
}
// NewMockTokenEndpointHandler creates a new mock instance
func NewMockTokenEndpointHandler(ctrl *gomock.Controller) *MockTokenEndpointHandler {
	mock := &MockTokenEndpointHandler{ctrl: ctrl}
	mock.recorder = &MockTokenEndpointHandlerMockRecorder{mock}
	return mock
}
// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockTokenEndpointHandler) EXPECT() *MockTokenEndpointHandlerMockRecorder {
	return m.recorder
}
// HandleTokenEndpointRequest mocks base method
func (m *MockTokenEndpointHandler) HandleTokenEndpointRequest(arg0 context.Context, arg1 fosite.AccessRequester) error {
	ret := m.ctrl.Call(m, ""HandleTokenEndpointRequest"", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}
// HandleTokenEndpointRequest indicates an expected call of HandleTokenEndpointRequest
func (mr *MockTokenEndpointHandlerMockRecorder) HandleTokenEndpointRequest(arg0, arg1 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""HandleTokenEndpointRequest"", reflect.TypeOf((*MockTokenEndpointHandler)(nil).HandleTokenEndpointRequest), arg0, arg1)
}
// PopulateTokenEndpointResponse mocks base method
func (m *MockTokenEndpointHandler) PopulateTokenEndpointResponse(arg0 context.Context, arg1 fosite.AccessRequester, arg2 fosite.AccessResponder) error {
	ret := m.ctrl.Call(m, ""PopulateTokenEndpointResponse"", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}
// PopulateTokenEndpointResponse indicates an expected call of PopulateTokenEndpointResponse
func (mr *MockTokenEndpointHandlerMockRecorder) PopulateTokenEndpointResponse(arg0, arg1, arg2 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""PopulateTokenEndpointResponse"", reflect.TypeOf((*MockTokenEndpointHandler)(nil).PopulateTokenEndpointResponse), arg0, arg1, arg2)
}
",CWE-345,62.0,1
"// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ory/fosite/storage (interfaces: Transactional)
// Package internal is a generated GoMock package.
package internal
import (
	context ""context""
	reflect ""reflect""
	gomock ""github.com/golang/mock/gomock""
)
// MockTransactional is a mock of Transactional interface
type MockTransactional struct {
	ctrl     *gomock.Controller
	recorder *MockTransactionalMockRecorder
}
// MockTransactionalMockRecorder is the mock recorder for MockTransactional
type MockTransactionalMockRecorder struct {
	mock *MockTransactional
}
// NewMockTransactional creates a new mock instance
func NewMockTransactional(ctrl *gomock.Controller) *MockTransactional {
	mock := &MockTransactional{ctrl: ctrl}
	mock.recorder = &MockTransactionalMockRecorder{mock}
	return mock
}
// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockTransactional) EXPECT() *MockTransactionalMockRecorder {
	return m.recorder
}
// BeginTX mocks base method
func (m *MockTransactional) BeginTX(arg0 context.Context) (context.Context, error) {
	ret := m.ctrl.Call(m, ""BeginTX"", arg0)
	ret0, _ := ret[0].(context.Context)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}
// BeginTX indicates an expected call of BeginTX
func (mr *MockTransactionalMockRecorder) BeginTX(arg0 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""BeginTX"", reflect.TypeOf((*MockTransactional)(nil).BeginTX), arg0)
}
// Commit mocks base method
func (m *MockTransactional) Commit(arg0 context.Context) error {
	ret := m.ctrl.Call(m, ""Commit"", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}
// Commit indicates an expected call of Commit
func (mr *MockTransactionalMockRecorder) Commit(arg0 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""Commit"", reflect.TypeOf((*MockTransactional)(nil).Commit), arg0)
}
// Rollback mocks base method
func (m *MockTransactional) Rollback(arg0 context.Context) error {
	ret := m.ctrl.Call(m, ""Rollback"", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}
// Rollback indicates an expected call of Rollback
func (mr *MockTransactionalMockRecorder) Rollback(arg0 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""Rollback"", reflect.TypeOf((*MockTransactional)(nil).Rollback), arg0)
}
",CWE-345,73.0,1
"/*
 * Copyright © 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @author		Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @copyright 	2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @license 	Apache-2.0
 *
 */
package fosite
import (
	""encoding/json""
	""fmt""
	""net/http""
)
func (f *Fosite) WriteAccessError(rw http.ResponseWriter, _ AccessRequester, err error) {
	f.writeJsonError(rw, err)
}
func (f *Fosite) writeJsonError(rw http.ResponseWriter, err error) {
	rw.Header().Set(""Content-Type"", ""application/json;charset=UTF-8"")
	rw.Header().Set(""Cache-Control"", ""no-store"")
	rw.Header().Set(""Pragma"", ""no-cache"")
	rfcerr := ErrorToRFC6749Error(err)
	if !f.SendDebugMessagesToClients {
		rfcerr = rfcerr.Sanitize()
	}
	js, err := json.Marshal(rfcerr)
	if err != nil {
		if f.SendDebugMessagesToClients {
			errorMessage := EscapeJSONString(err.Error())
			http.Error(rw, fmt.Sprintf(`{""error"":""server_error"",""error_description"":""%s""}`, errorMessage), http.StatusInternalServerError)
		} else {
			http.Error(rw, `{""error"":""server_error""}`, http.StatusInternalServerError)
		}
		return
	}
	rw.WriteHeader(rfcerr.Code)
	rw.Write(js)
}
",CWE-754,58.0,1
"/*
 * Copyright © 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @author		Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @copyright 	2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @license 	Apache-2.0
 *
 */
package fosite
import (
	""encoding/json""
	""net/http""
)
func (f *Fosite) WriteAccessResponse(rw http.ResponseWriter, requester AccessRequester, responder AccessResponder) {
	rw.Header().Set(""Cache-Control"", ""no-store"")
	rw.Header().Set(""Pragma"", ""no-cache"")
	js, err := json.Marshal(responder.ToMap())
	if err != nil {
		http.Error(rw, err.Error(), http.StatusInternalServerError)
		return
	}
	rw.Header().Set(""Content-Type"", ""application/json;charset=UTF-8"")
	rw.WriteHeader(http.StatusOK)
	rw.Write(js)
}
",CWE-754,44.0,1
"/*
 * Copyright © 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @author		Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @copyright 	2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @license 	Apache-2.0
 *
 */
package fosite
import (
	""encoding/json""
	""fmt""
	""net/http""
	""github.com/pkg/errors""
)
func (f *Fosite) WriteAuthorizeError(rw http.ResponseWriter, ar AuthorizeRequester, err error) {
	rw.Header().Set(""Cache-Control"", ""no-store"")
	rw.Header().Set(""Pragma"", ""no-cache"")
	rfcerr := ErrorToRFC6749Error(err)
	if !f.SendDebugMessagesToClients {
		rfcerr = rfcerr.Sanitize()
	}
	if !ar.IsRedirectURIValid() {
		rw.Header().Set(""Content-Type"", ""application/json;charset=UTF-8"")
		js, err := json.Marshal(rfcerr)
		if err != nil {
			if f.SendDebugMessagesToClients {
				errorMessage := EscapeJSONString(err.Error())
				http.Error(rw, fmt.Sprintf(`{""error"":""server_error"",""error_description"":""%s""}`, errorMessage), http.StatusInternalServerError)
			} else {
				http.Error(rw, `{""error"":""server_error""}`, http.StatusInternalServerError)
			}
			return
		}
		rw.WriteHeader(rfcerr.Code)
		rw.Write(js)
		return
	}
	redirectURI := ar.GetRedirectURI()
	// The endpoint URI MUST NOT include a fragment component.
	redirectURI.Fragment = """"
	query := rfcerr.ToValues()
	query.Add(""state"", ar.GetState())
	var redirectURIString string
	if !(len(ar.GetResponseTypes()) == 0 || ar.GetResponseTypes().ExactOne(""code"")) && !errors.Is(err, ErrUnsupportedResponseType) {
		redirectURIString = redirectURI.String() + ""
	} else {
		for key, values := range redirectURI.Query() {
			for _, value := range values {
				query.Add(key, value)
			}
		}
		redirectURI.RawQuery = query.Encode()
		redirectURIString = redirectURI.String()
	}
	rw.Header().Add(""Location"", redirectURIString)
	rw.WriteHeader(http.StatusFound)
}
",CWE-754,84.0,1
"/*
 * Copyright © 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @author		Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @copyright 	2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @license 	Apache-2.0
 *
 */
package fosite
import (
	""testing""
	""github.com/pkg/errors""
	""github.com/stretchr/testify/assert""
)
func TestAddDebug(t *testing.T) {
	err := ErrRevocationClientMismatch.WithDebug(""debug"")
	assert.NotEqual(t, err, ErrRevocationClientMismatch)
	assert.Empty(t, ErrRevocationClientMismatch.Debug)
	assert.NotEmpty(t, err.Debug)
}
func TestIs(t *testing.T) {
	assert.True(t, errors.Is(ErrUnknownRequest, ErrUnknownRequest))
	assert.True(t, errors.Is(ErrUnknownRequest, &RFC6749Error{
		Name: errUnknownErrorName,
	}))
	assert.True(t, errors.Is(&RFC6749Error{
		Name: errUnknownErrorName,
	}, ErrUnknownRequest))
}
",CWE-754,47.0,1
"// +build tools
package fosite
import (
	_ ""github.com/gorilla/websocket""
	_ ""github.com/mattn/goveralls""
	_ ""github.com/ory/go-acc""
)
",CWE-754,10.0,1
"/*
 * Copyright © 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @author		Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @copyright 	2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @license 	Apache-2.0
 *
 */
package oauth2
import (
	""context""
	""github.com/pkg/errors""
	""github.com/ory/fosite""
)
type TokenRevocationHandler struct {
	TokenRevocationStorage TokenRevocationStorage
	RefreshTokenStrategy   RefreshTokenStrategy
	AccessTokenStrategy    AccessTokenStrategy
}
// RevokeToken implements https://tools.ietf.org/html/rfc7009
// The token type hint indicates which token type check should be performed first.
func (r *TokenRevocationHandler) RevokeToken(ctx context.Context, token string, tokenType fosite.TokenType, client fosite.Client) error {
	discoveryFuncs := []func() (request fosite.Requester, err error){
		func() (request fosite.Requester, err error) {
			// Refresh token
			signature := r.RefreshTokenStrategy.RefreshTokenSignature(token)
			return r.TokenRevocationStorage.GetRefreshTokenSession(ctx, signature, nil)
		},
		func() (request fosite.Requester, err error) {
			// Access token
			signature := r.AccessTokenStrategy.AccessTokenSignature(token)
			return r.TokenRevocationStorage.GetAccessTokenSession(ctx, signature, nil)
		},
	}
	// Token type hinting
	if tokenType == fosite.AccessToken {
		discoveryFuncs[0], discoveryFuncs[1] = discoveryFuncs[1], discoveryFuncs[0]
	}
	var ar fosite.Requester
	var err error
	if ar, err = discoveryFuncs[0](); err != nil {
		ar, err = discoveryFuncs[1]()
	}
	if err != nil {
		return err
	}
	if ar.GetClient().GetID() != client.GetID() {
		return errors.WithStack(fosite.ErrRevocationClientMismatch)
	}
	requestID := ar.GetID()
	r.TokenRevocationStorage.RevokeRefreshToken(ctx, requestID)
	r.TokenRevocationStorage.RevokeAccessToken(ctx, requestID)
	return nil
}
",CWE-754,78.0,1
"/*
 * Copyright © 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @author		Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @copyright 	2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @license 	Apache-2.0
 *
 */
package openid
import (
	""bytes""
	""context""
	""crypto/sha256""
	""encoding/base64""
	""github.com/ory/fosite""
)
type IDTokenHandleHelper struct {
	IDTokenStrategy OpenIDConnectTokenStrategy
}
func (i *IDTokenHandleHelper) GetAccessTokenHash(ctx context.Context, requester fosite.AccessRequester, responder fosite.AccessResponder) string {
	token := responder.GetAccessToken()
	buffer := bytes.NewBufferString(token)
	hash := sha256.New()
	hash.Write(buffer.Bytes())
	hashBuf := bytes.NewBuffer(hash.Sum([]byte{}))
	len := hashBuf.Len()
	return base64.RawURLEncoding.EncodeToString(hashBuf.Bytes()[:len/2])
}
func (i *IDTokenHandleHelper) generateIDToken(ctx context.Context, fosr fosite.Requester) (token string, err error) {
	token, err = i.IDTokenStrategy.GenerateIDToken(ctx, fosr)
	if err != nil {
		return """", err
	}
	return token, nil
}
func (i *IDTokenHandleHelper) IssueImplicitIDToken(ctx context.Context, ar fosite.Requester, resp fosite.AuthorizeResponder) error {
	token, err := i.generateIDToken(ctx, ar)
	if err != nil {
		return err
	}
	resp.AddFragment(""id_token"", token)
	return nil
}
func (i *IDTokenHandleHelper) IssueExplicitIDToken(ctx context.Context, ar fosite.Requester, resp fosite.AccessResponder) error {
	token, err := i.generateIDToken(ctx, ar)
	if err != nil {
		return err
	}
	resp.SetExtra(""id_token"", token)
	return nil
}
",CWE-754,77.0,1
"/*
 * Copyright © 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @author		Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @copyright 	2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @license 	Apache-2.0
 *
 */
package fosite
import (
	""context""
	""encoding/json""
	""fmt""
	""net/http""
	""github.com/pkg/errors""
)
// NewRevocationRequest handles incoming token revocation requests and
// validates various parameters as specified in:
// https://tools.ietf.org/html/rfc7009
//
// The authorization server first validates the client credentials (in
// case of a confidential client) and then verifies whether the token
// was issued to the client making the revocation request.  If this
// validation fails, the request is refused and the client is informed
// of the error by the authorization server as described below.
//
// In the next step, the authorization server invalidates the token.
// The invalidation takes place immediately, and the token cannot be
// used again after the revocation.
//
// * https://tools.ietf.org/html/rfc7009
// An invalid token type hint value is ignored by the authorization
// server and does not influence the revocation response.
func (f *Fosite) NewRevocationRequest(ctx context.Context, r *http.Request) error {
	if r.Method != ""POST"" {
		return errors.WithStack(ErrInvalidRequest.WithHintf(""HTTP method is \""%s\"", expected \""POST\""."", r.Method))
	} else if err := r.ParseMultipartForm(1 << 20); err != nil && err != http.ErrNotMultipart {
		return errors.WithStack(ErrInvalidRequest.WithHint(""Unable to parse HTTP body, make sure to send a properly formatted form request body."").WithCause(err).WithDebug(err.Error()))
	} else if len(r.PostForm) == 0 {
		return errors.WithStack(ErrInvalidRequest.WithHint(""The POST body can not be empty.""))
	}
	client, err := f.AuthenticateClient(ctx, r, r.PostForm)
	if err != nil {
		return err
	}
	token := r.PostForm.Get(""token"")
	tokenTypeHint := TokenType(r.PostForm.Get(""token_type_hint""))
	var found = false
	for _, loader := range f.RevocationHandlers {
		if err := loader.RevokeToken(ctx, token, tokenTypeHint, client); err == nil {
			found = true
		} else if errors.Is(err, ErrUnknownRequest) {
			// do nothing
		} else if err != nil {
			return err
		}
	}
	if !found {
		return errors.WithStack(ErrInvalidRequest)
	}
	return nil
}
// WriteRevocationResponse writes a token revocation response as specified in:
// https://tools.ietf.org/html/rfc7009
//
// The authorization server responds with HTTP status code 200 if the
// token has been revoked successfully or if the client submitted an
// invalid token.
//
// Note: invalid tokens do not cause an error response since the client
// cannot handle such an error in a reasonable way.  Moreover, the
// purpose of the revocation request, invalidating the particular token,
// is already achieved.
func (f *Fosite) WriteRevocationResponse(rw http.ResponseWriter, err error) {
	rw.Header().Set(""Cache-Control"", ""no-store"")
	rw.Header().Set(""Pragma"", ""no-cache"")
	if err == nil {
		rw.WriteHeader(http.StatusOK)
		return
	}
	if errors.Is(err, ErrInvalidRequest) {
		rw.Header().Set(""Content-Type"", ""application/json;charset=UTF-8"")
		js, err := json.Marshal(ErrInvalidRequest)
		if err != nil {
			http.Error(rw, fmt.Sprintf(`{""error"": ""%s""}`, err.Error()), http.StatusInternalServerError)
			return
		}
		rw.WriteHeader(ErrInvalidRequest.Code)
		rw.Write(js)
	} else if errors.Is(err, ErrInvalidClient) {
		rw.Header().Set(""Content-Type"", ""application/json;charset=UTF-8"")
		js, err := json.Marshal(ErrInvalidClient)
		if err != nil {
			http.Error(rw, fmt.Sprintf(`{""error"": ""%s""}`, err.Error()), http.StatusInternalServerError)
			return
		}
		rw.WriteHeader(ErrInvalidClient.Code)
		rw.Write(js)
	} else {
		// 200 OK
		rw.WriteHeader(http.StatusOK)
	}
}
",CWE-754,132.0,1
"/*
 * Copyright © 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @author		Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @copyright 	2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @license 	Apache-2.0
 *
 */
// Package hmac is the default implementation for generating and validating challenges. It uses HMAC-SHA256 to
// generate and validate challenges.
package hmac
import (
	""crypto/hmac""
	""crypto/sha512""
	""encoding/base64""
	""fmt""
	""strings""
	""sync""
	""github.com/pkg/errors""
	""github.com/ory/fosite""
)
// HMACStrategy is responsible for generating and validating challenges.
type HMACStrategy struct {
	TokenEntropy         int
	GlobalSecret         []byte
	RotatedGlobalSecrets [][]byte
	sync.Mutex
}
const (
	// key should be at least 256 bit long, making it
	minimumEntropy = 32
	// the secrets (client and global) should each have at least 16 characters making it harder to guess them
	minimumSecretLength = 32
)
var b64 = base64.URLEncoding.WithPadding(base64.NoPadding)
// Generate generates a token and a matching signature or returns an error.
// This method implements rfc6819 Section 5.1.4.2.2: Use High Entropy for Secrets.
func (c *HMACStrategy) Generate() (string, string, error) {
	c.Lock()
	defer c.Unlock()
	if len(c.GlobalSecret) < minimumSecretLength {
		return """", """", errors.Errorf(""secret for signing HMAC-SHA256 is expected to be 32 byte long, got %d byte"", len(c.GlobalSecret))
	}
	var signingKey [32]byte
	copy(signingKey[:], c.GlobalSecret)
	if c.TokenEntropy < minimumEntropy {
		c.TokenEntropy = minimumEntropy
	}
	// When creating secrets not intended for usage by human users (e.g.,
	// client secrets or token handles), the authorization server should
	// include a reasonable level of entropy in order to mitigate the risk
	// of guessing attacks.  The token value should be >=128 bits long and
	// constructed from a cryptographically strong random or pseudo-random
	// number sequence (see [RFC4086] for best current practice) generated
	// by the authorization server.
	tokenKey, err := RandomBytes(c.TokenEntropy)
	if err != nil {
		return """", """", errors.WithStack(err)
	}
	signature := generateHMAC(tokenKey, &signingKey)
	encodedSignature := b64.EncodeToString(signature)
	encodedToken := fmt.Sprintf(""%s.%s"", b64.EncodeToString(tokenKey), encodedSignature)
	return encodedToken, encodedSignature, nil
}
// Validate validates a token and returns its signature or an error if the token is not valid.
func (c *HMACStrategy) Validate(token string) (err error) {
	var keys [][]byte
	if len(c.GlobalSecret) > 0 {
		keys = append(keys, c.GlobalSecret)
	}
	if len(c.RotatedGlobalSecrets) > 0 {
		keys = append(keys, c.RotatedGlobalSecrets...)
	}
	for _, key := range keys {
		if err = c.validate(key, token); err == nil {
			return nil
		} else if errors.Is(err, fosite.ErrTokenSignatureMismatch) {
		} else {
			return err
		}
	}
	if err == nil {
		return errors.New(""a secret for signing HMAC-SHA256 is expected to be defined, but none were"")
	}
	return err
}
func (c *HMACStrategy) validate(secret []byte, token string) error {
	if len(secret) < minimumSecretLength {
		return errors.Errorf(""secret for signing HMAC-SHA256 is expected to be 32 byte long, got %d byte"", len(secret))
	}
	var signingKey [32]byte
	copy(signingKey[:], secret)
	split := strings.Split(token, ""."")
	if len(split) != 2 {
		return errors.WithStack(fosite.ErrInvalidTokenFormat)
	}
	tokenKey := split[0]
	tokenSignature := split[1]
	if tokenKey == """" || tokenSignature == """" {
		return errors.WithStack(fosite.ErrInvalidTokenFormat)
	}
	decodedTokenSignature, err := b64.DecodeString(tokenSignature)
	if err != nil {
		return errors.WithStack(err)
	}
	decodedTokenKey, err := b64.DecodeString(tokenKey)
	if err != nil {
		return errors.WithStack(err)
	}
	expectedMAC := generateHMAC(decodedTokenKey, &signingKey)
	if !hmac.Equal(expectedMAC, decodedTokenSignature) {
		// Hash is invalid
		return errors.WithStack(fosite.ErrTokenSignatureMismatch)
	}
	return nil
}
func (c *HMACStrategy) Signature(token string) string {
	split := strings.Split(token, ""."")
	if len(split) != 2 {
		return """"
	}
	return split[1]
}
func generateHMAC(data []byte, key *[32]byte) []byte {
	h := hmac.New(sha512.New512_256, key[:])
	h.Write(data)
	return h.Sum(nil)
}
",CWE-754,175.0,1
"/*
 * Copyright © 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @author		Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @copyright 	2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @license 	Apache-2.0
 *
 */
package fosite
import (
	""net/url""
	""regexp""
	""strings""
	""github.com/asaskevich/govalidator""
	""github.com/pkg/errors""
)
// GetRedirectURIFromRequestValues extracts the redirect_uri from values but does not do any sort of validation.
//
// Considered specifications
// * https://tools.ietf.org/html/rfc6749
//   The endpoint URI MAY include an
//   ""application/x-www-form-urlencoded"" formatted (per Appendix B) query
//   component ([RFC3986] Section 3.4), which MUST be retained when adding
//   additional query parameters.
func GetRedirectURIFromRequestValues(values url.Values) (string, error) {
	// rfc6749 3.1.   Authorization Endpoint
	// The endpoint URI MAY include an ""application/x-www-form-urlencoded"" formatted (per Appendix B) query component
	redirectURI, err := url.QueryUnescape(values.Get(""redirect_uri""))
	if err != nil {
		return """", errors.WithStack(ErrInvalidRequest.WithHint(`The ""redirect_uri"" parameter is malformed or missing.`).WithCause(err).WithDebug(err.Error()))
	}
	return redirectURI, nil
}
// MatchRedirectURIWithClientRedirectURIs if the given uri is a registered redirect uri. Does not perform
// uri validation.
//
// Considered specifications
// * https://tools.ietf.org/html/rfc6749
//   If multiple redirection URIs have been registered, if only part of
//   the redirection URI has been registered, or if no redirection URI has
//   been registered, the client MUST include a redirection URI with the
//   authorization request using the ""redirect_uri"" request parameter.
//
//   When a redirection URI is included in an authorization request, the
//   authorization server MUST compare and match the value received
//   against at least one of the registered redirection URIs (or URI
//   components) as defined in [RFC3986] Section 6, if any redirection
//   URIs were registered.  If the client registration included the full
//   redirection URI, the authorization server MUST compare the two URIs
//   using simple string comparison as defined in [RFC3986] Section 6.2.1.
//
// * https://tools.ietf.org/html/rfc6819
//   * The authorization server may also enforce the usage and validation
//     of pre-registered redirect URIs (see Section 5.2.3.5).  This will
//     allow for early recognition of authorization ""code"" disclosure to
//     counterfeit clients.
//   * The attacker will need to use another redirect URI for its
//     authorization process rather than the target web site because it
//     needs to intercept the flow.  So, if the authorization server
//     associates the authorization ""code"" with the redirect URI of a
//     particular end-user authorization and validates this redirect URI
//     with the redirect URI passed to the token's endpoint, such an
//     attack is detected (see Section 5.2.4.5).
func MatchRedirectURIWithClientRedirectURIs(rawurl string, client Client) (*url.URL, error) {
	if rawurl == """" && len(client.GetRedirectURIs()) == 1 {
		if redirectURIFromClient, err := url.Parse(client.GetRedirectURIs()[0]); err == nil && IsValidRedirectURI(redirectURIFromClient) {
			// If no redirect_uri was given and the client has exactly one valid redirect_uri registered, use that instead
			return redirectURIFromClient, nil
		}
	} else if rawurl != """" && isMatchingRedirectURI(rawurl, client.GetRedirectURIs()) {
		// If a redirect_uri was given and the clients knows it (simple string comparison!)
		// return it.
		if parsed, err := url.Parse(rawurl); err == nil && IsValidRedirectURI(parsed) {
			// If no redirect_uri was given and the client has exactly one valid redirect_uri registered, use that instead
			return parsed, nil
		}
	}
	return nil, errors.WithStack(ErrInvalidRequest.WithHint(`The ""redirect_uri"" parameter does not match any of the OAuth 2.0 Client's pre-registered redirect urls.`))
}
// Match a requested  redirect URI against a pool of registered client URIs
//
// Test a given redirect URI against a pool of URIs provided by a registered client.
// If the OAuth 2.0 Client has loopback URIs registered either an IPv4 URI http://127.0.0.1 or
// an IPv6 URI http://[::1] a client is allowed to request a dynamic port and the server MUST accept
// it as a valid redirection uri.
//
// https://tools.ietf.org/html/rfc8252
// Native apps that are able to open a port on the loopback network
// interface without needing special permissions (typically, those on
// desktop operating systems) can use the loopback interface to receive
// the OAuth redirect.
//
// Loopback redirect URIs use the ""http"" scheme and are constructed with
// the loopback IP literal and whatever port the client is listening on.
func isMatchingRedirectURI(uri string, haystack []string) bool {
	requested, err := url.Parse(uri)
	if err != nil {
		return false
	}
	for _, b := range haystack {
		if strings.ToLower(b) == strings.ToLower(uri) || isLoopbackURI(requested, b) {
			return true
		}
	}
	return false
}
func isLoopbackURI(requested *url.URL, registeredURI string) bool {
	registered, err := url.Parse(registeredURI)
	if err != nil {
		return false
	}
	if registered.Scheme != ""http"" || !isLoopbackAddress(registered.Host) {
		return false
	}
	if requested.Scheme == ""http"" && isLoopbackAddress(requested.Host) && registered.Path == requested.Path {
		return true
	}
	return false
}
// Check if address is either an IPv4 loopback or an IPv6 loopback-
// An optional port is ignored
func isLoopbackAddress(address string) bool {
	match, _ := regexp.MatchString(""^(127.0.0.1|\\[::1\\])(:?)(\\d*)$"", address)
	return match
}
// IsValidRedirectURI validates a redirect_uri as specified in:
//
// * https://tools.ietf.org/html/rfc6749
//   * The redirection endpoint URI MUST be an absolute URI as defined by [RFC3986] Section 4.3.
//   * The endpoint URI MUST NOT include a fragment component.
// * https://tools.ietf.org/html/rfc3986
//   absolute-URI  = scheme "":"" hier-part [ ""?"" query ]
// * https://tools.ietf.org/html/rfc6819
func IsValidRedirectURI(redirectURI *url.URL) bool {
	// We need to explicitly check for a scheme
	if !govalidator.IsRequestURL(redirectURI.String()) {
		return false
	}
	if redirectURI.Fragment != """" {
		// ""The endpoint URI MUST NOT include a fragment component.""
		return false
	}
	return true
}
func IsRedirectURISecure(redirectURI *url.URL) bool {
	return !(redirectURI.Scheme == ""http"" && !IsLocalhost(redirectURI))
}
func IsLocalhost(redirectURI *url.URL) bool {
	hn := redirectURI.Hostname()
	return strings.HasSuffix(hn, "".localhost"") || hn == ""127.0.0.1"" || hn == ""localhost""
}
",CWE-601,182.0,1
"/*
 * Copyright © 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @author		Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @copyright 	2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @license 	Apache-2.0
 *
 */
package fosite
import (
	""net/url""
	""regexp""
	""strings""
	""github.com/asaskevich/govalidator""
	""github.com/pkg/errors""
)
// GetRedirectURIFromRequestValues extracts the redirect_uri from values but does not do any sort of validation.
//
// Considered specifications
// * https://tools.ietf.org/html/rfc6749
//   The endpoint URI MAY include an
//   ""application/x-www-form-urlencoded"" formatted (per Appendix B) query
//   component ([RFC3986] Section 3.4), which MUST be retained when adding
//   additional query parameters.
func GetRedirectURIFromRequestValues(values url.Values) (string, error) {
	// rfc6749 3.1.   Authorization Endpoint
	// The endpoint URI MAY include an ""application/x-www-form-urlencoded"" formatted (per Appendix B) query component
	redirectURI, err := url.QueryUnescape(values.Get(""redirect_uri""))
	if err != nil {
		return """", errors.WithStack(ErrInvalidRequest.WithHint(`The ""redirect_uri"" parameter is malformed or missing.`).WithCause(err).WithDebug(err.Error()))
	}
	return redirectURI, nil
}
// MatchRedirectURIWithClientRedirectURIs if the given uri is a registered redirect uri. Does not perform
// uri validation.
//
// Considered specifications
// * https://tools.ietf.org/html/rfc6749
//   If multiple redirection URIs have been registered, if only part of
//   the redirection URI has been registered, or if no redirection URI has
//   been registered, the client MUST include a redirection URI with the
//   authorization request using the ""redirect_uri"" request parameter.
//
//   When a redirection URI is included in an authorization request, the
//   authorization server MUST compare and match the value received
//   against at least one of the registered redirection URIs (or URI
//   components) as defined in [RFC3986] Section 6, if any redirection
//   URIs were registered.  If the client registration included the full
//   redirection URI, the authorization server MUST compare the two URIs
//   using simple string comparison as defined in [RFC3986] Section 6.2.1.
//
// * https://tools.ietf.org/html/rfc6819
//   * The authorization server may also enforce the usage and validation
//     of pre-registered redirect URIs (see Section 5.2.3.5).  This will
//     allow for early recognition of authorization ""code"" disclosure to
//     counterfeit clients.
//   * The attacker will need to use another redirect URI for its
//     authorization process rather than the target web site because it
//     needs to intercept the flow.  So, if the authorization server
//     associates the authorization ""code"" with the redirect URI of a
//     particular end-user authorization and validates this redirect URI
//     with the redirect URI passed to the token's endpoint, such an
//     attack is detected (see Section 5.2.4.5).
func MatchRedirectURIWithClientRedirectURIs(rawurl string, client Client) (*url.URL, error) {
	if rawurl == """" && len(client.GetRedirectURIs()) == 1 {
		if redirectURIFromClient, err := url.Parse(client.GetRedirectURIs()[0]); err == nil && IsValidRedirectURI(redirectURIFromClient) {
			// If no redirect_uri was given and the client has exactly one valid redirect_uri registered, use that instead
			return redirectURIFromClient, nil
		}
	} else if rawurl != """" && isMatchingRedirectURI(rawurl, client.GetRedirectURIs()) {
		// If a redirect_uri was given and the clients knows it (simple string comparison!)
		// return it.
		if parsed, err := url.Parse(rawurl); err == nil && IsValidRedirectURI(parsed) {
			// If no redirect_uri was given and the client has exactly one valid redirect_uri registered, use that instead
			return parsed, nil
		}
	}
	return nil, errors.WithStack(ErrInvalidRequest.WithHint(`The ""redirect_uri"" parameter does not match any of the OAuth 2.0 Client's pre-registered redirect urls.`))
}
// Match a requested  redirect URI against a pool of registered client URIs
//
// Test a given redirect URI against a pool of URIs provided by a registered client.
// If the OAuth 2.0 Client has loopback URIs registered either an IPv4 URI http://127.0.0.1 or
// an IPv6 URI http://[::1] a client is allowed to request a dynamic port and the server MUST accept
// it as a valid redirection uri.
//
// https://tools.ietf.org/html/rfc8252
// Native apps that are able to open a port on the loopback network
// interface without needing special permissions (typically, those on
// desktop operating systems) can use the loopback interface to receive
// the OAuth redirect.
//
// Loopback redirect URIs use the ""http"" scheme and are constructed with
// the loopback IP literal and whatever port the client is listening on.
func isMatchingRedirectURI(uri string, haystack []string) bool {
	requested, err := url.Parse(uri)
	if err != nil {
		return false
	}
	for _, b := range haystack {
		if strings.ToLower(b) == strings.ToLower(uri) || isLoopbackURI(requested, b) {
			return true
		}
	}
	return false
}
func isLoopbackURI(requested *url.URL, registeredURI string) bool {
	registered, err := url.Parse(registeredURI)
	if err != nil {
		return false
	}
	if registered.Scheme != ""http"" || !isLoopbackAddress(registered.Host) {
		return false
	}
	if requested.Scheme == ""http"" && isLoopbackAddress(requested.Host) && registered.Path == requested.Path {
		return true
	}
	return false
}
// Check if address is either an IPv4 loopback or an IPv6 loopback-
// An optional port is ignored
func isLoopbackAddress(address string) bool {
	match, _ := regexp.MatchString(""^(127.0.0.1|\\[::1\\])(:?)(\\d*)$"", address)
	return match
}
// IsValidRedirectURI validates a redirect_uri as specified in:
//
// * https://tools.ietf.org/html/rfc6749
//   * The redirection endpoint URI MUST be an absolute URI as defined by [RFC3986] Section 4.3.
//   * The endpoint URI MUST NOT include a fragment component.
// * https://tools.ietf.org/html/rfc3986
//   absolute-URI  = scheme "":"" hier-part [ ""?"" query ]
// * https://tools.ietf.org/html/rfc6819
func IsValidRedirectURI(redirectURI *url.URL) bool {
	// We need to explicitly check for a scheme
	if !govalidator.IsRequestURL(redirectURI.String()) {
		return false
	}
	if redirectURI.Fragment != """" {
		// ""The endpoint URI MUST NOT include a fragment component.""
		return false
	}
	return true
}
func IsRedirectURISecure(redirectURI *url.URL) bool {
	return !(redirectURI.Scheme == ""http"" && !IsLocalhost(redirectURI))
}
func IsLocalhost(redirectURI *url.URL) bool {
	hn := redirectURI.Hostname()
	return strings.HasSuffix(hn, "".localhost"") || hn == ""127.0.0.1"" || hn == ""localhost""
}
",CWE-178,182.0,1
"/*
 * Copyright © 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @author		Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @copyright 	2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @license 	Apache-2.0
 *
 */
package fosite
import (
	""encoding/json""
	""testing""
	""github.com/stretchr/testify/assert""
	""github.com/stretchr/testify/require""
)
func TestStringInSlice(t *testing.T) {
	for k, c := range []struct {
		needle   string
		haystack []string
		ok       bool
	}{
		{needle: ""foo"", haystack: []string{""foo"", ""bar""}, ok: true},
		{needle: ""bar"", haystack: []string{""foo"", ""bar""}, ok: true},
		{needle: ""baz"", haystack: []string{""foo"", ""bar""}, ok: false},
		{needle: ""foo"", haystack: []string{""bar""}, ok: false},
		{needle: ""bar"", haystack: []string{""bar""}, ok: true},
		{needle: ""foo"", haystack: []string{}, ok: false},
	} {
		assert.Equal(t, c.ok, StringInSlice(c.needle, c.haystack), ""%d"", k)
		t.Logf(""Passed test case %d"", k)
	}
}
func TestEscapeJSONString(t *testing.T) {
	for _, str := range []string{"""", ""foobar"", `foo""bar`, `foo\bar`, ""foo\n\tbar""} {
		escaped := EscapeJSONString(str)
		var unmarshaled string
		err := json.Unmarshal([]byte(`""` + escaped + `""`), &unmarshaled)
		require.NoError(t, err, str)
		assert.Equal(t, str, unmarshaled, str)
	}
}
",CWE-601,59.0,1
"/*
 * Copyright © 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @author		Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @copyright 	2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @license 	Apache-2.0
 *
 */
package fosite
import (
	""encoding/json""
	""testing""
	""github.com/stretchr/testify/assert""
	""github.com/stretchr/testify/require""
)
func TestStringInSlice(t *testing.T) {
	for k, c := range []struct {
		needle   string
		haystack []string
		ok       bool
	}{
		{needle: ""foo"", haystack: []string{""foo"", ""bar""}, ok: true},
		{needle: ""bar"", haystack: []string{""foo"", ""bar""}, ok: true},
		{needle: ""baz"", haystack: []string{""foo"", ""bar""}, ok: false},
		{needle: ""foo"", haystack: []string{""bar""}, ok: false},
		{needle: ""bar"", haystack: []string{""bar""}, ok: true},
		{needle: ""foo"", haystack: []string{}, ok: false},
	} {
		assert.Equal(t, c.ok, StringInSlice(c.needle, c.haystack), ""%d"", k)
		t.Logf(""Passed test case %d"", k)
	}
}
func TestEscapeJSONString(t *testing.T) {
	for _, str := range []string{"""", ""foobar"", `foo""bar`, `foo\bar`, ""foo\n\tbar""} {
		escaped := EscapeJSONString(str)
		var unmarshaled string
		err := json.Unmarshal([]byte(`""` + escaped + `""`), &unmarshaled)
		require.NoError(t, err, str)
		assert.Equal(t, str, unmarshaled, str)
	}
}
",CWE-178,59.0,1
"package config
import (
	""encoding/json""
	""io/ioutil""
	log ""github.com/gophish/gophish/logger""
)
// AdminServer represents the Admin server configuration details
type AdminServer struct {
	ListenURL string `json:""listen_url""`
	UseTLS    bool   `json:""use_tls""`
	CertPath  string `json:""cert_path""`
	KeyPath   string `json:""key_path""`
	CSRFKey   string `json:""csrf_key""`
}
// PhishServer represents the Phish server configuration details
type PhishServer struct {
	ListenURL string `json:""listen_url""`
	UseTLS    bool   `json:""use_tls""`
	CertPath  string `json:""cert_path""`
	KeyPath   string `json:""key_path""`
}
// Config represents the configuration information.
type Config struct {
	AdminConf      AdminServer `json:""admin_server""`
	PhishConf      PhishServer `json:""phish_server""`
	DBName         string      `json:""db_name""`
	DBPath         string      `json:""db_path""`
	DBSSLCaPath    string      `json:""db_sslca_path""`
	MigrationsPath string      `json:""migrations_prefix""`
	TestFlag       bool        `json:""test_flag""`
	ContactAddress string      `json:""contact_address""`
	Logging        *log.Config `json:""logging""`
}
// Version contains the current gophish version
var Version = """"
// ServerName is the server type that is returned in the transparency response.
const ServerName = ""gophish""
// LoadConfig loads the configuration from the specified filepath
func LoadConfig(filepath string) (*Config, error) {
	// Get the config file
	configFile, err := ioutil.ReadFile(filepath)
	if err != nil {
		return nil, err
	}
	config := &Config{}
	err = json.Unmarshal(configFile, config)
	if err != nil {
		return nil, err
	}
	if config.Logging == nil {
		config.Logging = &log.Config{}
	}
	// Choosing the migrations directory based on the database used.
	config.MigrationsPath = config.MigrationsPath + config.DBName
	// Explicitly set the TestFlag to false to prevent config.json overrides
	config.TestFlag = false
	return config, nil
}
",CWE-918,67.0,1
"package api
import (
	""bytes""
	""crypto/tls""
	""encoding/json""
	""errors""
	""fmt""
	""net/http""
	""strings""
	""github.com/PuerkitoBio/goquery""
	log ""github.com/gophish/gophish/logger""
	""github.com/gophish/gophish/models""
	""github.com/gophish/gophish/util""
	""github.com/jordan-wright/email""
)
type cloneRequest struct {
	URL              string `json:""url""`
	IncludeResources bool   `json:""include_resources""`
}
func (cr *cloneRequest) validate() error {
	if cr.URL == """" {
		return errors.New(""No URL Specified"")
	}
	return nil
}
type cloneResponse struct {
	HTML string `json:""html""`
}
type emailResponse struct {
	Text    string `json:""text""`
	HTML    string `json:""html""`
	Subject string `json:""subject""`
}
// ImportGroup imports a CSV of group members
func (as *Server) ImportGroup(w http.ResponseWriter, r *http.Request) {
	ts, err := util.ParseCSV(r)
	if err != nil {
		JSONResponse(w, models.Response{Success: false, Message: ""Error parsing CSV""}, http.StatusInternalServerError)
		return
	}
	JSONResponse(w, ts, http.StatusOK)
}
// ImportEmail allows for the importing of email.
// Returns a Message object
func (as *Server) ImportEmail(w http.ResponseWriter, r *http.Request) {
	if r.Method != ""POST"" {
		JSONResponse(w, models.Response{Success: false, Message: ""Method not allowed""}, http.StatusBadRequest)
		return
	}
	ir := struct {
		Content      string `json:""content""`
		ConvertLinks bool   `json:""convert_links""`
	}{}
	err := json.NewDecoder(r.Body).Decode(&ir)
	if err != nil {
		JSONResponse(w, models.Response{Success: false, Message: ""Error decoding JSON Request""}, http.StatusBadRequest)
		return
	}
	e, err := email.NewEmailFromReader(strings.NewReader(ir.Content))
	if err != nil {
		log.Error(err)
	}
	// If the user wants to convert links to point to
	// the landing page, let's make it happen by changing up
	// e.HTML
	if ir.ConvertLinks {
		d, err := goquery.NewDocumentFromReader(bytes.NewReader(e.HTML))
		if err != nil {
			JSONResponse(w, models.Response{Success: false, Message: err.Error()}, http.StatusBadRequest)
			return
		}
		d.Find(""a"").Each(func(i int, a *goquery.Selection) {
			a.SetAttr(""href"", ""{{.URL}}"")
		})
		h, err := d.Html()
		if err != nil {
			JSONResponse(w, models.Response{Success: false, Message: err.Error()}, http.StatusInternalServerError)
			return
		}
		e.HTML = []byte(h)
	}
	er := emailResponse{
		Subject: e.Subject,
		Text:    string(e.Text),
		HTML:    string(e.HTML),
	}
	JSONResponse(w, er, http.StatusOK)
}
// ImportSite allows for the importing of HTML from a website
// Without ""include_resources"" set, it will merely place a ""base"" tag
// so that all resources can be loaded relative to the given URL.
func (as *Server) ImportSite(w http.ResponseWriter, r *http.Request) {
	cr := cloneRequest{}
	if r.Method != ""POST"" {
		JSONResponse(w, models.Response{Success: false, Message: ""Method not allowed""}, http.StatusBadRequest)
		return
	}
	err := json.NewDecoder(r.Body).Decode(&cr)
	if err != nil {
		JSONResponse(w, models.Response{Success: false, Message: ""Error decoding JSON Request""}, http.StatusBadRequest)
		return
	}
	if err = cr.validate(); err != nil {
		JSONResponse(w, models.Response{Success: false, Message: err.Error()}, http.StatusBadRequest)
		return
	}
	tr := &http.Transport{
		TLSClientConfig: &tls.Config{
			InsecureSkipVerify: true,
		},
	}
	client := &http.Client{Transport: tr}
	resp, err := client.Get(cr.URL)
	if err != nil {
		JSONResponse(w, models.Response{Success: false, Message: err.Error()}, http.StatusBadRequest)
		return
	}
	// Insert the base href tag to better handle relative resources
	d, err := goquery.NewDocumentFromResponse(resp)
	if err != nil {
		JSONResponse(w, models.Response{Success: false, Message: err.Error()}, http.StatusBadRequest)
		return
	}
	// Assuming we don't want to include resources, we'll need a base href
	if d.Find(""head base"").Length() == 0 {
		d.Find(""head"").PrependHtml(fmt.Sprintf(""<base href=\""%s\"">"", cr.URL))
	}
	forms := d.Find(""form"")
	forms.Each(func(i int, f *goquery.Selection) {
		// We'll want to store where we got the form from
		// (the current URL)
		url := f.AttrOr(""action"", cr.URL)
		if !strings.HasPrefix(url, ""http"") {
			url = fmt.Sprintf(""%s%s"", cr.URL, url)
		}
		f.PrependHtml(fmt.Sprintf(""<input type=\""hidden\"" name=\""__original_url\"" value=\""%s\""/>"", url))
	})
	h, err := d.Html()
	if err != nil {
		JSONResponse(w, models.Response{Success: false, Message: err.Error()}, http.StatusInternalServerError)
		return
	}
	cs := cloneResponse{HTML: h}
	JSONResponse(w, cs, http.StatusOK)
}
",CWE-918,155.0,1
"module github.com/gophish/gophish
go 1.13
require (
	bitbucket.org/liamstask/goose v0.0.0-20150115234039-8488cc47d90c
	github.com/NYTimes/gziphandler v1.1.1
	github.com/PuerkitoBio/goquery v1.5.0
	github.com/alecthomas/template v0.0.0-20190718012654-fb15b899a751 // indirect
	github.com/alecthomas/units v0.0.0-20190924025748-f65c72e2690d // indirect
	github.com/emersion/go-imap v1.0.4
	github.com/emersion/go-message v0.12.0
	github.com/go-sql-driver/mysql v1.5.0
	github.com/gophish/gomail v0.0.0-20180314010319-cf7e1a5479be
	github.com/gorilla/context v1.1.1
	github.com/gorilla/csrf v1.6.2
	github.com/gorilla/handlers v1.4.2
	github.com/gorilla/mux v1.7.3
	github.com/gorilla/securecookie v1.1.1
	github.com/gorilla/sessions v1.2.0
	github.com/jinzhu/gorm v1.9.12
	github.com/jordan-wright/email v0.0.0-20200602115436-fd8a7622303e
	github.com/jordan-wright/unindexed v0.0.0-20181209214434-78fa79113c0f
	github.com/kylelemons/go-gypsy v0.0.0-20160905020020-08cad365cd28 // indirect
	github.com/mattn/go-sqlite3 v2.0.3+incompatible
	github.com/oschwald/maxminddb-golang v1.6.0
	github.com/sirupsen/logrus v1.4.2
	github.com/ziutek/mymysql v1.5.4 // indirect
	golang.org/x/crypto v0.0.0-20200128174031-69ecbb4d6d5d
	golang.org/x/time v0.0.0-20200416051211-89c76fbcd5d1
	gopkg.in/alecthomas/kingpin.v2 v2.2.6
	gopkg.in/alexcesaro/quotedprintable.v3 v3.0.0-20150716171945-2caba252f4dc // indirect
	gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405
	gopkg.in/gomail.v2 v2.0.0-20160411212932-81ebce5c23df // indirect
)
",CWE-918,36.0,1
"bitbucket.org/liamstask/goose v0.0.0-20150115234039-8488cc47d90c h1:bkb2NMGo3/Du52wvYj9Whth5KZfMV6d3O0Vbr3nz/UE=
bitbucket.org/liamstask/goose v0.0.0-20150115234039-8488cc47d90c/go.mod h1:hSVuE3qU7grINVSwrmzHfpg9k87ALBk+XaualNyUzI4=
github.com/NYTimes/gziphandler v1.1.1 h1:ZUDjpQae29j0ryrS0u/B8HZfJBtBQHjqw2rQ2cqUQ3I=
github.com/NYTimes/gziphandler v1.1.1/go.mod h1:n/CVRwUEOgIxrgPvAQhUUr9oeUtvrhMomdKFjzJNB0c=
github.com/PuerkitoBio/goquery v1.5.0 h1:uGvmFXOA73IKluu/F84Xd1tt/z07GYm8X49XKHP7EJk=
github.com/PuerkitoBio/goquery v1.5.0/go.mod h1:qD2PgZ9lccMbQlc7eEOjaeRlFQON7xY8kdmcsrnKqMg=
github.com/alecthomas/template v0.0.0-20190718012654-fb15b899a751 h1:JYp7IbQjafoB+tBA3gMyHYHrpOtNuDiK/uB5uXxq5wM=
github.com/alecthomas/template v0.0.0-20190718012654-fb15b899a751/go.mod h1:LOuyumcjzFXgccqObfd/Ljyb9UuFJ6TxHnclSeseNhc=
github.com/alecthomas/units v0.0.0-20190924025748-f65c72e2690d h1:UQZhZ2O0vMHr2cI+DC1Mbh0TJxzA3RcLoMsFw+aXw7E=
github.com/alecthomas/units v0.0.0-20190924025748-f65c72e2690d/go.mod h1:rBZYJk541a8SKzHPHnH3zbiI+7dagKZ0cgpgrD7Fyho=
github.com/andybalholm/cascadia v1.0.0 h1:hOCXnnZ5A+3eVDX8pvgl4kofXv2ELss0bKcqRySc45o=
github.com/andybalholm/cascadia v1.0.0/go.mod h1:GsXiBklL0woXo1j/WYWtSYYC4ouU9PqHO0sqidkEA4Y=
github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/denisenkom/go-mssqldb v0.0.0-20191124224453-732737034ffd h1:83Wprp6ROGeiHFAP8WJdI2RoxALQYgdllERc3N5N2DM=
github.com/denisenkom/go-mssqldb v0.0.0-20191124224453-732737034ffd/go.mod h1:xbL0rPBG9cCiLr28tMa8zpbdarY27NDyej4t/EjAShU=
github.com/emersion/go-imap v1.0.4 h1:uiCAIHM6Z5Jwkma1zdNDWWXxSCqb+/xHBkHflD7XBro=
github.com/emersion/go-imap v1.0.4/go.mod h1:yKASt+C3ZiDAiCSssxg9caIckWF/JG7ZQTO7GAmvicU=
github.com/emersion/go-message v0.11.1/go.mod h1:C4jnca5HOTo4bGN9YdqNQM9sITuT3Y0K6bSUw9RklvY=
github.com/emersion/go-message v0.12.0 h1:mZnv35eZ6lB6EftTQBgYXspOH0FQdhpFhSUhA9i6/Zg=
github.com/emersion/go-message v0.12.0/go.mod h1:C4jnca5HOTo4bGN9YdqNQM9sITuT3Y0K6bSUw9RklvY=
github.com/emersion/go-sasl v0.0.0-20191210011802-430746ea8b9b h1:uhWtEWBHgop1rqEk2klKaxPAkVDCXexai6hSuRQ7Nvs=
github.com/emersion/go-sasl v0.0.0-20191210011802-430746ea8b9b/go.mod h1:G/dpzLu16WtQpBfQ/z3LYiYJn3ZhKSGWn83fyoyQe/k=
github.com/emersion/go-textwrapper v0.0.0-20160606182133-d0e65e56babe h1:40SWqY0zE3qCi6ZrtTf5OUdNm5lDnGnjRSq9GgmeTrg=
github.com/emersion/go-textwrapper v0.0.0-20160606182133-d0e65e56babe/go.mod h1:aqO8z8wPrjkscevZJFVE1wXJrLpC5LtJG7fqLOsPb2U=
github.com/erikstmartin/go-testdb v0.0.0-20160219214506-8d10e4a1bae5 h1:Yzb9+7DPaBjB8zlTR87/ElzFsnQfuHnVUVqpZZIcV5Y=
github.com/erikstmartin/go-testdb v0.0.0-20160219214506-8d10e4a1bae5/go.mod h1:a2zkGnVExMxdzMo3M0Hi/3sEU+cWnZpSni0O6/Yb/P0=
github.com/go-sql-driver/mysql v1.4.1/go.mod h1:zAC/RDZ24gD3HViQzih4MyKcchzm+sOG5ZlKdlhCg5w=
github.com/go-sql-driver/mysql v1.5.0 h1:ozyZYNQW3x3HtqT1jira07DN2PArx2v7/mN66gGcHOs=
github.com/go-sql-driver/mysql v1.5.0/go.mod h1:DCzpHaOWr8IXmIStZouvnhqoel9Qv2LBy8hT2VhHyBg=
github.com/golang-sql/civil v0.0.0-20190719163853-cb61b32ac6fe h1:lXe2qZdvpiX5WZkZR4hgp4KJVfY3nMkvmwbVkpv1rVY=
github.com/golang-sql/civil v0.0.0-20190719163853-cb61b32ac6fe/go.mod h1:8vg3r2VgvsThLBIFL93Qb5yWzgyZWhEmBwUJWevAkK0=
github.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=
github.com/gophish/gomail v0.0.0-20180314010319-cf7e1a5479be h1:VTe1cdyqSi/wLowKNz/shz6E0G+9/XzldZbyAmt+0Yw=
github.com/gophish/gomail v0.0.0-20180314010319-cf7e1a5479be/go.mod h1:MpSuP7kw+gRy2z+4gIFZeF3DwhhdQhEXwRmPVQYD9ig=
github.com/gorilla/context v1.1.1 h1:AWwleXJkX/nhcU9bZSnZoi3h/qGYqQAGhq6zZe/aQW8=
github.com/gorilla/context v1.1.1/go.mod h1:kBGZzfjB9CEq2AlWe17Uuf7NDRt0dE0s8S51q0aT7Yg=
github.com/gorilla/csrf v1.6.2 h1:QqQ/OWwuFp4jMKgBFAzJVW3FMULdyUW7JoM4pEWuqKg=
github.com/gorilla/csrf v1.6.2/go.mod h1:7tSf8kmjNYr7IWDCYhd3U8Ck34iQ/Yw5CJu7bAkHEGI=
github.com/gorilla/handlers v1.4.2 h1:0QniY0USkHQ1RGCLfKxeNHK9bkDHGRYGNDFBCS+YARg=
github.com/gorilla/handlers v1.4.2/go.mod h1:Qkdc/uu4tH4g6mTK6auzZ766c4CA0Ng8+o/OAirnOIQ=
github.com/gorilla/mux v1.7.3 h1:gnP5JzjVOuiZD07fKKToCAOjS0yOpj/qPETTXCCS6hw=
github.com/gorilla/mux v1.7.3/go.mod h1:1lud6UwP+6orDFRuTfBEV8e9/aOM/c4fVVCaMa2zaAs=
github.com/gorilla/securecookie v1.1.1 h1:miw7JPhV+b/lAHSXz4qd/nN9jRiAFV5FwjeKyCS8BvQ=
github.com/gorilla/securecookie v1.1.1/go.mod h1:ra0sb63/xPlUeL+yeDciTfxMRAA+MP+HVt/4epWDjd4=
github.com/gorilla/sessions v1.2.0 h1:S7P+1Hm5V/AT9cjEcUD5uDaQSX0OE577aCXgoaKpYbQ=
github.com/gorilla/sessions v1.2.0/go.mod h1:dk2InVEVJ0sfLlnXv9EAgkf6ecYs/i80K/zI+bUmuGM=
github.com/jinzhu/gorm v1.9.12 h1:Drgk1clyWT9t9ERbzHza6Mj/8FY/CqMyVzOiHviMo6Q=
github.com/jinzhu/gorm v1.9.12/go.mod h1:vhTjlKSJUTWNtcbQtrMBFCxy7eXTzeCAzfL5fBZT/Qs=
github.com/jinzhu/inflection v1.0.0 h1:K317FqzuhWc8YvSVlFMCCUb36O/S9MCKRDI7QkRKD/E=
github.com/jinzhu/inflection v1.0.0/go.mod h1:h+uFLlag+Qp1Va5pdKtLDYj+kHp5pxUVkryuEj+Srlc=
github.com/jinzhu/now v1.0.1 h1:HjfetcXq097iXP0uoPCdnM4Efp5/9MsM0/M+XOTeR3M=
github.com/jinzhu/now v1.0.1/go.mod h1:d3SSVoowX0Lcu0IBviAWJpolVfI5UJVZZ7cO71lE/z8=
github.com/jordan-wright/email v0.0.0-20200602115436-fd8a7622303e h1:OGunVjqY7y4U4laftpEHv+mvZBlr7UGimJXKEGQtg48=
github.com/jordan-wright/email v0.0.0-20200602115436-fd8a7622303e/go.mod h1:Fy2gCFfZhay8jplf/Csj6cyH/oshQTkLQYZbKkcV+SY=
github.com/jordan-wright/unindexed v0.0.0-20181209214434-78fa79113c0f h1:bYVTBvVHcAYDkH8hyVMRUW7J2mYQNNSmQPXGadYd1nY=
github.com/jordan-wright/unindexed v0.0.0-20181209214434-78fa79113c0f/go.mod h1:eRt05O5haIXGKGodWjpQ2xdgBHTE7hg/pzsukNi9IRA=
github.com/konsorten/go-windows-terminal-sequences v1.0.1 h1:mweAR1A6xJ3oS2pRaGiHgQ4OO8tzTaLawm8vnODuwDk=
github.com/konsorten/go-windows-terminal-sequences v1.0.1/go.mod h1:T0+1ngSBFLxvqU3pZ+m/2kptfBszLMUkC4ZK/EgS/cQ=
github.com/kylelemons/go-gypsy v0.0.0-20160905020020-08cad365cd28 h1:mkl3tvPHIuPaWsLtmHTybJeoVEW7cbePK73Ir8VtruA=
github.com/kylelemons/go-gypsy v0.0.0-20160905020020-08cad365cd28/go.mod h1:T/T7jsxVqf9k/zYOqbgNAsANsjxTd1Yq3htjDhQ1H0c=
github.com/lib/pq v1.1.1 h1:sJZmqHoEaY7f+NPP8pgLB/WxulyR3fewgCM2qaSlBb4=
github.com/lib/pq v1.1.1/go.mod h1:5WUZQaWbwv1U+lTReE5YruASi9Al49XbQIvNi/34Woo=
github.com/martinlindhe/base36 v1.0.0/go.mod h1:+AtEs8xrBpCeYgSLoY/aJ6Wf37jtBuR0s35750M27+8=
github.com/mattn/go-sqlite3 v2.0.1+incompatible/go.mod h1:FPy6KqzDD04eiIsT53CuJW3U88zkxoIYsOqkbpncsNc=
github.com/mattn/go-sqlite3 v2.0.3+incompatible h1:gXHsfypPkaMZrKbD5209QV9jbUTJKjyR5WD3HYQSd+U=
github.com/mattn/go-sqlite3 v2.0.3+incompatible/go.mod h1:FPy6KqzDD04eiIsT53CuJW3U88zkxoIYsOqkbpncsNc=
github.com/oschwald/maxminddb-golang v1.6.0 h1:KAJSjdHQ8Kv45nFIbtoLGrGWqHFajOIm7skTyz/+Dls=
github.com/oschwald/maxminddb-golang v1.6.0/go.mod h1:DUJFucBg2cvqx42YmDa/+xHvb0elJtOm3o4aFQ/nb/w=
github.com/pkg/errors v0.8.0 h1:WdK/asTD0HN+q6hsWO3/vpuAkAr+tw6aNJNDFFf0+qw=
github.com/pkg/errors v0.8.0/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=
github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/sirupsen/logrus v1.4.2 h1:SPIRibHv4MatM3XXNO2BJeFLZwZ2LvZgfQ5+UNI2im4=
github.com/sirupsen/logrus v1.4.2/go.mod h1:tLMulIdttU9McNUspp0xgXVQah82FyeX6MwdIuYE2rE=
github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
github.com/stretchr/objx v0.1.1/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
github.com/stretchr/testify v1.2.2/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=
github.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=
github.com/stretchr/testify v1.4.0 h1:2E4SXV/wtOkTonXsotYi4li6zVWxYlZuYNCXe9XRJyk=
github.com/stretchr/testify v1.4.0/go.mod h1:j7eGeouHqKxXV5pUuKE4zz7dFj8WfuZ+81PSLYec5m4=
github.com/ziutek/mymysql v1.5.4 h1:GB0qdRGsTwQSBVYuVShFBKaXSnSnYYC2d9knnE1LHFs=
github.com/ziutek/mymysql v1.5.4/go.mod h1:LMSpPZ6DbqWFxNCHW77HeMg9I646SAhApZ/wKdgO/C0=
golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=
golang.org/x/crypto v0.0.0-20190325154230-a5d413f7728c/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=
golang.org/x/crypto v0.0.0-20191205180655-e7c4368fe9dd/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=
golang.org/x/crypto v0.0.0-20200128174031-69ecbb4d6d5d h1:9FCpayM9Egr1baVnV1SX0H87m+XB0B8S0hAMi99X/3U=
golang.org/x/crypto v0.0.0-20200128174031-69ecbb4d6d5d/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=
golang.org/x/net v0.0.0-20180218175443-cbe0f9307d01/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20181114220301-adae6a3d119a/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3 h1:0GoQqolDA55aaLxZyTzK/Y2ePZzZTUrRacwib7cNsYQ=
golang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20190422165155-953cdadca894/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20191224085550-c709ea063b76 h1:Dho5nD6R3PcW2SH1or8vS0dszDaXRxIw55lBX7XiE5g=
golang.org/x/sys v0.0.0-20191224085550-c709ea063b76/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
golang.org/x/text v0.3.2 h1:tW2bmiBqwgJj/UpqtC8EpXEZVYOwU0yG4iWbprSVAcs=
golang.org/x/text v0.3.2/go.mod h1:bEr9sfX3Q8Zfm5fL9x+3itogRgK3+ptLWKqgva+5dAk=
golang.org/x/time v0.0.0-20200416051211-89c76fbcd5d1 h1:NusfzzA6yGQ+ua51ck7E3omNUX/JuqbFSaRGqU8CcLI=
golang.org/x/time v0.0.0-20200416051211-89c76fbcd5d1/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=
golang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
google.golang.org/appengine v1.4.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=
gopkg.in/alecthomas/kingpin.v2 v2.2.6 h1:jMFz6MfLP0/4fUyZle81rXUoxOBFi19VUFKVDOQfozc=
gopkg.in/alecthomas/kingpin.v2 v2.2.6/go.mod h1:FMv+mEhP44yOT+4EoQTLFTRgOQ1FBLkstjWtayDeSgw=
gopkg.in/alexcesaro/quotedprintable.v3 v3.0.0-20150716171945-2caba252f4dc h1:2gGKlE2+asNV9m7xrywl36YYNnBG5ZQ0r/BOOxqPpmk=
gopkg.in/alexcesaro/quotedprintable.v3 v3.0.0-20150716171945-2caba252f4dc/go.mod h1:m7x9LTH6d71AHyAX77c9yqWCCa3UKHcVEj9y7hAtKDk=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/gomail.v2 v2.0.0-20160411212932-81ebce5c23df h1:n7WqCuqOuCbNr617RXOY0AWRXxgwEyPp2z+p0+hgMuE=
gopkg.in/gomail.v2 v2.0.0-20160411212932-81ebce5c23df/go.mod h1:LRQQ+SO6ZHR7tOkpBDuZnXENFzX8qRjMDMyPD6BRkCw=
gopkg.in/yaml.v2 v2.2.2 h1:ZCJp+EgiOT7lHqUV2J862kp8Qj64Jo6az82+3Td9dZw=
gopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
",CWE-918,117.0,1
"package main
/*
gophish - Open-Source Phishing Framework
The MIT License (MIT)
Copyright (c) 2013 Jordan Wright
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the ""Software""), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/
import (
	""fmt""
	""io/ioutil""
	""os""
	""os/signal""
	""gopkg.in/alecthomas/kingpin.v2""
	""github.com/gophish/gophish/config""
	""github.com/gophish/gophish/controllers""
	""github.com/gophish/gophish/imap""
	log ""github.com/gophish/gophish/logger""
	""github.com/gophish/gophish/middleware""
	""github.com/gophish/gophish/models""
)
const (
	modeAll   string = ""all""
	modeAdmin string = ""admin""
	modePhish string = ""phish""
)
var (
	configPath    = kingpin.Flag(""config"", ""Location of config.json."").Default(""./config.json"").String()
	disableMailer = kingpin.Flag(""disable-mailer"", ""Disable the mailer (for use with multi-system deployments)"").Bool()
	mode          = kingpin.Flag(""mode"", fmt.Sprintf(""Run the binary in one of the modes (%s, %s or %s)"", modeAll, modeAdmin, modePhish)).
			Default(""all"").Enum(modeAll, modeAdmin, modePhish)
)
func main() {
	// Load the version
	version, err := ioutil.ReadFile(""./VERSION"")
	if err != nil {
		log.Fatal(err)
	}
	kingpin.Version(string(version))
	// Parse the CLI flags and load the config
	kingpin.CommandLine.HelpFlag.Short('h')
	kingpin.Parse()
	// Load the config
	conf, err := config.LoadConfig(*configPath)
	// Just warn if a contact address hasn't been configured
	if err != nil {
		log.Fatal(err)
	}
	if conf.ContactAddress == """" {
		log.Warnf(""No contact address has been configured."")
		log.Warnf(""Please consider adding a contact_address entry in your config.json"")
	}
	config.Version = string(version)
	err = log.Setup(conf.Logging)
	if err != nil {
		log.Fatal(err)
	}
	// Provide the option to disable the built-in mailer
	// Setup the global variables and settings
	err = models.Setup(conf)
	if err != nil {
		log.Fatal(err)
	}
	// Unlock any maillogs that may have been locked for processing
	// when Gophish was last shutdown.
	err = models.UnlockAllMailLogs()
	if err != nil {
		log.Fatal(err)
	}
	// Create our servers
	adminOptions := []controllers.AdminServerOption{}
	if *disableMailer {
		adminOptions = append(adminOptions, controllers.WithWorker(nil))
	}
	adminConfig := conf.AdminConf
	adminServer := controllers.NewAdminServer(adminConfig, adminOptions...)
	middleware.Store.Options.Secure = adminConfig.UseTLS
	phishConfig := conf.PhishConf
	phishServer := controllers.NewPhishingServer(phishConfig)
	imapMonitor := imap.NewMonitor()
	if *mode == ""admin"" || *mode == ""all"" {
		go adminServer.Start()
		go imapMonitor.Start()
	}
	if *mode == ""phish"" || *mode == ""all"" {
		go phishServer.Start()
	}
	// Handle graceful shutdown
	c := make(chan os.Signal, 1)
	signal.Notify(c, os.Interrupt)
	<-c
	log.Info(""CTRL+C Received... Gracefully shutting down servers"")
	if *mode == modeAdmin || *mode == modeAll {
		adminServer.Shutdown()
		imapMonitor.Shutdown()
	}
	if *mode == modePhish || *mode == modeAll {
		phishServer.Shutdown()
	}
}
",CWE-918,136.0,1
"package models
import (
	""fmt""
	""github.com/jinzhu/gorm""
	check ""gopkg.in/check.v1""
)
func (s *ModelsSuite) TestPostSMTP(c *check.C) {
	smtp := SMTP{
		Name:        ""Test SMTP"",
		Host:        ""1.1.1.1:25"",
		FromAddress: ""Foo Bar <foo@example.com>"",
		UserId:      1,
	}
	err := PostSMTP(&smtp)
	c.Assert(err, check.Equals, nil)
	ss, err := GetSMTPs(1)
	c.Assert(err, check.Equals, nil)
	c.Assert(len(ss), check.Equals, 1)
}
func (s *ModelsSuite) TestPostSMTPNoHost(c *check.C) {
	smtp := SMTP{
		Name:        ""Test SMTP"",
		FromAddress: ""Foo Bar <foo@example.com>"",
		UserId:      1,
	}
	err := PostSMTP(&smtp)
	c.Assert(err, check.Equals, ErrHostNotSpecified)
}
func (s *ModelsSuite) TestPostSMTPNoFrom(c *check.C) {
	smtp := SMTP{
		Name:   ""Test SMTP"",
		UserId: 1,
		Host:   ""1.1.1.1:25"",
	}
	err := PostSMTP(&smtp)
	c.Assert(err, check.Equals, ErrFromAddressNotSpecified)
}
func (s *ModelsSuite) TestPostSMTPValidHeader(c *check.C) {
	smtp := SMTP{
		Name:        ""Test SMTP"",
		Host:        ""1.1.1.1:25"",
		FromAddress: ""Foo Bar <foo@example.com>"",
		UserId:      1,
		Headers: []Header{
			Header{Key: ""Reply-To"", Value: ""test@example.com""},
			Header{Key: ""X-Mailer"", Value: ""gophish""},
		},
	}
	err := PostSMTP(&smtp)
	c.Assert(err, check.Equals, nil)
	ss, err := GetSMTPs(1)
	c.Assert(err, check.Equals, nil)
	c.Assert(len(ss), check.Equals, 1)
}
func (s *ModelsSuite) TestSMTPGetDialer(ch *check.C) {
	host := ""localhost""
	port := 25
	smtp := SMTP{
		Host:             fmt.Sprintf(""%s:%d"", host, port),
		IgnoreCertErrors: false,
	}
	d, err := smtp.GetDialer()
	ch.Assert(err, check.Equals, nil)
	dialer := d.(*Dialer).Dialer
	ch.Assert(dialer.Host, check.Equals, host)
	ch.Assert(dialer.Port, check.Equals, port)
	ch.Assert(dialer.TLSConfig.ServerName, check.Equals, host)
	ch.Assert(dialer.TLSConfig.InsecureSkipVerify, check.Equals, smtp.IgnoreCertErrors)
}
func (s *ModelsSuite) TestGetInvalidSMTP(ch *check.C) {
	_, err := GetSMTP(-1, 1)
	ch.Assert(err, check.Equals, gorm.ErrRecordNotFound)
}
",CWE-918,84.0,1
"package webhook
import (
	""bytes""
	""crypto/hmac""
	""crypto/sha256""
	""encoding/hex""
	""encoding/json""
	""errors""
	""fmt""
	""net/http""
	""time""
	log ""github.com/gophish/gophish/logger""
)
const (
	// DefaultTimeoutSeconds is the number of seconds before a timeout occurs
	// when sending a webhook
	DefaultTimeoutSeconds = 10
	// MinHTTPStatusErrorCode is the lower bound of HTTP status codes which
	// indicate an error occurred
	MinHTTPStatusErrorCode = 400
	// SignatureHeader is the name of the HTTP header which contains the
	// webhook signature
	SignatureHeader = ""X-Gophish-Signature""
	// Sha256Prefix is the prefix that specifies the hashing algorithm used
	// for the signature
	Sha256Prefix = ""sha256""
)
// Sender represents a type which can send webhooks to an EndPoint
type Sender interface {
	Send(endPoint EndPoint, data interface{}) error
}
type defaultSender struct {
	client *http.Client
}
var senderInstance = &defaultSender{
	client: &http.Client{
		Timeout: time.Second * DefaultTimeoutSeconds,
		CheckRedirect: func(req *http.Request, via []*http.Request) error {
			return http.ErrUseLastResponse
		},
	},
}
// EndPoint represents a URL to send the webhook to, as well as a secret used
// to sign the event
type EndPoint struct {
	URL    string
	Secret string
}
// Send sends data to a single EndPoint
func Send(endPoint EndPoint, data interface{}) error {
	return senderInstance.Send(endPoint, data)
}
// SendAll sends data to multiple EndPoints
func SendAll(endPoints []EndPoint, data interface{}) {
	for _, e := range endPoints {
		go func(e EndPoint) {
			senderInstance.Send(e, data)
		}(e)
	}
}
// Send contains the implementation of sending webhook to an EndPoint
func (ds defaultSender) Send(endPoint EndPoint, data interface{}) error {
	jsonData, err := json.Marshal(data)
	if err != nil {
		log.Error(err)
		return err
	}
	req, err := http.NewRequest(""POST"", endPoint.URL, bytes.NewBuffer(jsonData))
	if err != nil {
		log.Error(err)
		return err
	}
	signat, err := sign(endPoint.Secret, jsonData)
	if err != nil {
		log.Error(err)
		return err
	}
	req.Header.Set(SignatureHeader, fmt.Sprintf(""%s=%s"", Sha256Prefix, signat))
	req.Header.Set(""Content-Type"", ""application/json"")
	resp, err := ds.client.Do(req)
	if err != nil {
		log.Error(err)
		return err
	}
	defer resp.Body.Close()
	if resp.StatusCode >= MinHTTPStatusErrorCode {
		errMsg := fmt.Sprintf(""http status of response: %s"", resp.Status)
		log.Error(errMsg)
		return errors.New(errMsg)
	}
	return nil
}
func sign(secret string, data []byte) (string, error) {
	hash1 := hmac.New(sha256.New, []byte(secret))
	_, err := hash1.Write(data)
	if err != nil {
		return """", err
	}
	hexStr := hex.EncodeToString(hash1.Sum(nil))
	return hexStr, nil
}
",CWE-918,119.0,1
"package middleware
import (
	""encoding/json""
	""fmt""
	""net/http""
	""strings""
	ctx ""github.com/gophish/gophish/context""
	""github.com/gophish/gophish/models""
	""github.com/gorilla/csrf""
)
// CSRFExemptPrefixes are a list of routes that are exempt from CSRF protection
var CSRFExemptPrefixes = []string{
	""/api"",
}
// CSRFExceptions is a middleware that prevents CSRF checks on routes listed in
// CSRFExemptPrefixes.
func CSRFExceptions(handler http.Handler) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		for _, prefix := range CSRFExemptPrefixes {
			if strings.HasPrefix(r.URL.Path, prefix) {
				r = csrf.UnsafeSkipCheck(r)
				break
			}
		}
		handler.ServeHTTP(w, r)
	}
}
// Use allows us to stack middleware to process the request
// Example taken from https://github.com/gorilla/mux/pull/36
func Use(handler http.HandlerFunc, mid ...func(http.Handler) http.HandlerFunc) http.HandlerFunc {
	for _, m := range mid {
		handler = m(handler)
	}
	return handler
}
// GetContext wraps each request in a function which fills in the context for a given request.
// This includes setting the User and Session keys and values as necessary for use in later functions.
func GetContext(handler http.Handler) http.HandlerFunc {
	// Set the context here
	return func(w http.ResponseWriter, r *http.Request) {
		// Parse the request form
		err := r.ParseForm()
		if err != nil {
			http.Error(w, ""Error parsing request"", http.StatusInternalServerError)
		}
		// Set the context appropriately here.
		// Set the session
		session, _ := Store.Get(r, ""gophish"")
		// Put the session in the context so that we can
		// reuse the values in different handlers
		r = ctx.Set(r, ""session"", session)
		if id, ok := session.Values[""id""]; ok {
			u, err := models.GetUser(id.(int64))
			if err != nil {
				r = ctx.Set(r, ""user"", nil)
			} else {
				r = ctx.Set(r, ""user"", u)
			}
		} else {
			r = ctx.Set(r, ""user"", nil)
		}
		handler.ServeHTTP(w, r)
		// Remove context contents
		ctx.Clear(r)
	}
}
// RequireAPIKey ensures that a valid API key is set as either the api_key GET
// parameter, or a Bearer token.
func RequireAPIKey(handler http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set(""Access-Control-Allow-Origin"", ""*"")
		if r.Method == ""OPTIONS"" {
			w.Header().Set(""Access-Control-Allow-Methods"", ""POST, GET, OPTIONS"")
			w.Header().Set(""Access-Control-Max-Age"", ""1000"")
			w.Header().Set(""Access-Control-Allow-Headers"", ""Origin, X-Requested-With, Content-Type, Accept"")
			return
		}
		r.ParseForm()
		ak := r.Form.Get(""api_key"")
		// If we can't get the API key, we'll also check for the
		// Authorization Bearer token
		if ak == """" {
			tokens, ok := r.Header[""Authorization""]
			if ok && len(tokens) >= 1 {
				ak = tokens[0]
				ak = strings.TrimPrefix(ak, ""Bearer "")
			}
		}
		if ak == """" {
			JSONError(w, http.StatusUnauthorized, ""API Key not set"")
			return
		}
		u, err := models.GetUserByAPIKey(ak)
		if err != nil {
			JSONError(w, http.StatusUnauthorized, ""Invalid API Key"")
			return
		}
		r = ctx.Set(r, ""user"", u)
		r = ctx.Set(r, ""user_id"", u.Id)
		r = ctx.Set(r, ""api_key"", ak)
		handler.ServeHTTP(w, r)
	})
}
// RequireLogin checks to see if the user is currently logged in.
// If not, the function returns a 302 redirect to the login page.
func RequireLogin(handler http.Handler) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		if u := ctx.Get(r, ""user""); u != nil {
			// If a password change is required for the user, then redirect them
			// to the login page
			currentUser := u.(models.User)
			if currentUser.PasswordChangeRequired && r.URL.Path != ""/reset_password"" {
				q := r.URL.Query()
				q.Set(""next"", r.URL.Path)
				http.Redirect(w, r, fmt.Sprintf(""/reset_password?%s"", q.Encode()), http.StatusTemporaryRedirect)
				return
			}
			handler.ServeHTTP(w, r)
			return
		}
		q := r.URL.Query()
		q.Set(""next"", r.URL.Path)
		http.Redirect(w, r, fmt.Sprintf(""/login?%s"", q.Encode()), http.StatusTemporaryRedirect)
	}
}
// EnforceViewOnly is a global middleware that limits the ability to edit
// objects to accounts with the PermissionModifyObjects permission.
func EnforceViewOnly(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// If the request is for any non-GET HTTP method, e.g. POST, PUT,
		// or DELETE, we need to ensure the user has the appropriate
		// permission.
		if r.Method != http.MethodGet && r.Method != http.MethodHead && r.Method != http.MethodOptions {
			user := ctx.Get(r, ""user"").(models.User)
			access, err := user.HasPermission(models.PermissionModifyObjects)
			if err != nil {
				http.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
				return
			}
			if !access {
				http.Error(w, http.StatusText(http.StatusForbidden), http.StatusForbidden)
				return
			}
		}
		next.ServeHTTP(w, r)
	})
}
// RequirePermission checks to see if the user has the requested permission
// before executing the handler. If the request is unauthorized, a JSONError
// is returned.
func RequirePermission(perm string) func(http.Handler) http.HandlerFunc {
	return func(next http.Handler) http.HandlerFunc {
		return func(w http.ResponseWriter, r *http.Request) {
			user := ctx.Get(r, ""user"").(models.User)
			access, err := user.HasPermission(perm)
			if err != nil {
				JSONError(w, http.StatusInternalServerError, err.Error())
				return
			}
			if !access {
				JSONError(w, http.StatusForbidden, http.StatusText(http.StatusForbidden))
				return
			}
			next.ServeHTTP(w, r)
		}
	}
}
// JSONError returns an error in JSON format with the given
// status code and message
func JSONError(w http.ResponseWriter, c int, m string) {
	cj, _ := json.MarshalIndent(models.Response{Success: false, Message: m}, """", ""  "")
	w.Header().Set(""Content-Type"", ""application/json"")
	w.WriteHeader(c)
	fmt.Fprintf(w, ""%s"", cj)
}
",CWE-1021,187.0,1
"package platform
import (
	""os""
	""github.com/dropbox/godropbox/errors""
	""github.com/hectane/go-acl""
	""github.com/pritunl/pritunl-client-electron/service/errortypes""
	""golang.org/x/sys/windows""
)
func MkdirSecure(pth string) (err error) {
	err = os.MkdirAll(pth, 0755)
	if err != nil {
		err = &errortypes.WriteError{
			errors.Wrap(err, ""utils: Failed to create directory""),
		}
		return
	}
	err = acl.Apply(
		pth,
		true,
		false,
		acl.GrantName(windows.GENERIC_ALL, ""CREATOR OWNER""),
		acl.GrantName(windows.GENERIC_ALL, ""SYSTEM""),
		acl.GrantName(windows.GENERIC_ALL, ""Administrators""),
	)
	if err != nil {
		err = &errortypes.WriteError{
			errors.Wrap(err, ""utils: Failed to acl directory""),
		}
		return
	}
	return
}
",CWE-269,38.0,1
"// +build !windows
package errors
import ""syscall""
// Abort will terminate & sends SIGTERM to process
func Abort(i ...int) {
	pgid, err := syscall.Getpgid(syscall.Getpid())
	if err != nil {
		Exit(err.Error())
	}
	// nolint:errcheck
	syscall.Kill(-pgid, syscall.SIGTERM)
}
",CWE-476,17.0,1
"module github.com/fleetdm/fleet
go 1.12
require (
	cloud.google.com/go v0.37.4
	github.com/AbGuthrie/goquery/v2 v2.0.1
	github.com/VividCortex/gohistogram v1.0.0 // indirect
	github.com/VividCortex/mysqlerr v0.0.0-20170204212430-6c6b55f8796f
	github.com/WatchBeam/clock v0.0.0-20170901150240-b08e6b4da7ea
	github.com/aws/aws-sdk-go v1.26.8
	github.com/beevik/etree v1.1.0
	github.com/bmizerany/assert v0.0.0-20160611221934-b7ed37b82869
	github.com/briandowns/spinner v0.0.0-20170614154858-48dbb65d7bd5
	github.com/cenkalti/backoff/v4 v4.0.0
	github.com/cpuguy83/go-md2man/v2 v2.0.0 // indirect
	github.com/davecgh/go-spew v1.1.1
	github.com/dgrijalva/jwt-go v3.2.0+incompatible
	github.com/e-dard/netbug v0.0.0-20151029172837-e64d308a0b20
	github.com/elazarl/go-bindata-assetfs v1.0.0
	github.com/fatih/color v1.7.0 // indirect
	github.com/ghodss/yaml v1.0.0
	github.com/go-kit/kit v0.8.0
	github.com/go-sql-driver/mysql v1.5.0
	github.com/gomodule/redigo v2.0.0+incompatible
	github.com/google/uuid v0.0.0-20161128191214-064e2069ce9c
	github.com/gorilla/mux v1.6.2
	github.com/gorilla/websocket v1.4.2
	github.com/gosuri/uilive v0.0.4
	github.com/hashicorp/golang-lru v0.5.1 // indirect
	github.com/hashicorp/hcl v0.0.0-20180404174102-ef8a98b0bbce // indirect
	github.com/igm/sockjs-go v3.0.0+incompatible
	github.com/igm/sockjs-go/v3 v3.0.0
	github.com/inconshreveable/mousetrap v1.0.0 // indirect
	github.com/jmoiron/sqlx v0.0.0-20180406164412-2aeb6a910c2b
	github.com/kolide/goose v0.0.0-20181015214854-7aebd1deb5ab
	github.com/kolide/kit v0.0.0-20180421083548-36eb8dc43916
	github.com/kolide/launcher v0.0.0-20180427153757-cb412b945cf7
	github.com/kolide/osquery-go v0.0.0-20190904034940-a74aa860032d
	github.com/lib/pq v1.2.0 // indirect
	github.com/magiconair/properties v1.7.6 // indirect
	github.com/mattn/go-isatty v0.0.12 // indirect
	github.com/mattn/go-runewidth v0.0.8 // indirect
	github.com/mattn/go-sqlite3 v1.11.0 // indirect
	github.com/mitchellh/mapstructure v0.0.0-20180220230111-00c29f56e238 // indirect
	github.com/mixer/clock v0.0.0-20200713181918-dd2ce6ac2af6
	github.com/olekukonko/tablewriter v0.0.0-20180506121414-d4647c9c7a84
	github.com/patrickmn/sortutil v0.0.0-20120526081524-abeda66eb583
	github.com/pelletier/go-toml v1.1.0 // indirect
	github.com/pkg/errors v0.8.1
	github.com/pressly/goose v2.6.0+incompatible
	github.com/prometheus/client_golang v0.9.3-0.20190127221311-3c4408c8b829
	github.com/russellhaering/gosaml2 v0.3.1
	github.com/russellhaering/goxmldsig v0.0.0-20180430223755-7acd5e4a6ef7
	github.com/spf13/afero v1.1.0 // indirect
	github.com/spf13/cast v1.2.0
	github.com/spf13/cobra v0.0.2
	github.com/spf13/jwalterweatherman v0.0.0-20180109140146-7c0cea34c8ec // indirect
	github.com/spf13/pflag v1.0.1 // indirect
	github.com/spf13/viper v1.0.2
	github.com/stretchr/testify v1.5.1
	github.com/urfave/cli v1.22.4
	go.opencensus.io v0.20.2 // indirect
	golang.org/x/crypto v0.0.0-20200622213623-75b288015ac9
	golang.org/x/oauth2 v0.0.0-20190402181905-9f3314589c9a // indirect
	golang.org/x/tools v0.0.0-20201102212025-f46e4245211d // indirect
	google.golang.org/api v0.3.2 // indirect
	google.golang.org/grpc v1.19.0
	gopkg.in/guregu/null.v3 v3.4.0
	gopkg.in/natefinch/lumberjack.v2 v2.0.0-20170531160350-a96e63847dc3
	gopkg.in/yaml.v2 v2.2.2
)
",CWE-290,73.0,1
"package fleet
const (
	// ActionRead refers to reading an entity.
	ActionRead = ""read""
	// ActionList refers to listing an entity.
	ActionList = ""list""
	// ActionWrite refers to writing (CRUD operations) an entity.
	ActionWrite = ""write""
	// ActionWriteRole is a write to a user's global roles and teams.
	ActionWriteRole = ""write_role""
	// ActionChangePassword is the permission to change a user's password. While
	// the Write action allows setting the password on creation of a user, the
	// ChangePassword action is required to modify an existing user's password.
	ActionChangePassword = ""change_password""
	// ActionRun is the action for running a live query.
	ActionRun = ""run""
	// ActionRunNew is the action for running a new live query.
	ActionRunNew = ""run_new""
)
",CWE-863,21.0,1
"package fleet
import (
	""errors""
)
type PackListOptions struct {
	ListOptions
	// IncludeSystemPacks will include Global & Team Packs while listing packs
	IncludeSystemPacks bool
}
// Pack is the structure which represents an osquery query pack.
type Pack struct {
	UpdateCreateTimestamps
	ID          uint     `json:""id""`
	Name        string   `json:""name""`
	Description string   `json:""description,omitempty""`
	Platform    string   `json:""platform,omitempty""`
	Disabled    bool     `json:""disabled""`
	Type        *string  `json:""type"" db:""pack_type""`
	Labels      []Target `json:""labels""`
	LabelIDs    []uint   `json:""label_ids""`
	Hosts       []Target `json:""hosts""`
	HostIDs     []uint   `json:""host_ids""`
	Teams       []Target `json:""teams""`
	TeamIDs     []uint   `json:""team_ids""`
}
// Verify verifies the pack's fields are valid.
func (p *Pack) Verify() error {
	if emptyString(p.Name) {
		return errPackEmptyName
	}
	return nil
}
// EditablePackType only returns true when the pack doesn't have a specific Type set, only nil & empty string Pack.Type
// is editable https://github.com/fleetdm/fleet/issues/1485
func (p *Pack) EditablePackType() bool {
	return p != nil && (p.Type == nil || (p.Type != nil && *p.Type == """"))
}
func (p Pack) AuthzType() string {
	return ""pack""
}
const (
	PackKind = ""pack""
)
// PackPayload is the struct which is used to create/update packs.
type PackPayload struct {
	Name        *string `json:""name""`
	Description *string `json:""description""`
	Platform    *string `json:""platform""`
	Disabled    *bool   `json:""disabled""`
	HostIDs     *[]uint `json:""host_ids""`
	LabelIDs    *[]uint `json:""label_ids""`
	TeamIDs     *[]uint `json:""team_ids""`
}
var errPackEmptyName = errors.New(""pack name cannot be empty"")
// Verify verifies the pack's payload fields are valid.
func (p *PackPayload) Verify() error {
	if p.Name != nil {
		if emptyString(*p.Name) {
			return errPackEmptyName
		}
	}
	return nil
}
type PackSpec struct {
	ID          uint            `json:""id,omitempty""`
	Name        string          `json:""name""`
	Description string          `json:""description,omitempty""`
	Platform    string          `json:""platform,omitempty""`
	Disabled    bool            `json:""disabled""`
	Targets     PackSpecTargets `json:""targets,omitempty""`
	Queries     []PackSpecQuery `json:""queries,omitempty""`
}
// Verify verifies the pack's spec fields are valid.
func (p *PackSpec) Verify() error {
	if emptyString(p.Name) {
		return errPackEmptyName
	}
	return nil
}
type PackSpecTargets struct {
	Labels []string `json:""labels""`
	Teams  []string `json:""teams""`
}
type PackSpecQuery struct {
	QueryName   string  `json:""query"" db:""query_name""`
	Name        string  `json:""name""`
	Description string  `json:""description""`
	Interval    uint    `json:""interval""`
	Snapshot    *bool   `json:""snapshot,omitempty""`
	Removed     *bool   `json:""removed,omitempty""`
	Shard       *uint   `json:""shard,omitempty""`
	Platform    *string `json:""platform,omitempty""`
	Version     *string `json:""version,omitempty""`
	Denylist    *bool   `json:""denylist,omitempty""`
}
// PackTarget targets a pack to a host, label, or team.
type PackTarget struct {
	ID     uint `db:""id"" json:""-""`
	PackID uint `db:""pack_id"" json:""-""`
	Target
}
type PackStats struct {
	PackID   uint   `json:""pack_id""`
	PackName string `json:""pack_name""`
	// Type indicates the type of the pack:
	//	- ""global"" is the type of the global pack.
	//	- ""team-$ID"" is returned for team packs.
	//	- ""pack"" means it is a user created pack.
	Type       string                `json:""type""`
	QueryStats []ScheduledQueryStats `json:""query_stats""`
}
",CWE-863,129.0,1
"package fleet
import ""time""
type SoftwareCVE struct {
	CVE         string `json:""cve"" db:""cve""`
	DetailsLink string `json:""details_link"" db:""details_link""`
}
// Software is a named and versioned piece of software installed on a device.
type Software struct {
	ID uint `json:""id"" db:""id""`
	// Name is the reported name.
	Name string `json:""name"" db:""name""`
	// Version is reported version.
	Version string `json:""version"" db:""version""`
	// BundleIdentifier is the CFBundleIdentifier label from the info properties
	BundleIdentifier string `json:""bundle_identifier,omitempty"" db:""bundle_identifier""`
	// Source is the source of the data (osquery table name).
	Source string `json:""source"" db:""source""`
	// Release is the version of the OS this software was released on
	// (e.g. ""30.el7"" for a CentOS package).
	Release string `json:""release,omitempty"" db:""release""`
	// Vendor is the supplier of the software (e.g. ""CentOS"").
	Vendor string `json:""vendor,omitempty"" db:""vendor""`
	// Arch is the architecture of the software (e.g. ""x86_64"").
	Arch string `json:""arch,omitempty"" db:""arch""`
	// GenerateCPE is the CPE23 string that corresponds to the current software
	GenerateCPE string `json:""generated_cpe"" db:""generated_cpe""`
	// Vulnerabilities lists all the found CVEs for the CPE
	Vulnerabilities VulnerabilitiesSlice `json:""vulnerabilities""`
	// HostsCount indicates the number of hosts with that software, filled only
	// if explicitly requested.
	HostsCount int `json:""hosts_count,omitempty"" db:""hosts_count""`
	// CountsUpdatedAt is the timestamp when the hosts count was last updated
	// for that software, filled only if hosts count is requested.
	CountsUpdatedAt time.Time `json:""-"" db:""counts_updated_at""`
}
func (Software) AuthzType() string {
	return ""software""
}
type VulnerabilitiesSlice []SoftwareCVE
// HostSoftware is the set of software installed on a specific host
type HostSoftware struct {
	// Software is the software information.
	Software []Software `json:""software,omitempty"" csv:""-""`
	// Modified is a boolean indicating whether this has been modified since
	// loading. If Modified is true, datastore implementations should save the
	// data. We track this here because saving the software set is likely to be
	// an expensive operation.
	Modified bool `json:""-"" csv:""-""`
}
type SoftwareIterator interface {
	Next() bool
	Value() (*Software, error)
	Err() error
	Close() error
}
type SoftwareListOptions struct {
	ListOptions
	TeamID         *uint `query:""team_id,optional""`
	VulnerableOnly bool  `query:""vulnerable,optional""`
	SkipLoadingCVEs bool
	// WithHostCounts indicates that the list of software should include the
	// counts of hosts per software, and include only those software that have
	// a count of hosts > 0.
	WithHostCounts bool
}
",CWE-863,79.0,1
"package service
import (
	""context""
	""testing""
	""github.com/fleetdm/fleet/v4/server/authz""
	""github.com/fleetdm/fleet/v4/server/fleet""
	""github.com/fleetdm/fleet/v4/server/mock""
	""github.com/fleetdm/fleet/v4/server/test""
	""github.com/stretchr/testify/require""
)
func TestListActivities(t *testing.T) {
	ds := new(mock.Store)
	svc := newTestService(t, ds, nil, nil)
	ds.ListActivitiesFunc = func(ctx context.Context, opts fleet.ListOptions) ([]*fleet.Activity, error) {
		return []*fleet.Activity{
			{ID: 1},
			{ID: 2},
		}, nil
	}
	// admin user
	activities, err := svc.ListActivities(test.UserContext(test.UserAdmin), fleet.ListOptions{})
	require.NoError(t, err)
	require.Len(t, activities, 2)
	// anyone can read activities
	activities, err = svc.ListActivities(test.UserContext(test.UserNoRoles), fleet.ListOptions{})
	require.NoError(t, err)
	require.Len(t, activities, 2)
	// no user in context
	_, err = svc.ListActivities(context.Background(), fleet.ListOptions{})
	require.Error(t, err)
	require.Contains(t, err.Error(), authz.ForbiddenErrorMessage)
}
",CWE-863,40.0,1
"package service
import (
	""context""
	""testing""
	""github.com/fleetdm/fleet/v4/server/contexts/viewer""
	""github.com/fleetdm/fleet/v4/server/fleet""
	""github.com/fleetdm/fleet/v4/server/mock""
	""github.com/fleetdm/fleet/v4/server/ptr""
)
func TestGlobalScheduleAuth(t *testing.T) {
	ds := new(mock.Store)
	svc := newTestService(t, ds, nil, nil)
	ds.ListScheduledQueriesInPackWithStatsFunc = func(ctx context.Context, id uint, opts fleet.ListOptions) ([]*fleet.ScheduledQuery, error) {
		return nil, nil
	}
	ds.EnsureGlobalPackFunc = func(ctx context.Context) (*fleet.Pack, error) {
		return &fleet.Pack{}, nil
	}
	ds.NewScheduledQueryFunc = func(ctx context.Context, sq *fleet.ScheduledQuery, opts ...fleet.OptionalArg) (*fleet.ScheduledQuery, error) {
		return sq, nil
	}
	ds.ScheduledQueryFunc = func(ctx context.Context, id uint) (*fleet.ScheduledQuery, error) {
		return &fleet.ScheduledQuery{}, nil
	}
	ds.SaveScheduledQueryFunc = func(ctx context.Context, sq *fleet.ScheduledQuery) (*fleet.ScheduledQuery, error) {
		return sq, nil
	}
	ds.DeleteScheduledQueryFunc = func(ctx context.Context, id uint) error {
		return nil
	}
	testCases := []struct {
		name            string
		user            *fleet.User
		shouldFailWrite bool
		shouldFailRead  bool
	}{
		{
			""global admin"",
			&fleet.User{GlobalRole: ptr.String(fleet.RoleAdmin)},
			false,
			false,
		},
		{
			""global maintainer"",
			&fleet.User{GlobalRole: ptr.String(fleet.RoleMaintainer)},
			false,
			false,
		},
		{
			""global observer"",
			&fleet.User{GlobalRole: ptr.String(fleet.RoleObserver)},
			true,
			true,
		},
		{
			""team admin"",
			&fleet.User{Teams: []fleet.UserTeam{{Team: fleet.Team{ID: 1}, Role: fleet.RoleAdmin}}},
			true,
			false,
		},
		{
			""team maintainer"",
			&fleet.User{Teams: []fleet.UserTeam{{Team: fleet.Team{ID: 1}, Role: fleet.RoleMaintainer}}},
			true,
			false,
		},
		{
			""team observer"",
			&fleet.User{Teams: []fleet.UserTeam{{Team: fleet.Team{ID: 1}, Role: fleet.RoleObserver}}},
			true,
			true,
		},
	}
	for _, tt := range testCases {
		t.Run(tt.name, func(t *testing.T) {
			ctx := viewer.NewContext(context.Background(), viewer.Viewer{User: tt.user})
			_, err := svc.GetGlobalScheduledQueries(ctx, fleet.ListOptions{})
			checkAuthErr(t, tt.shouldFailRead, err)
			_, err = svc.GlobalScheduleQuery(ctx, &fleet.ScheduledQuery{Name: ""query"", QueryName: ""query""})
			checkAuthErr(t, tt.shouldFailWrite, err)
			_, err = svc.ModifyGlobalScheduledQueries(ctx, 1, fleet.ScheduledQueryPayload{})
			checkAuthErr(t, tt.shouldFailWrite, err)
			err = svc.DeleteGlobalScheduledQueries(ctx, 1)
			checkAuthErr(t, tt.shouldFailWrite, err)
		})
	}
}
",CWE-863,97.0,1
"package service
import (
	""context""
	""time""
	""github.com/fleetdm/fleet/v4/server/fleet""
)
/////////////////////////////////////////////////////////////////////////////////
// List
/////////////////////////////////////////////////////////////////////////////////
type listSoftwareRequest struct {
	fleet.SoftwareListOptions
}
type listSoftwareResponse struct {
	CountsUpdatedAt *time.Time       `json:""counts_updated_at""`
	Software        []fleet.Software `json:""software,omitempty""`
	Err             error            `json:""error,omitempty""`
}
func (r listSoftwareResponse) error() error { return r.Err }
func listSoftwareEndpoint(ctx context.Context, request interface{}, svc fleet.Service) (interface{}, error) {
	req := request.(*listSoftwareRequest)
	resp, err := svc.ListSoftware(ctx, req.SoftwareListOptions)
	if err != nil {
		return listSoftwareResponse{Err: err}, nil
	}
	var latest time.Time
	for _, sw := range resp {
		if !sw.CountsUpdatedAt.IsZero() && sw.CountsUpdatedAt.After(latest) {
			latest = sw.CountsUpdatedAt
		}
	}
	listResp := listSoftwareResponse{Software: resp}
	if !latest.IsZero() {
		listResp.CountsUpdatedAt = &latest
	}
	return listResp, nil
}
func (svc Service) ListSoftware(ctx context.Context, opt fleet.SoftwareListOptions) ([]fleet.Software, error) {
	if err := svc.authz.Authorize(ctx, &fleet.Software{}, fleet.ActionRead); err != nil {
		return nil, err
	}
	// default sort order to hosts_count descending
	if opt.OrderKey == """" {
		opt.OrderKey = ""hosts_count""
		opt.OrderDirection = fleet.OrderDescending
	}
	opt.WithHostCounts = true
	return svc.ds.ListSoftware(ctx, opt)
}
/////////////////////////////////////////////////////////////////////////////////
// Count
/////////////////////////////////////////////////////////////////////////////////
type countSoftwareRequest struct {
	fleet.SoftwareListOptions
}
type countSoftwareResponse struct {
	Count int   `json:""count""`
	Err   error `json:""error,omitempty""`
}
func (r countSoftwareResponse) error() error { return r.Err }
func countSoftwareEndpoint(ctx context.Context, request interface{}, svc fleet.Service) (interface{}, error) {
	req := request.(*countSoftwareRequest)
	count, err := svc.CountSoftware(ctx, req.SoftwareListOptions)
	if err != nil {
		return countSoftwareResponse{Err: err}, nil
	}
	return countSoftwareResponse{Count: count}, nil
}
func (svc Service) CountSoftware(ctx context.Context, opt fleet.SoftwareListOptions) (int, error) {
	if err := svc.authz.Authorize(ctx, &fleet.Software{}, fleet.ActionRead); err != nil {
		return 0, err
	}
	return svc.ds.CountSoftware(ctx, opt)
}
",CWE-863,91.0,1
"package service
import (
	""context""
	""testing""
	""github.com/fleetdm/fleet/v4/server/contexts/viewer""
	""github.com/fleetdm/fleet/v4/server/fleet""
	""github.com/fleetdm/fleet/v4/server/mock""
	""github.com/fleetdm/fleet/v4/server/ptr""
	""github.com/stretchr/testify/assert""
	""github.com/stretchr/testify/require""
)
func TestService_ListSoftware(t *testing.T) {
	ds := new(mock.Store)
	var calledWithTeamID *uint
	var calledWithOpt fleet.SoftwareListOptions
	ds.ListSoftwareFunc = func(ctx context.Context, opt fleet.SoftwareListOptions) ([]fleet.Software, error) {
		calledWithTeamID = opt.TeamID
		calledWithOpt = opt
		return []fleet.Software{}, nil
	}
	user := &fleet.User{ID: 3, Email: ""foo@bar.com"", GlobalRole: ptr.String(fleet.RoleObserver)}
	svc := newTestService(t, ds, nil, nil)
	ctx := context.Background()
	ctx = viewer.NewContext(ctx, viewer.Viewer{User: user})
	_, err := svc.ListSoftware(ctx, fleet.SoftwareListOptions{TeamID: ptr.Uint(42), ListOptions: fleet.ListOptions{PerPage: 77, Page: 4}})
	require.NoError(t, err)
	assert.True(t, ds.ListSoftwareFuncInvoked)
	assert.Equal(t, ptr.Uint(42), calledWithTeamID)
	// sort order defaults to hosts_count descending, automatically, if not explicitly provided
	assert.Equal(t, fleet.ListOptions{PerPage: 77, Page: 4, OrderKey: ""hosts_count"", OrderDirection: fleet.OrderDescending}, calledWithOpt.ListOptions)
	assert.True(t, calledWithOpt.WithHostCounts)
	// call again, this time with an explicit sort
	ds.ListSoftwareFuncInvoked = false
	_, err = svc.ListSoftware(ctx, fleet.SoftwareListOptions{TeamID: nil, ListOptions: fleet.ListOptions{PerPage: 11, Page: 2, OrderKey: ""id"", OrderDirection: fleet.OrderAscending}})
	require.NoError(t, err)
	assert.True(t, ds.ListSoftwareFuncInvoked)
	assert.Nil(t, calledWithTeamID)
	assert.Equal(t, fleet.ListOptions{PerPage: 11, Page: 2, OrderKey: ""id"", OrderDirection: fleet.OrderAscending}, calledWithOpt.ListOptions)
	assert.True(t, calledWithOpt.WithHostCounts)
}
",CWE-863,51.0,1
"package service
import (
	""context""
	""github.com/fleetdm/fleet/v4/server/fleet""
	""github.com/fleetdm/fleet/v4/server/ptr""
	""gopkg.in/guregu/null.v3""
)
type getTeamScheduleRequest struct {
	TeamID      uint              `url:""team_id""`
	ListOptions fleet.ListOptions `url:""list_options""`
}
type getTeamScheduleResponse struct {
	Scheduled []scheduledQueryResponse `json:""scheduled""`
	Err       error                    `json:""error,omitempty""`
}
func (r getTeamScheduleResponse) error() error { return r.Err }
func getTeamScheduleEndpoint(ctx context.Context, request interface{}, svc fleet.Service) (interface{}, error) {
	req := request.(*getTeamScheduleRequest)
	resp := getTeamScheduleResponse{Scheduled: []scheduledQueryResponse{}}
	queries, err := svc.GetTeamScheduledQueries(ctx, req.TeamID, req.ListOptions)
	if err != nil {
		return getTeamScheduleResponse{Err: err}, nil
	}
	for _, q := range queries {
		resp.Scheduled = append(resp.Scheduled, scheduledQueryResponse{
			ScheduledQuery: *q,
		})
	}
	return resp, nil
}
func (svc Service) GetTeamScheduledQueries(ctx context.Context, teamID uint, opts fleet.ListOptions) ([]*fleet.ScheduledQuery, error) {
	if err := svc.authz.Authorize(ctx, &fleet.Pack{TeamIDs: []uint{teamID}}, fleet.ActionRead); err != nil {
		return nil, err
	}
	gp, err := svc.ds.EnsureTeamPack(ctx, teamID)
	if err != nil {
		return nil, err
	}
	return svc.ds.ListScheduledQueriesInPackWithStats(ctx, gp.ID, opts)
}
/////////////////////////////////////////////////////////////////////////////////
// Add
/////////////////////////////////////////////////////////////////////////////////
type teamScheduleQueryRequest struct {
	TeamID uint `url:""team_id""`
	fleet.ScheduledQueryPayload
}
type teamScheduleQueryResponse struct {
	Scheduled *fleet.ScheduledQuery `json:""scheduled,omitempty""`
	Err       error                 `json:""error,omitempty""`
}
func (r teamScheduleQueryResponse) error() error { return r.Err }
func uintValueOrZero(v *uint) uint {
	if v == nil {
		return 0
	}
	return *v
}
func nullIntToPtrUint(v *null.Int) *uint {
	if v == nil {
		return nil
	}
	return ptr.Uint(uint(v.ValueOrZero()))
}
func teamScheduleQueryEndpoint(ctx context.Context, request interface{}, svc fleet.Service) (interface{}, error) {
	req := request.(*teamScheduleQueryRequest)
	resp, err := svc.TeamScheduleQuery(ctx, req.TeamID, &fleet.ScheduledQuery{
		QueryID:  uintValueOrZero(req.QueryID),
		Interval: uintValueOrZero(req.Interval),
		Snapshot: req.Snapshot,
		Removed:  req.Removed,
		Platform: req.Platform,
		Version:  req.Version,
		Shard:    nullIntToPtrUint(req.Shard),
	})
	if err != nil {
		return teamScheduleQueryResponse{Err: err}, nil
	}
	_ = resp
	return teamScheduleQueryResponse{
		Scheduled: resp,
	}, nil
}
func (svc Service) TeamScheduleQuery(ctx context.Context, teamID uint, q *fleet.ScheduledQuery) (*fleet.ScheduledQuery, error) {
	if err := svc.authz.Authorize(ctx, &fleet.Pack{TeamIDs: []uint{teamID}}, fleet.ActionWrite); err != nil {
		return nil, err
	}
	gp, err := svc.ds.EnsureTeamPack(ctx, teamID)
	if err != nil {
		return nil, err
	}
	q.PackID = gp.ID
	return svc.unauthorizedScheduleQuery(ctx, q)
}
/////////////////////////////////////////////////////////////////////////////////
// Modify
/////////////////////////////////////////////////////////////////////////////////
type modifyTeamScheduleRequest struct {
	TeamID           uint `url:""team_id""`
	ScheduledQueryID uint `url:""scheduled_query_id""`
	fleet.ScheduledQueryPayload
}
type modifyTeamScheduleResponse struct {
	Scheduled *fleet.ScheduledQuery `json:""scheduled,omitempty""`
	Err       error                 `json:""error,omitempty""`
}
func (r modifyTeamScheduleResponse) error() error { return r.Err }
func modifyTeamScheduleEndpoint(ctx context.Context, request interface{}, svc fleet.Service) (interface{}, error) {
	req := request.(*modifyTeamScheduleRequest)
	resp, err := svc.ModifyTeamScheduledQueries(ctx, req.TeamID, req.ScheduledQueryID, req.ScheduledQueryPayload)
	if err != nil {
		return modifyTeamScheduleResponse{Err: err}, nil
	}
	_ = resp
	return modifyTeamScheduleResponse{}, nil
}
func (svc Service) ModifyTeamScheduledQueries(ctx context.Context, teamID uint, scheduledQueryID uint, query fleet.ScheduledQueryPayload) (*fleet.ScheduledQuery, error) {
	if err := svc.authz.Authorize(ctx, &fleet.Pack{TeamIDs: []uint{teamID}}, fleet.ActionWrite); err != nil {
		return nil, err
	}
	gp, err := svc.ds.EnsureTeamPack(ctx, teamID)
	if err != nil {
		return nil, err
	}
	query.PackID = ptr.Uint(gp.ID)
	return svc.unauthorizedModifyScheduledQuery(ctx, scheduledQueryID, query)
}
/////////////////////////////////////////////////////////////////////////////////
// Delete
/////////////////////////////////////////////////////////////////////////////////
type deleteTeamScheduleRequest struct {
	TeamID           uint `url:""team_id""`
	ScheduledQueryID uint `url:""scheduled_query_id""`
}
type deleteTeamScheduleResponse struct {
	Scheduled *fleet.ScheduledQuery `json:""scheduled,omitempty""`
	Err       error                 `json:""error,omitempty""`
}
func (r deleteTeamScheduleResponse) error() error { return r.Err }
func deleteTeamScheduleEndpoint(ctx context.Context, request interface{}, svc fleet.Service) (interface{}, error) {
	req := request.(*deleteTeamScheduleRequest)
	err := svc.DeleteTeamScheduledQueries(ctx, req.TeamID, req.ScheduledQueryID)
	if err != nil {
		return deleteTeamScheduleResponse{Err: err}, nil
	}
	return deleteTeamScheduleResponse{}, nil
}
func (svc Service) DeleteTeamScheduledQueries(ctx context.Context, teamID uint, scheduledQueryID uint) error {
	if err := svc.authz.Authorize(ctx, &fleet.Pack{TeamIDs: []uint{teamID}}, fleet.ActionWrite); err != nil {
		return err
	}
	return svc.ds.DeleteScheduledQuery(ctx, scheduledQueryID)
}
",CWE-863,188.0,1
"package service
import (
	""context""
	""testing""
	""github.com/fleetdm/fleet/v4/server/contexts/viewer""
	""github.com/fleetdm/fleet/v4/server/fleet""
	""github.com/fleetdm/fleet/v4/server/mock""
	""github.com/fleetdm/fleet/v4/server/ptr""
)
func TestTeamScheduleAuth(t *testing.T) {
	ds := new(mock.Store)
	svc := newTestService(t, ds, nil, nil)
	ds.EnsureTeamPackFunc = func(ctx context.Context, teamID uint) (*fleet.Pack, error) {
		return &fleet.Pack{ID: 999}, nil
	}
	ds.ListScheduledQueriesInPackWithStatsFunc = func(ctx context.Context, id uint, opts fleet.ListOptions) ([]*fleet.ScheduledQuery, error) {
		return nil, nil
	}
	ds.QueryFunc = func(ctx context.Context, id uint) (*fleet.Query, error) {
		return &fleet.Query{}, nil
	}
	ds.ScheduledQueryFunc = func(ctx context.Context, id uint) (*fleet.ScheduledQuery, error) {
		return &fleet.ScheduledQuery{}, nil
	}
	ds.NewScheduledQueryFunc = func(ctx context.Context, sq *fleet.ScheduledQuery, opts ...fleet.OptionalArg) (*fleet.ScheduledQuery, error) {
		return sq, nil
	}
	ds.SaveScheduledQueryFunc = func(ctx context.Context, sq *fleet.ScheduledQuery) (*fleet.ScheduledQuery, error) {
		return sq, nil
	}
	ds.DeleteScheduledQueryFunc = func(ctx context.Context, id uint) error {
		return nil
	}
	testCases := []struct {
		name            string
		user            *fleet.User
		shouldFailWrite bool
		shouldFailRead  bool
	}{
		{
			""global admin"",
			&fleet.User{GlobalRole: ptr.String(fleet.RoleAdmin)},
			false,
			false,
		},
		{
			""global maintainer"",
			&fleet.User{GlobalRole: ptr.String(fleet.RoleMaintainer)},
			false,
			false,
		},
		{
			""global observer"",
			&fleet.User{GlobalRole: ptr.String(fleet.RoleObserver)},
			true,
			true,
		},
		{
			""team admin, belongs to team"",
			&fleet.User{Teams: []fleet.UserTeam{{Team: fleet.Team{ID: 1}, Role: fleet.RoleAdmin}}},
			false,
			false,
		},
		{
			""team maintainer, belongs to team"",
			&fleet.User{Teams: []fleet.UserTeam{{Team: fleet.Team{ID: 1}, Role: fleet.RoleMaintainer}}},
			false,
			false,
		},
		{
			""team observer, belongs to team"",
			&fleet.User{Teams: []fleet.UserTeam{{Team: fleet.Team{ID: 1}, Role: fleet.RoleObserver}}},
			true,
			true,
		},
		{
			""team maintainer, DOES NOT belong to team"",
			&fleet.User{Teams: []fleet.UserTeam{{Team: fleet.Team{ID: 2}, Role: fleet.RoleMaintainer}}},
			true,
			true,
		},
		{
			""team admin, DOES NOT belong to team"",
			&fleet.User{Teams: []fleet.UserTeam{{Team: fleet.Team{ID: 2}, Role: fleet.RoleAdmin}}},
			true,
			true,
		},
		{
			""team observer, DOES NOT belong to team"",
			&fleet.User{Teams: []fleet.UserTeam{{Team: fleet.Team{ID: 2}, Role: fleet.RoleObserver}}},
			true,
			true,
		},
	}
	for _, tt := range testCases {
		t.Run(tt.name, func(t *testing.T) {
			ctx := viewer.NewContext(context.Background(), viewer.Viewer{User: tt.user})
			_, err := svc.GetTeamScheduledQueries(ctx, 1, fleet.ListOptions{})
			checkAuthErr(t, tt.shouldFailRead, err)
			_, err = svc.TeamScheduleQuery(ctx, 1, &fleet.ScheduledQuery{})
			checkAuthErr(t, tt.shouldFailWrite, err)
			_, err = svc.ModifyTeamScheduledQueries(ctx, 1, 99, fleet.ScheduledQueryPayload{})
			checkAuthErr(t, tt.shouldFailWrite, err)
			err = svc.DeleteTeamScheduledQueries(ctx, 1, 1)
			checkAuthErr(t, tt.shouldFailWrite, err)
		})
	}
}
",CWE-863,118.0,1
"// DBDeployer - The MySQL Sandbox
// Copyright © 2006-2020 Giuseppe Maxia
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package common
// This file was generated during build. Do not edit.
// Build time: 2020-12-14 16:00
var VersionDef string = ""1.58.1"" // 2020-12-14
// Compatible version is the version used to mark compatible archives (templates, configuration).
// It is usually major.minor.0, except when we are at version 0.x, when
// every revision may bring incompatibility
var CompatibleVersion string = ""1.58.0"" // 2020-12-11
",CWE-59,27.0,1
"module github.com/datacharmer/dbdeployer
go 1.12
require (
	github.com/alexeyco/simpletable v0.0.0-20180729223640-1fa9009f1080
	github.com/araddon/dateparse v0.0.0-20190622164848-0fb0a474d195
	github.com/dustin/go-humanize v1.0.0
	github.com/go-sql-driver/mysql v1.4.1
	github.com/nightlyone/lockfile v0.0.0-20180618180623-0ad87eef1443
	github.com/pkg/errors v0.8.1
	github.com/spf13/cobra v1.0.0
	github.com/spf13/pflag v1.0.3
	github.com/stretchr/testify v1.4.0 // indirect
	github.com/xi2/xz v0.0.0-20171230120015-48954b6210f8
	golang.org/x/crypto v0.0.0-20191011191535-87dc89f01550
	golang.org/x/sys v0.0.0-20190507160741-ecd444e8653b // indirect
)
",CWE-59,19.0,1
"package native
import (
	""bytes""
	""fmt""
	""text/template""
	types ""github.com/go-vela/types/yaml""
	""github.com/Masterminds/sprig""
	yaml ""gopkg.in/yaml.v2""
)
// Render combines the template with the step in the yaml pipeline.
func Render(tmpl string, s *types.Step) (types.StepSlice, error) {
	buffer := new(bytes.Buffer)
	config := new(types.Build)
	velaFuncs := funcHandler{envs: convertPlatformVars(s.Environment)}
	templateFuncMap := map[string]interface{}{
		""vela"": velaFuncs.returnPlatformVar,
	}
	// parse the template with Masterminds/sprig functions
	//
	// https://pkg.go.dev/github.com/Masterminds/sprig?tab=doc
	t, err := template.New(s.Name).Funcs(sprig.TxtFuncMap()).Funcs(templateFuncMap).Parse(tmpl)
	if err != nil {
		return types.StepSlice{}, fmt.Errorf(""unable to parse template %s: %v"", s.Template.Name, err)
	}
	// apply the variables to the parsed template
	err = t.Execute(buffer, s.Template.Variables)
	if err != nil {
		return types.StepSlice{}, fmt.Errorf(""unable to execute template %s: %v"", s.Template.Name, err)
	}
	// unmarshal the template to the pipeline
	err = yaml.Unmarshal(buffer.Bytes(), config)
	if err != nil {
		return types.StepSlice{}, fmt.Errorf(""unable to unmarshal yaml: %v"", err)
	}
	// ensure all templated steps have template prefix
	for index, newStep := range config.Steps {
		config.Steps[index].Name = fmt.Sprintf(""%s_%s"", s.Name, newStep.Name)
	}
	return config.Steps, nil
}
",CWE-78,52.0,1
"// Copyright (c) 2020 Target Brands, Inc. All rights reserved.
//
// Use of this source code is governed by the LICENSE file in this repository.
package native
import (
	""io/ioutil""
	""testing""
	""github.com/go-vela/types/raw""
	""github.com/google/go-cmp/cmp""
	goyaml ""gopkg.in/yaml.v2""
	""github.com/go-vela/types/yaml""
)
func TestNative_Render(t *testing.T) {
	type args struct {
		velaFile     string
		templateFile string
	}
	tests := []struct {
		name     string
		args     args
		wantFile string
		wantErr  bool
	}{
		{""basic"", args{velaFile: ""testdata/basic/step.yml"", templateFile: ""testdata/basic/tmpl.yml""}, ""testdata/basic/want.yml"", false},
		{""multiline"", args{velaFile: ""testdata/multiline/step.yml"", templateFile: ""testdata/multiline/tmpl.yml""}, ""testdata/multiline/want.yml"", false},
		{""conditional match"", args{velaFile: ""testdata/conditional/step.yml"", templateFile: ""testdata/conditional/tmpl.yml""}, ""testdata/conditional/want.yml"", false},
		{""loop map"", args{velaFile: ""testdata/loop_map/step.yml"", templateFile: ""testdata/loop_map/tmpl.yml""}, ""testdata/loop_map/want.yml"", false},
		{""loop slice"", args{velaFile: ""testdata/loop_slice/step.yml"", templateFile: ""testdata/loop_slice/tmpl.yml""}, ""testdata/loop_slice/want.yml"", false},
		{""platform vars"", args{velaFile: ""testdata/with_vars_plat/step.yml"", templateFile: ""testdata/with_vars_plat/tmpl.yml""}, ""testdata/with_vars_plat/want.yml"", false},
		{""invalid template"", args{velaFile: ""testdata/basic/step.yml"", templateFile: ""testdata/invalid_template.yml""}, """", true},
		{""invalid variable"", args{velaFile: ""testdata/basic/step.yml"", templateFile: ""testdata/invalid_variables.yml""}, """", true},
		{""invalid yml"", args{velaFile: ""testdata/basic/step.yml"", templateFile: ""testdata/invalid.yml""}, """", true},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			sFile, err := ioutil.ReadFile(tt.args.velaFile)
			if err != nil {
				t.Error(err)
			}
			b := &yaml.Build{}
			err = goyaml.Unmarshal(sFile, b)
			if err != nil {
				t.Error(err)
			}
			b.Steps[0].Environment = raw.StringSliceMap{
				""VELA_REPO_FULL_NAME"": ""octocat/hello-world"",
			}
			tmpl, err := ioutil.ReadFile(tt.args.templateFile)
			if err != nil {
				t.Error(err)
			}
			got, err := Render(string(tmpl), b.Steps[0])
			if (err != nil) != tt.wantErr {
				t.Errorf(""Render() error = %v, wantErr %v"", err, tt.wantErr)
				return
			}
			if tt.wantErr != true {
				wFile, err := ioutil.ReadFile(tt.wantFile)
				if err != nil {
					t.Error(err)
				}
				w := &yaml.Build{}
				err = goyaml.Unmarshal(wFile, w)
				if err != nil {
					t.Error(err)
				}
				want := w.Steps
				if diff := cmp.Diff(want, got); diff != """" {
					t.Errorf(""Render() mismatch (-want +got):\n%s"", diff)
				}
			}
		})
	}
}
",CWE-78,85.0,1
"package gateway
import (
	""context""
	""crypto/aes""
	""encoding/binary""
	""fmt""
	""time""
	""github.com/golang/protobuf/ptypes""
	""github.com/jmoiron/sqlx""
	""github.com/pkg/errors""
	log ""github.com/sirupsen/logrus""
	""github.com/brocaar/chirpstack-api/go/v3/common""
	""github.com/brocaar/chirpstack-api/go/v3/gw""
	""github.com/brocaar/chirpstack-network-server/internal/helpers""
	""github.com/brocaar/chirpstack-network-server/internal/logging""
	""github.com/brocaar/chirpstack-network-server/internal/storage""
	""github.com/brocaar/lorawan""
)
// UpdateMetaDataInRxInfoSet updates the gateway meta-data in the
// given rx-info set. It will:
//   - add the gateway location
//   - set the FPGA id if available
//   - decrypt the fine-timestamp (if available and AES key is set)
func UpdateMetaDataInRxInfoSet(ctx context.Context, db sqlx.Queryer, rxInfo []*gw.UplinkRXInfo) error {
	for i := range rxInfo {
		id := helpers.GetGatewayID(rxInfo[i])
		g, err := storage.GetAndCacheGateway(ctx, db, id)
		if err != nil {
			log.WithFields(log.Fields{
				""ctx_id"":     ctx.Value(logging.ContextIDKey),
				""gateway_id"": id,
			}).WithError(err).Error(""get gateway error"")
			continue
		}
		// set gateway location
		rxInfo[i].Location = &common.Location{
			Latitude:  g.Location.Latitude,
			Longitude: g.Location.Longitude,
			Altitude:  g.Altitude,
		}
		var board storage.GatewayBoard
		if int(rxInfo[i].Board) < len(g.Boards) {
			board = g.Boards[int(rxInfo[i].Board)]
		}
		// set FPGA ID
		// this is useful when the AES decryption key is not set as it
		// indicates which key to use for decryption
		if rxInfo[i].FineTimestampType == gw.FineTimestampType_ENCRYPTED && board.FPGAID != nil {
			tsInfo := rxInfo[i].GetEncryptedFineTimestamp()
			if tsInfo == nil {
				log.WithFields(log.Fields{
					""ctx_id"":     ctx.Value(logging.ContextIDKey),
					""gateway_id"": id,
				}).Error(""encrypted_fine_timestamp must not be nil"")
				continue
			}
			if len(tsInfo.FpgaId) == 0 {
				tsInfo.FpgaId = board.FPGAID[:]
			}
		}
		// decrypt fine-timestamp when the AES key is known
		if rxInfo[i].FineTimestampType == gw.FineTimestampType_ENCRYPTED && board.FineTimestampKey != nil {
			tsInfo := rxInfo[i].GetEncryptedFineTimestamp()
			if tsInfo == nil {
				log.WithFields(log.Fields{
					""ctx_id"":     ctx.Value(logging.ContextIDKey),
					""gateway_id"": id,
				}).Error(""encrypted_fine_timestamp must not be nil"")
				continue
			}
			if rxInfo[i].Time == nil {
				log.WithFields(log.Fields{
					""ctx_id"":     ctx.Value(logging.ContextIDKey),
					""gateway_id"": id,
				}).Error(""time must not be nil"")
				continue
			}
			rxTime, err := ptypes.Timestamp(rxInfo[i].Time)
			if err != nil {
				log.WithFields(log.Fields{
					""ctx_id"":     ctx.Value(logging.ContextIDKey),
					""gateway_id"": id,
				}).WithError(err).Error(""get timestamp error"")
			}
			plainTS, err := decryptFineTimestamp(*board.FineTimestampKey, rxTime, *tsInfo)
			if err != nil {
				log.WithFields(log.Fields{
					""ctx_id"":     ctx.Value(logging.ContextIDKey),
					""gateway_id"": id,
				}).WithError(err).Error(""decrypt fine-timestamp error"")
				continue
			}
			rxInfo[i].FineTimestampType = gw.FineTimestampType_PLAIN
			rxInfo[i].FineTimestamp = &gw.UplinkRXInfo_PlainFineTimestamp{
				PlainFineTimestamp: &plainTS,
			}
		}
	}
	return nil
}
func decryptFineTimestamp(key lorawan.AES128Key, rxTime time.Time, ts gw.EncryptedFineTimestamp) (gw.PlainFineTimestamp, error) {
	var plainTS gw.PlainFineTimestamp
	block, err := aes.NewCipher(key[:])
	if err != nil {
		return plainTS, errors.Wrap(err, ""new cipher error"")
	}
	if len(ts.EncryptedNs) != block.BlockSize() {
		return plainTS, fmt.Errorf(""invalid block-size (%d) or ciphertext length (%d)"", block.BlockSize(), len(ts.EncryptedNs))
	}
	ct := make([]byte, block.BlockSize())
	block.Decrypt(ct, ts.EncryptedNs)
	nanoSec := binary.BigEndian.Uint64(ct[len(ct)-8:])
	nanoSec = nanoSec / 32
	if time.Duration(nanoSec) >= time.Second {
		return plainTS, errors.New(""expected fine-timestamp nanosecond remainder must be < 1 second, did you set the correct decryption key?"")
	}
	rxTime = rxTime.Add(time.Duration(nanoSec) * time.Nanosecond)
	plainTS.Time, err = ptypes.TimestampProto(rxTime)
	if err != nil {
		return plainTS, errors.Wrap(err, ""timestamp proto error"")
	}
	return plainTS, nil
}
",CWE-20,147.0,1
"package uplink
import (
	""encoding/hex""
	""fmt""
	""time""
	""github.com/golang/protobuf/proto""
	""github.com/pkg/errors""
	log ""github.com/sirupsen/logrus""
	""github.com/brocaar/chirpstack-api/go/v3/gw""
	""github.com/brocaar/chirpstack-network-server/internal/band""
	""github.com/brocaar/chirpstack-network-server/internal/helpers""
	""github.com/brocaar/chirpstack-network-server/internal/models""
	""github.com/brocaar/chirpstack-network-server/internal/storage""
	""github.com/brocaar/lorawan""
)
// Templates used for generating Redis keys
const (
	CollectKeyTempl     = ""lora:ns:rx:collect:%s""
	CollectLockKeyTempl = ""lora:ns:rx:collect:%s:lock""
)
// collectAndCallOnce collects the package, sleeps the configured duraction and
// calls the callback only once with a slice of packets, sorted by signal
// strength (strongest at index 0). This method exists since multiple gateways
// are able to receive the same packet, but the packet needs to processed
// only once.
// It is safe to collect the same packet received by the same gateway twice.
// Since the underlying storage type is a set, the result will always be a
// unique set per gateway MAC and packet MIC.
func collectAndCallOnce(rxPacket gw.UplinkFrame, callback func(packet models.RXPacket) error) error {
	phyKey := hex.EncodeToString(rxPacket.PhyPayload)
	key := fmt.Sprintf(CollectKeyTempl, phyKey)
	lockKey := fmt.Sprintf(CollectLockKeyTempl, phyKey)
	// this way we can set a really low DeduplicationDelay for testing, without
	// the risk that the set already expired in redis on read
	deduplicationTTL := deduplicationDelay * 2
	if deduplicationTTL < time.Millisecond*200 {
		deduplicationTTL = time.Millisecond * 200
	}
	if err := collectAndCallOncePut(key, deduplicationTTL, rxPacket); err != nil {
		return err
	}
	if locked, err := collectAndCallOnceLocked(lockKey, deduplicationTTL); err != nil || locked {
		// when locked == true, err == nil
		return err
	}
	// wait the configured amount of time, more packets might be received
	// from other gateways
	time.Sleep(deduplicationDelay)
	// collect all packets from the set
	payloads, err := collectAndCallOnceCollect(key)
	if err != nil {
		return errors.Wrap(err, ""get deduplication set members error"")
	}
	if len(payloads) == 0 {
		return errors.New(""zero items in collect set"")
	}
	var out models.RXPacket
	for i, b := range payloads {
		var uplinkFrame gw.UplinkFrame
		if err := proto.Unmarshal(b, &uplinkFrame); err != nil {
			return errors.Wrap(err, ""unmarshal uplink frame error"")
		}
		if uplinkFrame.TxInfo == nil {
			log.Warning(""tx-info of uplink frame is empty, skipping"")
			continue
		}
		if uplinkFrame.RxInfo == nil {
			log.Warning(""rx-info of uplink frame is empty, skipping"")
			continue
		}
		if i == 0 {
			var phy lorawan.PHYPayload
			if err := phy.UnmarshalBinary(uplinkFrame.PhyPayload); err != nil {
				return errors.Wrap(err, ""unmarshal phypayload error"")
			}
			out.PHYPayload = phy
			dr, err := helpers.GetDataRateIndex(true, uplinkFrame.TxInfo, band.Band())
			if err != nil {
				return errors.Wrap(err, ""get data-rate index error"")
			}
			out.DR = dr
		}
		out.TXInfo = uplinkFrame.TxInfo
		out.RXInfoSet = append(out.RXInfoSet, uplinkFrame.RxInfo)
	}
	return callback(out)
}
func collectAndCallOncePut(key string, ttl time.Duration, rxPacket gw.UplinkFrame) error {
	b, err := proto.Marshal(&rxPacket)
	if err != nil {
		return errors.Wrap(err, ""marshal uplink frame error"")
	}
	pipe := storage.RedisClient().TxPipeline()
	pipe.SAdd(key, b)
	pipe.PExpire(key, ttl)
	_, err = pipe.Exec()
	if err != nil {
		return errors.Wrap(err, ""add uplink frame to set error"")
	}
	return nil
}
func collectAndCallOnceLocked(key string, ttl time.Duration) (bool, error) {
	// this way we can set a really low DeduplicationDelay for testing, without
	// the risk that the set already expired in redis on read
	deduplicationTTL := deduplicationDelay * 2
	if deduplicationTTL < time.Millisecond*200 {
		deduplicationTTL = time.Millisecond * 200
	}
	set, err := storage.RedisClient().SetNX(key, ""lock"", ttl).Result()
	if err != nil {
		return false, errors.Wrap(err, ""acquire deduplication lock error"")
	}
	// Set is true when we were able to set the lock, we return true if it
	// was already locked.
	return !set, nil
}
func collectAndCallOnceCollect(key string) ([][]byte, error) {
	pipe := storage.RedisClient().Pipeline()
	val := pipe.SMembers(key)
	pipe.Del(key)
	if _, err := pipe.Exec(); err != nil {
		return nil, errors.Wrap(err, ""get set members error"")
	}
	var out [][]byte
	vals := val.Val()
	for i := range vals {
		out = append(out, []byte(vals[i]))
	}
	return out, nil
}
",CWE-20,161.0,1
"// Copyright (c) Jeevanandam M. (https://github.com/jeevatkm)
// Source code and usage is governed by a MIT style
// license that can be found in the LICENSE file.
package aah
import (
	""bytes""
	""io/ioutil""
	""net/http""
	""net/http/httptest""
	""os""
	""path/filepath""
	""strings""
	""testing""
	""aahframe.work/ahttp""
	""aahframe.work/internal/util""
	""github.com/stretchr/testify/assert""
)
func TestStaticFilesDelivery(t *testing.T) {
	importPath := filepath.Join(testdataBaseDir(), ""webapp1"")
	ts := newTestServer(t, importPath)
	defer ts.Close()
	t.Logf(""Test Server URL [Static Files Delivery]: %s"", ts.URL)
	httpClient := new(http.Client)
	// Static File - /robots.txt
	t.Log(""Static File - /robots.txt"")
	resp, err := httpClient.Get(ts.URL + ""/robots.txt"")
	assert.Nil(t, err)
	assert.Equal(t, 200, resp.StatusCode)
	assert.True(t, strings.Contains(responseBody(resp), ""User-agent: *""))
	assert.Equal(t, ""no-cache, no-store, must-revalidate"", resp.Header.Get(ahttp.HeaderCacheControl))
	// Static File - /assets/css/aah.css
	t.Log(""Static File - /assets/css/aah.css"")
	resp, err = httpClient.Get(ts.URL + ""/assets/css/aah.css"")
	assert.Nil(t, err)
	assert.Equal(t, 200, resp.StatusCode)
	assert.True(t, strings.Contains(responseBody(resp), ""Minimal aah framework application template CSS.""))
	assert.Equal(t, ""no-cache, no-store, must-revalidate"", resp.Header.Get(ahttp.HeaderCacheControl))
	// Directory Listing - /assets
	t.Log(""Directory Listing - /assets"")
	resp, err = httpClient.Get(ts.URL + ""/assets"")
	assert.Nil(t, err)
	assert.Equal(t, 200, resp.StatusCode)
	body := responseBody(resp)
	assert.True(t, strings.Contains(body, ""<title>Listing of /assets/</title>""))
	assert.True(t, strings.Contains(body, ""<h1>Listing of /assets/</h1><hr>""))
	assert.True(t, strings.Contains(body, `<a href=""robots.txt"">robots.txt</a>`))
	assert.Equal(t, """", resp.Header.Get(ahttp.HeaderCacheControl))
	// Static File - /assets/img/aah-framework-logo.png
	t.Log(""Static File - /assets/img/aah-framework-logo.png"")
	resp, err = httpClient.Get(ts.URL + ""/assets/img/aah-framework-logo.png"")
	assert.Nil(t, err)
	assert.Equal(t, 200, resp.StatusCode)
	assert.Equal(t, ""image/png"", resp.Header.Get(ahttp.HeaderContentType))
	assert.Equal(t, ""6990"", resp.Header.Get(ahttp.HeaderContentLength))
	assert.Equal(t, ""no-cache, no-store, must-revalidate"", resp.Header.Get(ahttp.HeaderCacheControl))
	// Static File - /assets/img/notfound/file.txt
	t.Log(""Static File - /assets/img/notfound/file.txt"")
	resp, err = httpClient.Get(ts.URL + ""/assets/img/notfound/file.txt"")
	assert.Nil(t, err)
	assert.Equal(t, 200, resp.StatusCode)
	assert.Equal(t, ""0"", resp.Header.Get(ahttp.HeaderContentLength))
}
func TestStaticDetectContentType(t *testing.T) {
	testcases := []struct {
		label    string
		filename string
		result   string
	}{
		{
			label:    ""svg"",
			filename: ""image1.svg"",
			result:   ""image/svg+xml"",
		},
		{
			label:    ""png"",
			filename: ""image2.png"",
			result:   ""image/png"",
		},
		{
			label:    ""jpg"",
			filename: ""image3.jpg"",
			result:   ""image/jpeg"",
		},
		{
			label:    ""jpeg"",
			filename: ""image4.jpeg"",
			result:   ""image/jpeg"",
		},
		{
			label:    ""pdf"",
			filename: ""file.pdf"",
			result:   ""application/pdf"",
		},
		{
			label:    ""javascript"",
			filename: ""file.js"",
			result:   ""application/javascript; charset=utf-8"",
		},
		{
			label:    ""txt"",
			filename: ""file.txt"",
			result:   ""text/plain; charset=utf-8"",
		},
		{
			label:    ""xml"",
			filename: ""file.xml"",
			result:   ""application/xml; charset=utf-8"",
		},
		{
			label:    ""css"",
			filename: ""file.css"",
			result:   ""text/css; charset=utf-8"",
		},
		{
			label:    ""html"",
			filename: ""file.html"",
			result:   ""text/html; charset=utf-8"",
		},
	}
	for _, tc := range testcases {
		t.Run(tc.label, func(t *testing.T) {
			v, _ := util.DetectFileContentType(tc.filename, nil)
			assert.Equal(t, tc.result, v)
		})
	}
	content, _ := ioutil.ReadFile(filepath.Join(testdataBaseDir(), ""test-image.noext""))
	v, _ := util.DetectFileContentType(""test-image.noext"", bytes.NewReader(content))
	assert.Equal(t, ""image/png"", v)
}
func TestStaticCacheHeader(t *testing.T) {
	sm := staticManager{
		mimeCacheHdrMap: map[string]string{
			""text/css"":               ""public, max-age=604800, proxy-revalidate"",
			""application/javascript"": ""public, max-age=604800, proxy-revalidate"",
			""image/png"":              ""public, max-age=604800, proxy-revalidate"",
		},
		defaultCacheHdr: ""public, max-age=31536000"",
	}
	str := sm.cacheHeader(""application/json"")
	assert.Equal(t, ""public, max-age=31536000"", str)
	str = sm.cacheHeader(""image/png"")
	assert.Equal(t, ""public, max-age=604800, proxy-revalidate"", str)
	str = sm.cacheHeader(""application/json; charset=utf-8"")
	assert.Equal(t, ""public, max-age=31536000"", str)
	str = sm.cacheHeader(""text/css"")
	assert.Equal(t, ""public, max-age=604800, proxy-revalidate"", str)
}
func TestStaticWriteFileError(t *testing.T) {
	importPath := filepath.Join(testdataBaseDir(), ""webapp1"")
	ts := newTestServer(t, importPath)
	defer ts.Close()
	t.Logf(""Test Server URL [Static Write File Error]: %s"", ts.URL)
	sm := ts.app.staticMgr
	req := httptest.NewRequest(ahttp.MethodGet, ""http://localhost:8080/assets/js/myfile.js"", nil)
	w1 := httptest.NewRecorder()
	sm.writeError(ahttp.AcquireResponseWriter(w1), ahttp.AcquireRequest(req), os.ErrPermission)
	assert.Equal(t, ""403 Forbidden"", responseBody(w1.Result()))
	w2 := httptest.NewRecorder()
	sm.writeError(ahttp.AcquireResponseWriter(w2), ahttp.AcquireRequest(req), nil)
	assert.Equal(t, ""500 Internal Server Error"", responseBody(w2.Result()))
}
",CWE-22,186.0,1
"// Copyright (c) Jeevanandam M. (https://github.com/jeevatkm)
// Source code and usage is governed by a MIT style
// license that can be found in the LICENSE file.
package aah
// Version no. of aah framework
const Version = ""0.12.3""
",CWE-22,9.0,1
"github.com/go-macaron/inject v0.0.0-20160627170012-d8a0b8677191 h1:NjHlg70DuOkcAMqgt0+XA+NHwtu66MkTVVgR4fFWbcI=
github.com/go-macaron/inject v0.0.0-20160627170012-d8a0b8677191/go.mod h1:VFI2o2q9kYsC4o7VP1HrEVosiZZTd+MVT3YZx4gqvJw=
github.com/gopherjs/gopherjs v0.0.0-20181017120253-0766667cb4d1/go.mod h1:wJfORRmW1u3UXTncJ5qlYoELFm8eSnnEO6hX4iZ3EWY=
github.com/gopherjs/gopherjs v0.0.0-20181103185306-d547d1d9531e h1:JKmoR8x90Iww1ks85zJ1lfDGgIiMDuIptTOhJq+zKyg=
github.com/gopherjs/gopherjs v0.0.0-20181103185306-d547d1d9531e/go.mod h1:wJfORRmW1u3UXTncJ5qlYoELFm8eSnnEO6hX4iZ3EWY=
github.com/gopherjs/gopherjs v0.0.0-20190430165422-3e4dfb77656c h1:7lF+Vz0LqiRidnzC1Oq86fpX1q/iEv2KJdrCtttYjT4=
github.com/gopherjs/gopherjs v0.0.0-20190430165422-3e4dfb77656c/go.mod h1:wJfORRmW1u3UXTncJ5qlYoELFm8eSnnEO6hX4iZ3EWY=
github.com/jtolds/gls v4.2.1+incompatible/go.mod h1:QJZ7F/aHp+rZTRtaJ1ow/lLfFfVYBRgL+9YlvaHOwJU=
github.com/jtolds/gls v4.20.0+incompatible h1:xdiiI2gbIgH/gLH7ADydsJ1uDOEzR8yvV7C0MuV77Wo=
github.com/jtolds/gls v4.20.0+incompatible/go.mod h1:QJZ7F/aHp+rZTRtaJ1ow/lLfFfVYBRgL+9YlvaHOwJU=
github.com/smartystreets/assertions v0.0.0-20180927180507-b2de0cb4f26d/go.mod h1:OnSkiWE9lh6wB0YB77sQom3nweQdgAjqCqsofrRNTgc=
github.com/smartystreets/assertions v0.0.0-20190116191733-b6c0e53d7304 h1:Jpy1PXuP99tXNrhbq2BaPz9B+jNAvH1JPQQpG/9GCXY=
github.com/smartystreets/assertions v0.0.0-20190116191733-b6c0e53d7304/go.mod h1:OnSkiWE9lh6wB0YB77sQom3nweQdgAjqCqsofrRNTgc=
github.com/smartystreets/assertions v1.0.1 h1:voD4ITNjPL5jjBfgR/r8fPIIBrliWrWHeiJApdr3r4w=
github.com/smartystreets/assertions v1.0.1/go.mod h1:kHHU4qYBaI3q23Pp3VPrmWhuIUrLW/7eUrw0BU5VaoM=
github.com/smartystreets/goconvey v0.0.0-20181108003508-044398e4856c/go.mod h1:XDJAKZRPZ1CvBcN2aX5YOUTYGHki24fSF0Iv48Ibg0s=
github.com/smartystreets/goconvey v0.0.0-20190731233626-505e41936337 h1:WN9BUFbdyOsSH/XohnWpXOlq9NBD5sGAB2FciQMUEe8=
github.com/smartystreets/goconvey v0.0.0-20190731233626-505e41936337/go.mod h1:syvi0/a8iFYH4r/RixwvyeAJjdLS9QV7WQ/tjFTllLA=
github.com/unknwon/com v0.0.0-20190804042917-757f69c95f3e h1:GSGeB9EAKY2spCABz6xOX5DbxZEXolK+nBSvmsQwRjM=
github.com/unknwon/com v0.0.0-20190804042917-757f69c95f3e/go.mod h1:tOOxU81rwgoCLoOVVPHb6T/wt8HZygqH5id+GNnlCXM=
github.com/unknwon/i18n v0.0.0-20190805065654-5c6446a380b6 h1:sRrkJEHtNoaSvyXMbRgofEOX4/3gMiraevQKJdIBhYE=
github.com/unknwon/i18n v0.0.0-20190805065654-5c6446a380b6/go.mod h1:+5rDk6sDGpl3azws3O+f+GpFSyN9GVr0K8cvQLQM2ZQ=
golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=
golang.org/x/crypto v0.0.0-20190701094942-4def268fd1a4 h1:HuIa8hRrWRSrqYzx1qI49NNxhdi2PrY7gxVSq1JjLDc=
golang.org/x/crypto v0.0.0-20190701094942-4def268fd1a4/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=
golang.org/x/net v0.0.0-20190311183353-d8887717615a/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
golang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
golang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20190724013045-ca1201d0de80/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20190804053845-51ab0e2deafa/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
golang.org/x/text v0.3.2 h1:tW2bmiBqwgJj/UpqtC8EpXEZVYOwU0yG4iWbprSVAcs=
golang.org/x/text v0.3.2/go.mod h1:bEr9sfX3Q8Zfm5fL9x+3itogRgK3+ptLWKqgva+5dAk=
golang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
golang.org/x/tools v0.0.0-20190328211700-ab21143f2384/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=
golang.org/x/tools v0.0.0-20190802220118-1d1727260058/go.mod h1:jcCCGcm9btYwXyDqrUWc6MKQKKGJCWEQ3AfLSRIbEuI=
gopkg.in/ini.v1 v1.46.0 h1:VeDZbLYGaupuvIrsYCEOe/L/2Pcs5n7hdO1ZTjporag=
gopkg.in/ini.v1 v1.46.0/go.mod h1:pNLf8WUiyNEtQjuu5G5vTm06TEv9tsIgeAvK8hOrP4k=
gopkg.in/macaron.v1 v1.3.4 h1:HvIscOwxhFhx3swWM/979wh2QMYyuXrNmrF9l+j3HZs=
gopkg.in/macaron.v1 v1.3.4/go.mod h1:/RoHTdC8ALpyJ3+QR36mKjwnT1F1dyYtsGM9Ate6ZFI=
",CWE-601,44.0,1
"// Copyright 2014 The Macaron Authors
//
// Licensed under the Apache License, Version 2.0 (the ""License""): you may
// not use this file except in compliance with the License. You may obtain
// a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations
// under the License.
package i18n
import (
	""net/http""
	""net/http/httptest""
	""testing""
	. ""github.com/smartystreets/goconvey/convey""
	""gopkg.in/macaron.v1""
)
func Test_Version(t *testing.T) {
	Convey(""Check package version"", t, func() {
		So(Version(), ShouldEqual, _VERSION)
	})
}
func Test_I18n(t *testing.T) {
	Convey(""Use i18n middleware"", t, func() {
		Convey(""No langauge"", func() {
			defer func() {
				So(recover(), ShouldNotBeNil)
			}()
			m := macaron.New()
			m.Use(I18n(Options{}))
		})
		Convey(""Languages and names not match"", func() {
			defer func() {
				So(recover(), ShouldNotBeNil)
			}()
			m := macaron.New()
			m.Use(I18n(Options{
				Langs: []string{""en-US""},
			}))
		})
		Convey(""Invalid directory"", func() {
			defer func() {
				So(recover(), ShouldNotBeNil)
			}()
			m := macaron.New()
			m.Use(I18n(Options{
				Directory: ""404"",
				Langs:     []string{""en-US""},
				Names:     []string{""English""},
			}))
		})
		Convey(""With correct options"", func() {
			m := macaron.New()
			m.Use(I18n(Options{
				Files: map[string][]byte{""locale_en-US.ini"": []byte("""")},
				Langs: []string{""en-US""},
				Names: []string{""English""},
			}))
			m.Get(""/"", func() {})
			resp := httptest.NewRecorder()
			req, err := http.NewRequest(""GET"", ""/"", nil)
			So(err, ShouldBeNil)
			m.ServeHTTP(resp, req)
		})
		Convey(""Set by redirect of URL parameter"", func() {
			m := macaron.New()
			m.Use(I18n(Options{
				Langs:    []string{""en-US""},
				Names:    []string{""English""},
				Redirect: true,
			}))
			m.Get(""/"", func() {})
			resp := httptest.NewRecorder()
			req, err := http.NewRequest(""GET"", ""/?lang=en-US"", nil)
			So(err, ShouldBeNil)
			req.RequestURI = ""/?lang=en-US""
			m.ServeHTTP(resp, req)
		})
		Convey(""Set by Accept-Language"", func() {
			m := macaron.New()
			m.Use(I18n(Options{
				Langs: []string{""en-US"", ""zh-CN"", ""it-IT""},
				Names: []string{""English"", ""简体中文"", ""Italiano""},
			}))
			m.Get(""/"", func(l Locale) {
				So(l.Language(), ShouldEqual, ""it-IT"")
			})
			resp := httptest.NewRecorder()
			req, err := http.NewRequest(""GET"", ""/"", nil)
			So(err, ShouldBeNil)
			req.Header.Set(""Accept-Language"", ""it"")
			m.ServeHTTP(resp, req)
		})
		Convey(""Set to default language"", func() {
			m := macaron.New()
			m.Use(I18n(Options{
				Langs: []string{""en-US"", ""zh-CN"", ""it-IT""},
				Names: []string{""English"", ""简体中文"", ""Italiano""},
			}))
			m.Get(""/"", func(l Locale) {
				So(l.Language(), ShouldEqual, ""en-US"")
			})
			resp := httptest.NewRecorder()
			req, err := http.NewRequest(""GET"", ""/"", nil)
			So(err, ShouldBeNil)
			req.Header.Set(""Accept-Language"", ""ru"")
			m.ServeHTTP(resp, req)
		})
	})
}
",CWE-601,133.0,1
"{
  ""name"": ""pixl-class"",
  ""version"": ""1.0.2"",
  ""description"": ""A simple module for creating classes, with inheritance and mixins."",
  ""author"": ""Joseph Huckaby <jhuckaby@gmail.com>"",
  ""homepage"": ""https://github.com/jhuckaby/pixl-class"",
  ""license"": ""MIT"",
  ""main"": ""class.js"",
  ""repository"": {
    ""type"": ""git"",
    ""url"": ""https://github.com/jhuckaby/pixl-class""
  },
  ""bugs"": {
    ""url"": ""https://github.com/jhuckaby/pixl-class/issues""
  },
  ""keywords"": [
    ""oop"",
    ""class""
  ],
  ""dependencies"": {},
  ""devDependencies"": {}
}
",CWE-78,23.0,1
"/*
 * Copyright (c) SAS Institute, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package cpio
import (
	""fmt""
	""io""
	""os""
	""path""
	""github.com/sassoftware/go-rpmutils/fileutil""
)
// Standard set of permission bit masks.
const (
	S_ISUID  = 04000   // Set uid
	S_ISGID  = 02000   // Set gid
	S_ISVTX  = 01000   // Save text (sticky bit)
	S_ISDIR  = 040000  // Directory
	S_ISFIFO = 010000  // FIFO
	S_ISREG  = 0100000 // Regular file
	S_ISLNK  = 0120000 // Symbolic link
	S_ISBLK  = 060000  // Block special file
	S_ISCHR  = 020000  // Character special file
	S_ISSOCK = 0140000 // Socket
)
func Extract(rs io.Reader, dest string) error {
	linkMap := make(map[int][]string)
	stream := NewCpioStream(rs)
	for {
		entry, err := stream.ReadNextEntry()
		if err != nil {
			return err
		}
		if entry.Header.filename == TRAILER {
			break
		}
		target := path.Join(dest, path.Clean(entry.Header.filename))
		parent := path.Dir(target)
		// Create the parent directory if it doesn't exist.
		if _, err := os.Stat(parent); os.IsNotExist(err) {
			if err := os.MkdirAll(parent, 0755); err != nil {
				return err
			}
		}
		// FIXME: Need a makedev implementation in go.
		switch entry.Header.Mode() &^ 07777 {
		case S_ISCHR:
			logger.Debug(""unpacking char device"")
			// FIXME: skipping due to lack of makedev.
			continue
		case S_ISBLK:
			logger.Debug(""unpacking block device"")
			// FIXME: skipping due to lack of makedev.
			continue
		case S_ISDIR:
			logger.Debug(""unpacking dir"")
			m := os.FileMode(entry.Header.Mode()).Perm()
			if err := os.Mkdir(target, m); err != nil && !os.IsExist(err) {
				return err
			}
		case S_ISFIFO:
			logger.Debug(""unpacking named pipe"")
			if err := fileutil.Mkfifo(target, uint32(entry.Header.Mode())); err != nil {
				return err
			}
		case S_ISLNK:
			logger.Debug(""unpacking symlink"")
			buf := make([]byte, entry.Header.c_filesize)
			if _, err := entry.payload.Read(buf); err != nil {
				return err
			}
			if err := os.Symlink(string(buf), target); err != nil {
				return err
			}
		case S_ISREG:
			logger.Debug(""unpacking regular file"")
			// save hardlinks until after the taget is written
			if entry.Header.c_nlink > 1 && entry.Header.c_filesize == 0 {
				logger.Debug(""regular file is a hard link"")
				l, ok := linkMap[entry.Header.c_ino]
				if !ok {
					l = make([]string, 0)
				}
				l = append(l, target)
				linkMap[entry.Header.c_ino] = l
				continue
			}
			// FIXME: Set permissions on files when creating.
			f, err := os.Create(target)
			if err != nil {
				return err
			}
			written, err := io.Copy(f, entry.payload)
			if err != nil {
				return err
			}
			if written != int64(entry.Header.c_filesize) {
				logger.Debugf(""written: %d, filesize: %d"", written, entry.Header.c_filesize)
				return fmt.Errorf(""short write"")
			}
			if err := f.Close(); err != nil {
				return err
			}
			// Create hardlinks after the file content is written.
			if entry.Header.c_nlink > 1 && entry.Header.c_filesize > 0 {
				l, ok := linkMap[entry.Header.c_ino]
				if !ok {
					return fmt.Errorf(""hardlinks missing"")
				}
				for _, t := range l {
					if err := os.Link(target, t); err != nil {
						return err
					}
				}
			}
		default:
			return fmt.Errorf(""unknown file mode 0%o for %s"",
				entry.Header.c_mode, entry.Header.filename)
		}
	}
	return nil
}
",CWE-22,150.0,1
"/*
 * Copyright (c) SAS Institute, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package cpio
import (
	""io/ioutil""
	""os""
	""testing""
	""testing/iotest""
	""github.com/op/go-logging""
)
func TestExtract(t *testing.T) {
	setupLogging()
	f, err := os.Open(""../testdata/foo.cpio"")
	if err != nil {
		t.Fatal(err)
	}
	defer f.Close()
	tmpdir, err := ioutil.TempDir("""", ""cpio"")
	if err != nil {
		t.Fatal(err)
	}
	defer os.RemoveAll(tmpdir)
	logger.Debugf(""using destdir: %s"", tmpdir)
	hf := iotest.HalfReader(f)
	if err := Extract(hf, tmpdir); err != nil {
		t.Fatal(err)
	}
	logger.Debugf(""Test second extract on existing directory using destdir: %s"", tmpdir)
	if f, err = os.Open(""../testdata/foo.cpio""); err != nil {
		t.Fatal(err)
	}
	hf = iotest.HalfReader(f)
	if err := Extract(hf, tmpdir); err != nil {
		t.Fatal(err)
	}
}
var _format = logging.MustStringFormatter(
	`%{color}%{time:15:04:05.000} %{shortfunc} ▶ %{level:.4s} %{id:03x}%{color:reset} %{message}`,
)
func setupLogging() {
	cmdBackend := logging.NewLogBackend(os.Stderr, """", 0)
	cmdLevel := logging.AddModuleLevel(cmdBackend)
	cmdLevel.SetLevel(logging.DEBUG, """")
	logging.SetBackend(cmdLevel)
}
",CWE-22,71.0,1
"/*
 * Copyright (c) SAS Institute, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package rpmutils
import (
	""io/ioutil""
	""os""
	""testing""
	""testing/iotest""
)
func TestReadHeader(t *testing.T) {
	f, err := os.Open(""./testdata/simple-1.0.1-1.i386.rpm"")
	if err != nil {
		t.Fatal(err)
	}
	hdr, err := ReadHeader(iotest.HalfReader(f))
	if err != nil {
		t.Fatal(err)
	}
	if hdr == nil {
		t.Fatal(""no header found"")
	}
	nevra, err := hdr.GetNEVRA()
	if err != nil {
		t.Fatal(err)
	}
	if nevra.Epoch != ""0"" || nevra.Name != ""simple"" || nevra.Version != ""1.0.1"" || nevra.Release != ""1"" || nevra.Arch != ""i386"" {
		t.Fatalf(""incorrect nevra: %s-%s:%s-%s.%s"", nevra.Name, nevra.Epoch, nevra.Version, nevra.Release, nevra.Arch)
	}
	files, err := hdr.GetFiles()
	if err != nil {
		t.Fatal(err)
	}
	if len(files) != 3 {
		t.Fatalf(""incorrect number of files %d"", len(files))
	}
}
func TestPayloadReader(t *testing.T) {
	f, err := os.Open(""./testdata/simple-1.0.1-1.i386.rpm"")
	if err != nil {
		t.Fatal(err)
	}
	rpm, err := ReadRpm(iotest.HalfReader(f))
	if err != nil {
		t.Fatal(err)
	}
	pldr, err := rpm.PayloadReader()
	if err != nil {
		t.Fatal(err)
	}
	hdr, err := pldr.Next()
	if err != nil {
		t.Fatal(err)
	}
	if hdr.Filesize() != 7 {
		t.Fatalf(""wrong file size %d"", hdr.Filesize())
	}
	if hdr.Filename() != ""./config"" {
		t.Fatalf(""wrong file name %s"", hdr.Filename())
	}
}
func TestExpandPayload(t *testing.T) {
	f, err := os.Open(""./testdata/simple-1.0.1-1.i386.rpm"")
	if err != nil {
		t.Fatal(err)
	}
	rpm, err := ReadRpm(iotest.HalfReader(f))
	if err != nil {
		t.Fatal(err)
	}
	tmpdir, err := ioutil.TempDir("""", ""rpmutil"")
	if err != nil {
		t.Fatal(err)
	}
	if err := rpm.ExpandPayload(tmpdir); err != nil {
		t.Fatal(err)
	}
}
",CWE-22,110.0,1
"// Copyright Istio Authors
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package xds
import (
	""context""
	""errors""
	""fmt""
	""strings""
	""google.golang.org/grpc/codes""
	""google.golang.org/grpc/credentials""
	""google.golang.org/grpc/peer""
	""google.golang.org/grpc/status""
	""istio.io/istio/pilot/pkg/features""
	""istio.io/istio/pilot/pkg/model""
	""istio.io/istio/pkg/spiffe""
	""istio.io/pkg/env""
)
var AuthPlaintext = env.RegisterBoolVar(""XDS_AUTH_PLAINTEXT"", false,
	""Authenticate plain text requests - used if Istiod is behind a gateway handling TLS"").Get()
// authenticate authenticates the ADS request using the configured authenticators.
// Returns the validated principals or an error.
// If no authenticators are configured, or if the request is on a non-secure
// stream ( 15010 ) - returns an empty list of principals and no errors.
func (s *DiscoveryServer) authenticate(ctx context.Context) ([]string, error) {
	if !features.XDSAuth {
		return nil, nil
	}
	// Authenticate - currently just checks that request has a certificate signed with the our key.
	// Protected by flag to avoid breaking upgrades - should be enabled in multi-cluster/meshexpansion where
	// XDS is exposed.
	peerInfo, ok := peer.FromContext(ctx)
	if !ok {
		return nil, errors.New(""invalid context"")
	}
	// Not a TLS connection, we will not perform authentication
	// TODO: add a flag to prevent unauthenticated requests ( 15010 )
	// request not over TLS on the insecure port
	if _, ok := peerInfo.AuthInfo.(credentials.TLSInfo); !ok && !AuthPlaintext {
		return nil, nil
	}
	authFailMsgs := []string{}
	for _, authn := range s.Authenticators {
		u, err := authn.Authenticate(ctx)
		// If one authenticator passes, return
		if u != nil && u.Identities != nil && err == nil {
			return u.Identities, nil
		}
		authFailMsgs = append(authFailMsgs, fmt.Sprintf(""Authenticator %s: %v"", authn.AuthenticatorType(), err))
	}
	log.Errorf(""Failed to authenticate client from %s: %s"", peerInfo.Addr.String(), strings.Join(authFailMsgs, ""; ""))
	return nil, errors.New(""authentication failure"")
}
func (s *DiscoveryServer) authorize(con *Connection, identities []string) error {
	if con == nil || con.proxy == nil {
		return nil
	}
	if features.EnableXDSIdentityCheck && identities != nil {
		// TODO: allow locking down, rejecting unauthenticated requests.
		id, err := checkConnectionIdentity(con.proxy, identities)
		if err != nil {
			log.Warnf(""Unauthorized XDS: %v with identity %v: %v"", con.peerAddr, identities, err)
			return status.Newf(codes.PermissionDenied, ""authorization failed: %v"", err).Err()
		}
		con.proxy.VerifiedIdentity = id
	}
	return nil
}
func checkConnectionIdentity(proxy *model.Proxy, identities []string) (*spiffe.Identity, error) {
	for _, rawID := range identities {
		spiffeID, err := spiffe.ParseIdentity(rawID)
		if err != nil {
			continue
		}
		if proxy.ConfigNamespace != """" && spiffeID.Namespace != proxy.ConfigNamespace {
			continue
		}
		if proxy.Metadata.ServiceAccount != """" && spiffeID.ServiceAccount != proxy.Metadata.ServiceAccount {
			continue
		}
		return &spiffeID, nil
	}
	return nil, fmt.Errorf(""no identities (%v) matched %v/%v"", identities, proxy.ConfigNamespace, proxy.Metadata.ServiceAccount)
}
",CWE-863,106.0,1
"// Copyright Istio Authors
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package authenticate
import (
	""fmt""
	""net/http""
	""golang.org/x/net/context""
	""google.golang.org/grpc/credentials""
	""google.golang.org/grpc/peer""
	""istio.io/istio/pkg/security""
	""istio.io/istio/security/pkg/pki/util""
)
const (
	ClientCertAuthenticatorType = ""ClientCertAuthenticator""
)
// ClientCertAuthenticator extracts identities from client certificate.
type ClientCertAuthenticator struct{}
var _ security.Authenticator = &ClientCertAuthenticator{}
func (cca *ClientCertAuthenticator) AuthenticatorType() string {
	return ClientCertAuthenticatorType
}
// Authenticate extracts identities from presented client certificates. This
// method assumes that certificate chain has been properly validated before
// this method is called. In other words, this method does not do certificate
// chain validation itself.
func (cca *ClientCertAuthenticator) Authenticate(ctx context.Context) (*security.Caller, error) {
	peer, ok := peer.FromContext(ctx)
	if !ok || peer.AuthInfo == nil {
		return nil, fmt.Errorf(""no client certificate is presented"")
	}
	if authType := peer.AuthInfo.AuthType(); authType != ""tls"" {
		return nil, fmt.Errorf(""unsupported auth type: %q"", authType)
	}
	tlsInfo := peer.AuthInfo.(credentials.TLSInfo)
	chains := tlsInfo.State.VerifiedChains
	if len(chains) == 0 || len(chains[0]) == 0 {
		return nil, fmt.Errorf(""no verified chain is found"")
	}
	ids, err := util.ExtractIDs(chains[0][0].Extensions)
	if err != nil {
		return nil, err
	}
	return &security.Caller{
		AuthSource: security.AuthSourceClientCertificate,
		Identities: ids,
	}, nil
}
// AuthenticateRequest performs mTLS authentication for http requests. Requires having the endpoints on a listener
// with proper TLS configuration.
func (cca *ClientCertAuthenticator) AuthenticateRequest(req *http.Request) (*security.Caller, error) {
	if req.TLS == nil || req.TLS.VerifiedChains == nil {
		return nil, fmt.Errorf(""no client certificate is presented"")
	}
	chains := req.TLS.VerifiedChains
	if len(chains) == 0 || len(chains[0]) == 0 {
		return nil, fmt.Errorf(""no verified chain is found"")
	}
	ids, err := util.ExtractIDs(chains[0][0].Extensions)
	if err != nil {
		return nil, err
	}
	return &security.Caller{
		AuthSource: security.AuthSourceClientCertificate,
		Identities: ids,
	}, nil
}
",CWE-863,95.0,1
"// Copyright Istio Authors
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package ca
import (
	""fmt""
	""time""
	""golang.org/x/net/context""
	""google.golang.org/grpc""
	""google.golang.org/grpc/codes""
	""google.golang.org/grpc/peer""
	""google.golang.org/grpc/status""
	pb ""istio.io/api/security/v1alpha1""
	""istio.io/istio/pkg/security""
	""istio.io/istio/security/pkg/pki/ca""
	caerror ""istio.io/istio/security/pkg/pki/error""
	""istio.io/istio/security/pkg/pki/util""
	""istio.io/pkg/log""
)
var serverCaLog = log.RegisterScope(""serverca"", ""Citadel server log"", 0)
// CertificateAuthority contains methods to be supported by a CA.
type CertificateAuthority interface {
	// Sign generates a certificate for a workload or CA, from the given CSR and cert opts.
	Sign(csrPEM []byte, opts ca.CertOpts) ([]byte, error)
	// SignWithCertChain is similar to Sign but returns the leaf cert and the entire cert chain.
	SignWithCertChain(csrPEM []byte, opts ca.CertOpts) ([]string, error)
	// GetCAKeyCertBundle returns the KeyCertBundle used by CA.
	GetCAKeyCertBundle() *util.KeyCertBundle
}
// Server implements IstioCAService and IstioCertificateService and provides the services on the
// specified port.
type Server struct {
	pb.UnimplementedIstioCertificateServiceServer
	monitoring     monitoringMetrics
	Authenticators []security.Authenticator
	ca             CertificateAuthority
	serverCertTTL  time.Duration
}
func getConnectionAddress(ctx context.Context) string {
	peerInfo, ok := peer.FromContext(ctx)
	peerAddr := ""unknown""
	if ok {
		peerAddr = peerInfo.Addr.String()
	}
	return peerAddr
}
// CreateCertificate handles an incoming certificate signing request (CSR). It does
// authentication and authorization. Upon validated, signs a certificate that:
// the SAN is the identity of the caller in authentication result.
// the subject public key is the public key in the CSR.
// the validity duration is the ValidityDuration in request, or default value if the given duration is invalid.
// it is signed by the CA signing key.
func (s *Server) CreateCertificate(ctx context.Context, request *pb.IstioCertificateRequest) (
	*pb.IstioCertificateResponse, error,
) {
	s.monitoring.CSR.Increment()
	caller := Authenticate(ctx, s.Authenticators)
	if caller == nil {
		s.monitoring.AuthnError.Increment()
		return nil, status.Error(codes.Unauthenticated, ""request authenticate failure"")
	}
	// TODO: Call authorizer.
	crMetadata := request.Metadata.GetFields()
	certSigner := crMetadata[security.CertSigner].GetStringValue()
	log.Debugf(""cert signer from workload %s"", certSigner)
	_, _, certChainBytes, rootCertBytes := s.ca.GetCAKeyCertBundle().GetAll()
	certOpts := ca.CertOpts{
		SubjectIDs: caller.Identities,
		TTL:        time.Duration(request.ValidityDuration) * time.Second,
		ForCA:      false,
		CertSigner: certSigner,
	}
	var signErr error
	var cert []byte
	var respCertChain []string
	if certSigner == """" {
		cert, signErr = s.ca.Sign([]byte(request.Csr), certOpts)
	} else {
		respCertChain, signErr = s.ca.SignWithCertChain([]byte(request.Csr), certOpts)
	}
	if signErr != nil {
		serverCaLog.Errorf(""CSR signing error (%v)"", signErr.Error())
		s.monitoring.GetCertSignError(signErr.(*caerror.Error).ErrorType()).Increment()
		return nil, status.Errorf(signErr.(*caerror.Error).HTTPErrorCode(), ""CSR signing error (%v)"", signErr.(*caerror.Error))
	}
	if certSigner == """" {
		respCertChain = []string{string(cert)}
		if len(certChainBytes) != 0 {
			respCertChain = append(respCertChain, string(certChainBytes))
		}
	}
	if len(rootCertBytes) != 0 {
		respCertChain = append(respCertChain, string(rootCertBytes))
	}
	response := &pb.IstioCertificateResponse{
		CertChain: respCertChain,
	}
	s.monitoring.Success.Increment()
	serverCaLog.Debug(""CSR successfully signed."")
	return response, nil
}
func recordCertsExpiry(keyCertBundle *util.KeyCertBundle) {
	rootCertExpiry, err := keyCertBundle.ExtractRootCertExpiryTimestamp()
	if err != nil {
		serverCaLog.Errorf(""failed to extract root cert expiry timestamp (error %v)"", err)
	}
	rootCertExpiryTimestamp.Record(rootCertExpiry)
	if len(keyCertBundle.GetCertChainPem()) == 0 {
		return
	}
	certChainExpiry, err := keyCertBundle.ExtractCACertExpiryTimestamp()
	if err != nil {
		serverCaLog.Errorf(""failed to extract CA cert expiry timestamp (error %v)"", err)
	}
	certChainExpiryTimestamp.Record(certChainExpiry)
}
// Register registers a GRPC server on the specified port.
func (s *Server) Register(grpcServer *grpc.Server) {
	pb.RegisterIstioCertificateServiceServer(grpcServer, s)
}
// New creates a new instance of `IstioCAServiceServer`
func New(ca CertificateAuthority, ttl time.Duration,
	authenticators []security.Authenticator,
) (*Server, error) {
	certBundle := ca.GetCAKeyCertBundle()
	if len(certBundle.GetRootCertPem()) != 0 {
		recordCertsExpiry(certBundle)
	}
	server := &Server{
		Authenticators: authenticators,
		serverCertTTL:  ttl,
		ca:             ca,
		monitoring:     newMonitoringMetrics(),
	}
	return server, nil
}
// authenticate goes through a list of authenticators (provided client cert, k8s jwt, and ID token)
// and authenticates if one of them is valid.
func Authenticate(ctx context.Context, auth []security.Authenticator) *security.Caller {
	// TODO: apply different authenticators in specific order / according to configuration.
	var errMsg string
	for id, authn := range auth {
		u, err := authn.Authenticate(ctx)
		if err != nil {
			errMsg += fmt.Sprintf(""Authenticator %s at index %d got error: %v. "", authn.AuthenticatorType(), id, err)
		}
		if u != nil && err == nil {
			serverCaLog.Debugf(""Authentication successful through auth source %v"", u.AuthSource)
			return u
		}
	}
	serverCaLog.Warnf(""Authentication failed for %v: %s"", getConnectionAddress(ctx), errMsg)
	return nil
}
",CWE-863,180.0,1
"module github.com/containers/image/v5
go 1.11
require (
	github.com/14rcole/gopopulate v0.0.0-20180821133914-b175b219e774 // indirect
	github.com/BurntSushi/toml v0.3.1
	github.com/containers/libtrust v0.0.0-20190913040956-14b96171aa3b
	github.com/containers/ocicrypt v0.0.0-20190930154801-b87a4a69c741
	github.com/containers/storage v1.15.5
	github.com/docker/distribution v0.0.0-20170817175659-5f6282db7d65
	github.com/docker/docker v0.0.0-20180522102801-da99009bbb11
	github.com/docker/docker-credential-helpers v0.6.3
	github.com/docker/go-connections v0.0.0-20180212134524-7beb39f0b969
	github.com/docker/libtrust v0.0.0-20160708172513-aabc10ec26b7 // indirect
	github.com/etcd-io/bbolt v1.3.3
	github.com/ghodss/yaml v0.0.0-20161207003320-04f313413ffd
	github.com/gorilla/context v1.1.1 // indirect
	github.com/gorilla/mux v0.0.0-20170217192616-94e7d24fd285 // indirect
	github.com/gotestyourself/gotestyourself v2.2.0+incompatible // indirect
	github.com/imdario/mergo v0.3.8
	github.com/klauspost/compress v1.9.7
	github.com/klauspost/pgzip v1.2.1
	github.com/konsorten/go-windows-terminal-sequences v1.0.2 // indirect
	github.com/kr/pretty v0.1.0 // indirect
	github.com/mattn/go-isatty v0.0.4 // indirect
	github.com/mtrmac/gpgme v0.0.0-20170102180018-b2432428689c
	github.com/opencontainers/go-digest v1.0.0-rc1
	github.com/opencontainers/image-spec v1.0.2-0.20190823105129-775207bd45b6
	github.com/opencontainers/selinux v1.3.0
	github.com/ostreedev/ostree-go v0.0.0-20190702140239-759a8c1ac913
	github.com/pkg/errors v0.9.1
	github.com/pquerna/ffjson v0.0.0-20190813045741-dac163c6c0a9 // indirect
	github.com/sirupsen/logrus v1.4.2
	github.com/stretchr/testify v1.4.0
	github.com/ulikunitz/xz v0.5.6
	github.com/vbatts/tar-split v0.11.1
	github.com/vbauerster/mpb/v4 v4.11.2
	github.com/xeipuuv/gojsonpointer v0.0.0-20190809123943-df4f5c81cb3b // indirect
	github.com/xeipuuv/gojsonschema v0.0.0-20190816131739-be0936907f66
	go.etcd.io/bbolt v1.3.3 // indirect
	golang.org/x/crypto v0.0.0-20191112222119-e1110fd1c708
	golang.org/x/net v0.0.0-20190628185345-da137c7871d7
	golang.org/x/sync v0.0.0-20190423024810-112230192c58
	golang.org/x/sys v0.0.0-20191127021746-63cb32ae39b2
	gopkg.in/check.v1 v1.0.0-20190902080502-41f04d3bba15 // indirect
	k8s.io/client-go v0.0.0-20170217214107-bcde30fb7eae
)
",CWE-416,49.0,1
"package account
import ""github.com/kongchuanhujiao/server/internal/app/datahub/internal/memory""
func GetCode(id string) string {
	return memory.Code[id]
}
func WriteCode(id string, code string) {
	memory.Code[id] = code
}
func DeleteCode(id string) {
	delete(memory.Code, id)
}
",CWE-287,16.0,1
"package account
import (
	""github.com/kongchuanhujiao/server/internal/app/datahub/pkg/account""
	""time""
	""github.com/kongchuanhujiao/server/internal/app/kongchuanhujiao""
	""github.com/kongchuanhujiao/server/internal/pkg/config""
	""github.com/kongchuanhujiao/server/internal/pkg/logger""
	""github.com/iris-contrib/middleware/jwt""
	""go.uber.org/zap""
)
// APIs 账号 APIs
type APIs struct{}
// PostCodeReq 发送验证码 请求结构
type PostCodeReq struct {
	ID string // 标识号
}
// PostCode 发送验证码 APIs。
// 调用方法：POST apis/accounts/code
func (a *APIs) PostCode(v *PostCodeReq) *kongchuanhujiao.Response {
	if err := sendCode(v.ID); err != nil {
		return kongchuanhujiao.GenerateErrResp(1, err.Error())
	}
	return kongchuanhujiao.DefaultSuccResp
}
// ====================================================================================================================
// PostLoginReq 登录验证 请求结构
type PostLoginReq struct {
	ID   string // 标识号
	Code string // 验证码
}
// PostLogin 登录验证 APIs。
// 调用方法：POST apis/accounts/login
func (a *APIs) PostLogin(v *PostLoginReq) *kongchuanhujiao.Response {
	if v.Code != account.GetCode(v.ID) || v.Code == """" { // FIXME datahub 鉴权
		return kongchuanhujiao.GenerateErrResp(1, ""验证码有误"")
	}
	now := time.Now()
	t, err := jwt.NewTokenWithClaims(jwt.SigningMethodES256, jwt.MapClaims{
		""iss"": config.GetJWTConf().Iss,
		""sub"": v.ID,
		""exp"": now.AddDate(0, 1, 0).Unix(),
		""nbf"": now.Unix(),
		""iat"": now.Unix(),
	}).SignedString(config.GetJWTConf().Key)
	if err != nil {
		logger.Error(""生成 JWT Token 失败"", zap.Error(err))
		return kongchuanhujiao.DefaultErrResp
	}
	return &kongchuanhujiao.Response{Message: t}
}
",CWE-287,63.0,1
"package account
import (
	""errors""
	""math/rand""
	""strconv""
	""time""
	""github.com/kongchuanhujiao/server/internal/app/client""
	""github.com/kongchuanhujiao/server/internal/app/client/message""
	""github.com/kongchuanhujiao/server/internal/app/datahub/pkg/account""
	""github.com/kongchuanhujiao/server/internal/pkg/logger""
	""go.uber.org/zap""
)
// sendCode 发送验证码
func sendCode(id string) (err error) {
	a, err := account.SelectAccount(id, 0)
	if err != nil {
		logger.Error(""发送验证码失败"", zap.Error(err))
		return
	}
	if len(a) == 0 {
		return errors.New(""账号不存在"")
	}
	rand.Seed(time.Now().UnixNano())
	c := strconv.FormatFloat(rand.Float64(), 'f', -1, 64)[2:6]
	client.GetClient().SendMessage(
		message.NewTextMessage(""您的验证码是："" + c + ""，请勿泄露给他人。有效期5分钟"").
			SetTarget(&message.Target{ID: a[0].QQ}),
	)
	account.WriteCode(id, c)
	go func() {
		timer := time.NewTimer(5 * time.Minute)
		defer timer.Stop()
		<-timer.C
		account.DeleteCode(id)
	}()
	return
}
",CWE-287,49.0,1
"// Copyright (C) 2015 Audrius Butkevicius and Contributors (see the CONTRIBUTORS file).
package protocol
import (
	""errors""
	""io""
)
const (
	magic        = 0x9E79BC40
	ProtocolName = ""bep-relay""
)
var (
	ResponseSuccess           = Response{0, ""success""}
	ResponseNotFound          = Response{1, ""not found""}
	ResponseAlreadyConnected  = Response{2, ""already connected""}
	ResponseUnexpectedMessage = Response{100, ""unexpected message""}
)
func WriteMessage(w io.Writer, message interface{}) error {
	header := header{
		magic: magic,
	}
	var payload []byte
	var err error
	switch msg := message.(type) {
	case Ping:
		payload, err = msg.MarshalXDR()
		header.messageType = messageTypePing
	case Pong:
		payload, err = msg.MarshalXDR()
		header.messageType = messageTypePong
	case JoinRelayRequest:
		payload, err = msg.MarshalXDR()
		header.messageType = messageTypeJoinRelayRequest
	case JoinSessionRequest:
		payload, err = msg.MarshalXDR()
		header.messageType = messageTypeJoinSessionRequest
	case Response:
		payload, err = msg.MarshalXDR()
		header.messageType = messageTypeResponse
	case ConnectRequest:
		payload, err = msg.MarshalXDR()
		header.messageType = messageTypeConnectRequest
	case SessionInvitation:
		payload, err = msg.MarshalXDR()
		header.messageType = messageTypeSessionInvitation
	case RelayFull:
		payload, err = msg.MarshalXDR()
		header.messageType = messageTypeRelayFull
	default:
		err = errors.New(""unknown message type"")
	}
	if err != nil {
		return err
	}
	header.messageLength = int32(len(payload))
	headerpayload, err := header.MarshalXDR()
	if err != nil {
		return err
	}
	_, err = w.Write(append(headerpayload, payload...))
	return err
}
func ReadMessage(r io.Reader) (interface{}, error) {
	var header header
	buf := make([]byte, header.XDRSize())
	if _, err := io.ReadFull(r, buf); err != nil {
		return nil, err
	}
	if err := header.UnmarshalXDR(buf); err != nil {
		return nil, err
	}
	if header.magic != magic {
		return nil, errors.New(""magic mismatch"")
	}
	buf = make([]byte, int(header.messageLength))
	if _, err := io.ReadFull(r, buf); err != nil {
		return nil, err
	}
	switch header.messageType {
	case messageTypePing:
		var msg Ping
		err := msg.UnmarshalXDR(buf)
		return msg, err
	case messageTypePong:
		var msg Pong
		err := msg.UnmarshalXDR(buf)
		return msg, err
	case messageTypeJoinRelayRequest:
		var msg JoinRelayRequest
		err := msg.UnmarshalXDR(buf)
		return msg, err
	case messageTypeJoinSessionRequest:
		var msg JoinSessionRequest
		err := msg.UnmarshalXDR(buf)
		return msg, err
	case messageTypeResponse:
		var msg Response
		err := msg.UnmarshalXDR(buf)
		return msg, err
	case messageTypeConnectRequest:
		var msg ConnectRequest
		err := msg.UnmarshalXDR(buf)
		return msg, err
	case messageTypeSessionInvitation:
		var msg SessionInvitation
		err := msg.UnmarshalXDR(buf)
		return msg, err
	case messageTypeRelayFull:
		var msg RelayFull
		err := msg.UnmarshalXDR(buf)
		return msg, err
	}
	return nil, errors.New(""unknown message type"")
}
",CWE-20,132.0,1
"/*
 * Copyright 2022 Thoughtworks, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//= link_tree ../images
//= link application.js
//= link lib/d3-3.1.5.min.js
// Used by legacy templates `_header.ftl`
//= link application.css
//= link patterns/application.css
//= link css/application.css
//= link vm/application.css
//= link frameworks.css
//= link new-theme.css
//= link single_page_apps/agents.css
//= link single_page_apps/analytics.css
//= link single_page_apps/new_dashboard.css",CWE-79,33.0,1
"// Copyright 2014-2019 Ulrich Kunitz. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
package xz
import (
	""errors""
	""io""
)
// putUint32LE puts the little-endian representation of x into the first
// four bytes of p.
func putUint32LE(p []byte, x uint32) {
	p[0] = byte(x)
	p[1] = byte(x >> 8)
	p[2] = byte(x >> 16)
	p[3] = byte(x >> 24)
}
// putUint64LE puts the little-endian representation of x into the first
// eight bytes of p.
func putUint64LE(p []byte, x uint64) {
	p[0] = byte(x)
	p[1] = byte(x >> 8)
	p[2] = byte(x >> 16)
	p[3] = byte(x >> 24)
	p[4] = byte(x >> 32)
	p[5] = byte(x >> 40)
	p[6] = byte(x >> 48)
	p[7] = byte(x >> 56)
}
// uint32LE converts a little endian representation to an uint32 value.
func uint32LE(p []byte) uint32 {
	return uint32(p[0]) | uint32(p[1])<<8 | uint32(p[2])<<16 |
		uint32(p[3])<<24
}
// putUvarint puts a uvarint representation of x into the byte slice.
func putUvarint(p []byte, x uint64) int {
	i := 0
	for x >= 0x80 {
		p[i] = byte(x) | 0x80
		x >>= 7
		i++
	}
	p[i] = byte(x)
	return i + 1
}
// errOverflow indicates an overflow of the 64-bit unsigned integer.
var errOverflowU64 = errors.New(""xz: uvarint overflows 64-bit unsigned integer"")
// readUvarint reads a uvarint from the given byte reader.
func readUvarint(r io.ByteReader) (x uint64, n int, err error) {
	var s uint
	i := 0
	for {
		b, err := r.ReadByte()
		if err != nil {
			return x, i, err
		}
		i++
		if b < 0x80 {
			if i > 10 || i == 10 && b > 1 {
				return x, i, errOverflowU64
			}
			return x | uint64(b)<<s, i, nil
		}
		x |= uint64(b&0x7f) << s
		s += 7
	}
}
",CWE-835,75.0,1
"// Copyright 2014-2019 Ulrich Kunitz. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
package xz
import (
	""bytes""
	""testing""
)
func TestUvarint(t *testing.T) {
	tests := []uint64{0, 0x80, 0x100, 0xffffffff, 0x100000000, 1<<64 - 1}
	p := make([]byte, 10)
	for _, u := range tests {
		p = p[:10]
		n := putUvarint(p, u)
		if n < 1 {
			t.Fatalf(""putUvarint returned %d"", n)
		}
		r := bytes.NewReader(p[:n])
		x, m, err := readUvarint(r)
		if err != nil {
			t.Fatalf(""readUvarint returned %s"", err)
		}
		if m != n {
			t.Fatalf(""readUvarint read %d bytes; want %d"", m, n)
		}
		if x != u {
			t.Fatalf(""readUvarint returned 0x%x; want 0x%x"", x, u)
		}
	}
}
",CWE-835,34.0,1
"test interpret
test run
target aarch64
target s390x
set enable_simd
target x86_64 has_sse3 has_ssse3 has_sse41
target x86_64 has_sse3 has_ssse3 has_sse41 has_avx512vl has_avx512vbmi
function %shuffle_i8x16(i8x16, i8x16) -> i8x16 {
block0(v0: i8x16, v1: i8x16):
    v2 = shuffle v0, v1, [3 0 31 26 4 6 12 11 23 13 24 4 2 15 17 5]
    return v2
}
; run: %shuffle_i8x16([1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16], [17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32]) == [4 1 32 27 5 7 13 12 24 14 25 5 3 16 18 6]
function %shuffle_zeros(i8x16, i8x16) -> i8x16 {
block0(v0: i8x16, v1: i8x16):
    v2 = shuffle v0, v1, [3 0 32 255 4 6 12 11 23 13 24 4 2 97 17 5]
    return v2
}
; run: %shuffle_zeros([1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16], [17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32]) == [4 1 0 0 5 7 13 12 24 14 25 5 3 0 18 6]
",CWE-193,22.0,1
"test interpret
test run
target aarch64
target s390x
target x86_64
target x86_64 ssse3
target x86_64 sse41
target x86_64 sse42
target x86_64 sse42 has_avx
target x86_64 sse42 has_avx has_avx2
target x86_64 sse42 has_avx has_avx2 has_avx512f has_avx512vl
target riscv64 has_v
target riscv64 has_v has_c has_zcb
function %sshr_i8x16(i8x16, i32) -> i8x16 {
block0(v0: i8x16, v1: i32):
    v2 = sshr v0, v1
    return v2
}
; run: %sshr_i8x16([0 0xff 2 0xfd 4 0xfb 6 0xf9 8 0xf7 10 0xf5 12 0xf3 14 0xf1], 1) == [0 0xff 1 0xfe 2 0xfd 3 0xfc 4 0xfb 5 0xfa 6 0xf9 7 0xf8]
; run: %sshr_i8x16([0 0xff 2 0xfd 4 0xfb 6 0xf9 8 0xf7 10 0xf5 12 0xf3 14 0xf1], 9) == [0 0xff 1 0xfe 2 0xfd 3 0xfc 4 0xfb 5 0xfa 6 0xf9 7 0xf8]
function %sshr_i16x8(i16x8, i32) -> i16x8 {
block0(v0: i16x8, v1: i32):
    v2 = sshr v0, v1
    return v2
}
; note: because of the shifted-in sign-bit, lane 0 remains -1 == 0xffff, whereas lane 4 has been shifted to -8 == 0xfff8
; run: %sshr_i16x8([-1 2 4 8 -16 32 64 128], 1) == [-1 1 2 4 -8 16 32 64]
; run: %sshr_i16x8([-1 2 4 8 -16 32 64 128], 17) == [-1 1 2 4 -8 16 32 64]
function %sshr_i32x4(i32x4, i32) -> i32x4 {
block0(v0: i32x4, v1: i32):
    v2 = sshr v0, v1
    return v2
}
; run: %sshr_i32x4([1 2 4 -8], 1) == [0 1 2 -4]
; run: %sshr_i32x4([1 2 4 -8], 33) == [0 1 2 -4]
function %sshr_i64x2(i64x2, i32) -> i64x2 {
block0(v0:i64x2, v1:i32):
    v2 = sshr v0, v1
    return v2
}
; run: %sshr_i64x2([1 -1], 0) == [1 -1]
; run: %sshr_i64x2([1 -1], 1) == [0 -1] ; note the -1 shift result
; run: %sshr_i64x2([2 -2], 1) == [1 -1]
; run: %sshr_i64x2([0x80000000_00000000 0x7FFFFFFF_FFFFFFFF], 63) == [0xFFFFFFFF_FFFFFFFF 0]
; run: %sshr_i64x2([2 -2], 65) == [1 -1]
function %sshr_imm_i32x4(i32x4) -> i32x4 {
block0(v0: i32x4):
    v1 = sshr_imm v0, 1
    return v1
}
; run: %sshr_imm_i32x4([1 2 4 -8]) == [0 1 2 -4]
function %sshr_imm_i16x8(i16x8) -> i16x8 {
block0(v0: i16x8):
    v1 = sshr_imm v0, 1
    return v1
}
; run: %sshr_imm_i16x8([1 2 4 -8 0 0 0 0]) == [0 1 2 -4 0 0 0 0]
function %i8x16_sshr_const(i8x16) -> i8x16 {
block0(v0: i8x16):
    v1 = iconst.i32 2
    v2 = sshr v0, v1
    return v2
}
; run: %i8x16_sshr_const([0x01 0x02 0x04 0x08 0x10 0x20 0x40 0x80 0 0 0 0 0 0 0 0]) == [0 0 0x01 0x02 0x04 0x08 0x10 0xe0 0 0 0 0 0 0 0 0]
function %i16x8_sshr_const(i16x8) -> i16x8 {
block0(v0: i16x8):
    v1 = iconst.i32 4
    v2 = sshr v0, v1
    return v2
}
; run: %i16x8_sshr_const([0x0001 0x0002 0x0004 0x0008 0x0010 0x0020 0x0040 0x0080]) == [0 0 0 0 0x1 0x2 0x4 0x8]
; run: %i16x8_sshr_const([-1 -2 -4 -8 -16 16 0x8000 0x80f3]) == [-1 -1 -1 -1 -1 1 0xf800 0xf80f]
function %i32x4_sshr_const(i32x4) -> i32x4 {
block0(v0: i32x4):
    v1 = iconst.i32 4
    v2 = sshr v0, v1
    return v2
}
; run: %i32x4_sshr_const([1 0xfc 0x80000000 0xf83f3000]) == [0 0xf 0xf8000000 0xff83f300]
function %i64x2_sshr_const(i64x2) -> i64x2 {
block0(v0: i64x2):
    v1 = iconst.i32 32
    v2 = sshr v0, v1
    return v2
}
; run: %i64x2_sshr_const([0x1 0xf]) == [0 0]
; run: %i64x2_sshr_const([0x100000000 0]) == [1 0]
; run: %i64x2_sshr_const([-1 -1]) == [-1 -1]
function %i64x2_sshr_const2(i64x2) -> i64x2 {
block0(v0: i64x2):
    v1 = iconst.i32 8
    v2 = sshr v0, v1
    return v2
}
; run: %i64x2_sshr_const2([0x1 0xf]) == [0 0]
; run: %i64x2_sshr_const2([0x100000000 0]) == [0x1000000 0]
; run: %i64x2_sshr_const2([-1 -1]) == [-1 -1]
function %i64x2_sshr_const3(i64x2) -> i64x2 {
block0(v0: i64x2):
    v1 = iconst.i32 40
    v2 = sshr v0, v1
    return v2
}
; run: %i64x2_sshr_const3([0x1 0xf]) == [0 0]
; run: %i64x2_sshr_const3([0x10000000000 0]) == [1 0]
; run: %i64x2_sshr_const3([-1 -1]) == [-1 -1]
; run: %i64x2_sshr_const3([0x8000000080000000 0x8000000080000000]) == [0xffffffffff800000 0xffffffffff800000]
",CWE-193,125.0,1
"package config
import (
	""encoding/base64""
	""encoding/json""
	""github.com/docker/docker/api/types""
)
type dockerNetworkInterfaces struct {
	V4 struct {
		Subnet  string `default:""172.18.0.0/16""`
		Gateway string `default:""172.18.0.1""`
	}
	V6 struct {
		Subnet  string `default:""fdba:17c8:6c94::/64""`
		Gateway string `default:""fdba:17c8:6c94::1011""`
	}
}
type DockerNetworkConfiguration struct {
	// The interface that should be used to create the network. Must not conflict
	// with any other interfaces in use by Docker or on the system.
	Interface string `default:""172.18.0.1"" json:""interface"" yaml:""interface""`
	// The DNS settings for containers.
	Dns []string `default:""[\""1.1.1.1\"", \""1.0.0.1\""]""`
	// The name of the network to use. If this network already exists it will not
	// be created. If it is not found, a new network will be created using the interface
	// defined.
	Name       string                  `default:""pterodactyl_nw""`
	ISPN       bool                    `default:""false"" yaml:""ispn""`
	Driver     string                  `default:""bridge""`
	Mode       string                  `default:""pterodactyl_nw"" yaml:""network_mode""`
	IsInternal bool                    `default:""false"" yaml:""is_internal""`
	EnableICC  bool                    `default:""true"" yaml:""enable_icc""`
	Interfaces dockerNetworkInterfaces `yaml:""interfaces""`
}
// DockerConfiguration defines the docker configuration used by the daemon when
// interacting with containers and networks on the system.
type DockerConfiguration struct {
	// Network configuration that should be used when creating a new network
	// for containers run through the daemon.
	Network DockerNetworkConfiguration `json:""network"" yaml:""network""`
	// Domainname is the Docker domainname for all containers.
	Domainname string `default:"""" json:""domainname"" yaml:""domainname""`
	// Registries .
	Registries map[string]RegistryConfiguration `json:""registries"" yaml:""registries""`
	// The size of the /tmp directory when mounted into a container. Please be aware that Docker
	// utilizes host memory for this value, and that we do not keep track of the space used here
	// so avoid allocating too much to a server.
	TmpfsSize uint `default:""100"" json:""tmpfs_size"" yaml:""tmpfs_size""`
}
// RegistryConfiguration defines the authentication credentials for a given
// Docker registry.
type RegistryConfiguration struct {
	Username string `yaml:""username""`
	Password string `yaml:""password""`
}
// Base64 returns the authentication for a given registry as a base64 encoded
// string value.
func (c RegistryConfiguration) Base64() (string, error) {
	b, err := json.Marshal(types.AuthConfig{
		Username: c.Username,
		Password: c.Password,
	})
	if err != nil {
		return """", err
	}
	return base64.URLEncoding.EncodeToString(b), nil
}
",CWE-770,79.0,1
"package environment
import (
	""fmt""
	""math""
	""strconv""
	""github.com/apex/log""
)
type Mount struct {
	// In Docker environments this makes no difference, however in a non-Docker environment you
	// should treat the ""Default"" mount as the root directory for the server. All other mounts
	// are just in addition to that one, and generally things like shared maps or timezone data.
	Default bool `json:""-""`
	// The target path on the system. This is ""/home/container"" for all server's Default mount
	// but in non-container environments you can likely ignore the target and just work with the
	// source.
	Target string `json:""target""`
	// The directory from which the files will be read. In Docker environments this is the directory
	// that we're mounting into the container at the Target location.
	Source string `json:""source""`
	// Whether or not the directory is being mounted as read-only. It is up to the environment to
	// handle this value correctly and ensure security expectations are met with its usage.
	ReadOnly bool `json:""read_only""`
}
// The build settings for a given server that impact docker container creation and
// resource limits for a server instance.
type Limits struct {
	// The total amount of memory in megabytes that this server is allowed to
	// use on the host system.
	MemoryLimit int64 `json:""memory_limit""`
	// The amount of additional swap space to be provided to a container instance.
	Swap int64 `json:""swap""`
	// The relative weight for IO operations in a container. This is relative to other
	// containers on the system and should be a value between 10 and 1000.
	IoWeight uint16 `json:""io_weight""`
	// The percentage of CPU that this instance is allowed to consume relative to
	// the host. A value of 200% represents complete utilization of two cores. This
	// should be a value between 1 and THREAD_COUNT * 100.
	CpuLimit int64 `json:""cpu_limit""`
	// The amount of disk space in megabytes that a server is allowed to use.
	DiskSpace int64 `json:""disk_space""`
	// Sets which CPU threads can be used by the docker instance.
	Threads string `json:""threads""`
	OOMDisabled bool `json:""oom_disabled""`
}
// Converts the CPU limit for a server build into a number that can be better understood
// by the Docker environment. If there is no limit set, return -1 which will indicate to
// Docker that it has unlimited CPU quota.
func (r *Limits) ConvertedCpuLimit() int64 {
	if r.CpuLimit == 0 {
		return -1
	}
	return r.CpuLimit * 1000
}
// Set the hard limit for memory usage to be 5% more than the amount of memory assigned to
// the server. If the memory limit for the server is < 4G, use 10%, if less than 2G use
// 15%. This avoids unexpected crashes from processes like Java which run over the limit.
func (r *Limits) MemoryOverheadMultiplier() float64 {
	if r.MemoryLimit <= 2048 {
		return 1.15
	} else if r.MemoryLimit <= 4096 {
		return 1.10
	}
	return 1.05
}
func (r *Limits) BoundedMemoryLimit() int64 {
	return int64(math.Round(float64(r.MemoryLimit) * r.MemoryOverheadMultiplier() * 1_000_000))
}
// Returns the amount of swap available as a total in bytes. This is returned as the amount
// of memory available to the server initially, PLUS the amount of additional swap to include
// which is the format used by Docker.
func (r *Limits) ConvertedSwap() int64 {
	if r.Swap < 0 {
		return -1
	}
	return (r.Swap * 1_000_000) + r.BoundedMemoryLimit()
}
type Variables map[string]interface{}
// Ugly hacky function to handle environment variables that get passed through as not-a-string
// from the Panel. Ideally we'd just say only pass strings, but that is a fragile idea and if a
// string wasn't passed through you'd cause a crash or the server to become unavailable. For now
// try to handle the most likely values from the JSON and hope for the best.
func (v Variables) Get(key string) string {
	val, ok := v[key]
	if !ok {
		return """"
	}
	switch val.(type) {
	case int:
		return strconv.Itoa(val.(int))
	case int32:
		return strconv.FormatInt(val.(int64), 10)
	case int64:
		return strconv.FormatInt(val.(int64), 10)
	case float32:
		return fmt.Sprintf(""%f"", val.(float32))
	case float64:
		return fmt.Sprintf(""%f"", val.(float64))
	case bool:
		return strconv.FormatBool(val.(bool))
	case string:
		return val.(string)
	}
	// TODO: I think we can add a check for val == nil and return an empty string for those
	//  and this warning should theoretically never happen?
	log.Warn(fmt.Sprintf(""failed to marshal environment variable \""%s\"" of type %+v into string"", key, val))
	return """"
}
",CWE-770,133.0,1
"package filesystem
import (
	""context""
	""os""
	""path/filepath""
	""strings""
	""sync""
	""emperror.dev/errors""
	""golang.org/x/sync/errgroup""
)
// Checks if the given file or path is in the server's file denylist. If so, an Error
// is returned, otherwise nil is returned.
func (fs *Filesystem) IsIgnored(paths ...string) error {
	for _, p := range paths {
		sp, err := fs.SafePath(p)
		if err != nil {
			return err
		}
		if fs.denylist.MatchesPath(sp) {
			return errors.WithStack(&Error{code: ErrCodeDenylistFile, path: p, resolved: sp})
		}
	}
	return nil
}
// Normalizes a directory being passed in to ensure the user is not able to escape
// from their data directory. After normalization if the directory is still within their home
// path it is returned. If they managed to ""escape"" an error will be returned.
//
// This logic is actually copied over from the SFTP server code. Ideally that eventually
// either gets ported into this application, or is able to make use of this package.
func (fs *Filesystem) SafePath(p string) (string, error) {
	var nonExistentPathResolution string
	// Start with a cleaned up path before checking the more complex bits.
	r := fs.unsafeFilePath(p)
	// At the same time, evaluate the symlink status and determine where this file or folder
	// is truly pointing to.
	ep, err := filepath.EvalSymlinks(r)
	if err != nil && !os.IsNotExist(err) {
		return """", errors.Wrap(err, ""server/filesystem: failed to evaluate symlink"")
	} else if os.IsNotExist(err) {
		// The requested directory doesn't exist, so at this point we need to iterate up the
		// path chain until we hit a directory that _does_ exist and can be validated.
		parts := strings.Split(filepath.Dir(r), ""/"")
		var try string
		// Range over all of the path parts and form directory pathings from the end
		// moving up until we have a valid resolution or we run out of paths to try.
		for k := range parts {
			try = strings.Join(parts[:(len(parts)-k)], ""/"")
			if !fs.unsafeIsInDataDirectory(try) {
				break
			}
			t, err := filepath.EvalSymlinks(try)
			if err == nil {
				nonExistentPathResolution = t
				break
			}
		}
	}
	// If the new path doesn't start with their root directory there is clearly an escape
	// attempt going on, and we should NOT resolve this path for them.
	if nonExistentPathResolution != """" {
		if !fs.unsafeIsInDataDirectory(nonExistentPathResolution) {
			return """", NewBadPathResolution(p, nonExistentPathResolution)
		}
		// If the nonExistentPathResolution variable is not empty then the initial path requested
		// did not exist and we looped through the pathway until we found a match. At this point
		// we've confirmed the first matched pathway exists in the root server directory, so we
		// can go ahead and just return the path that was requested initially.
		return r, nil
	}
	// If the requested directory from EvalSymlinks begins with the server root directory go
	// ahead and return it. If not we'll return an error which will block any further action
	// on the file.
	if fs.unsafeIsInDataDirectory(ep) {
		return ep, nil
	}
	return """", NewBadPathResolution(p, r)
}
// Generate a path to the file by cleaning it up and appending the root server path to it. This
// DOES NOT guarantee that the file resolves within the server data directory. You'll want to use
// the fs.unsafeIsInDataDirectory(p) function to confirm.
func (fs *Filesystem) unsafeFilePath(p string) string {
	// Calling filepath.Clean on the joined directory will resolve it to the absolute path,
	// removing any ../ type of resolution arguments, and leaving us with a direct path link.
	//
	// This will also trim the existing root path off the beginning of the path passed to
	// the function since that can get a bit messy.
	return filepath.Clean(filepath.Join(fs.Path(), strings.TrimPrefix(p, fs.Path())))
}
// Check that that path string starts with the server data directory path. This function DOES NOT
// validate that the rest of the path does not end up resolving out of this directory, or that the
// targeted file or folder is not a symlink doing the same thing.
func (fs *Filesystem) unsafeIsInDataDirectory(p string) bool {
	return strings.HasPrefix(strings.TrimSuffix(p, ""/"")+""/"", strings.TrimSuffix(fs.Path(), ""/"")+""/"")
}
// Executes the fs.SafePath function in parallel against an array of paths. If any of the calls
// fails an error will be returned.
func (fs *Filesystem) ParallelSafePath(paths []string) ([]string, error) {
	var cleaned []string
	// Simple locker function to avoid racy appends to the array of cleaned paths.
	m := new(sync.Mutex)
	push := func(c string) {
		m.Lock()
		cleaned = append(cleaned, c)
		m.Unlock()
	}
	// Create an error group that we can use to run processes in parallel while retaining
	// the ability to cancel the entire process immediately should any of it fail.
	g, ctx := errgroup.WithContext(context.Background())
	// Iterate over all of the paths and generate a cleaned path, if there is an error for any
	// of the files, abort the process.
	for _, p := range paths {
		// Create copy so we can use it within the goroutine correctly.
		pi := p
		// Recursively call this function to continue digging through the directory tree within
		// a separate goroutine. If the context is canceled abort this process.
		g.Go(func() error {
			select {
			case <-ctx.Done():
				return ctx.Err()
			default:
				// If the callback returns true, go ahead and keep walking deeper. This allows
				// us to programmatically continue deeper into directories, or stop digging
				// if that pathway knows it needs nothing else.
				if c, err := fs.SafePath(pi); err != nil {
					return err
				} else {
					push(c)
				}
				return nil
			}
		})
	}
	// Block until all of the routines finish and have returned a value.
	return cleaned, g.Wait()
}
",CWE-59,159.0,1
"package configuration
import (
	""encoding/json""
	""net/url""
	""time""
	""github.com/gobuffalo/packr/v2""
	""github.com/ory/fosite""
	""github.com/ory/x/tracing""
	""github.com/rs/cors""
)
var schemas = packr.New(""schemas"", ""../../.schema"")
const (
	ForbiddenStrategyErrorType = ""forbidden""
)
// MatchingStrategy defines matching strategy such as Regexp or Glob.
// Empty string defaults to ""regexp"".
type MatchingStrategy string
// Possible matching strategies.
const (
	Regexp MatchingStrategy = ""regexp""
	Glob   MatchingStrategy = ""glob""
)
type Provider interface {
	CORSEnabled(iface string) bool
	CORSOptions(iface string) cors.Options
	ProviderAuthenticators
	ProviderErrorHandlers
	ProviderAuthorizers
	ProviderMutators
	ProxyReadTimeout() time.Duration
	ProxyWriteTimeout() time.Duration
	ProxyIdleTimeout() time.Duration
	APIReadTimeout() time.Duration
	APIWriteTimeout() time.Duration
	APIIdleTimeout() time.Duration
	AccessRuleRepositories() []url.URL
	AccessRuleMatchingStrategy() MatchingStrategy
	ProxyServeAddress() string
	APIServeAddress() string
	PrometheusServeAddress() string
	PrometheusMetricsPath() string
	PrometheusCollapseRequestPaths() bool
	ToScopeStrategy(value string, key string) fosite.ScopeStrategy
	ParseURLs(sources []string) ([]url.URL, error)
	JSONWebKeyURLs() []string
	TracingServiceName() string
	TracingProvider() string
	TracingJaegerConfig() *tracing.JaegerConfig
}
type ProviderErrorHandlers interface {
	ErrorHandlerConfig(id string, override json.RawMessage, dest interface{}) error
	ErrorHandlerIsEnabled(id string) bool
	ErrorHandlerFallbackSpecificity() []string
}
type ProviderAuthenticators interface {
	AuthenticatorConfig(id string, overrides json.RawMessage, destination interface{}) error
	AuthenticatorIsEnabled(id string) bool
	AuthenticatorJwtJwkMaxWait() time.Duration
	AuthenticatorJwtJwkTtl() time.Duration
}
type ProviderAuthorizers interface {
	AuthorizerConfig(id string, overrides json.RawMessage, destination interface{}) error
	AuthorizerIsEnabled(id string) bool
}
type ProviderMutators interface {
	MutatorConfig(id string, overrides json.RawMessage, destination interface{}) error
	MutatorIsEnabled(id string) bool
}
",CWE-863,88.0,1
"{
	""name"": ""GlobalNewFiles"",
	""author"": [
		""John Lewis"",
		""Paladox"",
		""Southparkfan"",
		""Universal Omega""
	],
	""url"": ""//github.com/miraheze/GlobalNewFiles"",
	""descriptionmsg"": ""globalnewfiles-description"",
	""license-name"": ""GPL-3.0-or-later"",
	""type"": ""specialpage"",
	""requires"": {
		""MediaWiki"": "">= 1.36.0"",
		""extensions"": {
			""CreateWiki"": ""*""
		}
	},
	""MessagesDirs"": {
		""GlobalNewFiles"": [
			""i18n""
		]
	},
	""ExtensionMessagesFiles"": {
		""GlobalNewFilesAliases"": ""includes/GlobalNewFilesAliases.php""
	},
	""AvailableRights"": [
		""viewglobalprivatefiles""
	],
	""AutoloadClasses"": {
		""GlobalNewFilesHooks"": ""includes/GlobalNewFilesHooks.php"",
		""GlobalNewFilesPager"": ""includes/GlobalNewFilesPager.php"",
		""SpecialGlobalNewFiles"": ""includes/SpecialGlobalNewFiles.php"",
		""GlobalNewFilesInsertJob"": ""includes/jobs/GlobalNewFilesInsertJob.php"",
		""GlobalNewFilesDeleteJob"": ""includes/jobs/GlobalNewFilesDeleteJob.php"",
		""GlobalNewFilesMoveJob"": ""includes/jobs/GlobalNewFilesMoveJob.php""
	},
	""JobClasses"": {
		""GlobalNewFilesInsertJob"": ""GlobalNewFilesInsertJob"",
		""GlobalNewFilesDeleteJob"": ""GlobalNewFilesDeleteJob"",
		""GlobalNewFilesMoveJob"": ""GlobalNewFilesMoveJob""
	},
	""SpecialPages"": {
		""GlobalNewFiles"": ""SpecialGlobalNewFiles""
	},
	""Hooks"": {
		""CreateWikiTables"": [
			""GlobalNewFilesHooks::onCreateWikiTables""
		],
		""LoadExtensionSchemaUpdates"": [
			""GlobalNewFilesHooks::onLoadExtensionSchemaUpdates""
		],
		""FileDeleteComplete"": [
			""GlobalNewFilesHooks::onFileDeleteComplete""
		],
		""TitleMoveComplete"": [
			""GlobalNewFilesHooks::onTitleMoveComplete""
		],
		""UploadComplete"": [
			""GlobalNewFilesHooks::onUploadComplete""
		]
	},
	""ConfigRegistry"": {
		""globalnewfiles"": ""GlobalVarConfig::newInstance""
	},
	""manifest_version"": 2
}
",CWE-400,68.0,1
"{
	""name"": ""GlobalNewFiles"",
	""author"": [
		""John Lewis"",
		""Paladox"",
		""Southparkfan"",
		""Universal Omega""
	],
	""url"": ""//github.com/miraheze/GlobalNewFiles"",
	""descriptionmsg"": ""globalnewfiles-description"",
	""license-name"": ""GPL-3.0-or-later"",
	""type"": ""specialpage"",
	""requires"": {
		""MediaWiki"": "">= 1.36.0"",
		""extensions"": {
			""CreateWiki"": ""*""
		}
	},
	""MessagesDirs"": {
		""GlobalNewFiles"": [
			""i18n""
		]
	},
	""ExtensionMessagesFiles"": {
		""GlobalNewFilesAliases"": ""includes/GlobalNewFilesAliases.php""
	},
	""AvailableRights"": [
		""viewglobalprivatefiles""
	],
	""AutoloadClasses"": {
		""GlobalNewFilesHooks"": ""includes/GlobalNewFilesHooks.php"",
		""GlobalNewFilesPager"": ""includes/GlobalNewFilesPager.php"",
		""SpecialGlobalNewFiles"": ""includes/SpecialGlobalNewFiles.php"",
		""GlobalNewFilesInsertJob"": ""includes/jobs/GlobalNewFilesInsertJob.php"",
		""GlobalNewFilesDeleteJob"": ""includes/jobs/GlobalNewFilesDeleteJob.php"",
		""GlobalNewFilesMoveJob"": ""includes/jobs/GlobalNewFilesMoveJob.php""
	},
	""JobClasses"": {
		""GlobalNewFilesInsertJob"": ""GlobalNewFilesInsertJob"",
		""GlobalNewFilesDeleteJob"": ""GlobalNewFilesDeleteJob"",
		""GlobalNewFilesMoveJob"": ""GlobalNewFilesMoveJob""
	},
	""SpecialPages"": {
		""GlobalNewFiles"": ""SpecialGlobalNewFiles""
	},
	""Hooks"": {
		""CreateWikiTables"": [
			""GlobalNewFilesHooks::onCreateWikiTables""
		],
		""LoadExtensionSchemaUpdates"": [
			""GlobalNewFilesHooks::onLoadExtensionSchemaUpdates""
		],
		""FileDeleteComplete"": [
			""GlobalNewFilesHooks::onFileDeleteComplete""
		],
		""PageMoveComplete"": [
			""GlobalNewFilesHooks::onPageMoveComplete""
		],
		""UploadComplete"": [
			""GlobalNewFilesHooks::onUploadComplete""
		]
	},
	""ConfigRegistry"": {
		""globalnewfiles"": ""GlobalVarConfig::newInstance""
	},
	""manifest_version"": 2
}
",CWE-20,68.0,1
"module github.com/projectcontour/contour
go 1.15
require (
	github.com/ahmetb/gen-crd-api-reference-docs v0.3.0
	github.com/bombsimon/logrusr v1.0.0
	github.com/envoyproxy/go-control-plane v0.9.9-0.20210111201334-f1f47757da33
	github.com/go-logr/logr v0.4.0
	github.com/golang/protobuf v1.5.2
	github.com/google/go-cmp v0.5.5
	github.com/google/uuid v1.1.2
	github.com/grpc-ecosystem/go-grpc-prometheus v1.2.0
	github.com/jetstack/cert-manager v1.3.0
	github.com/onsi/ginkgo v1.16.4
	github.com/onsi/gomega v1.13.0
	github.com/prometheus/client_golang v1.9.0
	github.com/prometheus/client_model v0.2.0
	github.com/prometheus/common v0.15.0
	github.com/sirupsen/logrus v1.7.0
	github.com/stretchr/testify v1.6.1
	google.golang.org/genproto v0.0.0-20201110150050-8816d57aaa9a
	google.golang.org/grpc v1.27.1
	google.golang.org/protobuf v1.26.0
	gopkg.in/alecthomas/kingpin.v2 v2.2.6
	gopkg.in/yaml.v2 v2.4.0
	k8s.io/api v0.21.0
	k8s.io/apiextensions-apiserver v0.21.0
	k8s.io/apimachinery v0.21.0
	k8s.io/client-go v0.21.0
	k8s.io/klog/v2 v2.8.1-0.20210504170414-0cc9b8363efc
	k8s.io/utils v0.0.0-20210305010621-2afb4311ab10
	sigs.k8s.io/controller-runtime v0.9.0-beta.1
	sigs.k8s.io/controller-tools v0.5.0
	sigs.k8s.io/gateway-api v0.3.0
	sigs.k8s.io/kustomize/kyaml v0.1.1
)
",CWE-610,38.0,1
"// Copyright Project Contour Authors
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package dag
import (
	""errors""
	""testing""
	""github.com/projectcontour/contour/internal/fixture""
	""github.com/stretchr/testify/assert""
	v1 ""k8s.io/api/core/v1""
	metav1 ""k8s.io/apimachinery/pkg/apis/meta/v1""
	""k8s.io/apimachinery/pkg/types""
	""k8s.io/apimachinery/pkg/util/intstr""
)
func TestBuilderLookupService(t *testing.T) {
	s1 := &v1.Service{
		ObjectMeta: metav1.ObjectMeta{
			Name:      ""kuard"",
			Namespace: ""default"",
		},
		Spec: v1.ServiceSpec{
			Ports: []v1.ServicePort{{
				Name:       ""http"",
				Protocol:   ""TCP"",
				Port:       8080,
				TargetPort: intstr.FromInt(8080),
			}},
		},
	}
	services := map[types.NamespacedName]*v1.Service{
		{Name: ""service1"", Namespace: ""default""}: s1,
	}
	tests := map[string]struct {
		types.NamespacedName
		port    intstr.IntOrString
		want    *Service
		wantErr error
	}{
		""lookup service by port number"": {
			NamespacedName: types.NamespacedName{Name: ""service1"", Namespace: ""default""},
			port:           intstr.FromInt(8080),
			want:           service(s1),
		},
		""lookup service by port name"": {
			NamespacedName: types.NamespacedName{Name: ""service1"", Namespace: ""default""},
			port:           intstr.FromString(""http""),
			want:           service(s1),
		},
		""lookup service by port number (as string)"": {
			NamespacedName: types.NamespacedName{Name: ""service1"", Namespace: ""default""},
			port:           intstr.Parse(""8080""),
			want:           service(s1),
		},
		""lookup service by port number (from string)"": {
			NamespacedName: types.NamespacedName{Name: ""service1"", Namespace: ""default""},
			port:           intstr.FromString(""8080""),
			want:           service(s1),
		},
		""when service does not exist an error is returned"": {
			NamespacedName: types.NamespacedName{Name: ""nonexistent-service"", Namespace: ""default""},
			port:           intstr.FromString(""8080""),
			wantErr:        errors.New(`service ""default/nonexistent-service"" not found`),
		},
		""when port does not exist an error is returned"": {
			NamespacedName: types.NamespacedName{Name: ""service1"", Namespace: ""default""},
			port:           intstr.FromString(""9999""),
			wantErr:        errors.New(`port ""9999"" on service ""default/service1"" not matched`),
		},
	}
	for name, tc := range tests {
		t.Run(name, func(t *testing.T) {
			b := Builder{
				Source: KubernetesCache{
					services:    services,
					FieldLogger: fixture.NewTestLogger(t),
				},
			}
			var dag DAG
			got, gotErr := dag.EnsureService(tc.NamespacedName, tc.port, &b.Source)
			assert.Equal(t, tc.want, got)
			assert.Equal(t, tc.wantErr, gotErr)
		})
	}
}
",CWE-610,102.0,1
"// Copyright Project Contour Authors
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package dag
import (
	""path""
	""strings""
	contour_api_v1 ""github.com/projectcontour/contour/apis/projectcontour/v1""
	contour_api_v1alpha1 ""github.com/projectcontour/contour/apis/projectcontour/v1alpha1""
	""github.com/projectcontour/contour/internal/k8s""
	""github.com/projectcontour/contour/internal/status""
	""github.com/projectcontour/contour/internal/xds""
	""github.com/sirupsen/logrus""
	corev1 ""k8s.io/api/core/v1""
	""k8s.io/apimachinery/pkg/types""
	""k8s.io/apimachinery/pkg/util/intstr""
)
type ExtensionServiceProcessor struct {
	logrus.FieldLogger
	// ClientCertificate is the optional identifier of the TLS
	// secret containing client certificate and private key to be
	// used when establishing TLS connection to upstream cluster.
	ClientCertificate *types.NamespacedName
}
var _ Processor = &ExtensionServiceProcessor{}
func (p *ExtensionServiceProcessor) Run(dag *DAG, cache *KubernetesCache) {
	for _, e := range cache.extensions {
		extStatus, commit := status.ExtensionAccessor(&dag.StatusCache, e)
		validCondition := extStatus.ConditionFor(status.ValidCondition)
		if ext := p.buildExtensionService(cache, e, validCondition); ext != nil {
			if len(validCondition.Errors) == 0 {
				dag.AddRoot(ext)
			}
		}
		if len(validCondition.Errors) == 0 {
			validCondition.Status = contour_api_v1.ConditionTrue
			validCondition.Reason = ""Valid""
			validCondition.Message = ""Valid ExtensionService""
		}
		commit()
	}
}
// ExtensionClusterName generates a unique Envoy cluster name
// for an ExtensionCluster.
// The namespaced name of an ExtensionCluster is globally
// unique, so we can simply use that as the cluster name. As
// long as we scope the context with the ""extension"" prefix
// there can't be a conflict. Note that the name doesn't include
// a hash of the contents because we want a 1-1 mapping between
// ExtensionServices and Envoy Clusters; we don't want a new
// Envoy Cluster just because a field changed.
func ExtensionClusterName(meta types.NamespacedName) string {
	return strings.Join([]string{""extension"", meta.Namespace, meta.Name}, ""/"")
}
// buildExtensionService builds one ExtensionCluster record based
// on the corresponding CRD.
func (p *ExtensionServiceProcessor) buildExtensionService(
	cache *KubernetesCache,
	ext *contour_api_v1alpha1.ExtensionService,
	validCondition *contour_api_v1.DetailedCondition,
) *ExtensionCluster {
	tp, err := timeoutPolicy(ext.Spec.TimeoutPolicy)
	if err != nil {
		validCondition.AddErrorf(contour_api_v1.ConditionTypeSpecError, ""TimeoutPolicyNotValid"",
			""spec.timeoutPolicy failed to parse: %s"", err)
	}
	var clientCertSecret *Secret
	if p.ClientCertificate != nil {
		clientCertSecret, err = cache.LookupSecret(*p.ClientCertificate, validSecret)
		if err != nil {
			validCondition.AddErrorf(contour_api_v1.ConditionTypeTLSError, ""SecretNotValid"",
				""tls.envoy-client-certificate Secret %q is invalid: %s"", p.ClientCertificate, err)
		}
	}
	extension := ExtensionCluster{
		Name: ExtensionClusterName(k8s.NamespacedNameOf(ext)),
		Upstream: ServiceCluster{
			ClusterName: path.Join(
				""extension"",
				xds.ClusterLoadAssignmentName(k8s.NamespacedNameOf(ext), """"),
			),
		},
		Protocol:           ""h2"",
		UpstreamValidation: nil,
		TimeoutPolicy:      tp,
		SNI:                """",
		ClientCertificate:  clientCertSecret,
	}
	lbPolicy := loadBalancerPolicy(ext.Spec.LoadBalancerPolicy)
	switch lbPolicy {
	case LoadBalancerPolicyCookie, LoadBalancerPolicyRequestHash:
		validCondition.AddWarningf(contour_api_v1.ConditionTypeSpecError, ""IgnoredField"",
			""ignoring field %q; %s load balancer policy is not supported for ExtensionClusters"",
			"".Spec.LoadBalancerPolicy"", lbPolicy)
		// Reset load balancer policy to ensure the default.
		lbPolicy = """"
	}
	extension.LoadBalancerPolicy = lbPolicy
	// Timeouts are specified above the cluster (e.g.
	// in the ext_authz filter). The ext_authz filter
	// doesn't have an idle timeout (only a request
	// timeout), so validate that it is not provided here.
	if timeouts := ext.Spec.TimeoutPolicy; timeouts != nil && timeouts.Idle != """" {
		validCondition.AddWarningf(""SpecError"", ""IgnoredField"",
			""ignoring field %q; idle timeouts are not supported for ExtensionClusters"",
			"".Spec.TimeoutPolicy.Idle"")
	}
	// API server validation ensures that the protocol is ""h2"" or ""h2c"".
	if ext.Spec.Protocol != nil {
		extension.Protocol = stringOrDefault(*ext.Spec.Protocol, extension.Protocol)
	}
	if v := ext.Spec.UpstreamValidation; v != nil {
		if uv, err := cache.LookupUpstreamValidation(v, ext.GetNamespace()); err != nil {
			validCondition.AddErrorf(contour_api_v1.ConditionTypeSpecError, ""TLSUpstreamValidation"",
				""TLS upstream validation policy error: %s"", err.Error())
		} else {
			extension.UpstreamValidation = uv
			// Default the SNI server name to the name
			// we need to validate. It is a bit onerous
			// to also have to provide a CA bundle here,
			// but maybe we can make that optional in the
			// future.
			//
			// TODO(jpeach): expose SNI in the API, https://github.com/projectcontour/contour/issues/2893.
			extension.SNI = uv.SubjectName
		}
		if extension.Protocol != ""h2"" {
			validCondition.AddErrorf(contour_api_v1.ConditionTypeSpecError, ""InconsistentProtocol"",
				""upstream TLS validation not supported for %q protocol"", extension.Protocol)
		}
	}
	for _, target := range ext.Spec.Services {
		// Note that ExtensionServices only expose Kubernetes
		// Service resources that are in the same namespace.
		// This prevent using a cross-namespace reference to
		// subvert the Contour installation.
		svcName := types.NamespacedName{
			Namespace: ext.GetNamespace(),
			Name:      target.Name,
		}
		svc, port, err := cache.LookupService(svcName, intstr.FromInt(target.Port))
		if err != nil {
			validCondition.AddErrorf(contour_api_v1.ConditionTypeServiceError, ""ServiceUnresolvedReference"",
				""unresolved service %q: %s"", svcName, err)
			continue
		}
		// TODO(jpeach): Add ExternalName support in https://github.com/projectcontour/contour/issues/2875.
		if svc.Spec.ExternalName != """" {
			validCondition.AddErrorf(contour_api_v1.ConditionTypeServiceError, ""UnsupportedServiceType"",
				""Service %q is of unsupported type %q."", svcName, corev1.ServiceTypeExternalName)
			continue
		}
		extension.Upstream.AddWeightedService(target.Weight, svcName, port)
	}
	return &extension
}
",CWE-610,191.0,1
"package ops
import (
	""fmt""
	. ""github.com/onsi/ginkgo""
	. ""github.com/onsi/gomega""
)
var _ = Describe(""ExecCommandError"", func() {
	It(""Creates the correct error for mkdir"", func() {
		err := &ExecCommandError{
			Command: ""mkdir"",
			Args:    []string{""-p"", ""/somedir""},
			Env:     []string{""HOME=/home/userZ""},
			ExitErr: fmt.Errorf(""Permission denied""),
			Output:  ""mkdir: cannot create directory ‘/somedir’: Permission denied"",
		}
		wantError := ""failed executing mkdir [-p /somedir], Error Permission denied, LastOutput \""mkdir: cannot create directory ‘/somedir’: Permission denied\""""
		wantDetailedError := ""failed executing mkdir [-p /somedir], env vars [HOME=/home/userZ], error Permission denied, waitStatus 0, Output \""mkdir: cannot create directory ‘/somedir’: Permission denied\""""
		Expect(err.Error()).To(Equal(wantError))
		Expect(err.DetailedError()).To(Equal(wantDetailedError))
	})
	It(""Creates the correct error for ignition extract"", func() {
		err := &ExecCommandError{
			Command:    ""nsenter"",
			Args:       []string{""-t"", ""1"", ""-m"", ""-i"", ""--"", ""podman"", ""run"", ""--net"", ""host"", ""--volume"", ""/:/rootfs:rw"", ""--volume"", ""/usr/bin/rpm-ostree:/usr/bin/rpm-ostree"", ""--privileged"", ""--entrypoint"", ""/usr/bin/machine-config-daemon"", ""quay.io/openshift-release-dev/ocp-v4.0-art-dev@sha256:dc1a34f55c712b2b9c5e5a14dd85e67cbdae11fd147046ac2fef9eaf179ab221"", ""start"", ""--node-name"", ""localhost"", ""--root-mount"", ""/rootfs"", ""--once-from"", ""/opt/install-dir/bootstrap.ign"", ""--skip-reboot""},
			Env:        []string{""HOME=/home/userZ""},
			ExitErr:    fmt.Errorf(""exit status 255""),
			WaitStatus: 255,
			Output:     ""Trying to pull quay.io/openshift-release-dev/ocp-v4.0-art-dev@sha256:dc1a34f55c712b2b9c5e5a14dd85e67cbdae11fd147046ac2fef9eaf179ab221...\nGetting image source signatures\nCopying blob sha256:74cbb6607642df5f9f70e8588e3c56d6de795d1a9af22866ea4cc82f2dad4f14\nCopying blob sha256:c9fa7d57b9028d4bd02b51cef3c3039fa7b23a8b2d9d26a6ce66b3428f6e2457\nCopying blob sha256:c676df4ac84e718ecee4f8129e43e9c2b7492942606cc65f1fc5e6f3da413160\nCopying blob sha256:b147db91a07555d29ed6085e4733f34dbaa673076488caa8f95f4677f55b3a5c\nCopying blob sha256:ad956945835b7630565fc23fcbd8194eef32b4300c28546d574b2a377fe5d0a5\nCopying config sha256:c4356549f53a30a1baefc5d1515ec1ab8b3786a4bf1738c0abaedc0e44829498\nWriting manifest to image destination\nStoring signatures\nI1019 19:03:28.797092 1 start.go:108] Version: v4.6.0-202008262209.p0-dirty (16d243c4bed178f5d4fd400c0518ebf1dbaface8)\nI1019 19:03:28.797227 1 start.go:118] Calling chroot(\""/rootfs\"")\nI1019 19:03:28.797307 1 rpm-ostree.go:261] Running captured: rpm-ostree status --json\nerror: Timeout was reached\nF1019 19:04:35.869592 1 start.go:147] Failed to initialize single run daemon: error reading osImageURL from rpm-ostree: error running rpm-ostree status --json: : exit status 1)"",
		}
		wantError := `failed executing nsenter [-t 1 -m -i -- podman run --net host --volume /:/rootfs:rw --volume /usr/bin/rpm-ostree:/usr/bin/rpm-ostree --privileged --entrypoint /usr/bin/machine-config-daemon quay.io/openshift-release-dev/ocp-v4.0-art-dev@sha256:dc1a34f55c712b2b9c5e5a14dd85e67cbdae11fd147046ac2fef9eaf179ab221 start --node-name localhost --root-mount /rootfs --once-from /opt/install-dir/bootstrap.ign --skip-reboot], Error exit status 255, LastOutput ""... or: Timeout was reached
F1019 19:04:35.869592 1 start.go:147] Failed to initialize single run daemon: error reading osImageURL from rpm-ostree: error running rpm-ostree status --json: : exit status 1)""`
		wantDetailedError := `failed executing nsenter [-t 1 -m -i -- podman run --net host --volume /:/rootfs:rw --volume /usr/bin/rpm-ostree:/usr/bin/rpm-ostree --privileged --entrypoint /usr/bin/machine-config-daemon quay.io/openshift-release-dev/ocp-v4.0-art-dev@sha256:dc1a34f55c712b2b9c5e5a14dd85e67cbdae11fd147046ac2fef9eaf179ab221 start --node-name localhost --root-mount /rootfs --once-from /opt/install-dir/bootstrap.ign --skip-reboot], env vars [HOME=/home/userZ], error exit status 255, waitStatus 255, Output ""Trying to pull quay.io/openshift-release-dev/ocp-v4.0-art-dev@sha256:dc1a34f55c712b2b9c5e5a14dd85e67cbdae11fd147046ac2fef9eaf179ab221...
Getting image source signatures
Copying blob sha256:74cbb6607642df5f9f70e8588e3c56d6de795d1a9af22866ea4cc82f2dad4f14
Copying blob sha256:c9fa7d57b9028d4bd02b51cef3c3039fa7b23a8b2d9d26a6ce66b3428f6e2457
Copying blob sha256:c676df4ac84e718ecee4f8129e43e9c2b7492942606cc65f1fc5e6f3da413160
Copying blob sha256:b147db91a07555d29ed6085e4733f34dbaa673076488caa8f95f4677f55b3a5c
Copying blob sha256:ad956945835b7630565fc23fcbd8194eef32b4300c28546d574b2a377fe5d0a5
Copying config sha256:c4356549f53a30a1baefc5d1515ec1ab8b3786a4bf1738c0abaedc0e44829498
Writing manifest to image destination
Storing signatures
I1019 19:03:28.797092 1 start.go:108] Version: v4.6.0-202008262209.p0-dirty (16d243c4bed178f5d4fd400c0518ebf1dbaface8)
I1019 19:03:28.797227 1 start.go:118] Calling chroot(""/rootfs"")
I1019 19:03:28.797307 1 rpm-ostree.go:261] Running captured: rpm-ostree status --json
error: Timeout was reached
F1019 19:04:35.869592 1 start.go:147] Failed to initialize single run daemon: error reading osImageURL from rpm-ostree: error running rpm-ostree status --json: : exit status 1)""`
		Expect(err.Error()).To(Equal(wantError))
		Expect(err.DetailedError()).To(Equal(wantDetailedError))
	})
})
var _ = Describe(""installerArgs"", func() {
	var (
		device       = ""/dev/sda""
		ignitionPath = ""/tmp/ignition.ign""
	)
	It(""Returns the correct list with no extra args"", func() {
		args := installerArgs(ignitionPath, device, nil)
		expected := []string{""install"", ""--insecure"", ""-i"", ""/tmp/ignition.ign"", ""/dev/sda""}
		Expect(args).To(Equal(expected))
	})
	It(""Returns the correct list with empty extra args"", func() {
		args := installerArgs(ignitionPath, device, []string{})
		expected := []string{""install"", ""--insecure"", ""-i"", ""/tmp/ignition.ign"", ""/dev/sda""}
		Expect(args).To(Equal(expected))
	})
	It(""Returns the correct list with extra args"", func() {
		args := installerArgs(ignitionPath, device, []string{""-n"", ""--append-karg"", ""nameserver=8.8.8.8""})
		expected := []string{""install"", ""--insecure"", ""-i"", ""/tmp/ignition.ign"", ""-n"", ""--append-karg"", ""nameserver=8.8.8.8"", ""/dev/sda""}
		Expect(args).To(Equal(expected))
	})
})
",CWE-532,82.0,1
"package unicorn
// For Unicorn Engine. AUTO-GENERATED FILE, DO NOT EDIT [arm_const.go]
const (
// ARM CPU
	CPU_ARM_926 = 0
	CPU_ARM_946 = 1
	CPU_ARM_1026 = 2
	CPU_ARM_1136_R2 = 3
	CPU_ARM_1136 = 4
	CPU_ARM_1176 = 5
	CPU_ARM_11MPCORE = 6
	CPU_ARM_CORTEX_M0 = 7
	CPU_ARM_CORTEX_M3 = 8
	CPU_ARM_CORTEX_M4 = 9
	CPU_ARM_CORTEX_M7 = 10
	CPU_ARM_CORTEX_M33 = 11
	CPU_ARM_CORTEX_R5 = 12
	CPU_ARM_CORTEX_R5F = 13
	CPU_ARM_CORTEX_A7 = 14
	CPU_ARM_CORTEX_A8 = 15
	CPU_ARM_CORTEX_A9 = 16
	CPU_ARM_CORTEX_A15 = 17
	CPU_ARM_TI925T = 18
	CPU_ARM_SA1100 = 19
	CPU_ARM_SA1110 = 20
	CPU_ARM_PXA250 = 21
	CPU_ARM_PXA255 = 22
	CPU_ARM_PXA260 = 23
	CPU_ARM_PXA261 = 24
	CPU_ARM_PXA262 = 25
	CPU_ARM_PXA270 = 26
	CPU_ARM_PXA270A0 = 27
	CPU_ARM_PXA270A1 = 28
	CPU_ARM_PXA270B0 = 29
	CPU_ARM_PXA270B1 = 30
	CPU_ARM_PXA270C0 = 31
	CPU_ARM_PXA270C5 = 32
	CPU_ARM_MAX = 33
// ARM registers
	ARM_REG_INVALID = 0
	ARM_REG_APSR = 1
	ARM_REG_APSR_NZCV = 2
	ARM_REG_CPSR = 3
	ARM_REG_FPEXC = 4
	ARM_REG_FPINST = 5
	ARM_REG_FPSCR = 6
	ARM_REG_FPSCR_NZCV = 7
	ARM_REG_FPSID = 8
	ARM_REG_ITSTATE = 9
	ARM_REG_LR = 10
	ARM_REG_PC = 11
	ARM_REG_SP = 12
	ARM_REG_SPSR = 13
	ARM_REG_D0 = 14
	ARM_REG_D1 = 15
	ARM_REG_D2 = 16
	ARM_REG_D3 = 17
	ARM_REG_D4 = 18
	ARM_REG_D5 = 19
	ARM_REG_D6 = 20
	ARM_REG_D7 = 21
	ARM_REG_D8 = 22
	ARM_REG_D9 = 23
	ARM_REG_D10 = 24
	ARM_REG_D11 = 25
	ARM_REG_D12 = 26
	ARM_REG_D13 = 27
	ARM_REG_D14 = 28
	ARM_REG_D15 = 29
	ARM_REG_D16 = 30
	ARM_REG_D17 = 31
	ARM_REG_D18 = 32
	ARM_REG_D19 = 33
	ARM_REG_D20 = 34
	ARM_REG_D21 = 35
	ARM_REG_D22 = 36
	ARM_REG_D23 = 37
	ARM_REG_D24 = 38
	ARM_REG_D25 = 39
	ARM_REG_D26 = 40
	ARM_REG_D27 = 41
	ARM_REG_D28 = 42
	ARM_REG_D29 = 43
	ARM_REG_D30 = 44
	ARM_REG_D31 = 45
	ARM_REG_FPINST2 = 46
	ARM_REG_MVFR0 = 47
	ARM_REG_MVFR1 = 48
	ARM_REG_MVFR2 = 49
	ARM_REG_Q0 = 50
	ARM_REG_Q1 = 51
	ARM_REG_Q2 = 52
	ARM_REG_Q3 = 53
	ARM_REG_Q4 = 54
	ARM_REG_Q5 = 55
	ARM_REG_Q6 = 56
	ARM_REG_Q7 = 57
	ARM_REG_Q8 = 58
	ARM_REG_Q9 = 59
	ARM_REG_Q10 = 60
	ARM_REG_Q11 = 61
	ARM_REG_Q12 = 62
	ARM_REG_Q13 = 63
	ARM_REG_Q14 = 64
	ARM_REG_Q15 = 65
	ARM_REG_R0 = 66
	ARM_REG_R1 = 67
	ARM_REG_R2 = 68
	ARM_REG_R3 = 69
	ARM_REG_R4 = 70
	ARM_REG_R5 = 71
	ARM_REG_R6 = 72
	ARM_REG_R7 = 73
	ARM_REG_R8 = 74
	ARM_REG_R9 = 75
	ARM_REG_R10 = 76
	ARM_REG_R11 = 77
	ARM_REG_R12 = 78
	ARM_REG_S0 = 79
	ARM_REG_S1 = 80
	ARM_REG_S2 = 81
	ARM_REG_S3 = 82
	ARM_REG_S4 = 83
	ARM_REG_S5 = 84
	ARM_REG_S6 = 85
	ARM_REG_S7 = 86
	ARM_REG_S8 = 87
	ARM_REG_S9 = 88
	ARM_REG_S10 = 89
	ARM_REG_S11 = 90
	ARM_REG_S12 = 91
	ARM_REG_S13 = 92
	ARM_REG_S14 = 93
	ARM_REG_S15 = 94
	ARM_REG_S16 = 95
	ARM_REG_S17 = 96
	ARM_REG_S18 = 97
	ARM_REG_S19 = 98
	ARM_REG_S20 = 99
	ARM_REG_S21 = 100
	ARM_REG_S22 = 101
	ARM_REG_S23 = 102
	ARM_REG_S24 = 103
	ARM_REG_S25 = 104
	ARM_REG_S26 = 105
	ARM_REG_S27 = 106
	ARM_REG_S28 = 107
	ARM_REG_S29 = 108
	ARM_REG_S30 = 109
	ARM_REG_S31 = 110
	ARM_REG_C1_C0_2 = 111
	ARM_REG_C13_C0_2 = 112
	ARM_REG_C13_C0_3 = 113
	ARM_REG_IPSR = 114
	ARM_REG_MSP = 115
	ARM_REG_PSP = 116
	ARM_REG_CONTROL = 117
	ARM_REG_IAPSR = 118
	ARM_REG_EAPSR = 119
	ARM_REG_XPSR = 120
	ARM_REG_EPSR = 121
	ARM_REG_IEPSR = 122
	ARM_REG_PRIMASK = 123
	ARM_REG_BASEPRI = 124
	ARM_REG_BASEPRI_MAX = 125
	ARM_REG_FAULTMASK = 126
	ARM_REG_APSR_NZCVQ = 127
	ARM_REG_APSR_G = 128
	ARM_REG_APSR_NZCVQG = 129
	ARM_REG_IAPSR_NZCVQ = 130
	ARM_REG_IAPSR_G = 131
	ARM_REG_IAPSR_NZCVQG = 132
	ARM_REG_EAPSR_NZCVQ = 133
	ARM_REG_EAPSR_G = 134
	ARM_REG_EAPSR_NZCVQG = 135
	ARM_REG_XPSR_NZCVQ = 136
	ARM_REG_XPSR_G = 137
	ARM_REG_XPSR_NZCVQG = 138
	ARM_REG_CP_REG = 139
	ARM_REG_ENDING = 140
// alias registers
	ARM_REG_R13 = 12
	ARM_REG_R14 = 10
	ARM_REG_R15 = 11
	ARM_REG_SB = 75
	ARM_REG_SL = 76
	ARM_REG_FP = 77
	ARM_REG_IP = 78
)",CWE-665,194.0,1
"package unicorn
// For Unicorn Engine. AUTO-GENERATED FILE, DO NOT EDIT [m68k_const.go]
const (
// M68K CPU
	CPU_M68K_M5206 = 0
	CPU_M68K_M68000 = 1
	CPU_M68K_M68020 = 2
	CPU_M68K_M68030 = 3
	CPU_M68K_M68040 = 4
	CPU_M68K_M68060 = 5
	CPU_M68K_M5208 = 6
	CPU_M68K_CFV4E = 7
	CPU_M68K_ANY = 8
// M68K registers
	M68K_REG_INVALID = 0
	M68K_REG_A0 = 1
	M68K_REG_A1 = 2
	M68K_REG_A2 = 3
	M68K_REG_A3 = 4
	M68K_REG_A4 = 5
	M68K_REG_A5 = 6
	M68K_REG_A6 = 7
	M68K_REG_A7 = 8
	M68K_REG_D0 = 9
	M68K_REG_D1 = 10
	M68K_REG_D2 = 11
	M68K_REG_D3 = 12
	M68K_REG_D4 = 13
	M68K_REG_D5 = 14
	M68K_REG_D6 = 15
	M68K_REG_D7 = 16
	M68K_REG_SR = 17
	M68K_REG_PC = 18
	M68K_REG_ENDING = 19
)",CWE-665,39.0,1
"package http
import (
	""io/fs""
	""net/http""
	""github.com/gorilla/mux""
	""github.com/filebrowser/filebrowser/v2/settings""
	""github.com/filebrowser/filebrowser/v2/storage""
)
type modifyRequest struct {
	What  string   `json:""what""`  // Answer to: what data type?
	Which []string `json:""which""` // Answer to: which fields?
}
func NewHandler(
	imgSvc ImgService,
	fileCache FileCache,
	store *storage.Storage,
	server *settings.Server,
	assetsFs fs.FS,
) (http.Handler, error) {
	server.Clean()
	r := mux.NewRouter()
	index, static := getStaticHandlers(store, server, assetsFs)
	// NOTE: This fixes the issue where it would redirect if people did not put a
	// trailing slash in the end. I hate this decision since this allows some awful
	// URLs https://www.gorillatoolkit.org/pkg/mux
	r = r.SkipClean(true)
	monkey := func(fn handleFunc, prefix string) http.Handler {
		return handle(fn, prefix, store, server)
	}
	r.HandleFunc(""/health"", healthHandler)
	r.PathPrefix(""/static"").Handler(static)
	r.NotFoundHandler = index
	api := r.PathPrefix(""/api"").Subrouter()
	api.Handle(""/login"", monkey(loginHandler, """"))
	api.Handle(""/signup"", monkey(signupHandler, """"))
	api.Handle(""/renew"", monkey(renewHandler, """"))
	users := api.PathPrefix(""/users"").Subrouter()
	users.Handle("""", monkey(usersGetHandler, """")).Methods(""GET"")
	users.Handle("""", monkey(userPostHandler, """")).Methods(""POST"")
	users.Handle(""/{id:[0-9]+}"", monkey(userPutHandler, """")).Methods(""PUT"")
	users.Handle(""/{id:[0-9]+}"", monkey(userGetHandler, """")).Methods(""GET"")
	users.Handle(""/{id:[0-9]+}"", monkey(userDeleteHandler, """")).Methods(""DELETE"")
	api.PathPrefix(""/resources"").Handler(monkey(resourceGetHandler, ""/api/resources"")).Methods(""GET"")
	api.PathPrefix(""/resources"").Handler(monkey(resourceDeleteHandler(fileCache), ""/api/resources"")).Methods(""DELETE"")
	api.PathPrefix(""/resources"").Handler(monkey(resourcePostHandler(fileCache), ""/api/resources"")).Methods(""POST"")
	api.PathPrefix(""/resources"").Handler(monkey(resourcePutHandler, ""/api/resources"")).Methods(""PUT"")
	api.PathPrefix(""/resources"").Handler(monkey(resourcePatchHandler(fileCache), ""/api/resources"")).Methods(""PATCH"")
	api.Path(""/shares"").Handler(monkey(shareListHandler, ""/api/shares"")).Methods(""GET"")
	api.PathPrefix(""/share"").Handler(monkey(shareGetsHandler, ""/api/share"")).Methods(""GET"")
	api.PathPrefix(""/share"").Handler(monkey(sharePostHandler, ""/api/share"")).Methods(""POST"")
	api.PathPrefix(""/share"").Handler(monkey(shareDeleteHandler, ""/api/share"")).Methods(""DELETE"")
	api.Handle(""/settings"", monkey(settingsGetHandler, """")).Methods(""GET"")
	api.Handle(""/settings"", monkey(settingsPutHandler, """")).Methods(""PUT"")
	api.PathPrefix(""/raw"").Handler(monkey(rawHandler, ""/api/raw"")).Methods(""GET"")
	api.PathPrefix(""/preview/{size}/{path:.*}"").
		Handler(monkey(previewHandler(imgSvc, fileCache, server.EnableThumbnails, server.ResizePreview), ""/api/preview"")).Methods(""GET"")
	api.PathPrefix(""/command"").Handler(monkey(commandsHandler, ""/api/command"")).Methods(""GET"")
	api.PathPrefix(""/search"").Handler(monkey(searchHandler, ""/api/search"")).Methods(""GET"")
	public := api.PathPrefix(""/public"").Subrouter()
	public.PathPrefix(""/dl"").Handler(monkey(publicDlHandler, ""/api/public/dl/"")).Methods(""GET"")
	public.PathPrefix(""/share"").Handler(monkey(publicShareHandler, ""/api/public/share/"")).Methods(""GET"")
	return stripPrefix(server.BaseURL, r), nil
}
",CWE-79,82.0,1
"package http
import (
	""bufio""
	""io""
	""log""
	""net/http""
	""os/exec""
	""strings""
	""time""
	""github.com/gorilla/websocket""
	""github.com/filebrowser/filebrowser/v2/runner""
)
const (
	WSWriteDeadline = 10 * time.Second
)
var upgrader = websocket.Upgrader{
	ReadBufferSize:  1024,
	WriteBufferSize: 1024,
}
var (
	cmdNotAllowed = []byte(""Command not allowed."")
)
func wsErr(ws *websocket.Conn, r *http.Request, status int, err error) { //nolint:unparam
	txt := http.StatusText(status)
	if err != nil || status >= 400 {
		log.Printf(""%s: %v %s %v"", r.URL.Path, status, r.RemoteAddr, err)
	}
	if err := ws.WriteControl(websocket.CloseInternalServerErr, []byte(txt), time.Now().Add(WSWriteDeadline)); err != nil {
		log.Print(err)
	}
}
var commandsHandler = withUser(func(w http.ResponseWriter, r *http.Request, d *data) (int, error) {
	conn, err := upgrader.Upgrade(w, r, nil)
	if err != nil {
		return http.StatusInternalServerError, err
	}
	defer conn.Close()
	var raw string
	for {
		_, msg, err := conn.ReadMessage() //nolint:govet
		if err != nil {
			wsErr(conn, r, http.StatusInternalServerError, err)
			return 0, nil
		}
		raw = strings.TrimSpace(string(msg))
		if raw != """" {
			break
		}
	}
	if !d.server.EnableExec || !d.user.CanExecute(strings.Split(raw, "" "")[0]) {
		if err := conn.WriteMessage(websocket.TextMessage, cmdNotAllowed); err != nil { //nolint:govet
			wsErr(conn, r, http.StatusInternalServerError, err)
		}
		return 0, nil
	}
	command, err := runner.ParseCommand(d.settings, raw)
	if err != nil {
		if err := conn.WriteMessage(websocket.TextMessage, []byte(err.Error())); err != nil { //nolint:govet
			wsErr(conn, r, http.StatusInternalServerError, err)
		}
		return 0, nil
	}
	cmd := exec.Command(command[0], command[1:]...) //nolint:gosec
	cmd.Dir = d.user.FullPath(r.URL.Path)
	stdout, err := cmd.StdoutPipe()
	if err != nil {
		wsErr(conn, r, http.StatusInternalServerError, err)
		return 0, nil
	}
	stderr, err := cmd.StderrPipe()
	if err != nil {
		wsErr(conn, r, http.StatusInternalServerError, err)
		return 0, nil
	}
	if err := cmd.Start(); err != nil {
		wsErr(conn, r, http.StatusInternalServerError, err)
		return 0, nil
	}
	s := bufio.NewScanner(io.MultiReader(stdout, stderr))
	for s.Scan() {
		if err := conn.WriteMessage(websocket.TextMessage, s.Bytes()); err != nil {
			log.Print(err)
		}
	}
	if err := cmd.Wait(); err != nil {
		wsErr(conn, r, http.StatusInternalServerError, err)
	}
	return 0, nil
})
",CWE-352,111.0,1
"// +build !libsodium
package internal
// This file contains functions that should return `nil`,
// in order to be able to build wal-g without specific implementations of the crypter.
// And the configure_crypter_<crypter>.go files must have a real implementation of the function.
//
// Thus, if the tag is missing, the condition:
// if crypter := configure<crypter>Crypter(); crypter != nil {
//     return crypter
// }
// will never be met.
// If there is a tag, we can configure the correct implementation of crypter.
import (
	""github.com/wal-g/wal-g/internal/crypto""
)
func configureLibsodiumCrypter() crypto.Crypter {
	return nil
}
",CWE-754,23.0,1
"package encoding
import (
	""encoding/binary""
	""io""
	""github.com/v2fly/v2ray-core/v4/common""
	""github.com/v2fly/v2ray-core/v4/common/buf""
	""github.com/v2fly/v2ray-core/v4/common/net""
	""github.com/v2fly/v2ray-core/v4/common/protocol""
	""github.com/v2fly/v2ray-core/v4/common/serial""
	""github.com/v2fly/v2ray-core/v4/common/uuid""
)
var (
	ErrCommandTypeMismatch = newError(""Command type mismatch."")
	ErrUnknownCommand      = newError(""Unknown command."")
	ErrCommandTooLarge     = newError(""Command too large."")
)
func MarshalCommand(command interface{}, writer io.Writer) error {
	if command == nil {
		return ErrUnknownCommand
	}
	var cmdID byte
	var factory CommandFactory
	switch command.(type) {
	case *protocol.CommandSwitchAccount:
		factory = new(CommandSwitchAccountFactory)
		cmdID = 1
	default:
		return ErrUnknownCommand
	}
	buffer := buf.New()
	defer buffer.Release()
	err := factory.Marshal(command, buffer)
	if err != nil {
		return err
	}
	auth := Authenticate(buffer.Bytes())
	length := buffer.Len() + 4
	if length > 255 {
		return ErrCommandTooLarge
	}
	common.Must2(writer.Write([]byte{cmdID, byte(length), byte(auth >> 24), byte(auth >> 16), byte(auth >> 8), byte(auth)}))
	common.Must2(writer.Write(buffer.Bytes()))
	return nil
}
func UnmarshalCommand(cmdID byte, data []byte) (protocol.ResponseCommand, error) {
	if len(data) <= 4 {
		return nil, newError(""insufficient length"")
	}
	expectedAuth := Authenticate(data[4:])
	actualAuth := binary.BigEndian.Uint32(data[:4])
	if expectedAuth != actualAuth {
		return nil, newError(""invalid auth"")
	}
	var factory CommandFactory
	switch cmdID {
	case 1:
		factory = new(CommandSwitchAccountFactory)
	default:
		return nil, ErrUnknownCommand
	}
	return factory.Unmarshal(data[4:])
}
type CommandFactory interface {
	Marshal(command interface{}, writer io.Writer) error
	Unmarshal(data []byte) (interface{}, error)
}
type CommandSwitchAccountFactory struct{}
func (f *CommandSwitchAccountFactory) Marshal(command interface{}, writer io.Writer) error {
	cmd, ok := command.(*protocol.CommandSwitchAccount)
	if !ok {
		return ErrCommandTypeMismatch
	}
	hostStr := """"
	if cmd.Host != nil {
		hostStr = cmd.Host.String()
	}
	common.Must2(writer.Write([]byte{byte(len(hostStr))}))
	if len(hostStr) > 0 {
		common.Must2(writer.Write([]byte(hostStr)))
	}
	common.Must2(serial.WriteUint16(writer, cmd.Port.Value()))
	idBytes := cmd.ID.Bytes()
	common.Must2(writer.Write(idBytes))
	common.Must2(serial.WriteUint16(writer, cmd.AlterIds))
	common.Must2(writer.Write([]byte{byte(cmd.Level)}))
	common.Must2(writer.Write([]byte{cmd.ValidMin}))
	return nil
}
func (f *CommandSwitchAccountFactory) Unmarshal(data []byte) (interface{}, error) {
	cmd := new(protocol.CommandSwitchAccount)
	if len(data) == 0 {
		return nil, newError(""insufficient length."")
	}
	lenHost := int(data[0])
	if len(data) < lenHost+1 {
		return nil, newError(""insufficient length."")
	}
	if lenHost > 0 {
		cmd.Host = net.ParseAddress(string(data[1 : 1+lenHost]))
	}
	portStart := 1 + lenHost
	if len(data) < portStart+2 {
		return nil, newError(""insufficient length."")
	}
	cmd.Port = net.PortFromBytes(data[portStart : portStart+2])
	idStart := portStart + 2
	if len(data) < idStart+16 {
		return nil, newError(""insufficient length."")
	}
	cmd.ID, _ = uuid.ParseBytes(data[idStart : idStart+16])
	alterIDStart := idStart + 16
	if len(data) < alterIDStart+2 {
		return nil, newError(""insufficient length."")
	}
	cmd.AlterIds = binary.BigEndian.Uint16(data[alterIDStart : alterIDStart+2])
	levelStart := alterIDStart + 2
	if len(data) < levelStart+1 {
		return nil, newError(""insufficient length."")
	}
	cmd.Level = uint32(data[levelStart])
	timeStart := levelStart + 1
	if len(data) < timeStart {
		return nil, newError(""insufficient length."")
	}
	cmd.ValidMin = data[timeStart]
	return cmd, nil
}
",CWE-193,148.0,1
"package encoding_test
import (
	""testing""
	""github.com/google/go-cmp/cmp""
	""github.com/v2fly/v2ray-core/v4/common""
	""github.com/v2fly/v2ray-core/v4/common/buf""
	""github.com/v2fly/v2ray-core/v4/common/protocol""
	""github.com/v2fly/v2ray-core/v4/common/uuid""
	. ""github.com/v2fly/v2ray-core/v4/proxy/vmess/encoding""
)
func TestSwitchAccount(t *testing.T) {
	sa := &protocol.CommandSwitchAccount{
		Port:     1234,
		ID:       uuid.New(),
		AlterIds: 1024,
		Level:    128,
		ValidMin: 16,
	}
	buffer := buf.New()
	common.Must(MarshalCommand(sa, buffer))
	cmd, err := UnmarshalCommand(1, buffer.BytesFrom(2))
	common.Must(err)
	sa2, ok := cmd.(*protocol.CommandSwitchAccount)
	if !ok {
		t.Fatal(""failed to convert command to CommandSwitchAccount"")
	}
	if r := cmp.Diff(sa2, sa); r != """" {
		t.Error(r)
	}
}
",CWE-193,38.0,1
"package operator
// Supported versions of the Grafana Agent.
var (
	AgentCompatibilityMatrix = []string{
		""v0.14.0"",
		""v0.15.0"",
		// ""v0.16.0"", // Pulled due to critical bug fixed in v0.16.1.
		""v0.16.1"",
		""v0.17.0"",
		""v0.18.0"",
		""v0.18.1"",
		""v0.18.2"",
		""v0.18.3"",
		""v0.18.4"",
		""v0.19.0"",
		""v0.20.0"",
		""v0.21.0"",
		""v0.21.1"",
		// NOTE(rfratto): when performing an upgrade, add the newest version above instead of changing the existing reference.
	}
	DefaultAgentVersion   = AgentCompatibilityMatrix[len(AgentCompatibilityMatrix)-1]
	DefaultAgentBaseImage = ""grafana/agent""
	DefaultAgentImage     = DefaultAgentBaseImage + "":"" + DefaultAgentVersion
)
",CWE-312,28.0,1
"{
	""name"": ""DynamicPageList3"",
	""version"": ""3.3.5"",
	""author"": [
		""Alexia E. Smith"",
		""[https://meta.miraheze.org/wiki/User:Universal_Omega Universal Omega]"",
		""[https://de.wikipedia.org/wiki/Benutzer:Algorithmix Gero Scholz]""
	],
	""url"": ""https://www.mediawiki.org/wiki/Extension:DynamicPageList3"",
	""descriptionmsg"": ""dpl-desc"",
	""license-name"": ""GPL-2.0-or-later"",
	""type"": ""parserhook"",
	""requires"": {
		""MediaWiki"": "">= 1.35.0""
	},
	""GroupPermissions"": {
		""sysop"": {
			""dpl_param_update_rules"": true,
			""dpl_param_delete_rules"": true
		}
	},
	""AvailableRights"": [
		""dpl_param_update_rules"",
		""dpl_param_delete_rules""
	],
	""MessagesDirs"": {
		""DynamicPageList"": [
			""i18n""
		]
	},
	""ExtensionMessagesFiles"": {
		""DynamicPageListMagic"": ""DynamicPageList.i18n.magic.php""
	},
	""AutoloadClasses"": {
		""DPL\\Article"": ""includes/Article.php"",
		""DPL\\Config"": ""includes/Config.php"",
		""DPL\\Heading\\DefinitionHeading"": ""includes/heading/DefinitionHeading.php"",
		""DPL\\Heading\\Heading"": ""includes/heading/Heading.php"",
		""DPL\\Heading\\OrderedHeading"": ""includes/heading/OrderedHeading.php"",
		""DPL\\Heading\\TieredHeading"": ""includes/heading/TieredHeading.php"",
		""DPL\\Heading\\UnorderedHeading"": ""includes/heading/UnorderedHeading.php"",
		""DPL\\Lister\\CategoryList"": ""includes/lister/CategoryList.php"",
		""DPL\\Lister\\DefinitionList"": ""includes/lister/DefinitionList.php"",
		""DPL\\Lister\\GalleryList"": ""includes/lister/GalleryList.php"",
		""DPL\\Lister\\InlineList"": ""includes/lister/InlineList.php"",
		""DPL\\Lister\\Lister"": ""includes/lister/Lister.php"",
		""DPL\\Lister\\OrderedList"": ""includes/lister/OrderedList.php"",
		""DPL\\Lister\\SubPageList"": ""includes/lister/SubPageList.php"",
		""DPL\\Lister\\UnorderedList"": ""includes/lister/UnorderedList.php"",
		""DPL\\Lister\\UserFormatList"": ""includes/lister/UserFormatList.php"",
		""DPL\\Logger"": ""includes/Logger.php"",
		""DPL\\LST"": ""includes/LST.php"",
		""DPL\\Maintenance\\CreateTemplate"": ""maintenance/createTemplate.php"",
		""DPL\\Parameters"": ""includes/Parameters.php"",
		""DPL\\ParametersData"": ""includes/ParametersData.php"",
		""DPL\\Parse"": ""includes/Parse.php"",
		""DPL\\Query"": ""includes/Query.php"",
		""DPL\\UpdateArticle"": ""includes/UpdateArticle.php"",
		""DPL\\Variables"": ""includes/Variables.php"",
		""DynamicPageListHooks"": ""DynamicPageListHooks.php""
	},
	""Hooks"": {
		""ParserFirstCallInit"": [
			""DynamicPageListHooks::onParserFirstCallInit""
		],
		""LoadExtensionSchemaUpdates"": [
			""DynamicPageListHooks::onLoadExtensionSchemaUpdates""
		]
	},
	""config"": {
		""DplSettings"": {
			""allowedNamespaces"": null,
			""allowUnlimitedCategories"": false,
			""allowUnlimitedResults"": false,
			""behavingLikeIntersection"": false,
			""categoryStyleListCutoff"": 6,
			""fixedCategories"": [],
			""functionalRichness"": 3,
			""maxCategoryCount"": 4,
			""minCategoryCount"": 0,
			""maxResultCount"": 500,
			""recursiveTagParse"": false,
			""runFromProtectedPagesOnly"": false,
			""handleSectionTag"": false,
			""alwaysCacheResults"": false
		}
	},
	""TrackingCategories"": [
		""dpl-tag-tracking-category"",
		""dpl-intersection-tracking-category"",
		""dpl-parserfunc-tracking-category"",
		""dplnum-parserfunc-tracking-category"",
		""dplvar-parserfunc-tracking-category"",
		""dplreplace-parserfunc-tracking-category"",
		""dplchapter-parserfunc-tracking-category"",
		""dplmatrix-parserfunc-tracking-category""
	],
	""callback"": ""DynamicPageListHooks::onRegistration"",
	""manifest_version"": 1
}
",CWE-400,101.0,1
"package authz
import (
	""time""
	proto ""github.com/gogo/protobuf/proto""
	cdctypes ""github.com/cosmos/cosmos-sdk/codec/types""
	sdkerrors ""github.com/cosmos/cosmos-sdk/types/errors""
)
// NewGrant returns new Grant
func NewGrant(a Authorization, expiration time.Time) (Grant, error) {
	g := Grant{
		Expiration: expiration,
	}
	msg, ok := a.(proto.Message)
	if !ok {
		return Grant{}, sdkerrors.Wrapf(sdkerrors.ErrPackAny, ""cannot proto marshal %T"", a)
	}
	any, err := cdctypes.NewAnyWithValue(msg)
	if err != nil {
		return Grant{}, err
	}
	g.Authorization = any
	return g, nil
}
var (
	_ cdctypes.UnpackInterfacesMessage = &Grant{}
)
// UnpackInterfaces implements UnpackInterfacesMessage.UnpackInterfaces
func (g Grant) UnpackInterfaces(unpacker cdctypes.AnyUnpacker) error {
	var authorization Authorization
	return unpacker.UnpackAny(g.Authorization, &authorization)
}
// GetAuthorization returns the cached value from the Grant.Authorization if present.
func (g Grant) GetAuthorization() Authorization {
	if g.Authorization == nil {
		return nil
	}
	a, ok := g.Authorization.GetCachedValue().(Authorization)
	if !ok {
		return nil
	}
	return a
}
func (g Grant) ValidateBasic() error {
	if g.Expiration.Unix() < time.Now().Unix() {
		return sdkerrors.Wrap(ErrInvalidExpirationTime, ""Time can't be in the past"")
	}
	av := g.Authorization.GetCachedValue()
	a, ok := av.(Authorization)
	if !ok {
		return sdkerrors.Wrapf(sdkerrors.ErrInvalidType, ""expected %T, got %T"", (Authorization)(nil), av)
	}
	return a.ValidateBasic()
}
",CWE-754,65.0,1
"package keeper
import (
	""context""
	sdk ""github.com/cosmos/cosmos-sdk/types""
	sdkerrors ""github.com/cosmos/cosmos-sdk/types/errors""
	""github.com/cosmos/cosmos-sdk/x/authz""
)
var _ authz.MsgServer = Keeper{}
// GrantAuthorization implements the MsgServer.Grant method.
func (k Keeper) Grant(goCtx context.Context, msg *authz.MsgGrant) (*authz.MsgGrantResponse, error) {
	ctx := sdk.UnwrapSDKContext(goCtx)
	grantee, err := sdk.AccAddressFromBech32(msg.Grantee)
	if err != nil {
		return nil, err
	}
	granter, err := sdk.AccAddressFromBech32(msg.Granter)
	if err != nil {
		return nil, err
	}
	authorization := msg.GetAuthorization()
	if authorization == nil {
		return nil, sdkerrors.ErrUnpackAny.Wrap(""Authorization is not present in the msg"")
	}
	t := authorization.MsgTypeURL()
	if k.router.HandlerByTypeURL(t) == nil {
		return nil, sdkerrors.Wrapf(sdkerrors.ErrInvalidType, ""%s doesn't exist."", t)
	}
	err = k.SaveGrant(ctx, grantee, granter, authorization, msg.Grant.Expiration)
	if err != nil {
		return nil, err
	}
	return &authz.MsgGrantResponse{}, nil
}
// RevokeAuthorization implements the MsgServer.Revoke method.
func (k Keeper) Revoke(goCtx context.Context, msg *authz.MsgRevoke) (*authz.MsgRevokeResponse, error) {
	ctx := sdk.UnwrapSDKContext(goCtx)
	grantee, err := sdk.AccAddressFromBech32(msg.Grantee)
	if err != nil {
		return nil, err
	}
	granter, err := sdk.AccAddressFromBech32(msg.Granter)
	if err != nil {
		return nil, err
	}
	err = k.DeleteGrant(ctx, grantee, granter, msg.MsgTypeUrl)
	if err != nil {
		return nil, err
	}
	return &authz.MsgRevokeResponse{}, nil
}
// Exec implements the MsgServer.Exec method.
func (k Keeper) Exec(goCtx context.Context, msg *authz.MsgExec) (*authz.MsgExecResponse, error) {
	ctx := sdk.UnwrapSDKContext(goCtx)
	grantee, err := sdk.AccAddressFromBech32(msg.Grantee)
	if err != nil {
		return nil, err
	}
	msgs, err := msg.GetMessages()
	if err != nil {
		return nil, err
	}
	results, err := k.DispatchActions(ctx, grantee, msgs)
	if err != nil {
		return nil, err
	}
	return &authz.MsgExecResponse{Results: results}, nil
}
",CWE-754,79.0,1
"package authz_test
import (
	""testing""
	""time""
	""github.com/stretchr/testify/require""
	cdctypes ""github.com/cosmos/cosmos-sdk/codec/types""
	sdk ""github.com/cosmos/cosmos-sdk/types""
	""github.com/cosmos/cosmos-sdk/x/authz""
	banktypes ""github.com/cosmos/cosmos-sdk/x/bank/types""
)
var (
	coinsPos = sdk.NewCoins(sdk.NewInt64Coin(""steak"", 100))
	granter  = sdk.AccAddress(""_______granter______"")
	grantee  = sdk.AccAddress(""_______grantee______"")
)
func TestMsgExecAuthorized(t *testing.T) {
	tests := []struct {
		title      string
		grantee    sdk.AccAddress
		msgs       []sdk.Msg
		expectPass bool
	}{
		{""nil grantee address"", nil, []sdk.Msg{}, false},
		{""zero-messages test: should fail"", grantee, []sdk.Msg{}, false},
		{""valid test: msg type"", grantee, []sdk.Msg{
			&banktypes.MsgSend{
				Amount:      sdk.NewCoins(sdk.NewInt64Coin(""steak"", 2)),
				FromAddress: granter.String(),
				ToAddress:   grantee.String(),
			},
		}, true},
	}
	for i, tc := range tests {
		msg := authz.NewMsgExec(tc.grantee, tc.msgs)
		if tc.expectPass {
			require.NoError(t, msg.ValidateBasic(), ""test: %v"", i)
		} else {
			require.Error(t, msg.ValidateBasic(), ""test: %v"", i)
		}
	}
}
func TestMsgRevokeAuthorization(t *testing.T) {
	tests := []struct {
		title            string
		granter, grantee sdk.AccAddress
		msgType          string
		expectPass       bool
	}{
		{""nil Granter address"", nil, grantee, ""hello"", false},
		{""nil Grantee address"", granter, nil, ""hello"", false},
		{""nil Granter and Grantee address"", nil, nil, ""hello"", false},
		{""valid test case"", granter, grantee, ""hello"", true},
	}
	for i, tc := range tests {
		msg := authz.NewMsgRevoke(tc.granter, tc.grantee, tc.msgType)
		if tc.expectPass {
			require.NoError(t, msg.ValidateBasic(), ""test: %v"", i)
		} else {
			require.Error(t, msg.ValidateBasic(), ""test: %v"", i)
		}
	}
}
func TestMsgGrantAuthorization(t *testing.T) {
	tests := []struct {
		title            string
		granter, grantee sdk.AccAddress
		authorization    authz.Authorization
		expiration       time.Time
		expectErr        bool
		expectPass       bool
	}{
		{""nil granter address"", nil, grantee, &banktypes.SendAuthorization{SpendLimit: coinsPos}, time.Now(), false, false},
		{""nil grantee address"", granter, nil, &banktypes.SendAuthorization{SpendLimit: coinsPos}, time.Now(), false, false},
		{""nil granter and grantee address"", nil, nil, &banktypes.SendAuthorization{SpendLimit: coinsPos}, time.Now(), false, false},
		{""nil authorization"", granter, grantee, nil, time.Now(), true, false},
		{""valid test case"", granter, grantee, &banktypes.SendAuthorization{SpendLimit: coinsPos}, time.Now().AddDate(0, 1, 0), false, true},
		{""past time"", granter, grantee, &banktypes.SendAuthorization{SpendLimit: coinsPos}, time.Now().AddDate(0, 0, -1), false, false},
	}
	for i, tc := range tests {
		msg, err := authz.NewMsgGrant(
			tc.granter, tc.grantee, tc.authorization, tc.expiration,
		)
		if !tc.expectErr {
			require.NoError(t, err)
		} else {
			continue
		}
		if tc.expectPass {
			require.NoError(t, msg.ValidateBasic(), ""test: %v"", i)
		} else {
			require.Error(t, msg.ValidateBasic(), ""test: %v"", i)
		}
	}
}
func TestMsgGrantGetAuthorization(t *testing.T) {
	require := require.New(t)
	m := authz.MsgGrant{}
	require.Nil(m.GetAuthorization())
	g := authz.GenericAuthorization{Msg: ""some_type""}
	var err error
	m.Grant.Authorization, err = cdctypes.NewAnyWithValue(&g)
	require.NoError(err)
	require.Equal(m.GetAuthorization(), &g)
	g = authz.GenericAuthorization{Msg: ""some_type2""}
	m.SetAuthorization(&g)
	require.Equal(m.GetAuthorization(), &g)
}
",CWE-754,118.0,1
"package main
import (
	""crypto/tls""
	""errors""
	""fmt""
	""log""
	""net/http""
	""github.com/StevenWeathers/thunderdome-planning-poker/pkg/database""
	ldap ""github.com/go-ldap/ldap/v3""
	""github.com/spf13/viper""
)
func (s *server) createCookie(UserID string) *http.Cookie {
	encoded, err := s.cookie.Encode(s.config.SecureCookieName, UserID)
	var NewCookie *http.Cookie
	if err == nil {
		NewCookie = &http.Cookie{
			Name:     s.config.SecureCookieName,
			Value:    encoded,
			Path:     s.config.PathPrefix + ""/"",
			HttpOnly: true,
			Domain:   s.config.AppDomain,
			MaxAge:   86400 * 30, // 30 days
			Secure:   s.config.SecureCookieFlag,
			SameSite: http.SameSiteStrictMode,
		}
	}
	return NewCookie
}
func (s *server) authUserDatabase(UserEmail string, UserPassword string) (*database.User, error) {
	AuthedUser, err := s.database.AuthUser(UserEmail, UserPassword)
	if err != nil {
		log.Println(""Failed authenticating user"", UserEmail)
	} else if AuthedUser == nil {
		log.Println(""Unknown user"", UserEmail)
	}
	return AuthedUser, err
}
// Authenticate using LDAP and if user does not exist, automatically add user as a verified user
func (s *server) authAndCreateUserLdap(UserName string, UserPassword string) (*database.User, error) {
	var AuthedUser *database.User
	l, err := ldap.DialURL(viper.GetString(""auth.ldap.url""))
	if err != nil {
		log.Println(""Failed connecting to ldap server at"", viper.GetString(""auth.ldap.url""))
		return AuthedUser, err
	}
	defer l.Close()
	if viper.GetBool(""auth.ldap.use_tls"") {
		err = l.StartTLS(&tls.Config{InsecureSkipVerify: true})
		if err != nil {
			log.Println(""Failed securing ldap connection"", err)
			return AuthedUser, err
		}
	}
	if viper.GetString(""auth.ldap.bindname"") != """" {
		err = l.Bind(viper.GetString(""auth.ldap.bindname""), viper.GetString(""auth.ldap.bindpass""))
		if err != nil {
			log.Println(""Failed binding for authentication:"", err)
			return AuthedUser, err
		}
	}
	searchRequest := ldap.NewSearchRequest(viper.GetString(""auth.ldap.basedn""),
		ldap.ScopeWholeSubtree, ldap.NeverDerefAliases, 0, 0, false,
		fmt.Sprintf(viper.GetString(""auth.ldap.filter""), UserName),
		[]string{""dn"", viper.GetString(""auth.ldap.mail_attr""), viper.GetString(""auth.ldap.cn_attr"")},
		nil,
	)
	sr, err := l.Search(searchRequest)
	if err != nil {
		log.Println(""Failed performing ldap search query for"", UserName, "":"", err)
		return AuthedUser, err
	}
	if len(sr.Entries) != 1 {
		log.Println(""User"", UserName, ""does not exist or too many entries returned"")
		return AuthedUser, errors.New(""user not found"")
	}
	userdn := sr.Entries[0].DN
	useremail := sr.Entries[0].GetAttributeValue(viper.GetString(""auth.ldap.mail_attr""))
	usercn := sr.Entries[0].GetAttributeValue(viper.GetString(""auth.ldap.cn_attr""))
	err = l.Bind(userdn, UserPassword)
	if err != nil {
		log.Println(""Failed authenticating user "", UserName)
		return AuthedUser, err
	}
	AuthedUser, err = s.database.GetUserByEmail(useremail)
	if AuthedUser == nil {
		log.Println(""User"", useremail, ""does not exist in database, auto-recruit"")
		newUser, verifyID, err := s.database.CreateUserRegistered(usercn, useremail, """", """")
		if err != nil {
			log.Println(""Failed auto-creating new user"", err)
			return AuthedUser, err
		}
		err = s.database.VerifyUserAccount(verifyID)
		if err != nil {
			log.Println(""Failed verifying new user"", err)
			return AuthedUser, err
		}
		AuthedUser = newUser
	}
	return AuthedUser, nil
}
",CWE-74,115.0,1
"package main
import (
	""crypto/tls""
	""errors""
	""fmt""
	""log""
	""net/http""
	""github.com/StevenWeathers/thunderdome-planning-poker/pkg/database""
	ldap ""github.com/go-ldap/ldap/v3""
	""github.com/spf13/viper""
)
func (s *server) createCookie(UserID string) *http.Cookie {
	encoded, err := s.cookie.Encode(s.config.SecureCookieName, UserID)
	var NewCookie *http.Cookie
	if err == nil {
		NewCookie = &http.Cookie{
			Name:     s.config.SecureCookieName,
			Value:    encoded,
			Path:     s.config.PathPrefix + ""/"",
			HttpOnly: true,
			Domain:   s.config.AppDomain,
			MaxAge:   86400 * 30, // 30 days
			Secure:   s.config.SecureCookieFlag,
			SameSite: http.SameSiteStrictMode,
		}
	}
	return NewCookie
}
func (s *server) authUserDatabase(UserEmail string, UserPassword string) (*database.User, error) {
	AuthedUser, err := s.database.AuthUser(UserEmail, UserPassword)
	if err != nil {
		log.Println(""Failed authenticating user"", UserEmail)
	} else if AuthedUser == nil {
		log.Println(""Unknown user"", UserEmail)
	}
	return AuthedUser, err
}
// Authenticate using LDAP and if user does not exist, automatically add user as a verified user
func (s *server) authAndCreateUserLdap(UserName string, UserPassword string) (*database.User, error) {
	var AuthedUser *database.User
	l, err := ldap.DialURL(viper.GetString(""auth.ldap.url""))
	if err != nil {
		log.Println(""Failed connecting to ldap server at"", viper.GetString(""auth.ldap.url""))
		return AuthedUser, err
	}
	defer l.Close()
	if viper.GetBool(""auth.ldap.use_tls"") {
		err = l.StartTLS(&tls.Config{InsecureSkipVerify: true})
		if err != nil {
			log.Println(""Failed securing ldap connection"", err)
			return AuthedUser, err
		}
	}
	if viper.GetString(""auth.ldap.bindname"") != """" {
		err = l.Bind(viper.GetString(""auth.ldap.bindname""), viper.GetString(""auth.ldap.bindpass""))
		if err != nil {
			log.Println(""Failed binding for authentication:"", err)
			return AuthedUser, err
		}
	}
	searchRequest := ldap.NewSearchRequest(viper.GetString(""auth.ldap.basedn""),
		ldap.ScopeWholeSubtree, ldap.NeverDerefAliases, 0, 0, false,
		fmt.Sprintf(viper.GetString(""auth.ldap.filter""), UserName),
		[]string{""dn"", viper.GetString(""auth.ldap.mail_attr""), viper.GetString(""auth.ldap.cn_attr"")},
		nil,
	)
	sr, err := l.Search(searchRequest)
	if err != nil {
		log.Println(""Failed performing ldap search query for"", UserName, "":"", err)
		return AuthedUser, err
	}
	if len(sr.Entries) != 1 {
		log.Println(""User"", UserName, ""does not exist or too many entries returned"")
		return AuthedUser, errors.New(""user not found"")
	}
	userdn := sr.Entries[0].DN
	useremail := sr.Entries[0].GetAttributeValue(viper.GetString(""auth.ldap.mail_attr""))
	usercn := sr.Entries[0].GetAttributeValue(viper.GetString(""auth.ldap.cn_attr""))
	err = l.Bind(userdn, UserPassword)
	if err != nil {
		log.Println(""Failed authenticating user "", UserName)
		return AuthedUser, err
	}
	AuthedUser, err = s.database.GetUserByEmail(useremail)
	if AuthedUser == nil {
		log.Println(""User"", useremail, ""does not exist in database, auto-recruit"")
		newUser, verifyID, err := s.database.CreateUserRegistered(usercn, useremail, """", """")
		if err != nil {
			log.Println(""Failed auto-creating new user"", err)
			return AuthedUser, err
		}
		err = s.database.VerifyUserAccount(verifyID)
		if err != nil {
			log.Println(""Failed verifying new user"", err)
			return AuthedUser, err
		}
		AuthedUser = newUser
	}
	return AuthedUser, nil
}
",CWE-116,115.0,1
"//
// Copyright (c) 2017 Cavium
// Copyright (c) 2021 Intel Corporation
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package transforms
import (
	""bytes""
	""crypto/aes""
	""crypto/cipher""
	""crypto/sha1"" //nolint: gosec
	""encoding/base64""
	""fmt""
	""github.com/edgexfoundry/app-functions-sdk-go/v2/pkg/interfaces""
	""github.com/edgexfoundry/app-functions-sdk-go/v2/pkg/util""
	""github.com/edgexfoundry/go-mod-core-contracts/v2/common""
)
type Encryption struct {
	SecretPath           string
	SecretName           string
	EncryptionKey        string
	InitializationVector string
}
// NewEncryption creates, initializes and returns a new instance of Encryption
func NewEncryption(encryptionKey string, initializationVector string) Encryption {
	return Encryption{
		EncryptionKey:        encryptionKey,
		InitializationVector: initializationVector,
	}
}
// NewEncryptionWithSecrets creates, initializes and returns a new instance of Encryption configured
// to retrieve the encryption key from the Secret Store
func NewEncryptionWithSecrets(secretPath string, secretName string, initializationVector string) Encryption {
	return Encryption{
		SecretPath:           secretPath,
		SecretName:           secretName,
		InitializationVector: initializationVector,
	}
}
// IV and KEY must be 16 bytes
const blockSize = 16
func pkcs5Padding(ciphertext []byte, blockSize int) []byte {
	padding := blockSize - len(ciphertext)%blockSize
	padText := bytes.Repeat([]byte{byte(padding)}, padding)
	return append(ciphertext, padText...)
}
// EncryptWithAES encrypts a string, []byte, or json.Marshaller type using AES encryption.
// It will return a Base64 encode []byte of the encrypted data.
func (aesData Encryption) EncryptWithAES(ctx interfaces.AppFunctionContext, data interface{}) (bool, interface{}) {
	if data == nil {
		return false, fmt.Errorf(""function EncryptWithAES in pipeline '%s': No Data Received"", ctx.PipelineId())
	}
	ctx.LoggingClient().Debugf(""Encrypting with AES in pipeline '%s'"", ctx.PipelineId())
	byteData, err := util.CoerceType(data)
	if err != nil {
		return false, err
	}
	iv := make([]byte, blockSize)
	copy(iv, aesData.InitializationVector)
	hash := sha1.New() //nolint: gosec
	// If using Secret Store for the encryption key
	if len(aesData.SecretPath) != 0 && len(aesData.SecretName) != 0 {
		// Note secrets are cached so this call doesn't result in unneeded calls to SecretStore Service and
		// the cache is invalidated when StoreSecrets is used.
		secretData, err := ctx.GetSecret(aesData.SecretPath, aesData.SecretName)
		if err != nil {
			return false, fmt.Errorf(
				""unable to retieve encryption key at secret path=%s and name=%s in pipeline '%s'"",
				aesData.SecretPath,
				aesData.SecretName,
				ctx.PipelineId())
		}
		key, ok := secretData[aesData.SecretName]
		if !ok {
			return false, fmt.Errorf(
				""unable find encryption key in secret data for name=%s in pipeline '%s'"",
				aesData.SecretName,
				ctx.PipelineId())
		}
		ctx.LoggingClient().Debugf(
			""Using encryption key from Secret Store at path=%s & name=%s in pipeline '%s'"",
			aesData.SecretPath,
			aesData.SecretName,
			ctx.PipelineId())
		aesData.EncryptionKey = key
	}
	if len(aesData.EncryptionKey) == 0 {
		return false, fmt.Errorf(""AES encryption key not set in pipeline '%s'"", ctx.PipelineId())
	}
	hash.Write([]byte((aesData.EncryptionKey)))
	key := hash.Sum(nil)
	key = key[:blockSize]
	block, err := aes.NewCipher(key)
	if err != nil {
		return false, fmt.Errorf(""failed to create new AES Cipher in pipeline '%s': %s"", ctx.PipelineId(), err)
	}
	ecb := cipher.NewCBCEncrypter(block, iv)
	content := pkcs5Padding(byteData, block.BlockSize())
	encrypted := make([]byte, len(content))
	ecb.CryptBlocks(encrypted, content)
	encodedData := []byte(base64.StdEncoding.EncodeToString(encrypted))
	// Set response ""content-type"" header to ""text/plain""
	ctx.SetResponseContentType(common.ContentTypeText)
	return true, encodedData
}
",CWE-327,142.0,1
"package web
import (
	""net/http""
	""github.com/gorilla/websocket""
	""github.com/julienschmidt/httprouter""
)
// Socket register a new websocket server at the given path
func (s *Server) Socket(path string, handle SocketHandle, options HandleOptions) {
	s.registerSocketEndpoint(""GET"", path, handle, options)
}
func (s *Server) registerSocketEndpoint(method string, path string, handle SocketHandle, options HandleOptions) {
	s.log.Debug(""Register HTTP %s %s"", method, path)
	s.router.Handle(method, path, s.socketHandler(handle, options))
}
var upgrader = websocket.Upgrader{
	ReadBufferSize:  1024,
	WriteBufferSize: 1024,
}
func (s *Server) socketHandler(endpointHandle SocketHandle, options HandleOptions) httprouter.Handle {
	return func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
		conn, err := upgrader.Upgrade(w, r, nil)
		if err != nil {
			s.log.Error(""Error upgrading client for websocket connection: %s"", err.Error())
			return
		}
		endpointHandle(Request{
			Params: ps,
			log:    s.log,
		}, WSConn{
			c: conn,
		})
		s.log.Debug(""HTTP WS Request: ws://%s"", r.RequestURI)
	}
}
",CWE-476,41.0,1
"package goutils
import (
	""testing""
	""unicode/utf8""
)
func TestCryptoRandomNonAlphaNumeric(t *testing.T) {
	// If asked for a string 0 characters long, CryptoRandomNonAlphaNumeric should provide an empty string.
	if x, _ := CryptoRandomNonAlphaNumeric(0); utf8.RuneCountInString(x) != 0 {
		t.Errorf(""String should be 0 characters; string was %v characters"", utf8.RuneCountInString(x))
	}
	// Test CryptoRandomNonAlphaNumeric's ability to generate strings 1 through 100 characters in length.
	for i := 1; i < 101; i++ {
		if x, _ := CryptoRandomNonAlphaNumeric(i); utf8.RuneCountInString(x) != i {
			t.Errorf(""String should be %v characters; string was %v characters"", i, utf8.RuneCountInString(x))
		}
	}
}
func TestCryptoRandomAscii(t *testing.T) {
	// If asked for a string 0 characters long, CryptoRandomAscii should provide an empty string.
	if x, _ := CryptoRandomAscii(0); len(x) != 0 {
		t.Errorf(""String should be 0 characters; string was %v characters"", len(x))
	}
	// Test CryptoRandomAscii's ability to generate strings 1 through 100 characters in length.
	for i := 1; i < 101; i++ {
		if x, _ := CryptoRandomAscii(i); len(x) != i {
			t.Errorf(""String should be %v characters; string was %v characters"", i, len(x))
		}
	}
}
func TestCryptoRandomNumeric(t *testing.T) {
	// If asked for a string 0 characters long, CryptoRandomNumeric should provide an empty string.
	if x, _ := CryptoRandomNumeric(0); len(x) != 0 {
		t.Errorf(""String should be 0 characters; string was %v characters"", len(x))
	}
	// Test CryptoRandomNumeric's ability to generate strings 1 through 100 characters in length.
	for i := 1; i < 101; i++ {
		if x, _ := CryptoRandomNumeric(i); len(x) != i {
			t.Errorf(""String should be %v characters; string was %v characters"", i, len(x))
		}
	}
}
func TestCryptoRandomAlphabetic(t *testing.T) {
	// If asked for a string 0 characters long, CryptoRandomAlphabetic should provide an empty string.
	if x, _ := CryptoRandomAlphabetic(0); len(x) != 0 {
		t.Errorf(""String should be 0 characters; string was %v characters"", len(x))
	}
	// Test CryptoRandomAlphabetic's ability to generate strings 1 through 100 characters in length.
	for i := 1; i < 101; i++ {
		if x, _ := CryptoRandomAlphabetic(i); len(x) != i {
			t.Errorf(""String should be %v characters; string was %v characters"", i, len(x))
		}
	}
}
func TestCryptoRandomAlphaNumeric(t *testing.T) {
	// If asked for a string 0 characters long, CryptoRandomAlphaNumeric should provide an empty string.
	if x, _ := CryptoRandomAlphaNumeric(0); len(x) != 0 {
		t.Errorf(""String should be 0 characters; string was %v characters"", len(x))
	}
	// Test CryptoRandomAlphaNumeric's ability to generate strings 1 through 100 characters in length.
	for i := 1; i < 101; i++ {
		if x, _ := CryptoRandomAlphaNumeric(i); len(x) != i {
			t.Errorf(""String should be %v characters; string was %v characters"", i, len(x))
		}
	}
}
",CWE-331,77.0,1
"package goutils
import (
	""fmt""
	""math/rand""
	""testing""
)
// ****************************** TESTS ********************************************
func TestRandomSeed(t *testing.T) {
	// count, start, end, letters, numbers := 5, 0, 0, true, true
	random := rand.New(rand.NewSource(10))
	out := ""3ip9v""
	// Test 1: Simulating RandomAlphaNumeric(count int)
	if x, _ := RandomSeed(5, 0, 0, true, true, nil, random); x != out {
		t.Errorf(""RandomSeed(%v, %v, %v, %v, %v, %v, %v) = %v, want %v"", 5, 0, 0, true, true, nil, random, x, out)
	}
	// Test 2: Simulating RandomAlphabetic(count int)
	out = ""MBrbj""
	if x, _ := RandomSeed(5, 0, 0, true, false, nil, random); x != out {
		t.Errorf(""RandomSeed(%v, %v, %v, %v, %v, %v, %v) = %v, want %v"", 5, 0, 0, true, false, nil, random, x, out)
	}
	// Test 3: Simulating RandomNumeric(count int)
	out = ""88935""
	if x, _ := RandomSeed(5, 0, 0, false, true, nil, random); x != out {
		t.Errorf(""RandomSeed(%v, %v, %v, %v, %v, %v, %v) = %v, want %v"", 5, 0, 0, false, true, nil, random, x, out)
	}
	// Test 4: Simulating RandomAscii(count int)
	out = ""H_I;E""
	if x, _ := RandomSeed(5, 32, 127, false, false, nil, random); x != out {
		t.Errorf(""RandomSeed(%v, %v, %v, %v, %v, %v, %v) = %v, want %v"", 5, 32, 127, false, false, nil, random, x, out)
	}
	// Test 5: Simulating RandomSeed(...) with custom chars
	chars := []rune{'1', '2', '3', 'a', 'b', 'c'}
	out = ""2b2ca""
	if x, _ := RandomSeed(5, 0, 0, false, false, chars, random); x != out {
		t.Errorf(""RandomSeed(%v, %v, %v, %v, %v, %v, %v) = %v, want %v"", 5, 0, 0, false, false, chars, random, x, out)
	}
}
// ****************************** EXAMPLES ********************************************
func ExampleRandomSeed() {
	var seed int64 = 10 // If you change this seed 
	random := rand.New(rand.NewSource(seed))
	chars := []rune{'1', '2', '3', 'a', 'b', 'c'}
	rand1, _ := RandomSeed(5, 0, 0, true, true, nil, random)      // RandomAlphaNumeric (Alphabets and numbers possible)
	rand2, _ := RandomSeed(5, 0, 0, true, false, nil, random)     // RandomAlphabetic (Only alphabets)
	rand3, _ := RandomSeed(5, 0, 0, false, true, nil, random)     // RandomNumeric (Only numbers)
	rand4, _ := RandomSeed(5, 32, 127, false, false, nil, random) // RandomAscii (Alphabets, numbers, and other ASCII chars)
	rand5, _ := RandomSeed(5, 0, 0, true, true, chars, random)    // RandomSeed with custom characters
	fmt.Println(rand1)
	fmt.Println(rand2)
	fmt.Println(rand3)
	fmt.Println(rand4)
	fmt.Println(rand5)
	// Output:
	// 3ip9v
	// MBrbj
	// 88935
	// H_I;E
	// 2b2ca
}
",CWE-331,79.0,1
"package osin
// Client information
type Client interface {
	// Client id
	GetId() string
	// Client secret
	GetSecret() string
	// Base client uri
	GetRedirectUri() string
	// Data to be passed to storage. Not used by the library.
	GetUserData() interface{}
}
// ClientSecretMatcher is an optional interface clients can implement
// which allows them to be the one to determine if a secret matches.
// If a Client implements ClientSecretMatcher, the framework will never call GetSecret
type ClientSecretMatcher interface {
	// SecretMatches returns true if the given secret matches
	ClientSecretMatches(secret string) bool
}
// DefaultClient stores all data in struct variables
type DefaultClient struct {
	Id          string
	Secret      string
	RedirectUri string
	UserData    interface{}
}
func (d *DefaultClient) GetId() string {
	return d.Id
}
func (d *DefaultClient) GetSecret() string {
	return d.Secret
}
func (d *DefaultClient) GetRedirectUri() string {
	return d.RedirectUri
}
func (d *DefaultClient) GetUserData() interface{} {
	return d.UserData
}
// Implement the ClientSecretMatcher interface
func (d *DefaultClient) ClientSecretMatches(secret string) bool {
	return d.Secret == secret
}
func (d *DefaultClient) CopyFrom(client Client) {
	d.Id = client.GetId()
	d.Secret = client.GetSecret()
	d.RedirectUri = client.GetRedirectUri()
	d.UserData = client.GetUserData()
}
",CWE-203,61.0,1
"package osin
import (
	""encoding/base64""
	""errors""
	""net/http""
	""net/url""
	""strings""
)
// Parse basic authentication header
type BasicAuth struct {
	Username string
	Password string
}
// Parse bearer authentication header
type BearerAuth struct {
	Code string
}
// CheckClientSecret determines whether the given secret matches a secret held by the client.
// Public clients return true for a secret of """"
func CheckClientSecret(client Client, secret string) bool {
	switch client := client.(type) {
	case ClientSecretMatcher:
		// Prefer the more secure method of giving the secret to the client for comparison
		return client.ClientSecretMatches(secret)
	default:
		// Fallback to the less secure method of extracting the plain text secret from the client for comparison
		return client.GetSecret() == secret
	}
}
// Return authorization header data
func CheckBasicAuth(r *http.Request) (*BasicAuth, error) {
	if r.Header.Get(""Authorization"") == """" {
		return nil, nil
	}
	s := strings.SplitN(r.Header.Get(""Authorization""), "" "", 2)
	if len(s) != 2 || s[0] != ""Basic"" {
		return nil, errors.New(""Invalid authorization header"")
	}
	b, err := base64.StdEncoding.DecodeString(s[1])
	if err != nil {
		return nil, err
	}
	pair := strings.SplitN(string(b), "":"", 2)
	if len(pair) != 2 {
		return nil, errors.New(""Invalid authorization message"")
	}
	// Decode the client_id and client_secret pairs as per
	// https://tools.ietf.org/html/rfc6749
	username, err := url.QueryUnescape(pair[0])
	if err != nil {
		return nil, err
	}
	password, err := url.QueryUnescape(pair[1])
	if err != nil {
		return nil, err
	}
	return &BasicAuth{Username: username, Password: password}, nil
}
// Return ""Bearer"" token from request. The header has precedence over query string.
func CheckBearerAuth(r *http.Request) *BearerAuth {
	authHeader := r.Header.Get(""Authorization"")
	authForm := r.FormValue(""code"")
	if authHeader == """" && authForm == """" {
		return nil
	}
	token := authForm
	if authHeader != """" {
		s := strings.SplitN(authHeader, "" "", 2)
		if (len(s) != 2 || strings.ToLower(s[0]) != ""bearer"") && token == """" {
			return nil
		}
		//Use authorization header token only if token type is bearer else query string access token would be returned
		if len(s) > 0 && strings.ToLower(s[0]) == ""bearer"" {
			token = s[1]
		}
	}
	return &BearerAuth{Code: token}
}
// getClientAuth checks client basic authentication in params if allowed,
// otherwise gets it from the header.
// Sets an error on the response if no auth is present or a server error occurs.
func (s Server) getClientAuth(w *Response, r *http.Request, allowQueryParams bool) *BasicAuth {
	if allowQueryParams {
		// Allow for auth without password
		if _, hasSecret := r.Form[""client_secret""]; hasSecret {
			auth := &BasicAuth{
				Username: r.FormValue(""client_id""),
				Password: r.FormValue(""client_secret""),
			}
			if auth.Username != """" {
				return auth
			}
		}
	}
	auth, err := CheckBasicAuth(r)
	if err != nil {
		s.setErrorAndLog(w, E_INVALID_REQUEST, err, ""get_client_auth=%s"", ""check auth error"")
		return nil
	}
	if auth == nil {
		s.setErrorAndLog(w, E_INVALID_REQUEST, errors.New(""Client authentication not sent""), ""get_client_auth=%s"", ""client authentication not sent"")
		return nil
	}
	return auth
}
",CWE-203,121.0,1
"module github.com/crypto-org-chain/cronos
go 1.17
require (
	github.com/armon/go-metrics v0.3.9
	github.com/cosmos/cosmos-sdk v0.44.3
	github.com/cosmos/ibc-go v1.2.2
	github.com/ethereum/go-ethereum v1.10.3
	github.com/gogo/protobuf v1.3.3
	github.com/golang/protobuf v1.5.2
	github.com/gorilla/mux v1.8.0
	github.com/grpc-ecosystem/grpc-gateway v1.16.0
	github.com/rakyll/statik v0.1.7
	github.com/spf13/cast v1.4.1
	github.com/spf13/cobra v1.2.1
	github.com/spf13/pflag v1.0.5
	github.com/stretchr/testify v1.7.0
	github.com/tendermint/tendermint v0.34.14
	github.com/tendermint/tm-db v0.6.4
	github.com/tharsis/ethermint v0.7.2
	google.golang.org/genproto v0.0.0-20210909211513-a8c4777a87af
	google.golang.org/grpc v1.41.0
	gopkg.in/yaml.v2 v2.4.0
)
require (
	filippo.io/edwards25519 v1.0.0-beta.2 // indirect
	github.com/99designs/keyring v1.1.6 // indirect
	github.com/ChainSafe/go-schnorrkel v0.0.0-20200405005733-88cbf1b4c40d // indirect
	github.com/DataDog/zstd v1.4.8 // indirect
	github.com/StackExchange/wmi v1.2.1 // indirect
	github.com/VictoriaMetrics/fastcache v1.5.7 // indirect
	github.com/Workiva/go-datastructures v1.0.52 // indirect
	github.com/allegro/bigcache v1.2.1 // indirect
	github.com/beorn7/perks v1.0.1 // indirect
	github.com/bgentry/speakeasy v0.1.0 // indirect
	github.com/btcsuite/btcd v0.22.0-beta // indirect
	github.com/btcsuite/btcutil v1.0.3-0.20201208143702-a53e38424cce // indirect
	github.com/cespare/xxhash v1.1.0 // indirect
	github.com/cespare/xxhash/v2 v2.1.1 // indirect
	github.com/coinbase/rosetta-sdk-go v0.6.10 // indirect
	github.com/confio/ics23/go v0.6.6 // indirect
	github.com/cosmos/go-bip39 v1.0.0 // indirect
	github.com/cosmos/iavl v0.17.1 // indirect
	github.com/cosmos/ledger-cosmos-go v0.11.1 // indirect
	github.com/cosmos/ledger-go v0.9.2 // indirect
	github.com/danieljoos/wincred v1.0.2 // indirect
	github.com/davecgh/go-spew v1.1.1 // indirect
	github.com/deckarep/golang-set v0.0.0-20180603214616-504e848d77ea // indirect
	github.com/desertbit/timer v0.0.0-20180107155436-c41aec40b27f // indirect
	github.com/dgraph-io/badger/v2 v2.2007.2 // indirect
	github.com/dgraph-io/ristretto v0.0.3 // indirect
	github.com/dgryski/go-farm v0.0.0-20200201041132-a6ae2369ad13 // indirect
	github.com/dustin/go-humanize v1.0.0 // indirect
	github.com/dvsekhvalnov/jose2go v0.0.0-20200901110807-248326c1351b // indirect
	github.com/edsrzf/mmap-go v1.0.0 // indirect
	github.com/enigmampc/btcutil v1.0.3-0.20200723161021-e2fb6adb2a25 // indirect
	github.com/felixge/httpsnoop v1.0.1 // indirect
	github.com/fsnotify/fsnotify v1.5.1 // indirect
	github.com/gballet/go-libpcsclite v0.0.0-20190607065134-2772fd86a8ff // indirect
	github.com/go-kit/kit v0.10.0 // indirect
	github.com/go-logfmt/logfmt v0.5.0 // indirect
	github.com/go-ole/go-ole v1.2.5 // indirect
	github.com/go-stack/stack v1.8.0 // indirect
	github.com/godbus/dbus v0.0.0-20190726142602-4481cbc300e2 // indirect
	github.com/gogo/gateway v1.1.0 // indirect
	github.com/golang/snappy v0.0.3 // indirect
	github.com/google/btree v1.0.1 // indirect
	github.com/google/orderedcode v0.0.1 // indirect
	github.com/google/uuid v1.3.0 // indirect
	github.com/gorilla/handlers v1.5.1 // indirect
	github.com/gorilla/websocket v1.4.2 // indirect
	github.com/grpc-ecosystem/go-grpc-middleware v1.3.0 // indirect
	github.com/gsterjov/go-libsecret v0.0.0-20161001094733-a6f4afe4910c // indirect
	github.com/gtank/merlin v0.1.1 // indirect
	github.com/gtank/ristretto255 v0.1.2 // indirect
	github.com/hashicorp/go-immutable-radix v1.0.0 // indirect
	github.com/hashicorp/go-uuid v1.0.2 // indirect
	github.com/hashicorp/golang-lru v0.5.5-0.20210104140557-80c98217689d // indirect
	github.com/hashicorp/hcl v1.0.0 // indirect
	github.com/hdevalence/ed25519consensus v0.0.0-20210204194344-59a8610d2b87 // indirect
	github.com/holiman/bloomfilter/v2 v2.0.3 // indirect
	github.com/holiman/uint256 v1.1.1 // indirect
	github.com/huin/goupnp v1.0.1-0.20210310174557-0ca763054c88 // indirect
	github.com/improbable-eng/grpc-web v0.14.1 // indirect
	github.com/inconshreveable/mousetrap v1.0.0 // indirect
	github.com/jackpal/go-nat-pmp v1.0.2-0.20160603034137-1fa385a6f458 // indirect
	github.com/jmhodges/levigo v1.0.0 // indirect
	github.com/keybase/go-keychain v0.0.0-20190712205309-48d3d31d256d // indirect
	github.com/klauspost/compress v1.11.9 // indirect
	github.com/lib/pq v1.10.2 // indirect
	github.com/libp2p/go-buffer-pool v0.0.2 // indirect
	github.com/magiconair/properties v1.8.5 // indirect
	github.com/mattn/go-isatty v0.0.14 // indirect
	github.com/mattn/go-runewidth v0.0.9 // indirect
	github.com/matttproud/golang_protobuf_extensions v1.0.1 // indirect
	github.com/mimoo/StrobeGo v0.0.0-20181016162300-f8f6d4d2b643 // indirect
	github.com/minio/highwayhash v1.0.1 // indirect
	github.com/mitchellh/mapstructure v1.4.2 // indirect
	github.com/mtibben/percent v0.2.1 // indirect
	github.com/olekukonko/tablewriter v0.0.5 // indirect
	github.com/palantir/stacktrace v0.0.0-20161112013806-78658fd2d177 // indirect
	github.com/pelletier/go-toml v1.9.4 // indirect
	github.com/petermattis/goid v0.0.0-20180202154549-b0b1615b78e5 // indirect
	github.com/pkg/errors v0.9.1 // indirect
	github.com/pmezard/go-difflib v1.0.0 // indirect
	github.com/prometheus/client_golang v1.11.0 // indirect
	github.com/prometheus/client_model v0.2.0 // indirect
	github.com/prometheus/common v0.29.0 // indirect
	github.com/prometheus/procfs v0.6.0 // indirect
	github.com/prometheus/tsdb v0.7.1 // indirect
	github.com/rcrowley/go-metrics v0.0.0-20201227073835-cf1acfcdf475 // indirect
	github.com/regen-network/cosmos-proto v0.3.1 // indirect
	github.com/rjeczalik/notify v0.9.1 // indirect
	github.com/rs/cors v1.8.0 // indirect
	github.com/rs/zerolog v1.25.0 // indirect
	github.com/sasha-s/go-deadlock v0.2.1-0.20190427202633-1595213edefa // indirect
	github.com/shirou/gopsutil v3.21.4-0.20210419000835-c7a38de76ee5+incompatible // indirect
	github.com/spf13/afero v1.6.0 // indirect
	github.com/spf13/jwalterweatherman v1.1.0 // indirect
	github.com/spf13/viper v1.9.0 // indirect
	github.com/status-im/keycard-go v0.0.0-20200402102358-957c09536969 // indirect
	github.com/subosito/gotenv v1.2.0 // indirect
	github.com/syndtr/goleveldb v1.0.1-0.20210305035536-64b5b1c73954 // indirect
	github.com/tecbot/gorocksdb v0.0.0-20191217155057-f0fad39f321c // indirect
	github.com/tendermint/btcd v0.1.1 // indirect
	github.com/tendermint/crypto v0.0.0-20191022145703-50d29ede1e15 // indirect
	github.com/tendermint/go-amino v0.16.0 // indirect
	github.com/tklauser/go-sysconf v0.3.7 // indirect
	github.com/tklauser/numcpus v0.2.3 // indirect
	github.com/tyler-smith/go-bip39 v1.1.0 // indirect
	github.com/zondax/hid v0.9.0 // indirect
	go.etcd.io/bbolt v1.3.6 // indirect
	golang.org/x/crypto v0.0.0-20210817164053-32db794688a5 // indirect
	golang.org/x/net v0.0.0-20210903162142-ad29c8ab022f // indirect
	golang.org/x/sync v0.0.0-20210220032951-036812b2e83c // indirect
	golang.org/x/sys v0.0.0-20210903071746-97244b99971b // indirect
	golang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1 // indirect
	golang.org/x/text v0.3.6 // indirect
	google.golang.org/protobuf v1.27.1 // indirect
	gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c // indirect
	gopkg.in/ini.v1 v1.63.2 // indirect
	gopkg.in/natefinch/npipe.v2 v2.0.0-20160621034901-c1b8fa8bdcce // indirect
	gopkg.in/olebedev/go-duktape.v3 v3.0.0-20200619000410-60c24ae608a6 // indirect
	gopkg.in/yaml.v3 v3.0.0-20210107192922-496545a6307b // indirect
	nhooyr.io/websocket v1.8.6 // indirect
)
replace google.golang.org/grpc => google.golang.org/grpc v1.33.2
replace github.com/gogo/protobuf => github.com/regen-network/protobuf v1.3.3-alpha.regen.1
// TODO: fix keyring upstream
replace github.com/99designs/keyring => github.com/crypto-org-chain/keyring v1.1.6-fixes
// TODO: remove when middleware will be implemented
replace github.com/cosmos/ibc-go => github.com/crypto-org-chain/ibc-go v1.2.1-hooks
replace github.com/cosmos/iavl => github.com/cosmos/iavl v0.17.1
replace github.com/ethereum/go-ethereum => github.com/crypto-org-chain/go-ethereum v1.10.3-patched
// TODO: remove when ibc-go and ethermint upgrades cosmos-sdk
replace github.com/cosmos/cosmos-sdk => github.com/cosmos/cosmos-sdk v0.44.2
replace github.com/tharsis/ethermint => github.com/crypto-org-chain/ethermint v0.7.2-cronos-4
",CWE-670,168.0,1
"/*
 * SPDX-License-Identifier: Apache-2.0
 *
 * The OpenSearch Contributors require contributions made to
 * this file be licensed under the Apache-2.0 license or a
 * compatible open source license.
 *
 * Modifications Copyright OpenSearch Contributors. See
 * GitHub history for details.
 */
/*
 * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the ""license"" file accompanying this file. This file is distributed
 * on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package commands
import (
	""fmt""
	""opensearch-cli/entity""
	""os""
	""path/filepath""
	""runtime""
	""github.com/spf13/cobra""
)
const (
	configFileType        = ""yaml""
	defaultConfigFileName = ""config""
	flagConfig            = ""config""
	flagProfileName       = ""profile""
	folderPermission      = 0755 // only owner can write, while everyone can read and execute
	ConfigEnvVarName      = ""OPENSEARCH_CLI_CONFIG""
	RootCommandName       = ""opensearch-cli""
	version               = ""1.0.0""
)
func buildVersionString() string {
	return fmt.Sprintf(""%s %s/%s"", version, runtime.GOOS, runtime.GOARCH)
}
var rootCommand = &cobra.Command{
	Use:     RootCommandName,
	Short:   ""opensearch-cli is a unified command line interface for managing OpenSearch clusters"",
	Version: buildVersionString(),
}
func GetRoot() *cobra.Command {
	return rootCommand
}
// Execute executes the root command.
func Execute() error {
	err := rootCommand.Execute()
	return err
}
func GetDefaultConfigFilePath() string {
	return filepath.Join(
		getDefaultConfigFolderRootPath(),
		fmt.Sprintf("".%s"", RootCommandName),
		fmt.Sprintf(""%s.%s"", defaultConfigFileName, configFileType),
	)
}
func getDefaultConfigFolderRootPath() string {
	if homeDir, err := os.UserHomeDir(); err == nil {
		return homeDir
	}
	if cwd, err := os.Getwd(); err == nil {
		return cwd
	}
	return """"
}
func init() {
	cobra.OnInitialize()
	configFilePath := GetDefaultConfigFilePath()
	rootCommand.PersistentFlags().StringP(flagConfig, ""c"", """", fmt.Sprintf(""Configuration file for opensearch-cli, default is %s"", configFilePath))
	rootCommand.PersistentFlags().StringP(flagProfileName, ""p"", """", ""Use a specific profile from your configuration file"")
	rootCommand.Flags().BoolP(""version"", ""v"", false, ""Version for opensearch-cli"")
	rootCommand.Flags().BoolP(""help"", ""h"", false, ""Help for opensearch-cli"")
}
// GetConfigFilePath gets config file path for execution
func GetConfigFilePath(configFlagValue string) (string, error) {
	if configFlagValue != """" {
		return configFlagValue, nil
	}
	if value, ok := os.LookupEnv(ConfigEnvVarName); ok {
		return value, nil
	}
	if err := createDefaultConfigFileIfNotExists(); err != nil {
		return """", err
	}
	return GetDefaultConfigFilePath(), nil
}
// createDefaultConfigFolderIfNotExists creates default config file along with folder if
// it doesn't exists
func createDefaultConfigFileIfNotExists() error {
	defaultFilePath := GetDefaultConfigFilePath()
	if isExists(defaultFilePath) {
		return nil
	}
	folderPath := filepath.Dir(defaultFilePath)
	if !isExists(folderPath) {
		err := os.Mkdir(folderPath, folderPermission)
		if err != nil {
			return err
		}
	}
	f, err := os.Create(defaultFilePath)
	if err != nil {
		return err
	}
	return f.Close()
}
//isExists check if given path exists or not
//if path is just a name, it will check in current directory
func isExists(path string) bool {
	if _, err := os.Stat(path); os.IsNotExist(err) {
		return false
	}
	return true
}
// DisplayError prints command name and error on console and exists as well.
func DisplayError(err error, cmdName string) {
	if err != nil {
		fmt.Println(cmdName, ""Command failed."")
		fmt.Println(""Reason:"", err)
	}
}
// GetProfile gets profile details for current execution
func GetProfile() (*entity.Profile, error) {
	p, err := GetProfileController()
	if err != nil {
		return nil, err
	}
	profileFlagValue, err := rootCommand.PersistentFlags().GetString(flagProfileName)
	if err != nil {
		return nil, err
	}
	profile, ok, err := p.GetProfileForExecution(profileFlagValue)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, fmt.Errorf(""no profile found for execution. Try %s %s --help for more information"", RootCommandName, ProfileCommandName)
	}
	return &profile, nil
}
",CWE-276,169.0,1
"package logic
import (
	""errors""
	""fmt""
	""time""
	""github.com/golang-jwt/jwt/v4""
	""github.com/gravitl/netmaker/logger""
	""github.com/gravitl/netmaker/models""
	""github.com/gravitl/netmaker/servercfg""
)
var jwtSecretKey []byte
// SetJWTSecret - sets the jwt secret on server startup
func SetJWTSecret() {
	currentSecret, jwtErr := FetchJWTSecret()
	if jwtErr != nil {
		jwtSecretKey = []byte(RandomString(64)) // 512 bit random password
		if err := StoreJWTSecret(string(jwtSecretKey)); err != nil {
			logger.FatalLog(""something went wrong when configuring JWT authentication"")
		}
	} else {
		jwtSecretKey = []byte(currentSecret)
	}
}
// CreateJWT func will used to create the JWT while signing in and signing out
func CreateJWT(uuid string, macAddress string, network string) (response string, err error) {
	expirationTime := time.Now().Add(5 * time.Minute)
	claims := &models.Claims{
		ID:         uuid,
		Network:    network,
		MacAddress: macAddress,
		StandardClaims: jwt.StandardClaims{
			Issuer:    ""Netmaker"",
			Subject:   fmt.Sprintf(""node|%s"", uuid),
			IssuedAt:  time.Now().Unix(),
			ExpiresAt: expirationTime.Unix(),
		},
	}
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	tokenString, err := token.SignedString(jwtSecretKey)
	if err == nil {
		return tokenString, nil
	}
	return """", err
}
// CreateUserJWT - creates a user jwt token
func CreateUserJWT(username string, networks []string, isadmin bool) (response string, err error) {
	expirationTime := time.Now().Add(60 * 12 * time.Minute)
	claims := &models.UserClaims{
		UserName: username,
		Networks: networks,
		IsAdmin:  isadmin,
		StandardClaims: jwt.StandardClaims{
			Issuer:    ""Netmaker"",
			IssuedAt:  time.Now().Unix(),
			Subject:   fmt.Sprintf(""user|%s"", username),
			ExpiresAt: expirationTime.Unix(),
		},
	}
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	tokenString, err := token.SignedString(jwtSecretKey)
	if err == nil {
		return tokenString, nil
	}
	return """", err
}
// VerifyToken func will used to Verify the JWT Token while using APIS
func VerifyUserToken(tokenString string) (username string, networks []string, isadmin bool, err error) {
	claims := &models.UserClaims{}
	if tokenString == servercfg.GetMasterKey() {
		return ""masteradministrator"", nil, true, nil
	}
	token, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {
		return jwtSecretKey, nil
	})
	if token != nil && token.Valid {
		// check that user exists
		if user, err := GetUser(claims.UserName); user.UserName != """" && err == nil {
			return claims.UserName, claims.Networks, claims.IsAdmin, nil
		}
		err = errors.New(""user does not exist"")
	}
	return """", nil, false, err
}
// VerifyToken - gRPC [nodes] Only
func VerifyToken(tokenString string) (nodeID string, mac string, network string, err error) {
	claims := &models.Claims{}
	//this may be a stupid way of serving up a master key
	//TODO: look into a different method. Encryption?
	if tokenString == servercfg.GetMasterKey() {
		return ""mastermac"", """", """", nil
	}
	token, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {
		return jwtSecretKey, nil
	})
	if token != nil {
		return claims.ID, claims.MacAddress, claims.Network, nil
	}
	return """", """", """", err
}
",CWE-321,116.0,1
"{
	""root"": true,
	""extends"": ""@ljharb/eslint-config/node/6"",
	""rules"": {
		""consistent-return"": 1,
		""func-name-matching"": 0,
		""max-nested-callbacks"": 0,
		""sort-keys"": 0,
	},
}
",CWE-78,13.0,1
"// Copyright 2014 The Gogs Authors. All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.
//go:build pam
// +build pam
package pam
import (
	""errors""
	""github.com/msteinert/pam""
)
// Supported is true when built with PAM
var Supported = true
// Auth pam auth service
func Auth(serviceName, userName, passwd string) (string, error) {
	t, err := pam.StartFunc(serviceName, userName, func(s pam.Style, msg string) (string, error) {
		switch s {
		case pam.PromptEchoOff:
			return passwd, nil
		case pam.PromptEchoOn, pam.ErrorMsg, pam.TextInfo:
			return """", nil
		}
		return """", errors.New(""Unrecognized PAM message style"")
	})
	if err != nil {
		return """", err
	}
	if err = t.Authenticate(0); err != nil {
		return """", err
	}
	// PAM login names might suffer transformations in the PAM stack.
	// We should take whatever the PAM stack returns for it.
	return t.GetItem(pam.User)
}
",CWE-862,42.0,1
"// Copyright 2021 The Gitea Authors. All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.
package typesniffer
import (
	""fmt""
	""io""
	""net/http""
	""regexp""
	""strings""
	""code.gitea.io/gitea/modules/util""
)
// Use at most this many bytes to determine Content Type.
const sniffLen = 1024
// SvgMimeType MIME type of SVG images.
const SvgMimeType = ""image/svg+xml""
var (
	svgTagRegex      = regexp.MustCompile(`(?si)\A\s*(?:(<!--.*?-->|<!DOCTYPE\s+svg([\s:]+.*?>|>))\s*)*<svg[\s>\/]`)
	svgTagInXMLRegex = regexp.MustCompile(`(?si)\A<\?xml\b.*?\?>\s*(?:(<!--.*?-->|<!DOCTYPE\s+svg([\s:]+.*?>|>))\s*)*<svg[\s>\/]`)
)
// SniffedType contains information about a blobs type.
type SniffedType struct {
	contentType string
}
// IsText etects if content format is plain text.
func (ct SniffedType) IsText() bool {
	return strings.Contains(ct.contentType, ""text/"")
}
// IsImage detects if data is an image format
func (ct SniffedType) IsImage() bool {
	return strings.Contains(ct.contentType, ""image/"")
}
// IsSvgImage detects if data is an SVG image format
func (ct SniffedType) IsSvgImage() bool {
	return strings.Contains(ct.contentType, SvgMimeType)
}
// IsPDF detects if data is a PDF format
func (ct SniffedType) IsPDF() bool {
	return strings.Contains(ct.contentType, ""application/pdf"")
}
// IsVideo detects if data is an video format
func (ct SniffedType) IsVideo() bool {
	return strings.Contains(ct.contentType, ""video/"")
}
// IsAudio detects if data is an video format
func (ct SniffedType) IsAudio() bool {
	return strings.Contains(ct.contentType, ""audio/"")
}
// IsRepresentableAsText returns true if file content can be represented as
// plain text or is empty.
func (ct SniffedType) IsRepresentableAsText() bool {
	return ct.IsText() || ct.IsSvgImage()
}
// DetectContentType extends http.DetectContentType with more content types. Defaults to text/unknown if input is empty.
func DetectContentType(data []byte) SniffedType {
	if len(data) == 0 {
		return SniffedType{""text/unknown""}
	}
	ct := http.DetectContentType(data)
	if len(data) > sniffLen {
		data = data[:sniffLen]
	}
	if (strings.Contains(ct, ""text/plain"") || strings.Contains(ct, ""text/html"")) && svgTagRegex.Match(data) ||
		strings.Contains(ct, ""text/xml"") && svgTagInXMLRegex.Match(data) {
		// SVG is unsupported. https://github.com/golang/go/issues/15888
		ct = SvgMimeType
	}
	return SniffedType{ct}
}
// DetectContentTypeFromReader guesses the content type contained in the reader.
func DetectContentTypeFromReader(r io.Reader) (SniffedType, error) {
	buf := make([]byte, sniffLen)
	n, err := util.ReadAtMost(r, buf)
	if err != nil {
		return SniffedType{}, fmt.Errorf(""DetectContentTypeFromReader io error: %w"", err)
	}
	buf = buf[:n]
	return DetectContentType(buf), nil
}
",CWE-79,101.0,1
"// Copyright 2021 The Gitea Authors. All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.
package common
import (
	""fmt""
	""io""
	""path""
	""path/filepath""
	""strings""
	""time""
	""code.gitea.io/gitea/modules/charset""
	""code.gitea.io/gitea/modules/context""
	""code.gitea.io/gitea/modules/git""
	""code.gitea.io/gitea/modules/httpcache""
	""code.gitea.io/gitea/modules/log""
	""code.gitea.io/gitea/modules/setting""
	""code.gitea.io/gitea/modules/typesniffer""
	""code.gitea.io/gitea/modules/util""
)
// ServeBlob download a git.Blob
func ServeBlob(ctx *context.Context, blob *git.Blob, lastModified time.Time) error {
	if httpcache.HandleGenericETagTimeCache(ctx.Req, ctx.Resp, `""`+blob.ID.String()+`""`, lastModified) {
		return nil
	}
	dataRc, err := blob.DataAsync()
	if err != nil {
		return err
	}
	defer func() {
		if err = dataRc.Close(); err != nil {
			log.Error(""ServeBlob: Close: %v"", err)
		}
	}()
	return ServeData(ctx, ctx.Repo.TreePath, blob.Size(), dataRc)
}
// ServeData download file from io.Reader
func ServeData(ctx *context.Context, name string, size int64, reader io.Reader) error {
	buf := make([]byte, 1024)
	n, err := util.ReadAtMost(reader, buf)
	if err != nil {
		return err
	}
	if n >= 0 {
		buf = buf[:n]
	}
	ctx.Resp.Header().Set(""Cache-Control"", ""public,max-age=86400"")
	if size >= 0 {
		ctx.Resp.Header().Set(""Content-Length"", fmt.Sprintf(""%d"", size))
	} else {
		log.Error(""ServeData called to serve data: %s with size < 0: %d"", name, size)
	}
	name = path.Base(name)
	// Google Chrome dislike commas in filenames, so let's change it to a space
	name = strings.ReplaceAll(name, "","", "" "")
	st := typesniffer.DetectContentType(buf)
	mappedMimeType := """"
	if setting.MimeTypeMap.Enabled {
		fileExtension := strings.ToLower(filepath.Ext(name))
		mappedMimeType = setting.MimeTypeMap.Map[fileExtension]
	}
	if st.IsText() || ctx.FormBool(""render"") {
		cs, err := charset.DetectEncoding(buf)
		if err != nil {
			log.Error(""Detect raw file %s charset failed: %v, using by default utf-8"", name, err)
			cs = ""utf-8""
		}
		if mappedMimeType == """" {
			mappedMimeType = ""text/plain""
		}
		ctx.Resp.Header().Set(""Content-Type"", mappedMimeType+""; charset=""+strings.ToLower(cs))
	} else {
		ctx.Resp.Header().Set(""Access-Control-Expose-Headers"", ""Content-Disposition"")
		if mappedMimeType != """" {
			ctx.Resp.Header().Set(""Content-Type"", mappedMimeType)
		}
		if (st.IsImage() || st.IsPDF()) && (setting.UI.SVG.Enabled || !st.IsSvgImage()) {
			ctx.Resp.Header().Set(""Content-Disposition"", fmt.Sprintf(`inline; filename=""%s""`, name))
			if st.IsSvgImage() {
				ctx.Resp.Header().Set(""Content-Security-Policy"", ""default-src 'none'; style-src 'unsafe-inline'; sandbox"")
				ctx.Resp.Header().Set(""X-Content-Type-Options"", ""nosniff"")
				ctx.Resp.Header().Set(""Content-Type"", typesniffer.SvgMimeType)
			}
		} else {
			ctx.Resp.Header().Set(""Content-Disposition"", fmt.Sprintf(`attachment; filename=""%s""`, name))
		}
	}
	_, err = ctx.Resp.Write(buf)
	if err != nil {
		return err
	}
	_, err = io.Copy(ctx.Resp, reader)
	return err
}
",CWE-79,108.0,1
"// Copyright 2023 The Gitea Authors. All rights reserved.
// SPDX-License-Identifier: MIT
package context
import (
	""errors""
	""fmt""
	""net""
	""net/http""
	""net/url""
	""path""
	""strconv""
	""strings""
	""time""
	user_model ""code.gitea.io/gitea/models/user""
	""code.gitea.io/gitea/modules/base""
	""code.gitea.io/gitea/modules/log""
	""code.gitea.io/gitea/modules/setting""
	""code.gitea.io/gitea/modules/templates""
	""code.gitea.io/gitea/modules/web/middleware""
)
// RedirectToUser redirect to a differently-named user
func RedirectToUser(ctx *Base, userName string, redirectUserID int64) {
	user, err := user_model.GetUserByID(ctx, redirectUserID)
	if err != nil {
		ctx.Error(http.StatusInternalServerError, ""unable to get user"")
		return
	}
	redirectPath := strings.Replace(
		ctx.Req.URL.EscapedPath(),
		url.PathEscape(userName),
		url.PathEscape(user.Name),
		1,
	)
	if ctx.Req.URL.RawQuery != """" {
		redirectPath += ""?"" + ctx.Req.URL.RawQuery
	}
	ctx.Redirect(path.Join(setting.AppSubURL, redirectPath), http.StatusTemporaryRedirect)
}
// RedirectToFirst redirects to first not empty URL
func (ctx *Context) RedirectToFirst(location ...string) {
	for _, loc := range location {
		if len(loc) == 0 {
			continue
		}
		// Unfortunately browsers consider a redirect Location with preceding ""//"" and ""/\"" as meaning redirect to ""http(s)://REST_OF_PATH""
		// Therefore we should ignore these redirect locations to prevent open redirects
		if len(loc) > 1 && loc[0] == '/' && (loc[1] == '/' || loc[1] == '\\') {
			continue
		}
		u, err := url.Parse(loc)
		if err != nil || ((u.Scheme != """" || u.Host != """") && !strings.HasPrefix(strings.ToLower(loc), strings.ToLower(setting.AppURL))) {
			continue
		}
		ctx.Redirect(loc)
		return
	}
	ctx.Redirect(setting.AppSubURL + ""/"")
}
const tplStatus500 base.TplName = ""status/500""
// HTML calls Context.HTML and renders the template to HTTP response
func (ctx *Context) HTML(status int, name base.TplName) {
	log.Debug(""Template: %s"", name)
	tmplStartTime := time.Now()
	if !setting.IsProd {
		ctx.Data[""TemplateName""] = name
	}
	ctx.Data[""TemplateLoadTimes""] = func() string {
		return strconv.FormatInt(time.Since(tmplStartTime).Nanoseconds()/1e6, 10) + ""ms""
	}
	err := ctx.Render.HTML(ctx.Resp, status, string(name), ctx.Data)
	if err == nil {
		return
	}
	// if rendering fails, show error page
	if name != tplStatus500 {
		err = fmt.Errorf(""failed to render template: %s, error: %s"", name, templates.HandleTemplateRenderingError(err))
		ctx.ServerError(""Render failed"", err) // show the 500 error page
	} else {
		ctx.PlainText(http.StatusInternalServerError, ""Unable to render status/500 page, the template system is broken, or Gitea can't find your template files."")
		return
	}
}
// RenderToString renders the template content to a string
func (ctx *Context) RenderToString(name base.TplName, data map[string]interface{}) (string, error) {
	var buf strings.Builder
	err := ctx.Render.HTML(&buf, http.StatusOK, string(name), data)
	return buf.String(), err
}
// RenderWithErr used for page has form validation but need to prompt error to users.
func (ctx *Context) RenderWithErr(msg string, tpl base.TplName, form interface{}) {
	if form != nil {
		middleware.AssignForm(form, ctx.Data)
	}
	ctx.Flash.ErrorMsg = msg
	ctx.Data[""Flash""] = ctx.Flash
	ctx.HTML(http.StatusOK, tpl)
}
// NotFound displays a 404 (Not Found) page and prints the given error, if any.
func (ctx *Context) NotFound(logMsg string, logErr error) {
	ctx.notFoundInternal(logMsg, logErr)
}
func (ctx *Context) notFoundInternal(logMsg string, logErr error) {
	if logErr != nil {
		log.Log(2, log.DEBUG, ""%s: %v"", logMsg, logErr)
		if !setting.IsProd {
			ctx.Data[""ErrorMsg""] = logErr
		}
	}
	// response simple message if Accept isn't text/html
	showHTML := false
	for _, part := range ctx.Req.Header[""Accept""] {
		if strings.Contains(part, ""text/html"") {
			showHTML = true
			break
		}
	}
	if !showHTML {
		ctx.plainTextInternal(3, http.StatusNotFound, []byte(""Not found.\n""))
		return
	}
	ctx.Data[""IsRepo""] = ctx.Repo.Repository != nil
	ctx.Data[""Title""] = ""Page Not Found""
	ctx.HTML(http.StatusNotFound, base.TplName(""status/404""))
}
// ServerError displays a 500 (Internal Server Error) page and prints the given error, if any.
func (ctx *Context) ServerError(logMsg string, logErr error) {
	ctx.serverErrorInternal(logMsg, logErr)
}
func (ctx *Context) serverErrorInternal(logMsg string, logErr error) {
	if logErr != nil {
		log.ErrorWithSkip(2, ""%s: %v"", logMsg, logErr)
		if _, ok := logErr.(*net.OpError); ok || errors.Is(logErr, &net.OpError{}) {
			// This is an error within the underlying connection
			// and further rendering will not work so just return
			return
		}
		// it's safe to show internal error to admin users, and it helps
		if !setting.IsProd || (ctx.Doer != nil && ctx.Doer.IsAdmin) {
			ctx.Data[""ErrorMsg""] = fmt.Sprintf(""%s, %s"", logMsg, logErr)
		}
	}
	ctx.Data[""Title""] = ""Internal Server Error""
	ctx.HTML(http.StatusInternalServerError, tplStatus500)
}
// NotFoundOrServerError use error check function to determine if the error
// is about not found. It responds with 404 status code for not found error,
// or error context description for logging purpose of 500 server error.
func (ctx *Context) NotFoundOrServerError(logMsg string, errCheck func(error) bool, logErr error) {
	if errCheck(logErr) {
		ctx.notFoundInternal(logMsg, logErr)
		return
	}
	ctx.serverErrorInternal(logMsg, logErr)
}
",CWE-601,182.0,1
"{
	""name"": ""git-interface"",
	""version"": ""2.1.1"",
	""description"": ""some interfaces for work with git repository"",
	""main"": ""dist/index"",
	""typings"": ""dist/index"",
	""scripts"": {
		""clean"": ""rm -rf ./dist"",
		""build"": ""npm run clean && npm run ts"",
		""dev"": ""npm run clean &&  ./node_modules/.bin/tsc -w"",
		""ts"": ""./node_modules/.bin/tsc"",
		""prepublish"": ""npm run build""
	},
	""repository"": {
		""type"": ""git"",
		""url"": ""git://github.com/yarkeev/git-interface.git""
	},
	""keywords"": [
		""git"",
		""hash"",
		""pull"",
		""push"",
		""commit"",
		""last changes"",
		""checkout"",
		""merge"",
		""conflicts"",
		""cvs""
	],
	""author"": ""Yarkeev Denis <denis.yarkeev@gmail.com>"",
	""license"": ""MIT"",
	""bugs"": {
		""url"": ""https://github.com/yarkeev/git-interface/issues""
	},
	""homepage"": ""https://github.com/yarkeev/git-interface"",
	""devDependencies"": {
		""@types/node"": ""^10.10.3"",
		""typescript"": ""^3.0.3""
	}
}
",CWE-78,41.0,1
"package restful
// Copyright 2013 Ernest Micklei. All rights reserved.
// Use of this source code is governed by a license
// that can be found in the LICENSE file.
import (
	""regexp""
	""strconv""
	""strings""
)
// CrossOriginResourceSharing is used to create a Container Filter that implements CORS.
// Cross-origin resource sharing (CORS) is a mechanism that allows JavaScript on a web page
// to make XMLHttpRequests to another domain, not the domain the JavaScript originated from.
//
// http://en.wikipedia.org/wiki/Cross-origin_resource_sharing
// http://enable-cors.org/server.html
// http://www.html5rocks.com/en/tutorials/cors/
type CrossOriginResourceSharing struct {
	ExposeHeaders  []string // list of Header names
	AllowedHeaders []string // list of Header names
	AllowedDomains []string // list of allowed values for Http Origin. An allowed value can be a regular expression to support subdomain matching. If empty all are allowed.
	AllowedMethods []string
	MaxAge         int // number of seconds before requiring new Options request
	CookiesAllowed bool
	Container      *Container
	allowedOriginPatterns []*regexp.Regexp // internal field for origin regexp check.
}
// Filter is a filter function that implements the CORS flow as documented on http://enable-cors.org/server.html
// and http://www.html5rocks.com/static/images/cors_server_flowchart.png
func (c CrossOriginResourceSharing) Filter(req *Request, resp *Response, chain *FilterChain) {
	origin := req.Request.Header.Get(HEADER_Origin)
	if len(origin) == 0 {
		if trace {
			traceLogger.Print(""no Http header Origin set"")
		}
		chain.ProcessFilter(req, resp)
		return
	}
	if !c.isOriginAllowed(origin) { // check whether this origin is allowed
		if trace {
			traceLogger.Printf(""HTTP Origin:%s is not part of %v, neither matches any part of %v"", origin, c.AllowedDomains, c.allowedOriginPatterns)
		}
		chain.ProcessFilter(req, resp)
		return
	}
	if req.Request.Method != ""OPTIONS"" {
		c.doActualRequest(req, resp)
		chain.ProcessFilter(req, resp)
		return
	}
	if acrm := req.Request.Header.Get(HEADER_AccessControlRequestMethod); acrm != """" {
		c.doPreflightRequest(req, resp)
	} else {
		c.doActualRequest(req, resp)
		chain.ProcessFilter(req, resp)
		return
	}
}
func (c CrossOriginResourceSharing) doActualRequest(req *Request, resp *Response) {
	c.setOptionsHeaders(req, resp)
	// continue processing the response
}
func (c *CrossOriginResourceSharing) doPreflightRequest(req *Request, resp *Response) {
	if len(c.AllowedMethods) == 0 {
		if c.Container == nil {
			c.AllowedMethods = DefaultContainer.computeAllowedMethods(req)
		} else {
			c.AllowedMethods = c.Container.computeAllowedMethods(req)
		}
	}
	acrm := req.Request.Header.Get(HEADER_AccessControlRequestMethod)
	if !c.isValidAccessControlRequestMethod(acrm, c.AllowedMethods) {
		if trace {
			traceLogger.Printf(""Http header %s:%s is not in %v"",
				HEADER_AccessControlRequestMethod,
				acrm,
				c.AllowedMethods)
		}
		return
	}
	acrhs := req.Request.Header.Get(HEADER_AccessControlRequestHeaders)
	if len(acrhs) > 0 {
		for _, each := range strings.Split(acrhs, "","") {
			if !c.isValidAccessControlRequestHeader(strings.Trim(each, "" "")) {
				if trace {
					traceLogger.Printf(""Http header %s:%s is not in %v"",
						HEADER_AccessControlRequestHeaders,
						acrhs,
						c.AllowedHeaders)
				}
				return
			}
		}
	}
	resp.AddHeader(HEADER_AccessControlAllowMethods, strings.Join(c.AllowedMethods, "",""))
	resp.AddHeader(HEADER_AccessControlAllowHeaders, acrhs)
	c.setOptionsHeaders(req, resp)
	// return http 200 response, no body
}
func (c CrossOriginResourceSharing) setOptionsHeaders(req *Request, resp *Response) {
	c.checkAndSetExposeHeaders(resp)
	c.setAllowOriginHeader(req, resp)
	c.checkAndSetAllowCredentials(resp)
	if c.MaxAge > 0 {
		resp.AddHeader(HEADER_AccessControlMaxAge, strconv.Itoa(c.MaxAge))
	}
}
func (c CrossOriginResourceSharing) isOriginAllowed(origin string) bool {
	if len(origin) == 0 {
		return false
	}
	if len(c.AllowedDomains) == 0 {
		return true
	}
	allowed := false
	for _, domain := range c.AllowedDomains {
		if domain == origin {
			allowed = true
			break
		}
	}
	if !allowed {
		if len(c.allowedOriginPatterns) == 0 {
			// compile allowed domains to allowed origin patterns
			allowedOriginRegexps, err := compileRegexps(c.AllowedDomains)
			if err != nil {
				return false
			}
			c.allowedOriginPatterns = allowedOriginRegexps
		}
		for _, pattern := range c.allowedOriginPatterns {
			if allowed = pattern.MatchString(origin); allowed {
				break
			}
		}
	}
	return allowed
}
func (c CrossOriginResourceSharing) setAllowOriginHeader(req *Request, resp *Response) {
	origin := req.Request.Header.Get(HEADER_Origin)
	if c.isOriginAllowed(origin) {
		resp.AddHeader(HEADER_AccessControlAllowOrigin, origin)
	}
}
func (c CrossOriginResourceSharing) checkAndSetExposeHeaders(resp *Response) {
	if len(c.ExposeHeaders) > 0 {
		resp.AddHeader(HEADER_AccessControlExposeHeaders, strings.Join(c.ExposeHeaders, "",""))
	}
}
func (c CrossOriginResourceSharing) checkAndSetAllowCredentials(resp *Response) {
	if c.CookiesAllowed {
		resp.AddHeader(HEADER_AccessControlAllowCredentials, ""true"")
	}
}
func (c CrossOriginResourceSharing) isValidAccessControlRequestMethod(method string, allowedMethods []string) bool {
	for _, each := range allowedMethods {
		if each == method {
			return true
		}
	}
	return false
}
func (c CrossOriginResourceSharing) isValidAccessControlRequestHeader(header string) bool {
	for _, each := range c.AllowedHeaders {
		if strings.ToLower(each) == strings.ToLower(header) {
			return true
		}
		if each == ""*"" {
			return true
		}
	}
	return false
}
// Take a list of strings and compile them into a list of regular expressions.
func compileRegexps(regexpStrings []string) ([]*regexp.Regexp, error) {
	regexps := []*regexp.Regexp{}
	for _, regexpStr := range regexpStrings {
		r, err := regexp.Compile(regexpStr)
		if err != nil {
			return regexps, err
		}
		regexps = append(regexps, r)
	}
	return regexps, nil
}
",CWE-639,206.0,1
"package restful
import (
	""net/http""
	""net/http/httptest""
	""testing""
)
// go test -v -test.run TestCORSFilter_Preflight ...restful
// http://www.html5rocks.com/en/tutorials/cors/
func TestCORSFilter_Preflight(t *testing.T) {
	tearDown()
	ws := new(WebService)
	ws.Route(ws.PUT(""/cors"").To(dummy))
	Add(ws)
	cors := CrossOriginResourceSharing{
		ExposeHeaders:  []string{""X-Custom-Header""},
		AllowedHeaders: []string{""X-Custom-Header"", ""X-Additional-Header""},
		CookiesAllowed: true,
		Container:      DefaultContainer}
	Filter(cors.Filter)
	// Preflight
	httpRequest, _ := http.NewRequest(""OPTIONS"", ""http://api.alice.com/cors"", nil)
	httpRequest.Method = ""OPTIONS""
	httpRequest.Header.Set(HEADER_Origin, ""http://api.bob.com"")
	httpRequest.Header.Set(HEADER_AccessControlRequestMethod, ""PUT"")
	httpRequest.Header.Set(HEADER_AccessControlRequestHeaders, ""X-Custom-Header, X-Additional-Header"")
	httpWriter := httptest.NewRecorder()
	DefaultContainer.Dispatch(httpWriter, httpRequest)
	actual := httpWriter.Header().Get(HEADER_AccessControlAllowOrigin)
	if ""http://api.bob.com"" != actual {
		t.Fatal(""expected: http://api.bob.com but got:"" + actual)
	}
	actual = httpWriter.Header().Get(HEADER_AccessControlAllowMethods)
	if ""PUT"" != actual {
		t.Fatal(""expected: PUT but got:"" + actual)
	}
	actual = httpWriter.Header().Get(HEADER_AccessControlAllowHeaders)
	if ""X-Custom-Header, X-Additional-Header"" != actual {
		t.Fatal(""expected: X-Custom-Header, X-Additional-Header but got:"" + actual)
	}
	if !cors.isOriginAllowed(""somewhere"") {
		t.Fatal(""origin expected to be allowed"")
	}
	cors.AllowedDomains = []string{""overthere.com""}
	if cors.isOriginAllowed(""somewhere"") {
		t.Fatal(""origin [somewhere] expected NOT to be allowed"")
	}
	if !cors.isOriginAllowed(""overthere.com"") {
		t.Fatal(""origin [overthere] expected to be allowed"")
	}
}
// go test -v -test.run TestCORSFilter_Actual ...restful
// http://www.html5rocks.com/en/tutorials/cors/
func TestCORSFilter_Actual(t *testing.T) {
	tearDown()
	ws := new(WebService)
	ws.Route(ws.PUT(""/cors"").To(dummy))
	Add(ws)
	cors := CrossOriginResourceSharing{
		ExposeHeaders:  []string{""X-Custom-Header""},
		AllowedHeaders: []string{""X-Custom-Header"", ""X-Additional-Header""},
		CookiesAllowed: true,
		Container:      DefaultContainer}
	Filter(cors.Filter)
	// Actual
	httpRequest, _ := http.NewRequest(""PUT"", ""http://api.alice.com/cors"", nil)
	httpRequest.Header.Set(HEADER_Origin, ""http://api.bob.com"")
	httpRequest.Header.Set(""X-Custom-Header"", ""value"")
	httpWriter := httptest.NewRecorder()
	DefaultContainer.Dispatch(httpWriter, httpRequest)
	actual := httpWriter.Header().Get(HEADER_AccessControlAllowOrigin)
	if ""http://api.bob.com"" != actual {
		t.Fatal(""expected: http://api.bob.com but got:"" + actual)
	}
	if httpWriter.Body.String() != ""dummy"" {
		t.Fatal(""expected: dummy but got:"" + httpWriter.Body.String())
	}
}
var allowedDomainInput = []struct {
	domains []string
	origin  string
	allowed bool
}{
	{[]string{}, ""http://anything.com"", true},
	{[]string{""example.com""}, ""example.com"", true},
	{[]string{""example.com""}, ""not-allowed"", false},
	{[]string{""not-matching.com"", ""example.com""}, ""example.com"", true},
	{[]string{"".*""}, ""example.com"", true},
}
// go test -v -test.run TestCORSFilter_AllowedDomains ...restful
func TestCORSFilter_AllowedDomains(t *testing.T) {
	for _, each := range allowedDomainInput {
		tearDown()
		ws := new(WebService)
		ws.Route(ws.PUT(""/cors"").To(dummy))
		Add(ws)
		cors := CrossOriginResourceSharing{
			AllowedDomains: each.domains,
			CookiesAllowed: true,
			Container:      DefaultContainer}
		Filter(cors.Filter)
		httpRequest, _ := http.NewRequest(""PUT"", ""http://api.his.com/cors"", nil)
		httpRequest.Header.Set(HEADER_Origin, each.origin)
		httpWriter := httptest.NewRecorder()
		DefaultContainer.Dispatch(httpWriter, httpRequest)
		actual := httpWriter.Header().Get(HEADER_AccessControlAllowOrigin)
		if actual != each.origin && each.allowed {
			t.Fatal(""expected to be accepted"")
		}
		if actual == each.origin && !each.allowed {
			t.Fatal(""did not expect to be accepted"")
		}
	}
}
",CWE-639,130.0,1
"package fasthttp
var (
	defaultServerName  = []byte(""fasthttp"")
	defaultUserAgent   = []byte(""fasthttp"")
	defaultContentType = []byte(""text/plain; charset=utf-8"")
)
var (
	strSlash            = []byte(""/"")
	strSlashSlash       = []byte(""//"")
	strSlashDotDot      = []byte(""/.."")
	strSlashDotSlash    = []byte(""/./"")
	strSlashDotDotSlash = []byte(""/../"")
	strCRLF             = []byte(""\r\n"")
	strHTTP             = []byte(""http"")
	strHTTPS            = []byte(""https"")
	strHTTP10           = []byte(""HTTP/1.0"")
	strHTTP11           = []byte(""HTTP/1.1"")
	strColon            = []byte("":"")
	strColonSlashSlash  = []byte(""://"")
	strColonSpace       = []byte("": "")
	strCommaSpace       = []byte("", "")
	strGMT              = []byte(""GMT"")
	strResponseContinue = []byte(""HTTP/1.1 100 Continue\r\n\r\n"")
	strExpect             = []byte(HeaderExpect)
	strConnection         = []byte(HeaderConnection)
	strContentLength      = []byte(HeaderContentLength)
	strContentType        = []byte(HeaderContentType)
	strDate               = []byte(HeaderDate)
	strHost               = []byte(HeaderHost)
	strReferer            = []byte(HeaderReferer)
	strServer             = []byte(HeaderServer)
	strTransferEncoding   = []byte(HeaderTransferEncoding)
	strContentEncoding    = []byte(HeaderContentEncoding)
	strAcceptEncoding     = []byte(HeaderAcceptEncoding)
	strUserAgent          = []byte(HeaderUserAgent)
	strCookie             = []byte(HeaderCookie)
	strSetCookie          = []byte(HeaderSetCookie)
	strLocation           = []byte(HeaderLocation)
	strIfModifiedSince    = []byte(HeaderIfModifiedSince)
	strLastModified       = []byte(HeaderLastModified)
	strAcceptRanges       = []byte(HeaderAcceptRanges)
	strRange              = []byte(HeaderRange)
	strContentRange       = []byte(HeaderContentRange)
	strAuthorization      = []byte(HeaderAuthorization)
	strTE                 = []byte(HeaderTE)
	strTrailer            = []byte(HeaderTrailer)
	strMaxForwards        = []byte(HeaderMaxForwards)
	strProxyConnection    = []byte(HeaderProxyConnection)
	strProxyAuthenticate  = []byte(HeaderProxyAuthenticate)
	strProxyAuthorization = []byte(HeaderProxyAuthorization)
	strWWWAuthenticate    = []byte(HeaderWWWAuthenticate)
	strCookieExpires        = []byte(""expires"")
	strCookieDomain         = []byte(""domain"")
	strCookiePath           = []byte(""path"")
	strCookieHTTPOnly       = []byte(""HttpOnly"")
	strCookieSecure         = []byte(""secure"")
	strCookieMaxAge         = []byte(""max-age"")
	strCookieSameSite       = []byte(""SameSite"")
	strCookieSameSiteLax    = []byte(""Lax"")
	strCookieSameSiteStrict = []byte(""Strict"")
	strCookieSameSiteNone   = []byte(""None"")
	strClose               = []byte(""close"")
	strGzip                = []byte(""gzip"")
	strBr                  = []byte(""br"")
	strDeflate             = []byte(""deflate"")
	strKeepAlive           = []byte(""keep-alive"")
	strUpgrade             = []byte(""Upgrade"")
	strChunked             = []byte(""chunked"")
	strIdentity            = []byte(""identity"")
	str100Continue         = []byte(""100-continue"")
	strPostArgsContentType = []byte(""application/x-www-form-urlencoded"")
	strDefaultContentType  = []byte(""application/octet-stream"")
	strMultipartFormData   = []byte(""multipart/form-data"")
	strBoundary            = []byte(""boundary"")
	strBytes               = []byte(""bytes"")
	strBasicSpace          = []byte(""Basic "")
	strApplicationSlash = []byte(""application/"")
	strImageSVG         = []byte(""image/svg"")
	strImageIcon        = []byte(""image/x-icon"")
	strFontSlash        = []byte(""font/"")
	strMultipartSlash   = []byte(""multipart/"")
	strTextSlash        = []byte(""text/"")
)
",CWE-22,91.0,1
"{
	""name"": ""ShortDescription"",
	""license-name"": ""GPL-3.0-or-later"",
	""version"": ""2.3.3"",
	""url"": ""https://www.mediawiki.org/wiki/Extension:ShortDescription"",
	""author"": [
		""alistair3149""
	],
	""namemsg"": ""shortdescription"",
	""descriptionmsg"": ""shortdescription-desc"",
	""type"": ""api"",
	""requires"": {
		""MediaWiki"": "">= 1.35.0""
	},
	""MessagesDirs"": {
		""ShortDescription"": [
			""i18n"",
			""i18n/api""
		]
	},
	""ResourceFileModulePaths"": {
		""localBasePath"": ""modules"",
		""remoteExtPath"": ""ShortDescription/modules""
	},
	""ResourceModules"": {
		""ext.shortDescription"": {
			""scripts"": [
				""ext.shortDescription.js""
			],
			""styles"": ""ext.shortDescription.less""
		}
	},
	""AutoloadNamespaces"": {
		""MediaWiki\\Extension\\ShortDescription\\"": ""includes/""
	},
	""APIPropModules"": {
		""description"": ""MediaWiki\\Extension\\ShortDescription\\ApiQueryDescription""
	},
	""ExtensionMessagesFiles"": {
		""ShortDescriptionMagic"": ""ShortDescription.i18n.magic.php""
	},
	""Hooks"": {
		""ApiOpenSearchSuggest"": ""api"",
		""BeforePageDisplay"": ""page"",
		""InfoAction"": ""actions"",
		""OutputPageParserOutput"": ""parser"",
		""ParserFirstCallInit"": ""parser"",
		""SearchResultProvideDescription"": ""rest""
	},
	""HookHandlers"": {
		""actions"": {
			""class"": ""MediaWiki\\Extension\\ShortDescription\\Hooks\\ActionsHooks""
		},
		""api"": {
			""class"": ""MediaWiki\\Extension\\ShortDescription\\Hooks\\ApiHooks""
		},
		""page"": {
			""class"": ""MediaWiki\\Extension\\ShortDescription\\Hooks\\PageHooks""
		},
		""parser"": {
			""class"": ""MediaWiki\\Extension\\ShortDescription\\Hooks\\ParserHooks""
		},
		""rest"": {
			""class"": ""MediaWiki\\Extension\\ShortDescription\\Hooks\\RestHooks""
		}
	},
	""config"": {
		""ShortDescriptionEnableTagline"": {
			""value"": true,
			""description"": ""Enable short description in site tagline.""
		},
		""ShortDescriptionExtendOpenSearchXml"": {
			""value"": false,
			""description"": ""Provide short description to the Opensearch API module.""
		}
	},
	""ConfigRegistry"": {
		""shortdescription"": ""GlobalVarConfig::newInstance""
	},
	""manifest_version"": 2
}
",CWE-79,82.0,1
"package auth
import (
	""time""
	""github.com/golang-jwt/jwt""
	""github.com/sipcapture/homer-app/model""
	""github.com/sipcapture/homer-app/utils/logger""
)
// jwt token claims which contains info regarding user
type JwtUserClaim struct {
	UserName        string `json:""username""`
	UserAdmin       bool   `json:""useradmin""`
	UserGroup       string `json:""usergroup""`
	ExternalAuth    bool   `json:""externalauth""`
	ExternalProfile string `json:""externaltype""`
	DisplayName     string `json:""displayname""`
	Avatar          string `json:""avatar""`
	jwt.StandardClaims
}
func Token(user model.TableUser) (string, error) {
	tNow := time.Now()
	tUTC := tNow
	newTUTC := tUTC.Add(time.Duration(TokenExpiryTime) * time.Minute)
	// Set custom claims
	claims := &JwtUserClaim{
		user.UserName,
		user.IsAdmin,
		user.UserGroup,
		user.ExternalAuth,
		user.ExternalProfile,
		user.FirstName + "" "" + user.LastName,
		user.Avatar,
		jwt.StandardClaims{
			ExpiresAt: newTUTC.Unix(),
		},
	}
	logger.Debug(""Current time : "", tNow)
	logger.Debug(""Local time : "", tUTC)
	logger.Debug(""Expire Local time : "", newTUTC)
	// Create token with claims
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	// Generate encoded token and send it as response.
	t, err := token.SignedString([]byte(JwtSecret))
	if err != nil {
		return """", err
	}
	return t, nil
}
",CWE-798,59.0,1
"package config
import (
	""net/http""
	""github.com/sipcapture/homer-app/model""
	""golang.org/x/oauth2""
)
var Setting HomerSettingServer
var OAuth2TokenMap map[string]model.OAuth2MapToken
type HomerSettingServer struct {
	MAIN_SETTINGS struct {
		IsolateQuery        string `default:""""`
		IsolateGroup        string `default:""""`
		UseCaptureIDInAlias bool   `default:""false""`
		DefaultAuth         string `default:""internal""`
		EnableGravatar      bool   `default:""false""`
		GravatarUrl         string `default:""https://www.gravatar.com/avatar/%s.jpg""`
		OAuth2Config        oauth2.Config
		GlobalToken         *oauth2.Token
		UserGroups          []string `default:""[admin,user,support]""`
		SubscribeHttpClient *http.Client
		TimeoutHttpClient   uint32 `default:""10""`
	}
	GRAFANA_SETTINGS struct {
		URL      string `default:""http://grafana/""`
		AuthKey  string `default:""""`
		User     string `default:""""`
		Password string `default:""""`
		Path     string `default:""/grafana""`
		Enable   bool   `default:""false""`
	}
	TRANSACTION_SETTINGS struct {
		DedupModel        string `default:""message-ip-pair""`
		GlobalDeduplicate bool   `default:""false""`
	}
	DASHBOARD_SETTINGS struct {
		ExternalHomeDashboard string `default:""""`
	}
	OAUTH2_SETTINGS struct {
		Enable               bool     `default:""false""`
		ClientID             string   `default:""1234565""`
		ClientSecret         string   `default:""FAKE""`
		ProjectID            string   `default:""Homer Oauth2""`
		AuthUri              string   `default:""https://accounts.google.com/o/oauth2/auth""`
		TokenUri             string   `default:""https://oauth2.googleapis.com/token""`
		AuthProviderCert     string   `default:""https://www.googleapis.com/oauth2/v1/certs""`
		RedirectUri          string   `default:""http://localhost:80/api/v3/oauth2/auth""`
		ProfileURL           string   `default:""https://www.googleapis.com/oauth2/v1/userinfo""`
		Method               string   `default:""GET""`
		UserToken            string   `default:""checkRandom""`
		ServiceProviderName  string   `default:""google""`
		ServiceProviderImage string   `default:""""`
		StateValue           string   `default:""jkwh027yasj""`
		UrlToServiceRedirect string   `default:""/api/v3/oauth2/redirect""`
		Scope                []string `default:""[email,openid,profile]""`
		EnableGravatar       bool     `default:""false""`
		AuthStyle            int      `default:""0""`
		GravatarUrl          string   `default:""https://www.gravatar.com/avatar/%s.jpg""`
		ExpireSSOToken       uint32   `default:""5""`
	}
	LOG_SETTINGS struct {
		Enable        bool   `default:""true""`
		MaxAgeDays    uint32 `default:""7""`
		RotationHours uint32 `default:""24""`
		Path          string `default:""/usr/local/homer/log""`
		Level         string `default:""error""`
		Name          string `default:""homer-app.log""`
		Stdout        bool   `default:""false""`
		Json          bool   `default:""true""`
		SysLogLevel   string `default:""LOG_INFO""`
		SysLog        bool   `default:""false""`
		SyslogUri     string `default:""""`
	}
	SWAGGER struct {
		Enable  bool   `default:""true""`
		ApiJson string `default:""/usr/local/homer/etc/swagger.json""`
		ApiHost string `default:""127.0.0.1:9080""`
	}
	DECODER_SHARK struct {
		Bin        string   `default:""/usr/local/bin/tshark""`
		Param      string   `default:""""`
		Protocols  []string `default:""""`
		UID        uint32   `default:""0""`
		GID        uint32   `default:""0""`
		ImportNode string   `default:""""`
		Enable     bool     `default:""false""`
	}
}
",CWE-798,100.0,1
"package main
//VERSION
var VERSION_APPLICATION = ""1.4.27""
//NAME
var NAME_APPLICATION = ""homer-app""
func getVersion() string {
	return VERSION_APPLICATION
}
func getName() string {
	return NAME_APPLICATION
}
",CWE-798,16.0,1
"// Copyright 2019 The Nakama Authors
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package server
import (
	""context""
	""crypto""
	""database/sql""
	""errors""
	""fmt""
	""time""
	jwt ""github.com/golang-jwt/jwt/v4""
	""github.com/heroiclabs/nakama/v3/console""
	""github.com/jackc/pgtype""
	""go.uber.org/zap""
	""golang.org/x/crypto/bcrypt""
	""google.golang.org/grpc/codes""
	""google.golang.org/grpc/status""
)
type ConsoleTokenClaims struct {
	Username  string           `json:""usn,omitempty""`
	Email     string           `json:""ema,omitempty""`
	Role      console.UserRole `json:""rol,omitempty""`
	ExpiresAt int64            `json:""exp,omitempty""`
	Cookie    string           `json:""cki,omitempty""`
}
func (stc *ConsoleTokenClaims) Valid() error {
	// Verify expiry.
	if stc.ExpiresAt <= time.Now().UTC().Unix() {
		vErr := new(jwt.ValidationError)
		vErr.Inner = errors.New(""Token is expired"")
		vErr.Errors |= jwt.ValidationErrorExpired
		return vErr
	}
	return nil
}
func parseConsoleToken(hmacSecretByte []byte, tokenString string) (username, email string, role console.UserRole, exp int64, ok bool) {
	token, err := jwt.ParseWithClaims(tokenString, &ConsoleTokenClaims{}, func(token *jwt.Token) (interface{}, error) {
		if s, ok := token.Method.(*jwt.SigningMethodHMAC); !ok || s.Hash != crypto.SHA256 {
			return nil, fmt.Errorf(""unexpected signing method: %v"", token.Header[""alg""])
		}
		return hmacSecretByte, nil
	})
	if err != nil {
		return
	}
	claims, ok := token.Claims.(*ConsoleTokenClaims)
	if !ok || !token.Valid {
		return
	}
	return claims.Username, claims.Email, claims.Role, claims.ExpiresAt, true
}
func (s *ConsoleServer) Authenticate(ctx context.Context, in *console.AuthenticateRequest) (*console.ConsoleSession, error) {
	role := console.UserRole_USER_ROLE_UNKNOWN
	var uname string
	var email string
	switch in.Username {
	case s.config.GetConsole().Username:
		if in.Password == s.config.GetConsole().Password {
			role = console.UserRole_USER_ROLE_ADMIN
			uname = in.Username
		}
	default:
		var err error
		uname, email, role, err = s.lookupConsoleUser(ctx, in.Username, in.Password)
		if err != nil {
			return nil, err
		}
	}
	if role == console.UserRole_USER_ROLE_UNKNOWN {
		return nil, status.Error(codes.Unauthenticated, ""Invalid credentials."")
	}
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, &ConsoleTokenClaims{
		ExpiresAt: time.Now().UTC().Add(time.Duration(s.config.GetConsole().TokenExpirySec) * time.Second).Unix(),
		Username:  uname,
		Email:     email,
		Role:      role,
		Cookie:    s.cookie,
	})
	key := []byte(s.config.GetConsole().SigningKey)
	signedToken, _ := token.SignedString(key)
	return &console.ConsoleSession{Token: signedToken}, nil
}
func (s *ConsoleServer) lookupConsoleUser(ctx context.Context, unameOrEmail, password string) (uname string, email string, role console.UserRole, err error) {
	role = console.UserRole_USER_ROLE_UNKNOWN
	query := ""SELECT username, email, role, password, disable_time FROM console_user WHERE username = $1 OR email = $1""
	var dbPassword []byte
	var dbDisableTime pgtype.Timestamptz
	err = s.db.QueryRowContext(ctx, query, unameOrEmail).Scan(&uname, &email, &role, &dbPassword, &dbDisableTime)
	if err != nil {
		if err == sql.ErrNoRows {
			err = nil
		}
		return
	}
	// Check if it's disabled.
	if dbDisableTime.Status == pgtype.Present && dbDisableTime.Time.Unix() != 0 {
		s.logger.Info(""Console user account is disabled."", zap.String(""username"", unameOrEmail))
		err = status.Error(codes.PermissionDenied, ""Invalid credentials."")
		return
	}
	// Check password
	err = bcrypt.CompareHashAndPassword(dbPassword, []byte(password))
	if err != nil {
		err = status.Error(codes.Unauthenticated, ""Invalid credentials."")
		return
	}
	return
}
",CWE-613,134.0,1
"// Copyright 2021 The Nakama Authors
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package server
import (
	""context""
	""sync""
	""time""
	""github.com/gofrs/uuid""
)
type SessionCache interface {
	Stop()
	// Check if a given user, expiry, and session token combination is valid.
	IsValidSession(userID uuid.UUID, exp int64, token string) bool
	// Check if a given user, expiry, and refresh token combination is valid.
	IsValidRefresh(userID uuid.UUID, exp int64, token string) bool
	// Add a valid session and/or refresh token for a given user.
	Add(userID uuid.UUID, sessionExp int64, sessionToken string, refreshExp int64, refreshToken string)
	// Remove a session and/or refresh token for a given user.
	Remove(userID uuid.UUID, sessionExp int64, sessionToken string, refreshExp int64, refreshToken string)
	// Remove all of a user's session and refresh tokens.
	RemoveAll(userID uuid.UUID)
	// Mark a set of users as banned.
	Ban(userIDs []uuid.UUID)
	// Unban a set of users.
	Unban(userIDs []uuid.UUID)
}
type sessionCacheUser struct {
	sessionTokens map[string]int64
	refreshTokens map[string]int64
}
type LocalSessionCache struct {
	sync.RWMutex
	config Config
	ctx         context.Context
	ctxCancelFn context.CancelFunc
	cache map[uuid.UUID]*sessionCacheUser
}
func NewLocalSessionCache(config Config) SessionCache {
	ctx, ctxCancelFn := context.WithCancel(context.Background())
	s := &LocalSessionCache{
		config: config,
		ctx:         ctx,
		ctxCancelFn: ctxCancelFn,
		cache: make(map[uuid.UUID]*sessionCacheUser),
	}
	go func() {
		ticker := time.NewTicker(2 * time.Duration(config.GetSession().TokenExpirySec) * time.Second)
		for {
			select {
			case <-s.ctx.Done():
				ticker.Stop()
				return
			case t := <-ticker.C:
				tMs := t.UTC().Unix()
				s.Lock()
				for userID, cache := range s.cache {
					for token, exp := range cache.sessionTokens {
						if exp <= tMs {
							delete(cache.sessionTokens, token)
						}
					}
					for token, exp := range cache.refreshTokens {
						if exp <= tMs {
							delete(cache.refreshTokens, token)
						}
					}
					if len(cache.sessionTokens) == 0 && len(cache.refreshTokens) == 0 {
						delete(s.cache, userID)
					}
				}
				s.Unlock()
			}
		}
	}()
	return s
}
func (s *LocalSessionCache) Stop() {
	s.ctxCancelFn()
}
func (s *LocalSessionCache) IsValidSession(userID uuid.UUID, exp int64, token string) bool {
	s.RLock()
	cache, found := s.cache[userID]
	if !found {
		s.RUnlock()
		return false
	}
	_, found = cache.sessionTokens[token]
	s.RUnlock()
	return found
}
func (s *LocalSessionCache) IsValidRefresh(userID uuid.UUID, exp int64, token string) bool {
	s.RLock()
	cache, found := s.cache[userID]
	if !found {
		s.RUnlock()
		return false
	}
	_, found = cache.refreshTokens[token]
	s.RUnlock()
	return found
}
func (s *LocalSessionCache) Add(userID uuid.UUID, sessionExp int64, sessionToken string, refreshExp int64, refreshToken string) {
	s.Lock()
	cache, found := s.cache[userID]
	if !found {
		cache = &sessionCacheUser{
			sessionTokens: make(map[string]int64),
			refreshTokens: make(map[string]int64),
		}
		s.cache[userID] = cache
	}
	if sessionToken != """" {
		cache.sessionTokens[sessionToken] = sessionExp + 1
	}
	if refreshToken != """" {
		cache.refreshTokens[refreshToken] = refreshExp + 1
	}
	s.Unlock()
}
func (s *LocalSessionCache) Remove(userID uuid.UUID, sessionExp int64, sessionToken string, refreshExp int64, refreshToken string) {
	s.Lock()
	cache, found := s.cache[userID]
	if !found {
		s.Unlock()
		return
	}
	if sessionToken != """" {
		delete(cache.sessionTokens, sessionToken)
	}
	if refreshToken != """" {
		delete(cache.refreshTokens, refreshToken)
	}
	if len(cache.sessionTokens) == 0 && len(cache.refreshTokens) == 0 {
		delete(s.cache, userID)
	}
	s.Unlock()
}
func (s *LocalSessionCache) RemoveAll(userID uuid.UUID) {
	s.Lock()
	delete(s.cache, userID)
	s.Unlock()
}
func (s *LocalSessionCache) Ban(userIDs []uuid.UUID) {
	s.Lock()
	for _, userID := range userIDs {
		delete(s.cache, userID)
	}
	s.Unlock()
}
func (s *LocalSessionCache) Unban(userIDs []uuid.UUID) {}
",CWE-613,185.0,1
"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: MIT
package main
import (
	""flag""
	""log""
	""os""
	""os/user""
	""path/filepath""
	""github.com/aws/amazon-cloudwatch-agent/cfg/commonconfig""
	""github.com/aws/amazon-cloudwatch-agent/translator""
	""github.com/aws/amazon-cloudwatch-agent/translator/cmdutil""
	""github.com/aws/amazon-cloudwatch-agent/translator/context""
	translatorUtil ""github.com/aws/amazon-cloudwatch-agent/translator/util""
)
const (
	exitErrorMessage  = ""Configuration validation first phase failed. Agent version: %v. Verify the JSON input is only using features supported by this version.\n""
	version           = ""1.0""
	envConfigFileName = ""env-config.json""
)
func initFlags() {
	var inputOs = flag.String(""os"", """", ""Please provide the os preference, valid value: windows/linux."")
	var inputJsonFile = flag.String(""input"", """", ""Please provide the path of input agent json config file"")
	var inputJsonDir = flag.String(""input-dir"", """", ""Please provide the path of input agent json config directory."")
	var inputTomlFile = flag.String(""output"", """", ""Please provide the path of the output CWAgent config file"")
	var inputMode = flag.String(""mode"", ""ec2"", ""Please provide the mode, i.e. ec2, onPremise, auto"")
	var inputConfig = flag.String(""config"", """", ""Please provide the common-config file"")
	var multiConfig = flag.String(""multi-config"", ""remove"", ""valid values: default, append, remove"")
	flag.Parse()
	ctx := context.CurrentContext()
	ctx.SetOs(*inputOs)
	ctx.SetInputJsonFilePath(*inputJsonFile)
	ctx.SetInputJsonDirPath(*inputJsonDir)
	ctx.SetMultiConfig(*multiConfig)
	ctx.SetOutputTomlFilePath(*inputTomlFile)
	if *inputConfig != """" {
		f, err := os.Open(*inputConfig)
		if err != nil {
			log.Fatalf(""E! Failed to open common-config file %s with error: %v"", *inputConfig, err)
		}
		defer f.Close()
		conf, err := commonconfig.Parse(f)
		if err != nil {
			log.Fatalf(""E! Failed to parse common-config file %s with error: %v"", *inputConfig, err)
		}
		ctx.SetCredentials(conf.CredentialsMap())
		ctx.SetProxy(conf.ProxyMap())
		ctx.SetSSL(conf.SSLMap())
	}
	translatorUtil.SetProxyEnv(ctx.Proxy())
	translatorUtil.SetSSLEnv(ctx.SSL())
	ctx.SetMode(translatorUtil.DetectAgentMode(*inputMode))
}
/**
 *	config-translator --input ${JSON} --input-dir ${JSON_DIR} --output ${TOML} --mode ${param_mode} --config ${COMMON_CONFIG}
 *  --multi-config [default|append|remove]
 *
 *		multi-config:
 *			default:	only process .tmp files
 *			append:		process both existing files and .tmp files
 *			remove:		only process existing files
 */
func main() {
	initFlags()
	defer func() {
		if r := recover(); r != nil {
			// Only emit error message if panic content is string(pre-checked)
			// Not emitting the non-handled error message for now, we don't want to show non-user-friendly error message to customer
			if val, ok := r.(string); ok {
				log.Println(val)
			}
			//If the Input JSON config file is invalid, output all the error path and error messages.
			for _, errMessage := range translator.ErrorMessages {
				log.Println(errMessage)
			}
			log.Printf(exitErrorMessage, version)
			os.Exit(1)
		}
	}()
	ctx := context.CurrentContext()
	mergedJsonConfigMap, err := cmdutil.GenerateMergedJsonConfigMap(ctx)
	if err != nil {
		log.Panicf(""E! Failed to generate merged json config: %v"", err)
	}
	if !ctx.RunInContainer() {
		// run as user only applies to non container situation.
		current, err := user.Current()
		if err == nil && current.Name == ""root"" {
			runAsUser, err := cmdutil.DetectRunAsUser(mergedJsonConfigMap)
			if err != nil {
				log.Panic(""E! Failed to detectRunAsUser"")
			}
			cmdutil.VerifyCredentials(ctx, runAsUser)
		}
	}
	tomlConfigPath := cmdutil.GetTomlConfigPath(ctx.OutputTomlFilePath())
	cmdutil.TranslateJsonMapToTomlFile(mergedJsonConfigMap, tomlConfigPath)
	// Put env config into the same folder as the toml config.
	envConfigPath := filepath.Join(filepath.Dir(tomlConfigPath), envConfigFileName)
	cmdutil.TranslateJsonMapToEnvConfigFile(mergedJsonConfigMap, envConfigPath)
}
",CWE-274,113.0,1
"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: MIT
package config
const (
	ModeEC2    = ""ec2""
	ModeOnPrem = ""onPremise""
)
",CWE-274,10.0,1
"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: MIT
package context
import (
	""log""
	""os""
	""github.com/aws/amazon-cloudwatch-agent/translator/config""
)
const (
	TmpFileSuffix = "".tmp""
)
var ctx *Context
func CurrentContext() *Context {
	if ctx == nil {
		ctx = &Context{
			credentials:         make(map[string]string),
			proxy:               make(map[string]string),
			cloudWatchLogConfig: make(map[string]interface{}),
			runInContainer:      os.Getenv(config.RUN_IN_CONTAINER) == config.RUN_IN_CONTAINER_TRUE,
		}
	}
	return ctx
}
//Testing only
func ResetContext() {
	ctx = nil
}
type Context struct {
	os                  string
	inputJsonFilePath   string
	inputJsonDirPath    string
	multiConfig         string
	outputTomlFilePath  string
	mode                string
	credentials         map[string]string
	proxy               map[string]string
	ssl                 map[string]string
	cloudWatchLogConfig map[string]interface{}
	runInContainer      bool
}
func (ctx *Context) Os() string {
	return ctx.os
}
func (ctx *Context) SetOs(os string) {
	ctx.os = config.ToValidOs(os)
}
func (ctx *Context) InputJsonFilePath() string {
	return ctx.inputJsonFilePath
}
func (ctx *Context) SetInputJsonFilePath(inputJsonFilePath string) {
	ctx.inputJsonFilePath = inputJsonFilePath
}
func (ctx *Context) InputJsonDirPath() string {
	return ctx.inputJsonDirPath
}
func (ctx *Context) SetInputJsonDirPath(inputJsonDirPath string) {
	ctx.inputJsonDirPath = inputJsonDirPath
}
func (ctx *Context) MultiConfig() string {
	return ctx.multiConfig
}
func (ctx *Context) SetMultiConfig(multiConfig string) {
	ctx.multiConfig = multiConfig
}
func (ctx *Context) OutputTomlFilePath() string {
	return ctx.outputTomlFilePath
}
func (ctx *Context) SetOutputTomlFilePath(outputTomlFilePath string) {
	ctx.outputTomlFilePath = outputTomlFilePath
}
func (ctx *Context) Mode() string {
	if ctx.mode == """" {
		ctx.mode = config.ModeEC2
	}
	return ctx.mode
}
func (ctx *Context) Credentials() map[string]string {
	return ctx.credentials
}
func (ctx *Context) SSL() map[string]string {
	return ctx.ssl
}
func (ctx *Context) Proxy() map[string]string {
	return ctx.proxy
}
func (ctx *Context) SetMode(mode string) {
	switch mode {
	case config.ModeEC2:
		ctx.mode = config.ModeEC2
	case config.ModeOnPrem:
		ctx.mode = config.ModeOnPrem
	default:
		log.Panicf(""Invalid mode %s. Valid mode values are %s and %s."", mode, config.ModeEC2, config.ModeOnPrem)
	}
}
func (ctx *Context) SetCredentials(creds map[string]string) {
	ctx.credentials = creds
}
func (ctx *Context) SetSSL(ssl map[string]string) {
	ctx.ssl = ssl
}
func (ctx *Context) SetProxy(proxy map[string]string) {
	ctx.proxy = proxy
}
func (ctx *Context) SetCloudWatchLogConfig(config map[string]interface{}) {
	ctx.cloudWatchLogConfig = config
}
func (ctx *Context) CloudWatchLogConfig() map[string]interface{} {
	return ctx.cloudWatchLogConfig
}
func (ctx *Context) RunInContainer() bool {
	return ctx.runInContainer
}
func (ctx *Context) SetRunInContainer(runInContainer bool) {
	ctx.runInContainer = runInContainer
}
",CWE-274,147.0,1
"//
// Copyright 2021 The Sigstore Authors.
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package sget
import (
	""context""
	""io""
	""github.com/google/go-containerregistry/pkg/authn""
	""github.com/google/go-containerregistry/pkg/name""
	""github.com/google/go-containerregistry/pkg/v1/remote""
	""github.com/pkg/errors""
	""github.com/sigstore/cosign/cmd/cosign/cli/fulcio""
	""github.com/sigstore/cosign/cmd/cosign/cli/options""
	""github.com/sigstore/cosign/cmd/cosign/cli/verify""
	""github.com/sigstore/cosign/pkg/cosign""
	ociremote ""github.com/sigstore/cosign/pkg/oci/remote""
	sigs ""github.com/sigstore/cosign/pkg/signature""
)
func New(image, key string, out io.Writer) *SecureGet {
	return &SecureGet{
		ImageRef: image,
		KeyRef:   key,
		Out:      out,
	}
}
type SecureGet struct {
	ImageRef string
	KeyRef   string
	Out      io.Writer
}
func (sg *SecureGet) Do(ctx context.Context) error {
	ref, err := name.ParseReference(sg.ImageRef)
	if err != nil {
		return err
	}
	opts := []remote.Option{
		remote.WithAuthFromKeychain(authn.DefaultKeychain),
		remote.WithContext(ctx),
	}
	co := &cosign.CheckOpts{
		ClaimVerifier:      cosign.SimpleClaimVerifier,
		RegistryClientOpts: []ociremote.Option{ociremote.WithRemoteOptions(opts...)},
	}
	if _, ok := ref.(name.Tag); ok {
		if sg.KeyRef == """" && !options.EnableExperimental() {
			return errors.New(""public key must be specified when fetching by tag, you must fetch by digest or supply a public key"")
		}
	}
	// Overwrite ""ref"" with a digest to avoid a race where we verify the tag,
	// and then access the file through the tag.  This has a race where we
	// might download content that isn't what we verified.
	ref, err = ociremote.ResolveDigest(ref, co.RegistryClientOpts...)
	if err != nil {
		return err
	}
	if sg.KeyRef != """" {
		pub, err := sigs.LoadPublicKey(ctx, sg.KeyRef)
		if err != nil {
			return err
		}
		co.SigVerifier = pub
	}
	if co.SigVerifier != nil || options.EnableExperimental() {
		co.RootCerts = fulcio.GetRoots()
		sp, bundleVerified, err := cosign.VerifyImageSignatures(ctx, ref, co)
		if err != nil {
			return err
		}
		verify.PrintVerificationHeader(sg.ImageRef, co, bundleVerified)
		verify.PrintVerification(sg.ImageRef, sp, ""text"")
	}
	// TODO(mattmoor): Depending on what this is, use the higher-level stuff.
	img, err := remote.Image(ref, opts...)
	if err != nil {
		return err
	}
	layers, err := img.Layers()
	if err != nil {
		return err
	}
	if len(layers) != 1 {
		return errors.New(""invalid artifact"")
	}
	rc, err := layers[0].Compressed()
	if err != nil {
		return err
	}
	_, err = io.Copy(sg.Out, rc)
	return err
}
",CWE-295,116.0,1
"// Copyright 2022 The Sigstore Authors.
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package mock
import (
	""encoding/base64""
	""encoding/hex""
	""github.com/go-openapi/runtime""
	""github.com/transparency-dev/merkle/rfc6962""
	""github.com/sigstore/rekor/pkg/generated/client/entries""
	""github.com/sigstore/rekor/pkg/generated/models""
)
var (
	lea = models.LogEntryAnon{
		Attestation:    &models.LogEntryAnonAttestation{},
		Body:           base64.StdEncoding.EncodeToString([]byte(""asdf"")),
		IntegratedTime: new(int64),
		LogID:          new(string),
		LogIndex:       new(int64),
		Verification: &models.LogEntryAnonVerification{
			InclusionProof: &models.InclusionProof{
				RootHash: new(string),
				TreeSize: new(int64),
				LogIndex: new(int64),
			},
		},
	}
	data = models.LogEntry{
		uuid(lea): lea,
	}
)
// uuid generates the UUID for the given LogEntry.
// This is effectively a reimplementation of
// pkg/cosign/tlog.go -> verifyUUID / ComputeLeafHash, but separated
// to avoid a circular dependency.
// TODO?: Perhaps we should refactor the tlog libraries into a separate
// package?
func uuid(e models.LogEntryAnon) string {
	entryBytes, err := base64.StdEncoding.DecodeString(e.Body.(string))
	if err != nil {
		panic(err)
	}
	return hex.EncodeToString(rfc6962.DefaultHasher.HashLeaf(entryBytes))
}
// EntriesClient is a client that implements entries.ClientService for Rekor
// To use:
// var mClient client.Rekor
// mClient.entries = &EntriesClient{}
type EntriesClient struct {
	Entries models.LogEntry
}
func (m *EntriesClient) CreateLogEntry(params *entries.CreateLogEntryParams, opts ...entries.ClientOption) (*entries.CreateLogEntryCreated, error) {
	return &entries.CreateLogEntryCreated{
		ETag:     """",
		Location: """",
		Payload:  data,
	}, nil
}
func (m *EntriesClient) GetLogEntryByIndex(params *entries.GetLogEntryByIndexParams, opts ...entries.ClientOption) (*entries.GetLogEntryByIndexOK, error) {
	return &entries.GetLogEntryByIndexOK{
		Payload: data,
	}, nil
}
func (m *EntriesClient) GetLogEntryByUUID(params *entries.GetLogEntryByUUIDParams, opts ...entries.ClientOption) (*entries.GetLogEntryByUUIDOK, error) {
	return &entries.GetLogEntryByUUIDOK{
		Payload: data,
	}, nil
}
func (m *EntriesClient) SearchLogQuery(params *entries.SearchLogQueryParams, opts ...entries.ClientOption) (*entries.SearchLogQueryOK, error) {
	return &entries.SearchLogQueryOK{
		Payload: []models.LogEntry{data},
	}, nil
}
// TODO: Implement mock
func (m *EntriesClient) SetTransport(transport runtime.ClientTransport) {
}
",CWE-347,99.0,1
"// Copyright 2022 The Sigstore Authors.
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package rekor
import (
	""bytes""
	""context""
	""crypto""
	""encoding/base64""
	""strings""
	""testing""
	""github.com/sigstore/cosign/internal/pkg/cosign/payload""
	""github.com/sigstore/cosign/internal/pkg/cosign/rekor/mock""
	""github.com/sigstore/cosign/pkg/cosign""
	""github.com/sigstore/rekor/pkg/generated/client""
	""github.com/sigstore/sigstore/pkg/signature""
)
func mustGetNewSigner(t *testing.T) signature.Signer {
	t.Helper()
	priv, err := cosign.GeneratePrivateKey()
	if err != nil {
		t.Fatalf(""cosign.GeneratePrivateKey() failed: %v"", err)
	}
	s, err := signature.LoadECDSASignerVerifier(priv, crypto.SHA256)
	if err != nil {
		t.Fatalf(""signature.LoadECDSASignerVerifier(key, crypto.SHA256) failed: %v"", err)
	}
	return s
}
func TestSigner(t *testing.T) {
	// Need real cert and chain
	payloadSigner := payload.NewSigner(mustGetNewSigner(t))
	// Mock out Rekor client
	var mClient client.Rekor
	mClient.Entries = &mock.EntriesClient{}
	testSigner := NewSigner(payloadSigner, &mClient)
	testPayload := ""test payload""
	ociSig, pub, err := testSigner.Sign(context.Background(), strings.NewReader(testPayload))
	if err != nil {
		t.Fatalf(""Sign() returned error: %v"", err)
	}
	// Verify that the wrapped signer was called.
	verifier, err := signature.LoadVerifier(pub, crypto.SHA256)
	if err != nil {
		t.Fatalf(""signature.LoadVerifier(pub) returned error: %v"", err)
	}
	b64Sig, err := ociSig.Base64Signature()
	if err != nil {
		t.Fatalf(""ociSig.Base64Signature() returned error: %v"", err)
	}
	sig, err := base64.StdEncoding.DecodeString(b64Sig)
	if err != nil {
		t.Fatalf(""base64.StdEncoding.DecodeString(b64Sig) returned error: %v"", err)
	}
	gotPayload, err := ociSig.Payload()
	if err != nil {
		t.Fatalf(""ociSig.Payload() returned error: %v"", err)
	}
	if string(gotPayload) != testPayload {
		t.Errorf(""ociSig.Payload() returned %q, wanted %q"", string(gotPayload), testPayload)
	}
	if err = verifier.VerifySignature(bytes.NewReader(sig), bytes.NewReader(gotPayload)); err != nil {
		t.Errorf(""VerifySignature() returned error: %v"", err)
	}
}
",CWE-347,86.0,1
"module github.com/clastix/capsule-proxy
go 1.16
require (
	github.com/clastix/capsule v0.1.0
	github.com/go-logr/logr v0.4.0
	github.com/golang-jwt/jwt v3.2.2+incompatible
	github.com/gorilla/handlers v1.5.1
	github.com/gorilla/mux v1.8.0
	github.com/pkg/errors v0.9.1
	github.com/spf13/pflag v1.0.5
	go.uber.org/zap v1.18.1
	k8s.io/api v0.22.0
	k8s.io/apimachinery v0.22.1
	k8s.io/apiserver v0.22.0
	k8s.io/client-go v0.22.0
	sigs.k8s.io/controller-runtime v0.9.5
)
",CWE-287,20.0,1
"// Package criteria implements a Criteria API based on Masterminds/squirrel
package criteria
import (
	""encoding/json""
	""errors""
	""strings""
	""github.com/navidrome/navidrome/log""
	""github.com/Masterminds/squirrel""
)
type Expression = squirrel.Sqlizer
type Criteria struct {
	Expression
	Sort   string
	Order  string
	Limit  int
	Offset int
}
func (c Criteria) OrderBy() string {
	if c.Sort == """" {
		c.Sort = ""title""
	}
	f := fieldMap[strings.ToLower(c.Sort)]
	var mapped string
	if f == nil {
		log.Error(""Invalid field in 'sort' field"", ""field"", c.Sort)
		mapped = c.Sort
	} else {
		if f.order == """" {
			mapped = f.field
		} else {
			mapped = f.order
		}
	}
	if c.Order != """" {
		mapped = mapped + "" "" + c.Order
	}
	return mapped
}
func (c Criteria) ToSql() (sql string, args []interface{}, err error) {
	return c.Expression.ToSql()
}
func (c Criteria) MarshalJSON() ([]byte, error) {
	aux := struct {
		All    []Expression `json:""all,omitempty""`
		Any    []Expression `json:""any,omitempty""`
		Sort   string       `json:""sort,omitempty""`
		Order  string       `json:""order,omitempty""`
		Limit  int          `json:""limit,omitempty""`
		Offset int          `json:""offset,omitempty""`
	}{
		Sort:   c.Sort,
		Order:  c.Order,
		Limit:  c.Limit,
		Offset: c.Offset,
	}
	switch rules := c.Expression.(type) {
	case Any:
		aux.Any = rules
	case All:
		aux.All = rules
	default:
		aux.All = All{rules}
	}
	return json.Marshal(aux)
}
func (c *Criteria) UnmarshalJSON(data []byte) error {
	var aux struct {
		All    unmarshalConjunctionType `json:""all""`
		Any    unmarshalConjunctionType `json:""any""`
		Sort   string                   `json:""sort""`
		Order  string                   `json:""order""`
		Limit  int                      `json:""limit""`
		Offset int                      `json:""offset""`
	}
	if err := json.Unmarshal(data, &aux); err != nil {
		return err
	}
	if len(aux.Any) > 0 {
		c.Expression = Any(aux.Any)
	} else if len(aux.All) > 0 {
		c.Expression = All(aux.All)
	} else {
		return errors.New(""invalid criteria json. missing rules (key 'all' or 'any')"")
	}
	c.Sort = aux.Sort
	c.Order = aux.Order
	c.Limit = aux.Limit
	c.Offset = aux.Offset
	return nil
}
",CWE-89,100.0,1
"/*
 * @Author: LinkLeong link@icewhale.org
 * @Date: 2022-07-26 18:13:22
 * @LastEditors: LinkLeong
 * @LastEditTime: 2022-08-04 20:10:31
 * @FilePath: /CasaOS/service/connections.go
 * @Description:
 * @Website: https://www.casaos.io
 * Copyright (c) 2022 by icewhale, All Rights Reserved.
 */
package service
import (
	""github.com/IceWhaleTech/CasaOS/pkg/config""
	command2 ""github.com/IceWhaleTech/CasaOS/pkg/utils/command""
	""github.com/IceWhaleTech/CasaOS/service/model""
	model2 ""github.com/IceWhaleTech/CasaOS/service/model""
	""github.com/moby/sys/mount""
	""gorm.io/gorm""
)
type ConnectionsService interface {
	GetConnectionsList() (connections []model2.ConnectionsDBModel)
	GetConnectionByHost(host string) (connections []model2.ConnectionsDBModel)
	GetConnectionByID(id string) (connections model2.ConnectionsDBModel)
	CreateConnection(connection *model2.ConnectionsDBModel)
	DeleteConnection(id string)
	UpdateConnection(connection *model2.ConnectionsDBModel)
	MountSmaba(username, host, directory, port, mountPoint, password string) string
	UnmountSmaba(mountPoint string) error
}
type connectionsStruct struct {
	db *gorm.DB
}
func (s *connectionsStruct) GetConnectionByHost(host string) (connections []model2.ConnectionsDBModel) {
	s.db.Select(""username,host,status,id"").Where(""host = ?"", host).Find(&connections)
	return
}
func (s *connectionsStruct) GetConnectionByID(id string) (connections model2.ConnectionsDBModel) {
	s.db.Select(""username,password,host,status,id,directories,mount_point,port"").Where(""id = ?"", id).First(&connections)
	return
}
func (s *connectionsStruct) GetConnectionsList() (connections []model2.ConnectionsDBModel) {
	s.db.Select(""username,host,port,status,id,mount_point"").Find(&connections)
	return
}
func (s *connectionsStruct) CreateConnection(connection *model2.ConnectionsDBModel) {
	s.db.Create(connection)
}
func (s *connectionsStruct) UpdateConnection(connection *model2.ConnectionsDBModel) {
	s.db.Save(connection)
}
func (s *connectionsStruct) DeleteConnection(id string) {
	s.db.Where(""id= ?"", id).Delete(&model.ConnectionsDBModel{})
}
func (s *connectionsStruct) MountSmaba(username, host, directory, port, mountPoint, password string) string {
	str := command2.ExecResultStr(""source "" + config.AppInfo.ShellPath + ""/helper.sh ;MountCIFS "" + username + "" "" + host + "" "" + directory + "" "" + port + "" "" + mountPoint + "" "" + password)
	return str
}
func (s *connectionsStruct) UnmountSmaba(mountPoint string) error {
	return mount.Unmount(mountPoint)
}
func NewConnectionsService(db *gorm.DB) ConnectionsService {
	return &connectionsStruct{db: db}
}
",CWE-77,70.0,1
"module github.com/IceWhaleTech/CasaOS
go 1.20
require (
	github.com/Curtis-Milo/nat-type-identifier-go v0.0.0-20220215191915-18d42168c63d
	github.com/IceWhaleTech/CasaOS-Common v0.4.3
	github.com/coreos/go-systemd v0.0.0-20191104093116-d3cd4ed1dbcf
	github.com/deckarep/golang-set/v2 v2.3.0
	github.com/deepmap/oapi-codegen v1.12.4
	github.com/disintegration/imaging v1.6.2
	github.com/dsoprea/go-exif/v3 v3.0.0-20221012082141-d21ac8e2de85
	github.com/getkin/kin-openapi v0.115.0
	github.com/gin-contrib/gzip v0.0.6
	github.com/gin-gonic/gin v1.9.0
	github.com/glebarez/sqlite v1.7.0
	github.com/go-ini/ini v1.67.0
	github.com/go-resty/resty/v2 v2.7.0
	github.com/golang/mock v1.6.0
	github.com/gomodule/redigo v1.8.9
	github.com/google/go-github/v36 v36.0.0
	github.com/googollee/go-socket.io v1.7.0
	github.com/gorilla/websocket v1.5.0
	github.com/h2non/filetype v1.1.3
	github.com/hirochachacha/go-smb2 v1.1.0
	github.com/json-iterator/go v1.1.12
	github.com/labstack/echo/v4 v4.10.2
	github.com/maruel/natural v1.1.0
	github.com/mholt/archiver/v3 v3.5.1
	github.com/mileusna/useragent v1.2.1
	github.com/moby/sys/mount v0.3.3
	github.com/moby/sys/mountinfo v0.6.2
	github.com/patrickmn/go-cache v2.1.0+incompatible
	github.com/pkg/errors v0.9.1
	github.com/robfig/cron/v3 v3.0.1
	github.com/samber/lo v1.38.1
	github.com/satori/go.uuid v1.2.0
	github.com/shirou/gopsutil/v3 v3.23.2
	github.com/sirupsen/logrus v1.9.0
	github.com/stretchr/testify v1.8.2
	github.com/tidwall/gjson v1.14.4
	go.uber.org/goleak v1.2.1
	go.uber.org/zap v1.24.0
	golang.org/x/crypto v0.7.0
	golang.org/x/oauth2 v0.6.0
	golang.org/x/sync v0.1.0
	golang.org/x/sys v0.6.0
	gorm.io/gorm v1.24.6
	gotest.tools v2.2.0+incompatible
)
require (
	github.com/andybalholm/brotli v1.0.5 // indirect
	github.com/apapsch/go-jsonmerge/v2 v2.0.0 // indirect
	github.com/benbjohnson/clock v1.3.0 // indirect
	github.com/bytedance/sonic v1.8.5 // indirect
	github.com/chenzhuoyu/base64x v0.0.0-20221115062448-fe3a3abad311 // indirect
	github.com/coreos/go-systemd/v22 v22.5.0 // indirect
	github.com/davecgh/go-spew v1.1.1 // indirect
	github.com/dsnet/compress v0.0.2-0.20210315054119-f66993602bf5 // indirect
	github.com/dsoprea/go-logging v0.0.0-20200710184922-b02d349568dd // indirect
	github.com/dsoprea/go-utility/v2 v2.0.0-20221003172846-a3e1774ef349 // indirect
	github.com/dustin/go-humanize v1.0.1 // indirect
	github.com/geoffgarside/ber v1.1.0 // indirect
	github.com/gin-contrib/sse v0.1.0 // indirect
	github.com/glebarez/go-sqlite v1.21.0 // indirect
	github.com/go-errors/errors v1.4.2 // indirect
	github.com/go-ole/go-ole v1.2.6 // indirect
	github.com/go-openapi/jsonpointer v0.19.6 // indirect
	github.com/go-openapi/swag v0.22.3 // indirect
	github.com/go-playground/locales v0.14.1 // indirect
	github.com/go-playground/universal-translator v0.18.1 // indirect
	github.com/go-playground/validator/v10 v10.12.0 // indirect
	github.com/goccy/go-json v0.10.2 // indirect
	github.com/godbus/dbus/v5 v5.1.0 // indirect
	github.com/gofrs/uuid v4.4.0+incompatible // indirect
	github.com/golang-jwt/jwt v3.2.2+incompatible // indirect
	github.com/golang-jwt/jwt/v4 v4.5.0 // indirect
	github.com/golang/geo v0.0.0-20210211234256-740aa86cb551 // indirect
	github.com/golang/protobuf v1.5.3 // indirect
	github.com/golang/snappy v0.0.4 // indirect
	github.com/google/go-cmp v0.5.9 // indirect
	github.com/google/go-querystring v1.1.0 // indirect
	github.com/google/uuid v1.3.0 // indirect
	github.com/gorilla/mux v1.8.0 // indirect
	github.com/invopop/yaml v0.2.0 // indirect
	github.com/jinzhu/inflection v1.0.0 // indirect
	github.com/jinzhu/now v1.1.5 // indirect
	github.com/josharian/intern v1.0.0 // indirect
	github.com/klauspost/compress v1.16.3 // indirect
	github.com/klauspost/cpuid/v2 v2.2.4 // indirect
	github.com/klauspost/pgzip v1.2.5 // indirect
	github.com/kr/pretty v0.3.1 // indirect
	github.com/labstack/gommon v0.4.0 // indirect
	github.com/leodido/go-urn v1.2.2 // indirect
	github.com/lufia/plan9stats v0.0.0-20230110061619-bbe2e5e100de // indirect
	github.com/mailru/easyjson v0.7.7 // indirect
	github.com/mattn/go-colorable v0.1.13 // indirect
	github.com/mattn/go-isatty v0.0.18 // indirect
	github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect
	github.com/modern-go/reflect2 v1.0.2 // indirect
	github.com/mohae/deepcopy v0.0.0-20170929034955-c48cc78d4826 // indirect
	github.com/nwaples/rardecode v1.1.3 // indirect
	github.com/pelletier/go-toml/v2 v2.0.7 // indirect
	github.com/perimeterx/marshmallow v1.1.4 // indirect
	github.com/pierrec/lz4/v4 v4.1.17 // indirect
	github.com/pmezard/go-difflib v1.0.0 // indirect
	github.com/power-devops/perfstat v0.0.0-20221212215047-62379fc7944b // indirect
	github.com/remyoudompheng/bigfft v0.0.0-20230129092748-24d4a6f8daec // indirect
	github.com/tidwall/match v1.1.1 // indirect
	github.com/tidwall/pretty v1.2.1 // indirect
	github.com/tklauser/go-sysconf v0.3.11 // indirect
	github.com/tklauser/numcpus v0.6.0 // indirect
	github.com/twitchyliquid64/golang-asm v0.15.1 // indirect
	github.com/ugorji/go/codec v1.2.11 // indirect
	github.com/ulikunitz/xz v0.5.11 // indirect
	github.com/valyala/bytebufferpool v1.0.0 // indirect
	github.com/valyala/fasttemplate v1.2.2 // indirect
	github.com/xi2/xz v0.0.0-20171230120015-48954b6210f8 // indirect
	github.com/yusufpapurcu/wmi v1.2.2 // indirect
	go.uber.org/atomic v1.10.0 // indirect
	go.uber.org/multierr v1.10.0 // indirect
	golang.org/x/arch v0.3.0 // indirect
	golang.org/x/exp v0.0.0-20220303212507-bbda1eaf7a17 // indirect
	golang.org/x/image v0.6.0 // indirect
	golang.org/x/net v0.8.0 // indirect
	golang.org/x/text v0.8.0 // indirect
	golang.org/x/time v0.3.0 // indirect
	google.golang.org/appengine v1.6.7 // indirect
	google.golang.org/protobuf v1.30.0 // indirect
	gopkg.in/natefinch/lumberjack.v2 v2.2.1 // indirect
	gopkg.in/yaml.v2 v2.4.0 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
	modernc.org/libc v1.22.3 // indirect
	modernc.org/mathutil v1.5.0 // indirect
	modernc.org/memory v1.5.0 // indirect
	modernc.org/sqlite v1.21.0 // indirect
)
",CWE-287,139.0,1
"package route
import (
	""os""
	""github.com/IceWhaleTech/CasaOS-Common/middleware""
	""github.com/IceWhaleTech/CasaOS-Common/utils/jwt""
	""github.com/IceWhaleTech/CasaOS/pkg/config""
	v1 ""github.com/IceWhaleTech/CasaOS/route/v1""
	""github.com/gin-contrib/gzip""
	""github.com/gin-gonic/gin""
)
func InitV1Router() *gin.Engine {
	ginMode := gin.ReleaseMode
	if config.ServerInfo.RunMode != """" {
		ginMode = config.ServerInfo.RunMode
	}
	if os.Getenv(gin.EnvGinMode) != """" {
		ginMode = os.Getenv(gin.EnvGinMode)
	}
	gin.SetMode(ginMode)
	r := gin.New()
	r.Use(gin.Recovery())
	r.Use(middleware.Cors())
	r.Use(gzip.Gzip(gzip.DefaultCompression))
	if ginMode != gin.ReleaseMode {
		r.Use(middleware.WriteLog())
	}
	r.GET(""/v1/sys/debug"", v1.GetSystemConfigDebug) // //debug
	r.GET(""/v1/sys/version/check"", v1.GetSystemCheckVersion)
	r.GET(""/ping"", func(ctx *gin.Context) {
		ctx.String(200, ""pong"")
	})
	r.GET(""/v1/recover/:type"", v1.GetRecoverStorage)
	v1Group := r.Group(""/v1"")
	v1Group.Use(jwt.ExceptLocalhost())
	{
		v1SysGroup := v1Group.Group(""/sys"")
		v1SysGroup.Use()
		{
			v1SysGroup.GET(""/version"", v1.GetSystemCheckVersion) // version/check
			v1SysGroup.POST(""/update"", v1.SystemUpdate)
			v1SysGroup.GET(""/hardware"", v1.GetSystemHardwareInfo) // hardware/info
			v1SysGroup.GET(""/wsssh"", v1.WsSsh)
			v1SysGroup.POST(""/ssh-login"", v1.PostSshLogin)
			// v1SysGroup.GET(""/config"", v1.GetSystemConfig) //delete
			// v1SysGroup.POST(""/config"", v1.PostSetSystemConfig)
			v1SysGroup.GET(""/logs"", v1.GetCasaOSErrorLogs) // error/logs
			// v1SysGroup.GET(""/widget/config"", v1.GetWidgetConfig)//delete
			// v1SysGroup.POST(""/widget/config"", v1.PostSetWidgetConfig)//delete
			v1SysGroup.POST(""/stop"", v1.PostKillCasaOS)
			v1SysGroup.GET(""/utilization"", v1.GetSystemUtilization)
			// v1SysGroup.GET(""/cpu"", v1.GetSystemCupInfo)
			// v1SysGroup.GET(""/mem"", v1.GetSystemMemInfo)
			// v1SysGroup.GET(""/disk"", v1.GetSystemDiskInfo)
			// v1SysGroup.GET(""/network"", v1.GetSystemNetInfo)
			v1SysGroup.GET(""/server-info"", nil)
			v1SysGroup.PUT(""/server-info"", nil)
			// v1SysGroup.GET(""/port"", v1.GetCasaOSPort)
			// v1SysGroup.PUT(""/port"", v1.PutCasaOSPort)
			v1SysGroup.GET(""/proxy"", v1.GetSystemProxy)
			v1SysGroup.PUT(""/state/:state"", v1.PutSystemState)
		}
		v1PortGroup := v1Group.Group(""/port"")
		v1PortGroup.Use()
		{
			v1PortGroup.GET(""/"", v1.GetPort)              // app/port
			v1PortGroup.GET(""/state/:port"", v1.PortCheck) // app/check/:port
		}
		v1FileGroup := v1Group.Group(""/file"")
		v1FileGroup.Use()
		{
			v1FileGroup.GET("""", v1.GetDownloadSingleFile) // download/:path
			v1FileGroup.POST("""", v1.PostCreateFile)
			v1FileGroup.PUT("""", v1.PutFileContent)
			v1FileGroup.PUT(""/name"", v1.RenamePath)
			// file/rename
			v1FileGroup.GET(""/content"", v1.GetFilerContent) // file/read
			// File uploads need to be handled separately, and will not be modified here
			//v1FileGroup.POST(""/upload"", v1.PostFileUpload)
			v1FileGroup.POST(""/upload"", v1.PostFileUpload)
			v1FileGroup.GET(""/upload"", v1.GetFileUpload)
			// v1FileGroup.GET(""/download"", v1.UserFileDownloadCommonService)
			v1FileGroup.GET(""/ws"", v1.ConnectWebSocket)
			v1FileGroup.GET(""/peers"", v1.GetPeers)
		}
		v1CloudGroup := v1Group.Group(""/cloud"")
		v1CloudGroup.Use()
		{
			v1CloudGroup.GET("""", v1.ListStorages)
			v1CloudGroup.DELETE("""", v1.UmountStorage)
		}
		v1DriverGroup := v1Group.Group(""/driver"")
		v1DriverGroup.Use()
		{
			v1DriverGroup.GET("""", v1.ListDriverInfo)
		}
		v1FolderGroup := v1Group.Group(""/folder"")
		v1FolderGroup.Use()
		{
			v1FolderGroup.PUT(""/name"", v1.RenamePath)
			v1FolderGroup.GET("""", v1.DirPath)   ///file/dirpath
			v1FolderGroup.POST("""", v1.MkdirAll) ///file/mkdir
			v1FolderGroup.GET(""/size"", v1.GetSize)
			v1FolderGroup.GET(""/count"", v1.GetFileCount)
		}
		v1BatchGroup := v1Group.Group(""/batch"")
		v1BatchGroup.Use()
		{
			v1BatchGroup.DELETE("""", v1.DeleteFile) // file/delete
			v1BatchGroup.DELETE(""/:id/task"", v1.DeleteOperateFileOrDir)
			v1BatchGroup.POST(""/task"", v1.PostOperateFileOrDir) // file/operate
			v1BatchGroup.GET("""", v1.GetDownloadFile)
		}
		v1ImageGroup := v1Group.Group(""/image"")
		v1ImageGroup.Use()
		{
			v1ImageGroup.GET("""", v1.GetFileImage)
		}
		v1SambaGroup := v1Group.Group(""/samba"")
		v1SambaGroup.Use()
		{
			v1ConnectionsGroup := v1SambaGroup.Group(""/connections"")
			v1ConnectionsGroup.Use()
			{
				v1ConnectionsGroup.GET("""", v1.GetSambaConnectionsList)
				v1ConnectionsGroup.POST("""", v1.PostSambaConnectionsCreate)
				v1ConnectionsGroup.DELETE(""/:id"", v1.DeleteSambaConnections)
			}
			v1SharesGroup := v1SambaGroup.Group(""/shares"")
			v1SharesGroup.Use()
			{
				v1SharesGroup.GET("""", v1.GetSambaSharesList)
				v1SharesGroup.POST("""", v1.PostSambaSharesCreate)
				v1SharesGroup.DELETE(""/:id"", v1.DeleteSambaShares)
				v1SharesGroup.GET(""/status"", v1.GetSambaStatus)
			}
		}
		v1NotifyGroup := v1Group.Group(""/notify"")
		v1NotifyGroup.Use()
		{
			v1NotifyGroup.POST(""/:path"", v1.PostNotifyMessage)
			// merge to system
			v1NotifyGroup.POST(""/system_status"", v1.PostSystemStatusNotify)
		}
		v1OtherGroup := v1Group.Group(""/other"")
		v1OtherGroup.Use()
		{
			v1OtherGroup.GET(""/search"", v1.GetSearchResult)
		}
	}
	return r
}
",CWE-287,174.0,1
"/*
 * Copyright 2022 Snyk Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package config
import (
	""os""
	""testing""
	""time""
	""github.com/google/uuid""
	""github.com/stretchr/testify/assert""
)
func TestSetToken(t *testing.T) {
	SetCurrentConfig(New())
	oldToken := CurrentConfig().Token()
	CurrentConfig().SetToken(""asdf"")
	assert.Equal(t, CurrentConfig().Token(), ""asdf"")
	CurrentConfig().SetToken(oldToken)
}
func TestConfigDefaults(t *testing.T) {
	c := New()
	assert.True(t, c.IsTelemetryEnabled(), ""Telemetry should be enabled by default"")
	assert.True(t, c.IsErrorReportingEnabled(), ""Error Reporting should be enabled by default"")
	assert.False(t, c.IsSnykAdvisorEnabled(), ""Advisor should be disabled by default"")
	assert.False(t, c.IsSnykCodeEnabled(), ""Snyk Code should be disabled by default"")
	assert.False(t, c.IsSnykContainerEnabled(), ""Snyk Container should be enabled by default"")
	assert.True(t, c.IsSnykOssEnabled(), ""Snyk Open Source should be enabled by default"")
	assert.True(t, c.IsSnykIacEnabled(), ""Snyk IaC should be enabled by default"")
	assert.Equal(t, """", c.LogPath(), ""Logpath should be empty by default"")
	assert.Equal(t, ""md"", c.Format(), ""Output format should be md by default"")
}
func Test_TokenChanged_ChannelsInformed(t *testing.T) {
	// Arrange
	c := New()
	tokenChangedChannel := c.TokenChangesChannel()
	// Act
	// There's a 1 in 5 undecillion (5 * 10^36) chance for a collision here so let's hold our fingers
	c.SetToken(uuid.New().String())
	// Assert
	// This will either pass the test or fail by deadlock immediately if SetToken did not write to the change channels,
	// therefore there's no need for assert.Eventually
	<-tokenChangedChannel
}
func Test_TokenChangedToSameToken_ChannelsNotInformed(t *testing.T) {
	// Arrange
	c := New()
	tokenChangedChannel := c.TokenChangesChannel()
	token := c.Token()
	// Act
	c.SetToken(token)
	// Assert
	select {
	case newToken := <-tokenChangedChannel:
		assert.Fail(t, ""Expected empty token changes channel, but received new token (%v)"", newToken)
	default:
		// This case triggers when tokenChangedChannel is empty, test passes
	}
}
func Test_SnykCodeAnalysisTimeoutReturnsTimeoutFromEnvironment(t *testing.T) {
	t.Setenv(snykCodeTimeoutKey, ""1s"")
	duration, _ := time.ParseDuration(""1s"")
	assert.Equal(t, duration, snykCodeAnalysisTimeoutFromEnv())
}
func Test_SnykCodeAnalysisTimeoutReturnsDefaultIfNoEnvVariableFound(t *testing.T) {
	t.Setenv(snykCodeTimeoutKey, """")
	duration, _ := time.ParseDuration(""10m"")
	assert.Equal(t, duration, snykCodeAnalysisTimeoutFromEnv())
}
func Test_updatePath(t *testing.T) {
	t.Setenv(""PATH"", ""a"")
	c := New()
	c.updatePath(""b"")
	assert.Contains(t, c.path, string(os.PathListSeparator)+""b"")
	assert.Contains(t, c.path, ""a""+string(os.PathListSeparator))
}
func Test_loadFile(t *testing.T) {
	t.Setenv(""A"", """")
	t.Setenv(""C"", """")
	os.Unsetenv(""A"")
	os.Unsetenv(""C"")
	envData := []byte(""A=B\nC=D"")
	file, err := os.CreateTemp(""."", ""config_test_loadFile"")
	if err != nil {
		assert.Fail(t, ""Couldn't create temp file"", err)
	}
	defer func(file *os.File) {
		_ = file.Close()
		_ = os.Remove(file.Name())
	}(file)
	if err != nil {
		assert.Fail(t, ""Couldn't create test file"")
	}
	_, _ = file.Write(envData)
	if err != nil {
		assert.Fail(t, ""Couldn't write to test file"")
	}
	CurrentConfig().loadFile(file.Name())
	assert.Equal(t, ""B"", os.Getenv(""A""))
	assert.Equal(t, ""D"", os.Getenv(""C""))
}
func TestSnykCodeApi(t *testing.T) {
	t.Run(""endpoint not provided"", func(t *testing.T) {
		codeApiEndpoint, _ := getCodeApiUrlFromCustomEndpoint("""")
		assert.Equal(t, ""https://deeproxy.snyk.io"", codeApiEndpoint)
	})
	t.Run(""endpoint provided without 'app' prefix"", func(t *testing.T) {
		endpoint := ""https://snyk.io/api/v1""
		codeApiEndpoint, _ := getCodeApiUrlFromCustomEndpoint(endpoint)
		assert.Equal(t, ""https://deeproxy.snyk.io"", codeApiEndpoint)
	})
	t.Run(""endpoint provided with 'app' prefix with v1 suffix"", func(t *testing.T) {
		endpoint := ""https://app.snyk.io/api/v1""
		codeApiEndpoint, _ := getCodeApiUrlFromCustomEndpoint(endpoint)
		assert.Equal(t, ""https://deeproxy.snyk.io"", codeApiEndpoint)
	})
	t.Run(""endpoint provided with 'app' prefix without v1 suffix"", func(t *testing.T) {
		endpoint := ""https://app.snyk.io/api""
		codeApiEndpoint, _ := getCodeApiUrlFromCustomEndpoint(endpoint)
		assert.Equal(t, ""https://deeproxy.snyk.io"", codeApiEndpoint)
	})
	t.Run(""endpoint provided with 'api' prefix"", func(t *testing.T) {
		endpoint := ""https://api.snyk.io""
		codeApiEndpoint, _ := getCodeApiUrlFromCustomEndpoint(endpoint)
		assert.Equal(t, ""https://deeproxy.snyk.io"", codeApiEndpoint)
	})
	t.Run(""proxy endpoint provided via 'DEEPROXY_API_URL' environment variable"", func(t *testing.T) {
		customDeeproxyUrl := ""https://deeproxy.custom.url.snyk.io""
		t.Setenv(""DEEPROXY_API_URL"", customDeeproxyUrl)
		codeApiEndpoint, _ := getCodeApiUrlFromCustomEndpoint("""")
		assert.Equal(t, customDeeproxyUrl, codeApiEndpoint)
	})
}
",CWE-78,168.0,1
"/*
 * Copyright 2022 Snyk Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package server
import (
	""context""
	""github.com/atotto/clipboard""
	""github.com/creachadair/jrpc2""
	""github.com/creachadair/jrpc2/handler""
	""github.com/rs/zerolog/log""
	sglsp ""github.com/sourcegraph/go-lsp""
	""github.com/snyk/snyk-ls/application/di""
	""github.com/snyk/snyk-ls/domain/ide/command""
	""github.com/snyk/snyk-ls/domain/ide/workspace""
	""github.com/snyk/snyk-ls/domain/snyk""
	""github.com/snyk/snyk-ls/internal/notification""
)
func ExecuteCommandHandler(srv *jrpc2.Server) jrpc2.Handler {
	return handler.New(func(ctx context.Context, params sglsp.ExecuteCommandParams) (interface{}, error) {
		// The context provided by the JSON-RPC server is cancelled once a new message is being processed,
		// so we don't want to propagate it to functions that start background operations
		bgCtx := context.Background()
		method := ""ExecuteCommandHandler""
		log.Info().Str(""method"", method).Interface(""command"", params).Msg(""RECEIVING"")
		defer log.Info().Str(""method"", method).Interface(""command"", params).Msg(""SENDING"")
		args := params.Arguments
		switch params.Command {
		case snyk.NavigateToRangeCommand:
			if len(args) < 2 {
				log.Warn().Str(""method"", method).Msg(""received NavigateToRangeCommand without range"")
			}
			navigateToLocation(srv, args)
		case snyk.WorkspaceScanCommand:
			workspace.Get().ClearIssues(bgCtx)
			workspace.Get().ScanWorkspace(bgCtx)
		case snyk.OpenBrowserCommand:
			command.OpenBrowser(params.Arguments[0].(string))
		case snyk.LoginCommand:
			authenticator := di.Authenticator()
			_, err := authenticator.Authenticate(context.Background())
			if err != nil {
				log.Err(err).Msg(""Error on snyk.login command"")
				notification.SendError(err)
			}
		case snyk.CopyAuthLinkCommand:
			url := di.Authenticator().Provider().AuthURL(bgCtx)
			err := clipboard.WriteAll(url)
			if err != nil {
				log.Err(err).Msg(""Error on snyk.copyAuthLink command"")
				notification.SendError(err)
				break
			}
		case snyk.LogoutCommand:
			di.Authenticator().Logout(bgCtx)
		}
		return nil, nil
	})
}
",CWE-78,78.0,1
"/*
 * Copyright 2022 Snyk Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package server
import (
	""testing""
	""time""
	""github.com/sourcegraph/go-lsp""
	""github.com/stretchr/testify/assert""
	""github.com/atotto/clipboard""
	""github.com/snyk/snyk-ls/application/di""
	""github.com/snyk/snyk-ls/domain/ide/workspace""
	""github.com/snyk/snyk-ls/domain/snyk""
	""github.com/snyk/snyk-ls/infrastructure/cli/auth""
)
func Test_executeWorkspaceScanCommand_shouldStartWorkspaceScanOnCommandReceipt(t *testing.T) {
	loc := setupServer(t)
	scanner := &snyk.TestScanner{}
	workspace.Get().AddFolder(workspace.NewFolder(""dummy"", ""dummy"", scanner, di.HoverService()))
	params := lsp.ExecuteCommandParams{Command: snyk.WorkspaceScanCommand}
	_, err := loc.Client.Call(ctx, ""workspace/executeCommand"", params)
	if err != nil {
		t.Fatal(err)
	}
	assert.Eventually(t, func() bool {
		return scanner.Calls() > 0
	}, 2*time.Second, time.Millisecond)
}
func Test_loginCommand_StartsAuthentication(t *testing.T) {
	// Arrange
	loc := setupServer(t)
	_, err := loc.Client.Call(ctx, ""initialize"", nil)
	if err != nil {
		t.Fatal(err)
	}
	authenticationMock := di.Authenticator().Provider().(*auth.FakeAuthenticationProvider)
	initialAuthenticatedStatus := authenticationMock.IsAuthenticated
	params := lsp.ExecuteCommandParams{Command: snyk.LoginCommand}
	// Act
	_, err = loc.Client.Call(ctx, ""workspace/executeCommand"", params)
	if err != nil {
		t.Fatal(err)
	}
	// Assert
	assert.False(t, initialAuthenticatedStatus)
	assert.True(t, authenticationMock.IsAuthenticated)
	assert.Eventually(t, func() bool { return len(jsonRPCRecorder.Notifications()) > 0 }, 5*time.Second, 50*time.Millisecond)
	assert.Equal(t, 1, len(jsonRPCRecorder.FindNotificationsByMethod(""$/snyk.hasAuthenticated"")))
}
func Test_executeCommand_shouldCopyAuthURLToClipboard(t *testing.T) {
	loc := setupServer(t)
	authenticationMock := di.Authenticator().Provider().(*auth.FakeAuthenticationProvider)
	params := lsp.ExecuteCommandParams{Command: snyk.CopyAuthLinkCommand}
	_, err := loc.Client.Call(ctx, ""workspace/executeCommand"", params)
	if err != nil {
		t.Fatal(err)
	}
	actualURL, _ := clipboard.ReadAll()
	assert.Equal(t, authenticationMock.ExpectedAuthURL, actualURL)
}
",CWE-78,87.0,1
"/*
 * Copyright 2022 Snyk Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package workspace
import (
	""context""
	""sync""
	""github.com/snyk/snyk-ls/application/server/lsp""
	""github.com/snyk/snyk-ls/domain/ide/hover""
	""github.com/snyk/snyk-ls/domain/observability/performance""
	""github.com/snyk/snyk-ls/domain/snyk""
	""github.com/snyk/snyk-ls/internal/uri""
)
// todo can we do without a singleton?
var instance *Workspace
var mutex = &sync.Mutex{}
// Workspace represents the highest entity in an IDE that contains code. A workspace may contain multiple folders
type Workspace struct {
	mutex        sync.Mutex
	folders      map[string]*Folder
	instrumentor performance.Instrumentor
	scanner      snyk.Scanner
	hoverService hover.Service
}
func New(instrumentor performance.Instrumentor, scanner snyk.Scanner, hoverService hover.Service) *Workspace {
	return &Workspace{
		folders:      make(map[string]*Folder, 0),
		instrumentor: instrumentor,
		scanner:      scanner,
		hoverService: hoverService,
	}
}
// todo can we move to di?
func Get() *Workspace {
	mutex.Lock()
	defer mutex.Unlock()
	return instance
}
func Set(w *Workspace) {
	mutex.Lock()
	defer mutex.Unlock()
	instance = w
}
func (w *Workspace) DeleteFolder(folder string) {
	w.mutex.Lock()
	defer w.mutex.Unlock()
	delete(w.folders, folder)
}
func (w *Workspace) AddFolder(f *Folder) {
	w.mutex.Lock()
	defer w.mutex.Unlock()
	if w.folders == nil {
		w.folders = map[string]*Folder{}
	}
	w.folders[f.Path()] = f
}
func (w *Workspace) GetFolderContaining(path string) (folder *Folder) {
	for _, folder := range w.folders {
		if folder.Contains(path) {
			return folder
		}
	}
	return nil
}
func (w *Workspace) ScanWorkspace(ctx context.Context) {
	for _, folder := range w.folders {
		go folder.ScanFolder(ctx)
	}
}
func (w *Workspace) ProcessFolderChange(ctx context.Context, params lsp.DidChangeWorkspaceFoldersParams) {
	for _, folder := range params.Event.Removed {
		w.DeleteFolder(uri.PathFromUri(folder.Uri))
		// TODO: check if we need to clean up the reported diagnostics, if folder was removed?
	}
	for _, folder := range params.Event.Added {
		f := NewFolder(uri.PathFromUri(folder.Uri), folder.Name, w.scanner, w.hoverService)
		w.AddFolder(f)
	}
	w.ScanWorkspace(ctx)
}
func (w *Workspace) ClearIssues(ctx context.Context) {
	for _, folder := range w.folders {
		folder.ClearScannedStatus()
		folder.ClearDiagnostics()
	}
	w.hoverService.ClearAllHovers()
}
",CWE-78,115.0,1
"/*
 * Copyright 2022 Snyk Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package snyk
const (
	NavigateToRangeCommand = ""snyk.navigateToRange""
	WorkspaceScanCommand   = ""snyk.workspace.scan""
	OpenBrowserCommand     = ""snyk.openBrowser""
	LoginCommand           = ""snyk.login""
	CopyAuthLinkCommand    = ""snyk.copyAuthLink""
	LogoutCommand          = ""snyk.logout""
)
type Command struct {
	/**
	 * Title of the command, like `save`.
	 */
	Title string
	/**
	 * The identifier of the actual command handler.
	 */
	Command string
	/**
	 * Arguments that the command handler should be
	 * invoked with.
	 */
	Arguments []interface{}
}
type CommandName string
",CWE-78,45.0,1
"/*
 * Copyright 2022 Snyk Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package testutil
import (
	""os""
	""runtime""
	""testing""
	""github.com/pact-foundation/pact-go/dsl""
	""github.com/snyk/snyk-ls/application/config""
	""github.com/snyk/snyk-ls/internal/progress""
)
const (
	integTestEnvVar = ""INTEG_TESTS""
	smokeTestEnvVar = ""SMOKE_TESTS""
)
func IntegTest(t *testing.T) {
	prepareTestHelper(t, integTestEnvVar)
}
func SmokeTest(t *testing.T) {
	prepareTestHelper(t, smokeTestEnvVar)
}
func UnitTest(t *testing.T) {
	t.Helper()
	c := config.New()
	c.SetManageBinariesAutomatically(false)
	c.SetToken(""00000000-0000-0000-0000-000000000001"")
	config.SetCurrentConfig(c)
	CLIDownloadLockFileCleanUp(t)
}
func CLIDownloadLockFileCleanUp(t *testing.T) {
	t.Helper()
	// remove lock file before test and after test
	lockFileName := config.CurrentConfig().CLIDownloadLockFileName()
	file, _ := os.Open(lockFileName)
	file.Close()
	_ = os.Remove(lockFileName)
	t.Cleanup(func() {
		_ = os.Remove(lockFileName)
	})
}
func NotOnWindows(t *testing.T, reason string) {
	t.Helper()
	if //goland:noinspection GoBoolExpressions
	runtime.GOOS == ""windows"" {
		t.Skipf(""Not on windows, because %s"", reason)
	}
}
func OnlyOnWindows(t *testing.T, reason string) {
	t.Helper()
	if //goland:noinspection GoBoolExpressions
	runtime.GOOS != ""windows"" {
		t.Skipf(""Only on windows, because %s"", reason)
	}
}
func Pact(t *testing.T, pactDir string, provider string) *dsl.Pact {
	t.Helper()
	NotOnWindows(t, ""we don't have a pact cli"")
	pact := &dsl.Pact{
		Consumer: ""SnykLS"",
		Provider: provider,
		PactDir:  pactDir,
	}
	t.Cleanup(func() {
		pact.Teardown()
	})
	return pact
}
func CreateDummyProgressListener(t *testing.T) {
	t.Helper()
	var dummyProgressStopChannel = make(chan bool, 1)
	t.Cleanup(func() {
		dummyProgressStopChannel <- true
	})
	go func() {
		for {
			select {
			case <-progress.Channel:
				continue
			case <-dummyProgressStopChannel:
				return
			}
		}
	}()
}
func prepareTestHelper(t *testing.T, envVar string) {
	t.Helper()
	if os.Getenv(envVar) == """" {
		t.Logf(""%s is not set"", envVar)
		t.SkipNow()
	}
	c := config.New()
	c.SetToken(GetEnvironmentToken())
	c.SetErrorReportingEnabled(false)
	c.SetTelemetryEnabled(false)
	config.SetCurrentConfig(c)
	CLIDownloadLockFileCleanUp(t)
}
func OnlyEnableCodeAndDisableBinaryManagement() {
	config.CurrentConfig().SetSnykIacEnabled(false)
	config.CurrentConfig().SetSnykOssEnabled(false)
	config.CurrentConfig().SetSnykCodeEnabled(true)
	config.CurrentConfig().SetManageBinariesAutomatically(false)
}
",CWE-78,137.0,1
"package external
import (
	""errors""
	""fmt""
	""os""
	""path/filepath""
	""github.com/foxcpp/maddy/internal/auth""
	""github.com/foxcpp/maddy/internal/config""
	""github.com/foxcpp/maddy/internal/log""
	""github.com/foxcpp/maddy/internal/module""
)
type ExternalAuth struct {
	modName    string
	instName   string
	helperPath string
	perDomain bool
	domains   []string
	Log log.Logger
}
func NewExternalAuth(modName, instName string, _, inlineArgs []string) (module.Module, error) {
	ea := &ExternalAuth{
		modName:  modName,
		instName: instName,
		Log:      log.Logger{Name: modName},
	}
	if len(inlineArgs) != 0 {
		return nil, errors.New(""external: inline arguments are not used"")
	}
	return ea, nil
}
func (ea *ExternalAuth) Name() string {
	return ea.modName
}
func (ea *ExternalAuth) InstanceName() string {
	return ea.instName
}
func (ea *ExternalAuth) Init(cfg *config.Map) error {
	cfg.Bool(""debug"", false, false, &ea.Log.Debug)
	cfg.Bool(""perdomain"", false, false, &ea.perDomain)
	cfg.StringList(""domains"", false, false, nil, &ea.domains)
	cfg.String(""helper"", false, false, """", &ea.helperPath)
	if _, err := cfg.Process(); err != nil {
		return err
	}
	if ea.perDomain && ea.domains == nil {
		return errors.New(""auth_domains must be set if auth_perdomain is used"")
	}
	if ea.helperPath != """" {
		ea.Log.Debugln(""using helper:"", ea.helperPath)
	} else {
		ea.helperPath = filepath.Join(config.LibexecDirectory, ""maddy-auth-helper"")
	}
	if _, err := os.Stat(ea.helperPath); err != nil {
		return fmt.Errorf(""%s doesn't exist"", ea.helperPath)
	}
	ea.Log.Debugln(""using helper:"", ea.helperPath)
	return nil
}
func (ea *ExternalAuth) AuthPlain(username, password string) ([]string, error) {
	accountName, ok := auth.CheckDomainAuth(username, ea.perDomain, ea.domains)
	if !ok {
		return nil, module.ErrUnknownCredentials
	}
	// TODO: Extend process protocol to support multiple authorization identities.
	return []string{username}, AuthUsingHelper(ea.helperPath, accountName, password)
}
func init() {
	module.Register(""extauth"", NewExternalAuth)
}
",CWE-287,87.0,1
"package pam
import (
	""errors""
	""fmt""
	""os""
	""path/filepath""
	""github.com/foxcpp/maddy/internal/auth/external""
	""github.com/foxcpp/maddy/internal/config""
	""github.com/foxcpp/maddy/internal/log""
	""github.com/foxcpp/maddy/internal/module""
)
type Auth struct {
	instName   string
	useHelper  bool
	helperPath string
	Log log.Logger
}
func New(modName, instName string, _, inlineArgs []string) (module.Module, error) {
	if len(inlineArgs) != 0 {
		return nil, errors.New(""pam: inline arguments are not used"")
	}
	return &Auth{
		instName: instName,
		Log:      log.Logger{Name: modName},
	}, nil
}
func (a *Auth) Name() string {
	return ""pam""
}
func (a *Auth) InstanceName() string {
	return a.instName
}
func (a *Auth) Init(cfg *config.Map) error {
	cfg.Bool(""debug"", true, false, &a.Log.Debug)
	cfg.Bool(""use_helper"", false, false, &a.useHelper)
	if _, err := cfg.Process(); err != nil {
		return err
	}
	if !canCallDirectly && !a.useHelper {
		return errors.New(""pam: this build lacks support for direct libpam invocation, use helper binary"")
	}
	if a.useHelper {
		a.helperPath = filepath.Join(config.LibexecDirectory, ""maddy-pam-helper"")
		if _, err := os.Stat(a.helperPath); err != nil {
			return fmt.Errorf(""pam: no helper binary (maddy-pam-helper) found in %s"", config.LibexecDirectory)
		}
	}
	return nil
}
func (a *Auth) AuthPlain(username, password string) ([]string, error) {
	if a.useHelper {
		if err := external.AuthUsingHelper(a.helperPath, username, password); err != nil {
			return nil, err
		}
	}
	err := runPAMAuth(username, password)
	if err != nil {
		return nil, err
	}
	return []string{username}, nil
}
func init() {
	module.Register(""pam"", New)
}
",CWE-287,77.0,1
"package plain_separate
import (
	""errors""
	""github.com/foxcpp/maddy/internal/config""
	""github.com/foxcpp/maddy/internal/log""
	""github.com/foxcpp/maddy/internal/module""
	""golang.org/x/text/secure/precis""
)
type Auth struct {
	modName  string
	instName string
	userTbls []module.Table
	passwd   []module.PlainAuth
	onlyFirstID bool
	Log log.Logger
}
func NewAuth(modName, instName string, _, inlinargs []string) (module.Module, error) {
	a := &Auth{
		modName:     modName,
		instName:    instName,
		onlyFirstID: false,
		Log:         log.Logger{Name: modName},
	}
	if len(inlinargs) != 0 {
		return nil, errors.New(""plain_separate: inline arguments are not used"")
	}
	return a, nil
}
func (a *Auth) Name() string {
	return a.modName
}
func (a *Auth) InstanceName() string {
	return a.instName
}
func (a *Auth) Init(cfg *config.Map) error {
	cfg.Bool(""debug"", false, false, &a.Log.Debug)
	if _, err := cfg.Process(); err != nil {
		return err
	}
	return nil
}
func (a *Auth) AuthPlain(username, password string) ([]string, error) {
	key, err := precis.UsernameCaseMapped.CompareKey(username)
	if err != nil {
		return nil, err
	}
	identities := make([]string, 0, 1)
	if len(a.userTbls) != 0 {
		for _, tbl := range a.userTbls {
			repl, ok, err := tbl.Lookup(key)
			if err != nil {
				return nil, err
			}
			if !ok {
				continue
			}
			if repl != """" {
				identities = append(identities, repl)
			} else {
				identities = append(identities, key)
			}
			if a.onlyFirstID && len(identities) != 0 {
				break
			}
		}
		if len(identities) == 0 {
			return nil, errors.New(""plain_separate: unknown credentials"")
		}
	}
	var (
		lastErr error
		ok      bool
	)
	for _, pass := range a.passwd {
		passIDs, err := pass.AuthPlain(username, password)
		if err != nil {
			lastErr = err
			continue
		}
		if len(a.userTbls) == 0 {
			identities = append(identities, passIDs...)
		}
		ok = true
	}
	if !ok {
		return nil, lastErr
	}
	return identities, nil
}
func init() {
	module.Register(""plain_separate"", NewAuth)
}
",CWE-287,112.0,1
"package plain_separate
import (
	""errors""
	""reflect""
	""testing""
	""github.com/emersion/go-sasl""
	""github.com/foxcpp/maddy/internal/module""
)
type mockAuth struct {
	db map[string][]string
}
func (mockAuth) SASLMechanisms() []string {
	return []string{sasl.Plain, sasl.Login}
}
func (m mockAuth) AuthPlain(username, _ string) ([]string, error) {
	ids, ok := m.db[username]
	if !ok {
		return nil, errors.New(""invalid creds"")
	}
	return ids, nil
}
type mockTable struct {
	db map[string]string
}
func (m mockTable) Lookup(a string) (string, bool, error) {
	b, ok := m.db[a]
	return b, ok, nil
}
func TestPlainSplit_NoUser(t *testing.T) {
	a := Auth{
		passwd: []module.PlainAuth{
			mockAuth{
				db: map[string][]string{
					""user1"": []string{""user1a"", ""user1b""},
				},
			},
		},
	}
	ids, err := a.AuthPlain(""user1"", ""aaa"")
	if err != nil {
		t.Fatal(""Unexpected error:"", err)
	}
	if !reflect.DeepEqual(ids, []string{""user1a"", ""user1b""}) {
		t.Fatal(""Wrong ids returned:"", ids)
	}
}
func TestPlainSplit_NoUser_MultiPass(t *testing.T) {
	a := Auth{
		passwd: []module.PlainAuth{
			mockAuth{
				db: map[string][]string{
					""user2"": []string{""user2a"", ""user2b""},
				},
			},
			mockAuth{
				db: map[string][]string{
					""user1"": []string{""user1a"", ""user1b""},
				},
			},
		},
	}
	ids, err := a.AuthPlain(""user1"", ""aaa"")
	if err != nil {
		t.Fatal(""Unexpected error:"", err)
	}
	if !reflect.DeepEqual(ids, []string{""user1a"", ""user1b""}) {
		t.Fatal(""Wrong ids returned:"", ids)
	}
}
func TestPlainSplit_UserPass(t *testing.T) {
	a := Auth{
		userTbls: []module.Table{
			mockTable{
				db: map[string]string{
					""user1"": ""user2"",
				},
			},
		},
		passwd: []module.PlainAuth{
			mockAuth{
				db: map[string][]string{
					""user2"": []string{""user2a"", ""user2b""},
				},
			},
			mockAuth{
				db: map[string][]string{
					""user1"": []string{""user1a"", ""user1b""},
				},
			},
		},
	}
	ids, err := a.AuthPlain(""user1"", ""aaa"")
	if err != nil {
		t.Fatal(""Unexpected error:"", err)
	}
	if !reflect.DeepEqual(ids, []string{""user2""}) {
		t.Fatal(""Wrong ids returned:"", ids)
	}
}
func TestPlainSplit_MultiUser_Pass(t *testing.T) {
	a := Auth{
		userTbls: []module.Table{
			mockTable{
				db: map[string]string{
					""userWH"": ""user1"",
				},
			},
			mockTable{
				db: map[string]string{
					""user1"": ""user2"",
				},
			},
		},
		passwd: []module.PlainAuth{
			mockAuth{
				db: map[string][]string{
					""user2"": []string{""user2a"", ""user2b""},
				},
			},
			mockAuth{
				db: map[string][]string{
					""user1"": []string{""user1a"", ""user1b""},
				},
			},
		},
	}
	ids, err := a.AuthPlain(""user1"", ""aaa"")
	if err != nil {
		t.Fatal(""Unexpected error:"", err)
	}
	if !reflect.DeepEqual(ids, []string{""user2""}) {
		t.Fatal(""Wrong ids returned:"", ids)
	}
}
",CWE-287,150.0,1
"package auth
import (
	""errors""
	""fmt""
	""net""
	""github.com/emersion/go-sasl""
	""github.com/foxcpp/maddy/internal/config""
	modconfig ""github.com/foxcpp/maddy/internal/config/module""
	""github.com/foxcpp/maddy/internal/log""
	""github.com/foxcpp/maddy/internal/module""
	""golang.org/x/text/secure/precis""
)
var (
	ErrUnsupportedMech = errors.New(""Unsupported SASL mechanism"")
)
// SASLAuth is a wrapper that initializes sasl.Server using authenticators that
// call maddy module objects.
//
// It supports reporting of multiple authorization identities so multiple
// accounts can be associated with a single set of credentials.
type SASLAuth struct {
	Log         log.Logger
	OnlyFirstID bool
	Plain []module.PlainAuth
}
func (s *SASLAuth) SASLMechanisms() []string {
	var mechs []string
	if len(s.Plain) != 0 {
		mechs = append(mechs, sasl.Plain, sasl.Login)
	}
	return mechs
}
func (s *SASLAuth) AuthPlain(username, password string) ([]string, error) {
	if len(s.Plain) == 0 {
		return nil, ErrUnsupportedMech
	}
	var lastErr error
	accounts := make([]string, 0, 1)
	for _, p := range s.Plain {
		pAccs, err := p.AuthPlain(username, password)
		if err != nil {
			lastErr = err
			continue
		}
		if s.OnlyFirstID {
			return pAccs, nil
		}
		accounts = append(accounts, pAccs...)
	}
	if len(accounts) == 0 {
		return nil, fmt.Errorf(""no auth. provider accepted creds, last err: %w"", lastErr)
	}
	return accounts, nil
}
func filterIdentity(accounts []string, identity string) ([]string, error) {
	if identity == """" {
		return accounts, nil
	}
	matchFound := false
	for _, acc := range accounts {
		if precis.UsernameCaseMapped.Compare(acc, identity) {
			accounts = []string{identity}
			matchFound = true
			break
		}
	}
	if !matchFound {
		return nil, errors.New(""auth: invalid credentials"")
	}
	return accounts, nil
}
// CreateSASL creates the sasl.Server instance for the corresponding mechanism.
//
// successCb will be called with the slice of authorization identities
// associated with credentials used.
// If it fails - authentication will fail too.
func (s *SASLAuth) CreateSASL(mech string, remoteAddr net.Addr, successCb func([]string) error) sasl.Server {
	switch mech {
	case sasl.Plain:
		return sasl.NewPlainServer(func(identity, username, password string) error {
			accounts, err := s.AuthPlain(username, password)
			if err != nil {
				s.Log.Error(""authentication failed"", err, ""username"", username, ""identity"", identity, ""src_ip"", remoteAddr)
				return errors.New(""auth: invalid credentials"")
			}
			if len(accounts) == 0 {
				accounts = []string{username}
			}
			accounts, err = filterIdentity(accounts, identity)
			if err != nil {
				s.Log.Error(""not authorized"", err, ""username"", username, ""identity"", identity, ""src_ip"", remoteAddr)
				return errors.New(""auth: invalid credentials"")
			}
			return successCb(accounts)
		})
	case sasl.Login:
		return sasl.NewLoginServer(func(username, password string) error {
			accounts, err := s.AuthPlain(username, password)
			if err != nil {
				s.Log.Error(""authentication failed"", err, ""username"", username, ""src_ip"", remoteAddr)
				return errors.New(""auth: invalid credentials"")
			}
			return successCb(accounts)
		})
	}
	return FailingSASLServ{Err: ErrUnsupportedMech}
}
// AddProvider adds the SASL authentication provider to its mapping by parsing
// the 'auth' configuration directive.
func (s *SASLAuth) AddProvider(m *config.Map, node *config.Node) error {
	mod, err := modconfig.SASLAuthDirective(m, node)
	if err != nil {
		return err
	}
	saslAuth := mod.(module.SASLProvider)
	for _, mech := range saslAuth.SASLMechanisms() {
		switch mech {
		case sasl.Login, sasl.Plain:
			plainAuth, ok := saslAuth.(module.PlainAuth)
			if !ok {
				return m.MatchErr(""auth: provider does not implement PlainAuth even though it reports PLAIN/LOGIN mechanism"")
			}
			s.Plain = append(s.Plain, plainAuth)
		default:
			return m.MatchErr(""auth: unknown SASL mechanism"")
		}
	}
	return nil
}
type FailingSASLServ struct{ Err error }
func (s FailingSASLServ) Next([]byte) ([]byte, bool, error) {
	return nil, true, s.Err
}
",CWE-287,155.0,1
"package auth
import (
	""errors""
	""net""
	""reflect""
	""testing""
	""github.com/emersion/go-sasl""
	""github.com/foxcpp/maddy/internal/module""
	""github.com/foxcpp/maddy/internal/testutils""
)
type mockAuth struct {
	db map[string][]string
}
func (mockAuth) SASLMechanisms() []string {
	return []string{sasl.Plain, sasl.Login}
}
func (m mockAuth) AuthPlain(username, _ string) ([]string, error) {
	ids, ok := m.db[username]
	if !ok {
		return nil, errors.New(""invalid creds"")
	}
	return ids, nil
}
func TestCreateSASL(t *testing.T) {
	a := SASLAuth{
		Log: testutils.Logger(t, ""saslauth""),
		Plain: []module.PlainAuth{
			&mockAuth{
				db: map[string][]string{
					""user1"": []string{""user1a"", ""user1b""},
				},
			},
		},
	}
	t.Run(""XWHATEVER"", func(t *testing.T) {
		srv := a.CreateSASL(""XWHATEVER"", &net.TCPAddr{}, func([]string) error { return nil })
		_, _, err := srv.Next([]byte(""""))
		if err == nil {
			t.Error(""No error for XWHATEVER use"")
		}
	})
	t.Run(""PLAIN"", func(t *testing.T) {
		var ids []string
		srv := a.CreateSASL(""PLAIN"", &net.TCPAddr{}, func(passed []string) error {
			ids = passed
			return nil
		})
		_, _, err := srv.Next([]byte(""\x00user1\x00aa""))
		if err != nil {
			t.Error(""Unexpected error:"", err)
		}
		if !reflect.DeepEqual(ids, []string{""user1a"", ""user1b""}) {
			t.Error(""Wrong auth. identities passed to callback:"", ids)
		}
	})
	t.Run(""PLAIN with autorization identity"", func(t *testing.T) {
		var ids []string
		srv := a.CreateSASL(""PLAIN"", &net.TCPAddr{}, func(passed []string) error {
			ids = passed
			return nil
		})
		_, _, err := srv.Next([]byte(""user1a\x00user1\x00aa""))
		if err != nil {
			t.Error(""Unexpected error:"", err)
		}
		if !reflect.DeepEqual(ids, []string{""user1a""}) {
			t.Error(""Wrong auth. identities passed to callback:"", ids)
		}
	})
	t.Run(""PLAIN with wrong authorization identity"", func(t *testing.T) {
		srv := a.CreateSASL(""PLAIN"", &net.TCPAddr{}, func(passed []string) error {
			return nil
		})
		_, _, err := srv.Next([]byte(""user1c\x00user1\x00aa""))
		if err == nil {
			t.Error(""Next should fail"")
		}
	})
	t.Run(""PLAIN with wrong authentication identity"", func(t *testing.T) {
		srv := a.CreateSASL(""PLAIN"", &net.TCPAddr{}, func(passed []string) error {
			return nil
		})
		_, _, err := srv.Next([]byte(""\x00user2\x00aa""))
		if err == nil {
			t.Error(""Next should fail"")
		}
	})
}
",CWE-287,104.0,1
"// +build !windows
package shadow
import (
	""errors""
	""fmt""
	""os""
	""path/filepath""
	""github.com/foxcpp/maddy/internal/auth/external""
	""github.com/foxcpp/maddy/internal/config""
	""github.com/foxcpp/maddy/internal/log""
	""github.com/foxcpp/maddy/internal/module""
)
type Auth struct {
	instName   string
	useHelper  bool
	helperPath string
	Log log.Logger
}
func New(modName, instName string, _, inlineArgs []string) (module.Module, error) {
	if len(inlineArgs) != 0 {
		return nil, errors.New(""shadow: inline arguments are not used"")
	}
	return &Auth{
		instName: instName,
		Log:      log.Logger{Name: modName},
	}, nil
}
func (a *Auth) Name() string {
	return ""shadow""
}
func (a *Auth) InstanceName() string {
	return a.instName
}
func (a *Auth) Init(cfg *config.Map) error {
	cfg.Bool(""debug"", true, false, &a.Log.Debug)
	cfg.Bool(""use_helper"", false, false, &a.useHelper)
	if _, err := cfg.Process(); err != nil {
		return err
	}
	if a.useHelper {
		a.helperPath = filepath.Join(config.LibexecDirectory, ""maddy-shadow-helper"")
		if _, err := os.Stat(a.helperPath); err != nil {
			return fmt.Errorf(""shadow: no helper binary (maddy-shadow-helper) found in %s"", config.LibexecDirectory)
		}
	} else {
		f, err := os.Open(""/etc/shadow"")
		if err != nil {
			if os.IsPermission(err) {
				return fmt.Errorf(""shadow: can't read /etc/shadow due to permission error, use helper binary or run maddy as a privileged user"")
			}
			return fmt.Errorf(""shadow: can't read /etc/shadow: %v"", err)
		}
		f.Close()
	}
	return nil
}
func (a *Auth) AuthPlain(username, password string) ([]string, error) {
	if a.useHelper {
		return []string{username}, external.AuthUsingHelper(a.helperPath, username, password)
	}
	ent, err := Lookup(username)
	if err != nil {
		return nil, err
	}
	if !ent.IsAccountValid() {
		return nil, fmt.Errorf(""shadow: account is expired"")
	}
	if !ent.IsPasswordValid() {
		return nil, fmt.Errorf(""shadow: password is expired"")
	}
	if err := ent.VerifyPassword(password); err != nil {
		if err == ErrWrongPassword {
			return nil, module.ErrUnknownCredentials
		}
		return nil, err
	}
	return []string{username}, nil
}
func init() {
	module.Register(""shadow"", New)
}
",CWE-287,100.0,1
"package modconfig
import (
	""github.com/foxcpp/maddy/internal/config""
	""github.com/foxcpp/maddy/internal/module""
)
func MessageCheck(globals map[string]interface{}, args []string, block *config.Node) (module.Check, error) {
	var check module.Check
	if err := ModuleFromNode(args, block, globals, &check); err != nil {
		return nil, err
	}
	return check, nil
}
// deliveryDirective is a callback for use in config.Map.Custom.
//
// It does all work necessary to create a module instance from the config
// directive with the following structure:
// directive_name mod_name [inst_name] [{
//   inline_mod_config
// }]
//
// Note that if used configuration structure lacks directive_name before mod_name - this function
// should not be used (call DeliveryTarget directly).
func DeliveryDirective(m *config.Map, node *config.Node) (interface{}, error) {
	return DeliveryTarget(m.Globals, node.Args, node)
}
func DeliveryTarget(globals map[string]interface{}, args []string, block *config.Node) (module.DeliveryTarget, error) {
	var target module.DeliveryTarget
	if err := ModuleFromNode(args, block, globals, &target); err != nil {
		return nil, err
	}
	return target, nil
}
func MsgModifier(globals map[string]interface{}, args []string, block *config.Node) (module.Modifier, error) {
	var check module.Modifier
	if err := ModuleFromNode(args, block, globals, &check); err != nil {
		return nil, err
	}
	return check, nil
}
func StorageDirective(m *config.Map, node *config.Node) (interface{}, error) {
	var backend module.Storage
	if err := ModuleFromNode(node.Args, node, m.Globals, &backend); err != nil {
		return nil, err
	}
	return backend, nil
}
func SASLAuthDirective(m *config.Map, node *config.Node) (interface{}, error) {
	var provider module.SASLProvider
	if err := ModuleFromNode(node.Args, node, m.Globals, &provider); err != nil {
		return nil, err
	}
	return provider, nil
}
func TableDirective(m *config.Map, node *config.Node) (interface{}, error) {
	var tbl module.Table
	if err := ModuleFromNode(node.Args, node, m.Globals, &tbl); err != nil {
		return nil, err
	}
	return tbl, nil
}
",CWE-287,69.0,1
"package module
import ""errors""
var (
	// ErrUnknownCredentials should be returned by auth. provider if supplied
	// credentials are valid for it but are not recognized (e.g. not found in
	// used DB).
	ErrUnknownCredentials = errors.New(""unknown credentials"")
)
// PlainAuth is the interface implemented by modules providing authentication using
// username:password pairs.
type PlainAuth interface {
	AuthPlain(username, password string) ([]string, error)
}
// SASLProvider is the interface implemented by modules and used by protocol
// endpoints that rely on SASL framework for user authentication.
//
// This actual interface is only used to indicate that the module is a
// SASL-compatible auth. provider. For each unique value returned by
// SASLMechanisms, the module object should also implement the coresponding
// mechanism-specific interface.
//
// *Rationale*: There is no single generic interface that would handle any SASL
// mechanism while permiting the use of a credentials set estabilished once with
// multiple auth. providers at once.
//
// Per-mechanism interfaces:
// - PLAIN => PlainAuth
type SASLProvider interface {
	SASLMechanisms() []string
}
",CWE-287,35.0,1
"package module
import (
	""context""
	""github.com/emersion/go-message/textproto""
	""github.com/emersion/go-sasl""
	""github.com/foxcpp/maddy/internal/buffer""
	""github.com/foxcpp/maddy/internal/config""
)
// Dummy is a struct that implements PlainAuth and DeliveryTarget
// interfaces but does nothing. Useful for testing.
//
// It is always registered under the 'dummy' name and can be used in both tests
// and the actual server code (but the latter is kinda pointless).
type Dummy struct{ instName string }
func (d *Dummy) SASLMechanisms() []string {
	return []string{sasl.Plain, sasl.Login}
}
func (d *Dummy) AuthPlain(username, _ string) ([]string, error) {
	return []string{username}, nil
}
func (d *Dummy) Name() string {
	return ""dummy""
}
func (d *Dummy) InstanceName() string {
	return d.instName
}
func (d *Dummy) Init(_ *config.Map) error {
	return nil
}
func (d *Dummy) Start(ctx context.Context, msgMeta *MsgMetadata, mailFrom string) (Delivery, error) {
	return dummyDelivery{}, nil
}
type dummyDelivery struct{}
func (dd dummyDelivery) AddRcpt(ctx context.Context, to string) error {
	return nil
}
func (dd dummyDelivery) Body(ctx context.Context, header textproto.Header, body buffer.Buffer) error {
	return nil
}
func (dd dummyDelivery) Abort(ctx context.Context) error {
	return nil
}
func (dd dummyDelivery) Commit(ctx context.Context) error {
	return nil
}
func init() {
	Register(""dummy"", func(_, instName string, _, _ []string) (Module, error) {
		return &Dummy{instName: instName}, nil
	})
}
",CWE-287,66.0,1
"/*
Maddy Mail Server - Composable all-in-one email server.
Copyright © 2019-2020 Max Mazurov <fox.cpp@disroot.org>, Maddy Mail Server contributors
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/
package auth
import (
	""errors""
	""fmt""
	""net""
	""github.com/emersion/go-sasl""
	""github.com/foxcpp/maddy/framework/config""
	modconfig ""github.com/foxcpp/maddy/framework/config/module""
	""github.com/foxcpp/maddy/framework/log""
	""github.com/foxcpp/maddy/framework/module""
)
var (
	ErrUnsupportedMech = errors.New(""Unsupported SASL mechanism"")
	ErrInvalidAuthCred = errors.New(""auth: invalid credentials"")
)
// SASLAuth is a wrapper that initializes sasl.Server using authenticators that
// call maddy module objects.
//
// It supports reporting of multiple authorization identities so multiple
// accounts can be associated with a single set of credentials.
type SASLAuth struct {
	Log         log.Logger
	OnlyFirstID bool
	Plain []module.PlainAuth
}
func (s *SASLAuth) SASLMechanisms() []string {
	var mechs []string
	if len(s.Plain) != 0 {
		mechs = append(mechs, sasl.Plain, sasl.Login)
	}
	return mechs
}
func (s *SASLAuth) AuthPlain(username, password string) error {
	if len(s.Plain) == 0 {
		return ErrUnsupportedMech
	}
	var lastErr error
	for _, p := range s.Plain {
		lastErr = p.AuthPlain(username, password)
		if lastErr == nil {
			return nil
		}
	}
	return fmt.Errorf(""no auth. provider accepted creds, last err: %w"", lastErr)
}
// CreateSASL creates the sasl.Server instance for the corresponding mechanism.
func (s *SASLAuth) CreateSASL(mech string, remoteAddr net.Addr, successCb func(identity string) error) sasl.Server {
	switch mech {
	case sasl.Plain:
		return sasl.NewPlainServer(func(identity, username, password string) error {
			if identity == """" {
				identity = username
			}
			err := s.AuthPlain(username, password)
			if err != nil {
				s.Log.Error(""authentication failed"", err, ""username"", username, ""src_ip"", remoteAddr)
				return ErrInvalidAuthCred
			}
			return successCb(identity)
		})
	case sasl.Login:
		return sasl.NewLoginServer(func(username, password string) error {
			err := s.AuthPlain(username, password)
			if err != nil {
				s.Log.Error(""authentication failed"", err, ""username"", username, ""src_ip"", remoteAddr)
				return ErrInvalidAuthCred
			}
			return successCb(username)
		})
	}
	return FailingSASLServ{Err: ErrUnsupportedMech}
}
// AddProvider adds the SASL authentication provider to its mapping by parsing
// the 'auth' configuration directive.
func (s *SASLAuth) AddProvider(m *config.Map, node config.Node) error {
	var any interface{}
	if err := modconfig.ModuleFromNode(""auth"", node.Args, node, m.Globals, &any); err != nil {
		return err
	}
	hasAny := false
	if plainAuth, ok := any.(module.PlainAuth); ok {
		s.Plain = append(s.Plain, plainAuth)
		hasAny = true
	}
	if !hasAny {
		return config.NodeErr(node, ""auth: specified module does not provide any SASL mechanism"")
	}
	return nil
}
type FailingSASLServ struct{ Err error }
func (s FailingSASLServ) Next([]byte) ([]byte, bool, error) {
	return nil, true, s.Err
}
",CWE-287,132.0,1
"/*
Maddy Mail Server - Composable all-in-one email server.
Copyright © 2019-2020 Max Mazurov <fox.cpp@disroot.org>, Maddy Mail Server contributors
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/
package auth
import (
	""errors""
	""net""
	""testing""
	""github.com/foxcpp/maddy/framework/module""
	""github.com/foxcpp/maddy/internal/testutils""
)
type mockAuth struct {
	db map[string]bool
}
func (m mockAuth) AuthPlain(username, _ string) error {
	ok := m.db[username]
	if !ok {
		return errors.New(""invalid creds"")
	}
	return nil
}
func TestCreateSASL(t *testing.T) {
	a := SASLAuth{
		Log: testutils.Logger(t, ""saslauth""),
		Plain: []module.PlainAuth{
			&mockAuth{
				db: map[string]bool{
					""user1"": true,
				},
			},
		},
	}
	t.Run(""XWHATEVER"", func(t *testing.T) {
		srv := a.CreateSASL(""XWHATEVER"", &net.TCPAddr{}, func(string) error { return nil })
		_, _, err := srv.Next([]byte(""""))
		if err == nil {
			t.Error(""No error for XWHATEVER use"")
		}
	})
	t.Run(""PLAIN"", func(t *testing.T) {
		srv := a.CreateSASL(""PLAIN"", &net.TCPAddr{}, func(id string) error {
			if id != ""user1"" {
				t.Fatal(""Wrong auth. identities passed to callback:"", id)
			}
			return nil
		})
		_, _, err := srv.Next([]byte(""\x00user1\x00aa""))
		if err != nil {
			t.Error(""Unexpected error:"", err)
		}
	})
	t.Run(""PLAIN with authorization identity"", func(t *testing.T) {
		srv := a.CreateSASL(""PLAIN"", &net.TCPAddr{}, func(id string) error {
			if id != ""user1a"" {
				t.Fatal(""Wrong authorization identity passed:"", id)
			}
			return nil
		})
		_, _, err := srv.Next([]byte(""user1a\x00user1\x00aa""))
		if err != nil {
			t.Error(""Unexpected error:"", err)
		}
	})
}
",CWE-287,90.0,1
"// Code generated by statik. DO NOT EDIT.
package statik
import (
	""github.com/rakyll/statik/fs""
)
func init() {
	data := ""PK\x03\x04\x14\x00\x08\x00\x08\x00\x8az<S\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x11\x00	\x00favicon-16x16.pngUT\x05\x00\x01\xb52Sa\x00\xbd\x01B\xfe\x89PNG\x0d\n\x1a\n\x00\x00\x00\x0dIHDR\x00\x00\x00\x10\x00\x00\x00\x10\x08\x06\x00\x00\x00\x1f\xf3\xffa\x00\x00\x01\x84IDATx\x01\x95S\x03Luq\x1c\xfd\x8c\xf1\xc3\xec0\xa7)\xcda\xb6k6\xb2\x9b\xf9\xb2k\xc85/\xdb\x8dqx\xc6\x94m\xcc{\xef\x7fO\xff\xf3l\xdc\xed\xf2\xe0\xfe\xf8\xc9\xffP\x14\x11/\x14[\xa3P\xc4\xa1\xbc?\xf1t>7\x12s\x13\x03\x85\xca7IR	a\xb5j\x8f\xa71\xbe]\x88\xf6\xb9L\xf0\x1c\x93\xcf\xda\xe3)\x10\x93f\x8d\xe4\x06\x13\xcf\xde<\x9b\xd14\x95\x8a\x92\x81OA\xcfF\x89\xdd<\x9b M\xe6}L\xe4\x07\x15\xc5\xf5\xe3\xffI\x0c{\xd6\x8d\xffs\x994\xbasfh\xae?\xafk\x1aprw\x10 <\xb9\xdb\xc7\x86\xa6\xd1\x19I\n\xa8\xb1\xd7\x84y3g\x171T$\xb5c\x7fq\xfbbq\xbfk\x8e'\x1dQ\xb0\xc2,\x92\x0bx|;F\xe5\xf0\xef\x00\x83\xf2\xa1\x1fx|?q\xbd\xcb\xc2\x16\x80ZF\xf0\xc4J\xf3\xe3\xe4n1\xcc\x17k`:}\xcby\xe8\x98\xcbB\xc7|6z\x97r\xd14\x9d\x06\xd3\xf9\x8a\xe4\x94\x90\x8b\xb6\xd9\x0cP\xebc@\xd0|\xbe*\xc94\xc8\xa7\x98'\xcdh\x00\xe3\xd92\xa6vK}\x0cB\xa4\xf0+D\n\xc7\x81)\xb0\x10\x9a\xe3\xa9\xd8\x8bx\xe4(\xa2\xbb\x8dl\x0d\x01\xb6\x8a-\xf378\xbe\xdd\xc7\xa6\xb6\xc9\xd9\xc6d\xd8\\m\xf4\x0c\x92	uQ\x0e\xd2\xf5\xb3\xd1\xf1w\xdfQ\x16\xb34a$\xa1\xc4\xc4(V\xbcF\xd9\xdf\xa4\x91\xe9\xb0&,\x12+\xcd\x93\xcf\x1c\x1cb\xdc\xca\x00qt\xeb\xcc-\x14\x89\xfe\xfc\x0fm2j\x88\xec\xccs\x18\x00\x00\x00\x00IEND\xaeB`\x82\x01\x00\x00\xff\xffPK\x07\x08\xd4`4t\xc7\x01\x00\x00\xbd\x01\x00\x00PK\x03\x04\x14\x00\x08\x00\x08\x00\x8az<S\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x11\x00	\x00favicon-32x32.pngUT\x05\x00\x01\xb52Sa\x00u\x04\x8a\xfb\x89PNG\x0d\n\x1a\n\x00\x00\x00\x0dIHDR\x00\x00\x00 \x00\x00\x00 \x08\x06\x00\x00\x00szz\xf4\x00\x00\x04<IDATx\x01\xbdW\x03\xcceY\x0c~k\xdb\xb6m\xc4^\xc7^\xdb\xb6=F\xf0\xdb\xb6m\xdb\xb6m\xf3\xa2\xd3o\xf2\xce3\x7f5i\xeea\xdb[\x1f\x8d\xa3\xa0\xaa\xea\xa9\xb2\xb2\xf9\xa4\xacH?\xf27B\x92\xd7\xabx<\x02\x94\xe4\x8d\x1a\xfeFa\x0fgpV\xb3S\xa0\xa8\xf2\x85L\xf8{E\x91\xfa\x88Tr\x04p\x96\x05\xf9\x91\xef^l\x8f\xbe\x9d?\x96\xdef\""S\x820\xaf\xd1\xf0t\x03\x95\xb4zRb\xe5\xcf\x14^\xf4!\x90\xc7?Qq\xab\x07\xef\xd5\x13\xce\x08\xc0]\xa6\xf1.h9\xc9\\\xb9\x98\xff N\x10[\xdf\\\xa6\xbc\xa6\xe3\xf4o\xc4\xdd\xf4\x99\xa7\xc6&\xfe\x13q\x17\xe56\x1e\xe3;K:\xa1Y\x88\x04\xd0t\x94\xf9\xd5|\xa1A\\\xae\xea\n\xa1_\x82\xaf\x01q\xa7\xf0\x97\xa0\xab\xa9\xb23\x084\x84Y\x9a\x98\xf6\xb5v\xff\\0g\xc7\xa2\x90\xfc\xb7Al[\x18\x9c\xff&\xb1\xc3\x1a\x08\xa1^l\xcb\xe6q\x82\xb9G\xc6+ \xb0
		fs.Register(data)
	}
	",CWE-287,14.0,1
"package keeper
import (
	""strings""
	sdk ""github.com/cosmos/cosmos-sdk/types""
	sdkerrors ""github.com/cosmos/cosmos-sdk/types/errors""
	transfertypes ""github.com/cosmos/ibc-go/v3/modules/apps/transfer/types""
	channeltypes ""github.com/cosmos/ibc-go/v3/modules/core/04-channel/types""
	""github.com/cosmos/ibc-go/v3/modules/core/exported""
	""github.com/tharsis/evmos/v2/x/claims/types""
)
// OnRecvPacket performs an IBC receive callback. It performs a no-op if
// claims are inactive
func (k Keeper) OnRecvPacket(
	ctx sdk.Context,
	packet channeltypes.Packet,
	ack exported.Acknowledgement,
) exported.Acknowledgement {
	params := k.GetParams(ctx)
	// short circuit in case claim is not active (no-op)
	if !params.IsClaimsActive(ctx.BlockTime()) {
		return ack
	}
	// unmarshal packet data to obtain the sender and recipient
	var data transfertypes.FungibleTokenPacketData
	if err := transfertypes.ModuleCdc.UnmarshalJSON(packet.GetData(), &data); err != nil {
		err = sdkerrors.Wrapf(sdkerrors.ErrUnknownRequest, ""cannot unmarshal ICS-20 transfer packet data"")
		return channeltypes.NewErrorAcknowledgement(err.Error())
	}
	// validate the sender bech32 address from the counterparty chain
	bech32Prefix := strings.Split(data.Sender, ""1"")[0]
	if bech32Prefix == data.Sender {
		return channeltypes.NewErrorAcknowledgement(
			sdkerrors.Wrapf(sdkerrors.ErrInvalidAddress, ""invalid sender: %s"", data.Sender).Error(),
		)
	}
	senderBz, err := sdk.GetFromBech32(data.Sender, bech32Prefix)
	if err != nil {
		return channeltypes.NewErrorAcknowledgement(
			sdkerrors.Wrapf(sdkerrors.ErrInvalidAddress, ""invalid sender %s, %s"", data.Sender, err.Error()).Error(),
		)
	}
	// change the bech32 human readable prefix (HRP) of the sender to `evmos1`
	sender := sdk.AccAddress(senderBz)
	// obtain the evmos recipient address
	recipient, err := sdk.AccAddressFromBech32(data.Receiver)
	if err != nil {
		return channeltypes.NewErrorAcknowledgement(
			sdkerrors.Wrapf(sdkerrors.ErrInvalidAddress, ""invalid receiver address %s"", err.Error()).Error(),
		)
	}
	senderClaimsRecord, senderRecordFound := k.GetClaimsRecord(ctx, sender)
	recipientClaimsRecord, recipientRecordFound := k.GetClaimsRecord(ctx, recipient)
	// handle the 4 cases for the recipient and sender claim records
	switch {
	case senderRecordFound && recipientRecordFound:
		// 1. Both sender and recipient have a claims record
		// Merge sender's record with the recipient's record and
		// claim actions that have been completed by one or the other
		recipientClaimsRecord, err = k.MergeClaimsRecords(ctx, recipient, senderClaimsRecord, recipientClaimsRecord, params)
		if err != nil {
			return channeltypes.NewErrorAcknowledgement(err.Error())
		}
		// update the recipient's record with the new merged one, while deleting the
		// sender's record
		k.SetClaimsRecord(ctx, recipient, recipientClaimsRecord)
		k.DeleteClaimsRecord(ctx, sender)
	case senderRecordFound && !recipientRecordFound:
		// 2. Only the sender has a claims record.
		// Migrate the sender record to the recipient address
		k.SetClaimsRecord(ctx, recipient, senderClaimsRecord)
		k.DeleteClaimsRecord(ctx, sender)
		// claim IBC action
		_, err = k.ClaimCoinsForAction(ctx, recipient, senderClaimsRecord, types.ActionIBCTransfer, params)
	case !senderRecordFound && recipientRecordFound:
		// 3. Only the recipient has a claims record.
		// Only claim IBC transfer action
		_, err = k.ClaimCoinsForAction(ctx, recipient, recipientClaimsRecord, types.ActionIBCTransfer, params)
	case !senderRecordFound && !recipientRecordFound:
		// 4. Neither the sender or recipient have a claims record.
		// Perform a no-op by returning the  original success acknowledgement
		return ack
	}
	if err != nil {
		return channeltypes.NewErrorAcknowledgement(err.Error())
	}
	// return the original success acknowledgement
	return ack
}
// OnAcknowledgementPacket claims the amount from the `ActionIBCTransfer` for
// the sender of the IBC transfer.
// The function performs a no-op if claims are disabled globally,
// acknowledgment failed, or if sender the sender has no claims record.
func (k Keeper) OnAcknowledgementPacket(
	ctx sdk.Context,
	packet channeltypes.Packet,
	acknowledgement []byte,
) error {
	params := k.GetParams(ctx)
	// short circuit in case claim is not active (no-op)
	if !params.IsClaimsActive(ctx.BlockTime()) {
		return nil
	}
	var ack channeltypes.Acknowledgement
	if err := transfertypes.ModuleCdc.UnmarshalJSON(acknowledgement, &ack); err != nil {
		return sdkerrors.Wrapf(sdkerrors.ErrUnknownRequest, ""cannot unmarshal ICS-20 transfer packet acknowledgement: %v"", err)
	}
	// no-op if the acknowledgement is an error ACK
	if !ack.Success() {
		return nil
	}
	var data transfertypes.FungibleTokenPacketData
	if err := transfertypes.ModuleCdc.UnmarshalJSON(packet.GetData(), &data); err != nil {
		return sdkerrors.Wrapf(sdkerrors.ErrUnknownRequest, ""cannot unmarshal ICS-20 transfer packet data: %s"", err.Error())
	}
	sender, err := sdk.AccAddressFromBech32(data.Sender)
	if err != nil {
		return err
	}
	claimRecord, found := k.GetClaimsRecord(ctx, sender)
	if !found {
		// no-op. The user doesn't have a claim record so we don't need to perform
		// any claim
		return nil
	}
	// claim IBC transfer action
	_, err = k.ClaimCoinsForAction(ctx, sender, claimRecord, types.ActionIBCTransfer, params)
	if err != nil {
		return err
	}
	return nil
}
",CWE-287,158.0,1
"package claims
import (
	""context""
	""encoding/json""
	""fmt""
	""github.com/gorilla/mux""
	""github.com/grpc-ecosystem/grpc-gateway/runtime""
	""github.com/spf13/cobra""
	abci ""github.com/tendermint/tendermint/abci/types""
	""github.com/cosmos/cosmos-sdk/client""
	""github.com/cosmos/cosmos-sdk/codec""
	cdctypes ""github.com/cosmos/cosmos-sdk/codec/types""
	sdk ""github.com/cosmos/cosmos-sdk/types""
	""github.com/cosmos/cosmos-sdk/types/module""
	""github.com/tharsis/evmos/v2/x/claims/client/cli""
	""github.com/tharsis/evmos/v2/x/claims/keeper""
	""github.com/tharsis/evmos/v2/x/claims/types""
)
var (
	_ module.AppModule      = AppModule{}
	_ module.AppModuleBasic = AppModuleBasic{}
)
// ----------------------------------------------------------------------------
// AppModuleBasic
// ----------------------------------------------------------------------------
// AppModuleBasic implements the AppModuleBasic interface for the claim module.
type AppModuleBasic struct {
	cdc codec.Codec
}
func NewAppModuleBasic(cdc codec.Codec) AppModuleBasic {
	return AppModuleBasic{cdc: cdc}
}
// Name returns the claim module's name.
func (AppModuleBasic) Name() string {
	return types.ModuleName
}
func (AppModuleBasic) RegisterLegacyAminoCodec(cdc *codec.LegacyAmino) {
}
// RegisterInterfaces registers the module's interface types
func (a AppModuleBasic) RegisterInterfaces(reg cdctypes.InterfaceRegistry) {
}
// DefaultGenesis returns the claim module's default genesis state.
func (AppModuleBasic) DefaultGenesis(cdc codec.JSONCodec) json.RawMessage {
	return cdc.MustMarshalJSON(types.DefaultGenesis())
}
// ValidateGenesis performs genesis state validation for the claim module.
func (AppModuleBasic) ValidateGenesis(cdc codec.JSONCodec, config client.TxEncodingConfig, bz json.RawMessage) error {
	var genState types.GenesisState
	if err := cdc.UnmarshalJSON(bz, &genState); err != nil {
		return fmt.Errorf(""failed to unmarshal %s genesis state: %w"", types.ModuleName, err)
	}
	return genState.Validate()
}
// RegisterRESTRoutes registers the claim module's REST service handlers.
func (AppModuleBasic) RegisterRESTRoutes(clientCtx client.Context, rtr *mux.Router) {
}
// RegisterGRPCGatewayRoutes registers the gRPC Gateway routes for the module.
func (AppModuleBasic) RegisterGRPCGatewayRoutes(clientCtx client.Context, mux *runtime.ServeMux) {
	err := types.RegisterQueryHandlerClient(context.Background(), mux, types.NewQueryClient(clientCtx))
	if err != nil {
		panic(err)
	}
}
// GetTxCmd returns the claim module's root tx command.
func (a AppModuleBasic) GetTxCmd() *cobra.Command { return nil }
// GetQueryCmd returns the claim module's root query command.
func (AppModuleBasic) GetQueryCmd() *cobra.Command {
	return cli.GetQueryCmd()
}
// ----------------------------------------------------------------------------
// AppModule
// ----------------------------------------------------------------------------
// AppModule implements the AppModule interface for the claim module.
type AppModule struct {
	AppModuleBasic
	keeper keeper.Keeper
}
func NewAppModule(cdc codec.Codec, keeper keeper.Keeper) AppModule {
	return AppModule{
		AppModuleBasic: NewAppModuleBasic(cdc),
		keeper:         keeper,
	}
}
// Name returns the claim module's name.
func (am AppModule) Name() string {
	return am.AppModuleBasic.Name()
}
// Route returns the claim module's message routing key.
func (am AppModule) Route() sdk.Route {
	return sdk.NewRoute(types.RouterKey, NewHandler(am.keeper))
}
// QuerierRoute returns the claim module's query routing key.
func (AppModule) QuerierRoute() string { return """" }
// LegacyQuerierHandler returns the claim module's Querier.
func (am AppModule) LegacyQuerierHandler(legacyQuerierCdc *codec.LegacyAmino) sdk.Querier {
	return nil
}
// RegisterServices registers a GRPC query service to respond to the
// module-specific GRPC queries.
func (am AppModule) RegisterServices(cfg module.Configurator) {
	types.RegisterQueryServer(cfg.QueryServer(), am.keeper)
	migrator := keeper.NewMigrator(am.keeper)
	// register v1 -> v2 migration
	if err := cfg.RegisterMigration(types.ModuleName, 1, migrator.Migrate1to2); err != nil {
		panic(fmt.Errorf(""failed to migrate %s to v2: %w"", types.ModuleName, err))
	}
}
// RegisterInvariants registers the claim module's invariants.
func (am AppModule) RegisterInvariants(_ sdk.InvariantRegistry) {}
// InitGenesis performs the claim module's genesis initialization It returns
// no validator updates.
func (am AppModule) InitGenesis(ctx sdk.Context, cdc codec.JSONCodec, gs json.RawMessage) []abci.ValidatorUpdate {
	var genState types.GenesisState
	// Initialize global index to index in genesis state
	cdc.MustUnmarshalJSON(gs, &genState)
	InitGenesis(ctx, am.keeper, genState)
	return []abci.ValidatorUpdate{}
}
// ExportGenesis returns the claim module's exported genesis state as raw JSON bytes.
func (am AppModule) ExportGenesis(ctx sdk.Context, cdc codec.JSONCodec) json.RawMessage {
	genState := ExportGenesis(ctx, am.keeper)
	return cdc.MustMarshalJSON(genState)
}
// BeginBlock executes all ABCI BeginBlock logic respective to the claim module.
func (am AppModule) BeginBlock(_ sdk.Context, _ abci.RequestBeginBlock) {}
// EndBlock executes all ABCI EndBlock logic respective to the claim module. It
// returns no validator updates.
func (am AppModule) EndBlock(ctx sdk.Context, _ abci.RequestEndBlock) []abci.ValidatorUpdate {
	am.keeper.EndBlocker(ctx)
	return []abci.ValidatorUpdate{}
}
// ConsensusVersion implements AppModule/ConsensusVersion.
func (AppModule) ConsensusVersion() uint64 { return 1 }
",CWE-287,171.0,1
"package types
import (
	""errors""
	""fmt""
	sdk ""github.com/cosmos/cosmos-sdk/types""
)
// NewClaimsRecord creates a new claim record instance
func NewClaimsRecord(initialClaimableAmt sdk.Int) ClaimsRecord {
	return ClaimsRecord{
		InitialClaimableAmount: initialClaimableAmt,
		ActionsCompleted:       []bool{false, false, false, false},
	}
}
// Validate performs a stateless validation of the fields
func (cr ClaimsRecord) Validate() error {
	if cr.InitialClaimableAmount.IsNil() {
		return errors.New(""initial claimable amount is nil"")
	}
	if !cr.InitialClaimableAmount.IsPositive() {
		return fmt.Errorf(""initial claimable amount is not positive, %s"", cr.InitialClaimableAmount)
	}
	if len(cr.ActionsCompleted) == 0 || len(Action_value)-1 != len(cr.ActionsCompleted) {
		return fmt.Errorf(""action length mismatch, expected %d, got %d"", len(Action_value)-1, len(cr.ActionsCompleted))
	}
	return nil
}
// ClaimAction marks the given action as completed. It performs a no-op if the
// action is invalid or if the ActionsCompleted slice has an invalid length.
func (cr *ClaimsRecord) ClaimAction(action Action) {
	switch {
	case len(cr.ActionsCompleted) != len(Action_value)-1:
		return
	case action == ActionUnspecified || int(action) > len(Action_value)-1:
		return
	default:
		cr.ActionsCompleted[action-1] = true
	}
}
// HasClaimedAction checks if the user has claimed a given action. It also
// returns false if the action is invalid or if the ActionsCompleted slice has
// an invalid length.
func (cr ClaimsRecord) HasClaimedAction(action Action) bool {
	switch {
	case len(cr.ActionsCompleted) != len(Action_value)-1:
		return false
	case action == 0 || int(action) > len(Action_value)-1:
		return false
	default:
		return cr.ActionsCompleted[action-1]
	}
}
// HasClaimedAll returns true if the user has claimed all the rewards from the
// available actions
func (cr ClaimsRecord) HasClaimedAll() bool {
	if len(cr.ActionsCompleted) == 0 {
		return false
	}
	for _, completed := range cr.ActionsCompleted {
		if !completed {
			return false
		}
	}
	return true
}
// NewClaimsRecordAddress creates a new claim record instance
func NewClaimsRecordAddress(address sdk.AccAddress, initialClaimableAmt sdk.Int) ClaimsRecordAddress {
	return ClaimsRecordAddress{
		Address:                address.String(),
		InitialClaimableAmount: initialClaimableAmt,
		ActionsCompleted:       []bool{false, false, false, false},
	}
}
// Validate performs a stateless validation of the fields
func (cra ClaimsRecordAddress) Validate() error {
	if _, err := sdk.AccAddressFromBech32(cra.Address); err != nil {
		return err
	}
	if cra.InitialClaimableAmount.IsNil() {
		return errors.New(""initial claimable amount is nil"")
	}
	if !cra.InitialClaimableAmount.IsPositive() {
		return fmt.Errorf(""initial claimable amount is not positive, %s"", cra.InitialClaimableAmount)
	}
	if len(Action_value)-1 != len(cra.ActionsCompleted) {
		return fmt.Errorf(""action length mismatch, expected %d, got %d"", len(Action_value)-1, len(cra.ActionsCompleted))
	}
	return nil
}
",CWE-287,103.0,1
"package erc20
import (
	""context""
	""encoding/json""
	""fmt""
	""math/rand""
	""github.com/cosmos/cosmos-sdk/client""
	""github.com/cosmos/cosmos-sdk/codec""
	codectypes ""github.com/cosmos/cosmos-sdk/codec/types""
	sdk ""github.com/cosmos/cosmos-sdk/types""
	""github.com/cosmos/cosmos-sdk/types/module""
	simtypes ""github.com/cosmos/cosmos-sdk/types/simulation""
	authkeeper ""github.com/cosmos/cosmos-sdk/x/auth/keeper""
	""github.com/gorilla/mux""
	""github.com/grpc-ecosystem/grpc-gateway/runtime""
	""github.com/spf13/cobra""
	abci ""github.com/tendermint/tendermint/abci/types""
	""github.com/tharsis/evmos/v2/x/erc20/client/cli""
	""github.com/tharsis/evmos/v2/x/erc20/keeper""
	""github.com/tharsis/evmos/v2/x/erc20/types""
)
// type check to ensure the interface is properly implemented
var (
	_ module.AppModule           = AppModule{}
	_ module.AppModuleBasic      = AppModuleBasic{}
	_ module.AppModuleSimulation = AppModule{}
)
// app module Basics object
type AppModuleBasic struct{}
func (AppModuleBasic) Name() string {
	return types.ModuleName
}
// RegisterLegacyAminoCodec performs a no-op as the erc20 doesn't support Amino encoding
func (AppModuleBasic) RegisterLegacyAminoCodec(cdc *codec.LegacyAmino) {}
// ConsensusVersion returns the consensus state-breaking version for the module.
func (AppModuleBasic) ConsensusVersion() uint64 {
	return 1
}
// RegisterInterfaces registers interfaces and implementations of the erc20 module.
func (AppModuleBasic) RegisterInterfaces(interfaceRegistry codectypes.InterfaceRegistry) {
	types.RegisterInterfaces(interfaceRegistry)
}
// DefaultGenesis returns default genesis state as raw bytes for the erc20
// module.
func (AppModuleBasic) DefaultGenesis(cdc codec.JSONCodec) json.RawMessage {
	return cdc.MustMarshalJSON(types.DefaultGenesisState())
}
func (b AppModuleBasic) ValidateGenesis(cdc codec.JSONCodec, config client.TxEncodingConfig, bz json.RawMessage) error {
	var genesisState types.GenesisState
	if err := cdc.UnmarshalJSON(bz, &genesisState); err != nil {
		return fmt.Errorf(""failed to unmarshal %s genesis state: %w"", types.ModuleName, err)
	}
	return genesisState.Validate()
}
// RegisterRESTRoutes performs a no-op as the erc20 module doesn't expose REST
// endpoints
func (AppModuleBasic) RegisterRESTRoutes(clientCtx client.Context, rtr *mux.Router) {}
func (b AppModuleBasic) RegisterGRPCGatewayRoutes(c client.Context, serveMux *runtime.ServeMux) {
	if err := types.RegisterQueryHandlerClient(context.Background(), serveMux, types.NewQueryClient(c)); err != nil {
		panic(err)
	}
}
// GetTxCmd returns the root tx command for the erc20 module.
func (AppModuleBasic) GetTxCmd() *cobra.Command {
	return cli.NewTxCmd()
}
// GetQueryCmd returns no root query command for the erc20 module.
func (AppModuleBasic) GetQueryCmd() *cobra.Command {
	return cli.GetQueryCmd()
}
type AppModule struct {
	AppModuleBasic
	keeper keeper.Keeper
	ak     authkeeper.AccountKeeper
}
// NewAppModule creates a new AppModule Object
func NewAppModule(
	k keeper.Keeper,
	ak authkeeper.AccountKeeper,
) AppModule {
	return AppModule{
		AppModuleBasic: AppModuleBasic{},
		keeper:         k,
		ak:             ak,
	}
}
func (AppModule) Name() string {
	return types.ModuleName
}
func (am AppModule) RegisterInvariants(ir sdk.InvariantRegistry) {}
func (am AppModule) NewHandler() sdk.Handler {
	return NewHandler(am.keeper)
}
func (am AppModule) Route() sdk.Route {
	return sdk.NewRoute(types.RouterKey, am.NewHandler())
}
func (am AppModule) QuerierRoute() string {
	return types.RouterKey
}
func (am AppModule) LegacyQuerierHandler(amino *codec.LegacyAmino) sdk.Querier {
	return nil
}
func (am AppModule) RegisterServices(cfg module.Configurator) {
	types.RegisterMsgServer(cfg.MsgServer(), am.keeper)
	types.RegisterQueryServer(cfg.QueryServer(), am.keeper)
	migrator := keeper.NewMigrator(am.keeper)
	// register v1 -> v2 migration
	if err := cfg.RegisterMigration(types.ModuleName, 1, migrator.Migrate1to2); err != nil {
		panic(fmt.Errorf(""failed to migrate %s to v2: %w"", types.ModuleName, err))
	}
}
func (am AppModule) BeginBlock(_ sdk.Context, _ abci.RequestBeginBlock) {
}
func (am AppModule) EndBlock(_ sdk.Context, _ abci.RequestEndBlock) []abci.ValidatorUpdate {
	return []abci.ValidatorUpdate{}
}
func (am AppModule) InitGenesis(ctx sdk.Context, cdc codec.JSONCodec, data json.RawMessage) []abci.ValidatorUpdate {
	var genesisState types.GenesisState
	cdc.MustUnmarshalJSON(data, &genesisState)
	InitGenesis(ctx, am.keeper, am.ak, genesisState)
	return []abci.ValidatorUpdate{}
}
func (am AppModule) ExportGenesis(ctx sdk.Context, cdc codec.JSONCodec) json.RawMessage {
	gs := ExportGenesis(ctx, am.keeper)
	return cdc.MustMarshalJSON(gs)
}
func (am AppModule) GenerateGenesisState(input *module.SimulationState) {
}
func (am AppModule) ProposalContents(simState module.SimulationState) []simtypes.WeightedProposalContent {
	return []simtypes.WeightedProposalContent{}
}
func (am AppModule) RandomizedParams(r *rand.Rand) []simtypes.ParamChange {
	return []simtypes.ParamChange{}
}
func (am AppModule) RegisterStoreDecoder(decoderRegistry sdk.StoreDecoderRegistry) {
}
func (am AppModule) WeightedOperations(simState module.SimulationState) []simtypes.WeightedOperation {
	return []simtypes.WeightedOperation{}
}
",CWE-287,177.0,1
"package inflation
import (
	sdk ""github.com/cosmos/cosmos-sdk/types""
	""github.com/tharsis/evmos/v2/x/inflation/keeper""
	""github.com/tharsis/evmos/v2/x/inflation/types""
)
// InitGenesis import module genesis
func InitGenesis(
	ctx sdk.Context,
	k keeper.Keeper,
	ak types.AccountKeeper,
	sk types.StakingKeeper,
	data types.GenesisState,
) {
	// Ensure inflation module account is set on genesis
	if acc := ak.GetModuleAccount(ctx, types.ModuleName); acc == nil {
		panic(""the inflation module account has not been set"")
	}
	// Set genesis state
	params := data.Params
	k.SetParams(ctx, params)
	period := data.Period
	k.SetPeriod(ctx, period)
	epochIdentifier := data.EpochIdentifier
	k.SetEpochIdentifier(ctx, epochIdentifier)
	epochsPerPeriod := data.EpochsPerPeriod
	k.SetEpochsPerPeriod(ctx, epochsPerPeriod)
	// Get bondedRatio
	bondedRatio := sk.BondedRatio(ctx)
	// Calculate epoch mint provision
	epochMintProvision := types.CalculateEpochMintProvision(
		params,
		period,
		epochsPerPeriod,
		bondedRatio,
	)
	k.SetEpochMintProvision(ctx, epochMintProvision)
}
// ExportGenesis returns a GenesisState for a given context and keeper.
func ExportGenesis(ctx sdk.Context, k keeper.Keeper) *types.GenesisState {
	return &types.GenesisState{
		Params:          k.GetParams(ctx),
		Period:          k.GetPeriod(ctx),
		EpochIdentifier: k.GetEpochIdentifier(ctx),
		EpochsPerPeriod: k.GetEpochsPerPeriod(ctx),
	}
}
",CWE-287,57.0,1
"package keeper
import (
	""fmt""
	sdk ""github.com/cosmos/cosmos-sdk/types""
	epochstypes ""github.com/tharsis/evmos/v2/x/epochs/types""
	""github.com/tharsis/evmos/v2/x/inflation/types""
)
// BeforeEpochStart: noop, We don't need to do anything here
func (k Keeper) BeforeEpochStart(_ sdk.Context, _ string, _ int64) {
}
// AfterEpochEnd mints and distributes coins at the end of each epoch end
func (k Keeper) AfterEpochEnd(ctx sdk.Context, epochIdentifier string, epochNumber int64) {
	params := k.GetParams(ctx)
	expEpochID := k.GetEpochIdentifier(ctx)
	if epochIdentifier != expEpochID {
		return
	}
	// mint coins, update supply
	epochMintProvision, found := k.GetEpochMintProvision(ctx)
	if !found {
		panic(""the epochMintProvision was not found"")
	}
	mintedCoin := sdk.NewCoin(params.MintDenom, epochMintProvision.TruncateInt())
	if err := k.MintAndAllocateInflation(ctx, mintedCoin); err != nil {
		panic(err)
	}
	// check if a period is over. If it's completed, update period, and epochMintProvision
	period := k.GetPeriod(ctx)
	epochsPerPeriod := k.GetEpochsPerPeriod(ctx)
	newProvision := epochMintProvision
	// current epoch number needs to be within range for the period
	// Given, epochNumber = 1, period = 0, epochPerPeriod = 365
	// 1 - 365 * 0 < 365 --- nothing to do here
	// Given, epochNumber = 731, period = 1, epochPerPeriod = 365
	// 731 - 1 * 365 > 365 --- a period has passed! we change the epochMintProvision and set a new period
	if epochNumber-epochsPerPeriod*int64(period) > epochsPerPeriod {
		period++
		k.SetPeriod(ctx, period)
		period = k.GetPeriod(ctx)
		bondedRatio := k.stakingKeeper.BondedRatio(ctx)
		newProvision = types.CalculateEpochMintProvision(
			params,
			period,
			epochsPerPeriod,
			bondedRatio,
		)
		k.SetEpochMintProvision(ctx, newProvision)
	}
	ctx.EventManager().EmitEvent(
		sdk.NewEvent(
			types.EventTypeMint,
			sdk.NewAttribute(types.AttributeEpochNumber, fmt.Sprintf(""%d"", epochNumber)),
			sdk.NewAttribute(types.AttributeKeyEpochProvisions, newProvision.String()),
			sdk.NewAttribute(sdk.AttributeKeyAmount, mintedCoin.Amount.String()),
		),
	)
}
// ___________________________________________________________________________________________________
// Hooks wrapper struct for incentives keeper
type Hooks struct {
	k Keeper
}
var _ epochstypes.EpochHooks = Hooks{}
// Return the wrapper struct
func (k Keeper) Hooks() Hooks {
	return Hooks{k}
}
// epochs hooks
func (h Hooks) BeforeEpochStart(ctx sdk.Context, epochIdentifier string, epochNumber int64) {
	h.k.BeforeEpochStart(ctx, epochIdentifier, epochNumber)
}
func (h Hooks) AfterEpochEnd(ctx sdk.Context, epochIdentifier string, epochNumber int64) {
	h.k.AfterEpochEnd(ctx, epochIdentifier, epochNumber)
}
",CWE-287,91.0,1
"package keeper_test
import (
	""fmt""
	""time""
	""github.com/tharsis/evmos/v2/x/inflation/types""
)
func (suite *KeeperTestSuite) TestEpochIdentifierAfterEpochEnd() {
	testCases := []struct {
		name            string
		epochIdentifier string
		expDistribution bool
	}{
		{
			""correct epoch identifier"",
			""day"",
			true,
		},
		{
			""incorrect epoch identifier"",
			""week"",
			false,
		},
	}
	for _, tc := range testCases {
		suite.Run(fmt.Sprintf(""Case %s"", tc.name), func() {
			suite.SetupTest()
			futureCtx := suite.ctx.WithBlockTime(time.Now().Add(time.Hour))
			newHeight := suite.app.LastBlockHeight() + 1
			feePoolOrigin := suite.app.DistrKeeper.GetFeePool(suite.ctx)
			suite.app.EpochsKeeper.BeforeEpochStart(futureCtx, tc.epochIdentifier, newHeight)
			suite.app.EpochsKeeper.AfterEpochEnd(futureCtx, tc.epochIdentifier, newHeight)
			suite.app.EpochsKeeper.AfterEpochEnd(futureCtx, tc.epochIdentifier, newHeight)
			// check the distribution happened as well
			feePoolNew := suite.app.DistrKeeper.GetFeePool(suite.ctx)
			if tc.expDistribution {
				// Actual distribution portions are tested elsewhere; we just want to verify the value of the pool is greater here
				suite.Require().Greater(feePoolNew.CommunityPool.AmountOf(denomMint).BigInt().Uint64(),
					feePoolOrigin.CommunityPool.AmountOf(denomMint).BigInt().Uint64())
			} else {
				suite.Require().Equal(feePoolNew.CommunityPool.AmountOf(denomMint), feePoolOrigin.CommunityPool.AmountOf(denomMint))
			}
		})
	}
}
func (suite *KeeperTestSuite) TestPeriodChangesAfterEpochEnd() {
	suite.SetupTest()
	currentEpochPeriod := suite.app.InflationKeeper.GetEpochsPerPeriod(suite.ctx)
	// bondingRatio is zero in tests
	bondedRatio := suite.app.StakingKeeper.BondedRatio(suite.ctx)
	testCases := []struct {
		name    string
		height  int64
		changes bool
	}{
		{
			""[Period 0] period stays the same under epoch per period"",
			currentEpochPeriod - 10, // so it's within range
			false,
		},
		{
			""[Period 0] period changes once enough epochs have passed"",
			currentEpochPeriod + 1,
			true,
		},
		{
			""[Period 1] period stays the same under the epoch per period"",
			2*currentEpochPeriod - 1,
			false,
		},
		{
			""[Period 1] period changes once enough epochs have passed"",
			2*currentEpochPeriod + 1,
			true,
		},
	}
	for _, tc := range testCases {
		suite.Run(fmt.Sprintf(""Case %s"", tc.name), func() {
			currentPeriod := suite.app.InflationKeeper.GetPeriod(suite.ctx)
			epochIdentifier := suite.app.InflationKeeper.GetEpochIdentifier(suite.ctx)
			originalProvision, found := suite.app.InflationKeeper.GetEpochMintProvision(suite.ctx)
			suite.Require().True(found)
			futureCtx := suite.ctx.WithBlockTime(time.Now().Add(time.Minute))
			suite.app.EpochsKeeper.BeforeEpochStart(futureCtx, epochIdentifier, tc.height)
			suite.app.EpochsKeeper.AfterEpochEnd(futureCtx, epochIdentifier, tc.height)
			newPeriod := suite.app.InflationKeeper.GetPeriod(suite.ctx)
			if tc.changes {
				newProvision, found := suite.app.InflationKeeper.GetEpochMintProvision(suite.ctx)
				suite.Require().True(found)
				expectedProvision := types.CalculateEpochMintProvision(
					suite.app.InflationKeeper.GetParams(suite.ctx),
					newPeriod,
					currentEpochPeriod,
					bondedRatio,
				)
				suite.Require().Equal(expectedProvision, newProvision)
				// mint provisions will change
				suite.Require().NotEqual(newProvision.BigInt().Uint64(), originalProvision.BigInt().Uint64())
				suite.Require().Equal(currentPeriod+1, newPeriod)
			} else {
				suite.Require().Equal(newPeriod, currentPeriod)
			}
		})
	}
}
",CWE-287,118.0,1
"package keeper
import (
	sdk ""github.com/cosmos/cosmos-sdk/types""
	incentivestypes ""github.com/tharsis/evmos/v2/x/incentives/types""
	""github.com/tharsis/evmos/v2/x/inflation/types""
)
// MintAndAllocateInflation performs inflation minting and allocation
func (k Keeper) MintAndAllocateInflation(ctx sdk.Context, coin sdk.Coin) error {
	// Mint coins for distribution
	if err := k.MintCoins(ctx, coin); err != nil {
		return err
	}
	// Allocate minted coins according to allocation proportions (staking, usage
	// incentives, community pool)
	return k.AllocateExponentialInflation(ctx, coin)
}
// MintCoins implements an alias call to the underlying supply keeper's
// MintCoins to be used in BeginBlocker.
func (k Keeper) MintCoins(ctx sdk.Context, newCoin sdk.Coin) error {
	newCoins := sdk.NewCoins(newCoin)
	// skip as no coins need to be minted
	if newCoins.Empty() {
		return nil
	}
	return k.bankKeeper.MintCoins(ctx, types.ModuleName, newCoins)
}
// AllocateExponentialInflation allocates coins from the inflation to external
// modules according to allocation proportions:
//   - staking rewards -> sdk `auth` module fee collector
//   - usage incentives -> `x/incentives` module
//   - community pool -> `sdk `distr` module community pool
func (k Keeper) AllocateExponentialInflation(ctx sdk.Context, mintedCoin sdk.Coin) error {
	params := k.GetParams(ctx)
	proportions := params.InflationDistribution
	// Allocate staking rewards into fee collector account
	stakingRewardsAmt := sdk.NewCoins(k.GetProportions(ctx, mintedCoin, proportions.StakingRewards))
	err := k.bankKeeper.SendCoinsFromModuleToModule(
		ctx,
		types.ModuleName,
		k.feeCollectorName,
		stakingRewardsAmt,
	)
	if err != nil {
		return err
	}
	// Allocate usage incentives to incentives module account
	usageIncentivesAmt := sdk.NewCoins(k.GetProportions(ctx, mintedCoin, proportions.UsageIncentives))
	err = k.bankKeeper.SendCoinsFromModuleToModule(
		ctx,
		types.ModuleName,
		incentivestypes.ModuleName,
		usageIncentivesAmt,
	)
	if err != nil {
		return err
	}
	// Allocate community pool amount (remaining module balance) to community
	// pool address
	moduleAddr := k.accountKeeper.GetModuleAddress(types.ModuleName)
	communityPoolAmt := k.bankKeeper.GetAllBalances(ctx, moduleAddr)
	return k.distrKeeper.FundCommunityPool(
		ctx,
		communityPoolAmt,
		moduleAddr,
	)
}
// GetAllocationProportion calculates the proportion of coins that is to be
// allocated during inflation for a given distribution.
func (k Keeper) GetProportions(
	ctx sdk.Context,
	coin sdk.Coin,
	distribution sdk.Dec,
) sdk.Coin {
	return sdk.NewCoin(
		coin.Denom,
		coin.Amount.ToDec().Mul(distribution).TruncateInt(),
	)
}
",CWE-287,91.0,1
"package types // noalias
import (
	sdk ""github.com/cosmos/cosmos-sdk/types""
	""github.com/cosmos/cosmos-sdk/x/auth/types""
)
// AccountKeeper defines the contract required for account APIs.
type AccountKeeper interface {
	GetModuleAddress(name string) sdk.AccAddress
	GetModuleAccount(ctx sdk.Context, moduleName string) types.ModuleAccountI
	GetAccount(sdk.Context, sdk.AccAddress) types.AccountI
	SetAccount(sdk.Context, types.AccountI)
}
// BankKeeper defines the contract needed to be fulfilled for banking and supply
// dependencies.
type BankKeeper interface {
	GetBalance(ctx sdk.Context, addr sdk.AccAddress, denom string) sdk.Coin
	GetAllBalances(ctx sdk.Context, addr sdk.AccAddress) sdk.Coins
	SendCoinsFromModuleToAccount(ctx sdk.Context, senderModule string, recipientAddr sdk.AccAddress, amt sdk.Coins) error
	SendCoinsFromModuleToModule(ctx sdk.Context, senderModule, recipientModule string, amt sdk.Coins) error
	MintCoins(ctx sdk.Context, name string, amt sdk.Coins) error
	BurnCoins(ctx sdk.Context, name string, amt sdk.Coins) error
	HasSupply(ctx sdk.Context, denom string) bool
}
// DistrKeeper defines the contract needed to be fulfilled for distribution keeper
type DistrKeeper interface {
	FundCommunityPool(ctx sdk.Context, amount sdk.Coins, sender sdk.AccAddress) error
}
// StakingKeeper expected staking keeper
type StakingKeeper interface {
	// BondedRatio the fraction of the staking tokens which are currently bonded
	BondedRatio(ctx sdk.Context) sdk.Dec
}
",CWE-287,38.0,1
"// Copyright 2017 HootSuite Media Inc.
//
// Licensed under the Apache License, Version 2.0 (the License);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//    http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an AS IS BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Modified hereafter by contributors to runatlantis/atlantis.
package events
import (
	""encoding/json""
	""fmt""
	""io""
	""net/http""
	gitlab ""github.com/xanzy/go-gitlab""
)
const secretHeader = ""X-Gitlab-Token"" // 
//go:generate pegomock generate -m --use-experimental-model-gen --package mocks -o mocks/mock_gitlab_request_parser_validator.go GitlabRequestParserValidator
// GitlabRequestParserValidator parses and validates GitLab requests.
type GitlabRequestParserValidator interface {
	// ParseAndValidate validates that the request has a token header matching secret.
	// If the secret does not match it returns an error.
	// If secret is empty it does not check the token header.
	// It then parses the request as a GitLab object depending on the header
	// provided by GitLab identifying the webhook type. If the webhook type
	// is not recognized it will return nil but will not return an error.
	// Usage:
	//	event, err := GitlabRequestParserValidator.ParseAndValidate(r, secret)
	//	if err != nil {
	//		return
	//	}
	//	switch event := event.(type) {
	//	case gitlab.MergeCommentEvent:
	//		// handle
	//	case gitlab.MergeEvent:
	//		// handle
	//	default:
	//		// unsupported event
	//	}
	ParseAndValidate(r *http.Request, secret []byte) (interface{}, error)
}
// DefaultGitlabRequestParserValidator parses and validates GitLab requests.
type DefaultGitlabRequestParserValidator struct{}
// ParseAndValidate returns the JSON payload of the request.
// See GitlabRequestParserValidator.ParseAndValidate().
func (d *DefaultGitlabRequestParserValidator) ParseAndValidate(r *http.Request, secret []byte) (interface{}, error) {
	const mergeEventHeader = ""Merge Request Hook""
	const noteEventHeader = ""Note Hook""
	// Validate secret if specified.
	headerSecret := r.Header.Get(secretHeader)
	secretStr := string(secret)
	if len(secret) != 0 && headerSecret != secretStr {
		return nil, fmt.Errorf(""header %s=%s did not match expected secret"", secretHeader, headerSecret)
	}
	// Parse request into a gitlab object based on the object type specified
	// in the gitlabHeader.
	bytes, err := io.ReadAll(r.Body)
	if err != nil {
		return nil, err
	}
	switch r.Header.Get(gitlabHeader) {
	case mergeEventHeader:
		var m gitlab.MergeEvent
		if err := json.Unmarshal(bytes, &m); err != nil {
			return nil, err
		}
		return m, nil
	case noteEventHeader:
		// First, parse a small part of the json to determine if this is a
		// comment on a merge request or a commit.
		var subset struct {
			ObjectAttributes struct {
				NoteableType string `json:""noteable_type""`
			} `json:""object_attributes""`
		}
		if err := json.Unmarshal(bytes, &subset); err != nil {
			return nil, err
		}
		// We then parse into the correct comment event type.
		switch subset.ObjectAttributes.NoteableType {
		case ""Commit"":
			var e gitlab.CommitCommentEvent
			err := json.Unmarshal(bytes, &e)
			return e, err
		case ""MergeRequest"":
			var e gitlab.MergeCommentEvent
			err := json.Unmarshal(bytes, &e)
			return e, err
		}
	}
	return nil, nil
}
",CWE-203,108.0,1
"// Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
package singleflight
import (
	""errors""
	""fmt""
	""sync""
	""sync/atomic""
	""testing""
	""time""
)
func TestDo(t *testing.T) {
	var g Group
	v, err, _ := g.Do(""key"", func() (interface{}, error) {
		return ""bar"", nil
	})
	if got, want := fmt.Sprintf(""%v (%T)"", v, v), ""bar (string)""; got != want {
		t.Errorf(""Do = %v; want %v"", got, want)
	}
	if err != nil {
		t.Errorf(""Do error = %v"", err)
	}
}
func TestDoErr(t *testing.T) {
	var g Group
	someErr := errors.New(""Some error"")
	v, err, _ := g.Do(""key"", func() (interface{}, error) {
		return nil, someErr
	})
	if err != someErr {
		t.Errorf(""Do error = %v; want someErr %v"", err, someErr)
	}
	if v != nil {
		t.Errorf(""unexpected non-nil value %
	}
}
func TestDoDupSuppress(t *testing.T) {
	var g Group
	var wg1, wg2 sync.WaitGroup
	c := make(chan string, 1)
	var calls int32
	fn := func() (interface{}, error) {
		if atomic.AddInt32(&calls, 1) == 1 {
			// First invocation.
			wg1.Done()
		}
		v := <-c
		c <- v // pump; make available for any future calls
		time.Sleep(10 * time.Millisecond) // let more goroutines enter Do
		return v, nil
	}
	const n = 10
	wg1.Add(1)
	for i := 0; i < n; i++ {
		wg1.Add(1)
		wg2.Add(1)
		go func() {
			defer wg2.Done()
			wg1.Done()
			v, err, _ := g.Do(""key"", fn)
			if err != nil {
				t.Errorf(""Do error: %v"", err)
				return
			}
			if s, _ := v.(string); s != ""bar"" {
				t.Errorf(""Do = %T %v; want %q"", v, v, ""bar"")
			}
		}()
	}
	wg1.Wait()
	// At least one goroutine is in fn now and all of them have at
	// least reached the line before the Do.
	c <- ""bar""
	wg2.Wait()
	if got := atomic.LoadInt32(&calls); got <= 0 || got >= n {
		t.Errorf(""number of calls = %d; want over 0 and less than %d"", got, n)
	}
}
// Test that singleflight behaves correctly after Forget called.
// See https://github.com/golang/go/issues/31420
func TestForget(t *testing.T) {
	var g Group
	var firstStarted, firstFinished sync.WaitGroup
	firstStarted.Add(1)
	firstFinished.Add(1)
	firstCh := make(chan struct{})
	go func() {
		g.Do(""key"", func() (i interface{}, e error) {
			firstStarted.Done()
			<-firstCh
			firstFinished.Done()
			return
		})
	}()
	firstStarted.Wait()
	g.Forget(""key"") // from this point no two function using same key should be executed concurrently
	var secondStarted int32
	var secondFinished int32
	var thirdStarted int32
	secondCh := make(chan struct{})
	secondRunning := make(chan struct{})
	go func() {
		g.Do(""key"", func() (i interface{}, e error) {
			defer func() {
			}()
			atomic.AddInt32(&secondStarted, 1)
			// Notify that we started
			secondCh <- struct{}{}
			// Wait other get above signal
			<-secondRunning
			<-secondCh
			atomic.AddInt32(&secondFinished, 1)
			return 2, nil
		})
	}()
	close(firstCh)
	firstFinished.Wait() // wait for first execution (which should not affect execution after Forget)
	<-secondCh
	// Notify second that we got the signal that it started
	secondRunning <- struct{}{}
	if atomic.LoadInt32(&secondStarted) != 1 {
		t.Fatal(""Second execution should be executed due to usage of forget"")
	}
	if atomic.LoadInt32(&secondFinished) == 1 {
		t.Fatal(""Second execution should be still active"")
	}
	close(secondCh)
	result, _, _ := g.Do(""key"", func() (i interface{}, e error) {
		atomic.AddInt32(&thirdStarted, 1)
		return 3, nil
	})
	if atomic.LoadInt32(&thirdStarted) != 0 {
		t.Error(""Third call should not be started because was started during second execution"")
	}
	if result != 2 {
		t.Errorf(""We should receive result produced by second call, expected: 2, got %d"", result)
	}
}
",CWE-326,160.0,1
"package s3crypto
import (
	""io""
	""strings""
)
const (
	cbcKeySize   = 32
	cbcNonceSize = 16
)
type cbcContentCipherBuilder struct {
	generator CipherDataGenerator
	padder    Padder
}
// AESCBCContentCipherBuilder returns a new encryption only mode structure with a specific cipher
// for the master key
func AESCBCContentCipherBuilder(generator CipherDataGenerator, padder Padder) ContentCipherBuilder {
	return cbcContentCipherBuilder{generator: generator, padder: padder}
}
func (builder cbcContentCipherBuilder) ContentCipher() (ContentCipher, error) {
	cd, err := builder.generator.GenerateCipherData(cbcKeySize, cbcNonceSize)
	if err != nil {
		return nil, err
	}
	cd.Padder = builder.padder
	return newAESCBCContentCipher(cd)
}
// newAESCBCContentCipher will create a new aes cbc content cipher. If the cipher data's
// will set the CEK algorithm if it hasn't been set.
func newAESCBCContentCipher(cd CipherData) (ContentCipher, error) {
	if len(cd.CEKAlgorithm) == 0 {
		cd.CEKAlgorithm = strings.Join([]string{AESCBC, cd.Padder.Name()}, ""/"")
	}
	cipher, err := newAESCBC(cd, cd.Padder)
	if err != nil {
		return nil, err
	}
	return &aesCBCContentCipher{
		CipherData: cd,
		Cipher:     cipher,
	}, nil
}
// aesCBCContentCipher will use AES CBC for the main cipher.
type aesCBCContentCipher struct {
	CipherData CipherData
	Cipher     Cipher
}
// EncryptContents will generate a random key and iv and encrypt the data using cbc
func (cc *aesCBCContentCipher) EncryptContents(src io.Reader) (io.Reader, error) {
	return cc.Cipher.Encrypt(src), nil
}
// DecryptContents will use the symmetric key provider to instantiate a new CBC cipher.
// We grab a decrypt reader from CBC and wrap it in a CryptoReadCloser. The only error
// expected here is when the key or iv is of invalid length.
func (cc *aesCBCContentCipher) DecryptContents(src io.ReadCloser) (io.ReadCloser, error) {
	reader := cc.Cipher.Decrypt(src)
	return &CryptoReadCloser{Body: src, Decrypter: reader}, nil
}
// GetCipherData returns cipher data
func (cc aesCBCContentCipher) GetCipherData() CipherData {
	return cc.CipherData
}
",CWE-326,74.0,1
"package s3crypto
import (
	""io""
	""github.com/aws/aws-sdk-go/aws""
)
const (
	gcmKeySize   = 32
	gcmNonceSize = 12
)
type gcmContentCipherBuilder struct {
	generator CipherDataGenerator
}
// AESGCMContentCipherBuilder returns a new encryption only mode structure with a specific cipher
// for the master key
func AESGCMContentCipherBuilder(generator CipherDataGenerator) ContentCipherBuilder {
	return gcmContentCipherBuilder{generator}
}
func (builder gcmContentCipherBuilder) ContentCipher() (ContentCipher, error) {
	return builder.ContentCipherWithContext(aws.BackgroundContext())
}
func (builder gcmContentCipherBuilder) ContentCipherWithContext(ctx aws.Context) (ContentCipher, error) {
	var cd CipherData
	var err error
	if v, ok := builder.generator.(CipherDataGeneratorWithContext); ok {
		cd, err = v.GenerateCipherDataWithContext(ctx, gcmKeySize, gcmNonceSize)
	} else {
		cd, err = builder.generator.GenerateCipherData(gcmKeySize, gcmNonceSize)
	}
	if err != nil {
		return nil, err
	}
	return newAESGCMContentCipher(cd)
}
func newAESGCMContentCipher(cd CipherData) (ContentCipher, error) {
	cd.CEKAlgorithm = AESGCMNoPadding
	cd.TagLength = ""128""
	cipher, err := newAESGCM(cd)
	if err != nil {
		return nil, err
	}
	return &aesGCMContentCipher{
		CipherData: cd,
		Cipher:     cipher,
	}, nil
}
// AESGCMContentCipher will use AES GCM for the main cipher.
type aesGCMContentCipher struct {
	CipherData CipherData
	Cipher     Cipher
}
// EncryptContents will generate a random key and iv and encrypt the data using cbc
func (cc *aesGCMContentCipher) EncryptContents(src io.Reader) (io.Reader, error) {
	return cc.Cipher.Encrypt(src), nil
}
// DecryptContents will use the symmetric key provider to instantiate a new GCM cipher.
// We grab a decrypt reader from gcm and wrap it in a CryptoReadCloser. The only error
// expected here is when the key or iv is of invalid length.
func (cc *aesGCMContentCipher) DecryptContents(src io.ReadCloser) (io.ReadCloser, error) {
	reader := cc.Cipher.Decrypt(src)
	return &CryptoReadCloser{Body: src, Decrypter: reader}, nil
}
// GetCipherData returns cipher data
func (cc aesGCMContentCipher) GetCipherData() CipherData {
	return cc.CipherData
}
",CWE-326,82.0,1
"package s3crypto_test
import (
	""testing""
	""github.com/aws/aws-sdk-go/service/s3/s3crypto""
)
func TestAESGCMContentCipherBuilder(t *testing.T) {
	generator := mockGenerator{}
	if builder := s3crypto.AESGCMContentCipherBuilder(generator); builder == nil {
		t.Error(""expected non-nil value"")
	}
}
func TestAESGCMContentCipherNewEncryptor(t *testing.T) {
	generator := mockGenerator{}
	builder := s3crypto.AESGCMContentCipherBuilder(generator)
	cipher, err := builder.ContentCipher()
	if err != nil {
		t.Errorf(""expected no error, but received %v"", err)
	}
	if cipher == nil {
		t.Errorf(""expected non-nil vaue"")
	}
}
",CWE-326,29.0,1
"package s3crypto
import (
	""encoding/base64""
	""strconv""
	""strings""
	""github.com/aws/aws-sdk-go/aws""
	""github.com/aws/aws-sdk-go/aws/awserr""
)
func (client *DecryptionClient) contentCipherFromEnvelope(ctx aws.Context, env Envelope) (ContentCipher, error) {
	wrap, err := client.wrapFromEnvelope(env)
	if err != nil {
		return nil, err
	}
	return client.cekFromEnvelope(ctx, env, wrap)
}
func (client *DecryptionClient) wrapFromEnvelope(env Envelope) (CipherDataDecrypter, error) {
	f, ok := client.WrapRegistry[env.WrapAlg]
	if !ok || f == nil {
		return nil, awserr.New(
			""InvalidWrapAlgorithmError"",
			""wrap algorithm isn't supported, ""+env.WrapAlg,
			nil,
		)
	}
	return f(env)
}
// AESGCMNoPadding is the constant value that is used to specify
// the CEK algorithm consiting of AES GCM with no padding.
const AESGCMNoPadding = ""AES/GCM/NoPadding""
// AESCBC is the string constant that signifies the AES CBC algorithm cipher.
const AESCBC = ""AES/CBC""
func (client *DecryptionClient) cekFromEnvelope(ctx aws.Context, env Envelope, decrypter CipherDataDecrypter) (ContentCipher, error) {
	f, ok := client.CEKRegistry[env.CEKAlg]
	if !ok || f == nil {
		return nil, awserr.New(
			""InvalidCEKAlgorithmError"",
			""cek algorithm isn't supported, ""+env.CEKAlg,
			nil,
		)
	}
	key, err := base64.StdEncoding.DecodeString(env.CipherKey)
	if err != nil {
		return nil, err
	}
	iv, err := base64.StdEncoding.DecodeString(env.IV)
	if err != nil {
		return nil, err
	}
	if d, ok := decrypter.(CipherDataDecrypterWithContext); ok {
		key, err = d.DecryptKeyWithContext(ctx, key)
	} else {
		key, err = decrypter.DecryptKey(key)
	}
	if err != nil {
		return nil, err
	}
	cd := CipherData{
		Key:          key,
		IV:           iv,
		CEKAlgorithm: env.CEKAlg,
		Padder:       client.getPadder(env.CEKAlg),
	}
	return f(cd)
}
// getPadder will return an unpadder with checking the cek algorithm specific padder.
// If there wasn't a cek algorithm specific padder, we check the padder itself.
// We return a no unpadder, if no unpadder was found. This means any customization
// either contained padding within the cipher implementation, and to maintain
// backwards compatility we will simply not unpad anything.
func (client *DecryptionClient) getPadder(cekAlg string) Padder {
	padder, ok := client.PadderRegistry[cekAlg]
	if !ok {
		padder, ok = client.PadderRegistry[cekAlg[strings.LastIndex(cekAlg, ""/"")+1:]]
		if !ok {
			return NoPadder
		}
	}
	return padder
}
func encodeMeta(reader hashReader, cd CipherData) (Envelope, error) {
	iv := base64.StdEncoding.EncodeToString(cd.IV)
	key := base64.StdEncoding.EncodeToString(cd.EncryptedKey)
	md5 := reader.GetValue()
	contentLength := reader.GetContentLength()
	md5Str := base64.StdEncoding.EncodeToString(md5)
	matdesc, err := cd.MaterialDescription.encodeDescription()
	if err != nil {
		return Envelope{}, err
	}
	return Envelope{
		CipherKey:             key,
		IV:                    iv,
		MatDesc:               string(matdesc),
		WrapAlg:               cd.WrapAlgorithm,
		CEKAlg:                cd.CEKAlgorithm,
		TagLen:                cd.TagLength,
		UnencryptedMD5:        md5Str,
		UnencryptedContentLen: strconv.FormatInt(contentLength, 10),
	}, nil
}
",CWE-326,119.0,1
"package s3crypto
import (
	""strings""
	""github.com/aws/aws-sdk-go/aws""
	""github.com/aws/aws-sdk-go/aws/client""
	""github.com/aws/aws-sdk-go/aws/request""
	""github.com/aws/aws-sdk-go/service/kms""
	""github.com/aws/aws-sdk-go/service/s3""
	""github.com/aws/aws-sdk-go/service/s3/s3iface""
)
// WrapEntry is builder that return a proper key decrypter and error
type WrapEntry func(Envelope) (CipherDataDecrypter, error)
// CEKEntry is a builder thatn returns a proper content decrypter and error
type CEKEntry func(CipherData) (ContentCipher, error)
// DecryptionClient is an S3 crypto client. The decryption client
// will handle all get object requests from Amazon S3.
// Supported key wrapping algorithms:
//	*AWS KMS
//
// Supported content ciphers:
//	* AES/GCM
//	* AES/CBC
type DecryptionClient struct {
	S3Client s3iface.S3API
	// LoadStrategy is used to load the metadata either from the metadata of the object
	// or from a separate file in s3.
	//
	// Defaults to our default load strategy.
	LoadStrategy LoadStrategy
	WrapRegistry   map[string]WrapEntry
	CEKRegistry    map[string]CEKEntry
	PadderRegistry map[string]Padder
}
// NewDecryptionClient instantiates a new S3 crypto client
//
// Example:
//	sess := session.New()
//	svc := s3crypto.NewDecryptionClient(sess, func(svc *s3crypto.DecryptionClient{
//		// Custom client options here
//	}))
func NewDecryptionClient(prov client.ConfigProvider, options ...func(*DecryptionClient)) *DecryptionClient {
	s3client := s3.New(prov)
	s3client.Handlers.Build.PushBack(func(r *request.Request) {
		request.AddToUserAgent(r, ""S3Crypto"")
	})
	client := &DecryptionClient{
		S3Client: s3client,
		LoadStrategy: defaultV2LoadStrategy{
			client: s3client,
		},
		WrapRegistry: map[string]WrapEntry{
			KMSWrap: (kmsKeyHandler{
				kms: kms.New(prov),
			}).decryptHandler,
		},
		CEKRegistry: map[string]CEKEntry{
			AESGCMNoPadding: newAESGCMContentCipher,
			strings.Join([]string{AESCBC, AESCBCPadder.Name()}, ""/""): newAESCBCContentCipher,
		},
		PadderRegistry: map[string]Padder{
			strings.Join([]string{AESCBC, AESCBCPadder.Name()}, ""/""): AESCBCPadder,
			""NoPadding"": NoPadder,
		},
	}
	for _, option := range options {
		option(client)
	}
	return client
}
// GetObjectRequest will make a request to s3 and retrieve the object. In this process
// decryption will be done. The SDK only supports V2 reads of KMS and GCM.
//
// Example:
//	sess := session.New()
//	svc := s3crypto.NewDecryptionClient(sess)
//	req, out := svc.GetObjectRequest(&s3.GetObjectInput {
//	  Key: aws.String(""testKey""),
//	  Bucket: aws.String(""testBucket""),
//	})
//	err := req.Send()
func (c *DecryptionClient) GetObjectRequest(input *s3.GetObjectInput) (*request.Request, *s3.GetObjectOutput) {
	req, out := c.S3Client.GetObjectRequest(input)
	req.Handlers.Unmarshal.PushBack(func(r *request.Request) {
		env, err := c.LoadStrategy.Load(r)
		if err != nil {
			r.Error = err
			out.Body.Close()
			return
		}
		// If KMS should return the correct CEK algorithm with the proper
		// KMS key provider
		cipher, err := c.contentCipherFromEnvelope(r.Context(), env)
		if err != nil {
			r.Error = err
			out.Body.Close()
			return
		}
		reader, err := cipher.DecryptContents(out.Body)
		if err != nil {
			r.Error = err
			out.Body.Close()
			return
		}
		out.Body = reader
	})
	return req, out
}
// GetObject is a wrapper for GetObjectRequest
func (c *DecryptionClient) GetObject(input *s3.GetObjectInput) (*s3.GetObjectOutput, error) {
	req, out := c.GetObjectRequest(input)
	return out, req.Send()
}
// GetObjectWithContext is a wrapper for GetObjectRequest with the additional
// context, and request options support.
//
// GetObjectWithContext is the same as GetObject with the additional support for
// Context input parameters. The Context must not be nil. A nil Context will
// cause a panic. Use the Context to add deadlining, timeouts, etc. In the future
// this may create sub-contexts for individual underlying requests.
func (c *DecryptionClient) GetObjectWithContext(ctx aws.Context, input *s3.GetObjectInput, opts ...request.Option) (*s3.GetObjectOutput, error) {
	req, out := c.GetObjectRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}
",CWE-326,141.0,1
"package s3crypto
import (
	""encoding/hex""
	""io""
	""github.com/aws/aws-sdk-go/aws""
	""github.com/aws/aws-sdk-go/aws/client""
	""github.com/aws/aws-sdk-go/aws/request""
	""github.com/aws/aws-sdk-go/internal/sdkio""
	""github.com/aws/aws-sdk-go/service/s3""
	""github.com/aws/aws-sdk-go/service/s3/s3iface""
)
// DefaultMinFileSize is used to check whether we want to write to a temp file
// or store the data in memory.
const DefaultMinFileSize = 1024 * 512 * 5
// EncryptionClient is an S3 crypto client. By default the SDK will use Authentication mode which
// will use KMS for key wrapping and AES GCM for content encryption.
// AES GCM will load all data into memory. However, the rest of the content algorithms
// do not load the entire contents into memory.
type EncryptionClient struct {
	S3Client             s3iface.S3API
	ContentCipherBuilder ContentCipherBuilder
	// SaveStrategy will dictate where the envelope is saved.
	//
	// Defaults to the object's metadata
	SaveStrategy SaveStrategy
	// TempFolderPath is used to store temp files when calling PutObject.
	// Temporary files are needed to compute the X-Amz-Content-Sha256 header.
	TempFolderPath string
	// MinFileSize is the minimum size for the content to write to a
	// temporary file instead of using memory.
	MinFileSize int64
}
// NewEncryptionClient instantiates a new S3 crypto client
//
// Example:
//	cmkID := ""arn:aws:kms:region:000000000000:key/00000000-0000-0000-0000-000000000000""
//	sess := session.New()
//	handler := s3crypto.NewKMSKeyGenerator(kms.New(sess), cmkID)
//	svc := s3crypto.New(sess, s3crypto.AESGCMContentCipherBuilder(handler))
func NewEncryptionClient(prov client.ConfigProvider, builder ContentCipherBuilder, options ...func(*EncryptionClient)) *EncryptionClient {
	s3client := s3.New(prov)
	s3client.Handlers.Build.PushBack(func(r *request.Request) {
		request.AddToUserAgent(r, ""S3Crypto"")
	})
	client := &EncryptionClient{
		S3Client:             s3client,
		ContentCipherBuilder: builder,
		SaveStrategy:         HeaderV2SaveStrategy{},
		MinFileSize:          DefaultMinFileSize,
	}
	for _, option := range options {
		option(client)
	}
	return client
}
// PutObjectRequest creates a temp file to encrypt the contents into. It then streams
// that data to S3.
//
// Example:
//	svc := s3crypto.New(session.New(), s3crypto.AESGCMContentCipherBuilder(handler))
//	req, out := svc.PutObjectRequest(&s3.PutObjectInput {
//	  Key: aws.String(""testKey""),
//	  Bucket: aws.String(""testBucket""),
//	  Body: strings.NewReader(""test data""),
//	})
//	err := req.Send()
func (c *EncryptionClient) PutObjectRequest(input *s3.PutObjectInput) (*request.Request, *s3.PutObjectOutput) {
	req, out := c.S3Client.PutObjectRequest(input)
	// Get Size of file
	n, err := aws.SeekerLen(input.Body)
	if err != nil {
		req.Error = err
		return req, out
	}
	dst, err := getWriterStore(req, c.TempFolderPath, n >= c.MinFileSize)
	if err != nil {
		req.Error = err
		return req, out
	}
	req.Handlers.Build.PushFront(func(r *request.Request) {
		if err != nil {
			r.Error = err
			return
		}
		var encryptor ContentCipher
		if v, ok := c.ContentCipherBuilder.(ContentCipherBuilderWithContext); ok {
			encryptor, err = v.ContentCipherWithContext(r.Context())
		} else {
			encryptor, err = c.ContentCipherBuilder.ContentCipher()
		}
		if err != nil {
			r.Error = err
			return
		}
		md5 := newMD5Reader(input.Body)
		sha := newSHA256Writer(dst)
		reader, err := encryptor.EncryptContents(md5)
		if err != nil {
			r.Error = err
			return
		}
		_, err = io.Copy(sha, reader)
		if err != nil {
			r.Error = err
			return
		}
		data := encryptor.GetCipherData()
		env, err := encodeMeta(md5, data)
		if err != nil {
			r.Error = err
			return
		}
		shaHex := hex.EncodeToString(sha.GetValue())
		req.HTTPRequest.Header.Set(""X-Amz-Content-Sha256"", shaHex)
		dst.Seek(0, sdkio.SeekStart)
		input.Body = dst
		err = c.SaveStrategy.Save(env, r)
		r.Error = err
	})
	return req, out
}
// PutObject is a wrapper for PutObjectRequest
func (c *EncryptionClient) PutObject(input *s3.PutObjectInput) (*s3.PutObjectOutput, error) {
	req, out := c.PutObjectRequest(input)
	return out, req.Send()
}
// PutObjectWithContext is a wrapper for PutObjectRequest with the additional
// context, and request options support.
//
// PutObjectWithContext is the same as PutObject with the additional support for
// Context input parameters. The Context must not be nil. A nil Context will
// cause a panic. Use the Context to add deadlining, timeouts, etc. In the future
// this may create sub-contexts for individual underlying requests.
func (c *EncryptionClient) PutObjectWithContext(ctx aws.Context, input *s3.PutObjectInput, opts ...request.Option) (*s3.PutObjectOutput, error) {
	req, out := c.PutObjectRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}
",CWE-326,162.0,1
"package s3crypto
// DefaultInstructionKeySuffix is appended to the end of the instruction file key when
// grabbing or saving to S3
const DefaultInstructionKeySuffix = "".instruction""
const (
	metaHeader                     = ""x-amz-meta""
	keyV1Header                    = ""x-amz-key""
	keyV2Header                    = keyV1Header + ""-v2""
	ivHeader                       = ""x-amz-iv""
	matDescHeader                  = ""x-amz-matdesc""
	cekAlgorithmHeader             = ""x-amz-cek-alg""
	wrapAlgorithmHeader            = ""x-amz-wrap-alg""
	tagLengthHeader                = ""x-amz-tag-len""
	unencryptedMD5Header           = ""x-amz-unencrypted-content-md5""
	unencryptedContentLengthHeader = ""x-amz-unencrypted-content-length""
)
// Envelope encryption starts off by generating a random symmetric key using
// AES GCM. The SDK generates a random IV based off the encryption cipher
// chosen. The master key that was provided, whether by the user or KMS, will be used
// to encrypt the randomly generated symmetric key and base64 encode the iv. This will
// allow for decryption of that same data later.
type Envelope struct {
	// IV is the randomly generated IV base64 encoded.
	IV string `json:""x-amz-iv""`
	// CipherKey is the randomly generated cipher key.
	CipherKey string `json:""x-amz-key-v2""`
	// MaterialDesc is a description to distinguish from other envelopes.
	MatDesc               string `json:""x-amz-matdesc""`
	WrapAlg               string `json:""x-amz-wrap-alg""`
	CEKAlg                string `json:""x-amz-cek-alg""`
	TagLen                string `json:""x-amz-tag-len""`
	UnencryptedMD5        string `json:""x-amz-unencrypted-content-md5""`
	UnencryptedContentLen string `json:""x-amz-unencrypted-content-length""`
}
",CWE-326,38.0,1
"package s3crypto
import (
	""crypto/rand""
	""github.com/aws/aws-sdk-go/aws""
)
// CipherDataGenerator handles generating proper key and IVs of proper size for the
// content cipher. CipherDataGenerator will also encrypt the key and store it in
// the CipherData.
type CipherDataGenerator interface {
	GenerateCipherData(int, int) (CipherData, error)
}
// CipherDataGeneratorWithContext handles generating proper key and IVs of
// proper size for the content cipher. CipherDataGenerator will also encrypt
// the key and store it in the CipherData.
type CipherDataGeneratorWithContext interface {
	GenerateCipherDataWithContext(aws.Context, int, int) (CipherData, error)
}
// CipherDataDecrypter is a handler to decrypt keys from the envelope.
type CipherDataDecrypter interface {
	DecryptKey([]byte) ([]byte, error)
}
// CipherDataDecrypterWithContext is a handler to decrypt keys from the envelope with request context.
type CipherDataDecrypterWithContext interface {
	DecryptKeyWithContext(aws.Context, []byte) ([]byte, error)
}
func generateBytes(n int) []byte {
	b := make([]byte, n)
	rand.Read(b)
	return b
}
",CWE-326,38.0,1
"package s3crypto
import (
	""testing""
)
func TestGenerateBytes(t *testing.T) {
	b := generateBytes(5)
	if e, a := 5, len(b); e != a {
		t.Errorf(""expected %d, but received %d"", e, a)
	}
	b = generateBytes(0)
	if e, a := 0, len(b); e != a {
		t.Errorf(""expected %d, but received %d"", e, a)
	}
	b = generateBytes(1024)
	if e, a := 1024, len(b); e != a {
		t.Errorf(""expected %d, but received %d"", e, a)
	}
}
",CWE-326,21.0,1
"package s3crypto_test
import (
	""bytes""
	""io""
	""io/ioutil""
	""github.com/aws/aws-sdk-go/service/s3/s3crypto""
)
type mockGenerator struct {
}
func (m mockGenerator) GenerateCipherData(keySize, ivSize int) (s3crypto.CipherData, error) {
	cd := s3crypto.CipherData{
		Key: make([]byte, keySize),
		IV:  make([]byte, ivSize),
	}
	return cd, nil
}
func (m mockGenerator) EncryptKey(key []byte) ([]byte, error) {
	size := len(key)
	b := bytes.Repeat([]byte{1}, size)
	return b, nil
}
func (m mockGenerator) DecryptKey(key []byte) ([]byte, error) {
	return make([]byte, 16), nil
}
type mockCipherBuilder struct {
	generator s3crypto.CipherDataGenerator
}
func (builder mockCipherBuilder) ContentCipher() (s3crypto.ContentCipher, error) {
	cd, err := builder.generator.GenerateCipherData(32, 16)
	if err != nil {
		return nil, err
	}
	return &mockContentCipher{cd}, nil
}
type mockContentCipher struct {
	cd s3crypto.CipherData
}
func (cipher *mockContentCipher) GetCipherData() s3crypto.CipherData {
	return cipher.cd
}
func (cipher *mockContentCipher) EncryptContents(src io.Reader) (io.Reader, error) {
	b, err := ioutil.ReadAll(src)
	if err != nil {
		return nil, err
	}
	size := len(b)
	b = bytes.Repeat([]byte{1}, size)
	return bytes.NewReader(b), nil
}
func (cipher *mockContentCipher) DecryptContents(src io.ReadCloser) (io.ReadCloser, error) {
	b, err := ioutil.ReadAll(src)
	if err != nil {
		return nil, err
	}
	size := len(b)
	return ioutil.NopCloser(bytes.NewReader(make([]byte, size))), nil
}
",CWE-326,71.0,1
"package s3crypto
import (
	""bytes""
	""encoding/json""
	""io/ioutil""
	""net/http""
	""strings""
	""github.com/aws/aws-sdk-go/aws""
	""github.com/aws/aws-sdk-go/aws/awserr""
	""github.com/aws/aws-sdk-go/aws/request""
	""github.com/aws/aws-sdk-go/service/s3""
)
// SaveStrategy is how the data's metadata wants to be saved
type SaveStrategy interface {
	Save(Envelope, *request.Request) error
}
// S3SaveStrategy will save the metadata to a separate instruction file in S3
type S3SaveStrategy struct {
	Client                *s3.S3
	InstructionFileSuffix string
}
// Save will save the envelope contents to s3.
func (strat S3SaveStrategy) Save(env Envelope, req *request.Request) error {
	input := req.Params.(*s3.PutObjectInput)
	b, err := json.Marshal(env)
	if err != nil {
		return err
	}
	instInput := s3.PutObjectInput{
		Bucket: input.Bucket,
		Body:   bytes.NewReader(b),
	}
	if strat.InstructionFileSuffix == """" {
		instInput.Key = aws.String(*input.Key + DefaultInstructionKeySuffix)
	} else {
		instInput.Key = aws.String(*input.Key + strat.InstructionFileSuffix)
	}
	_, err = strat.Client.PutObject(&instInput)
	return err
}
// HeaderV2SaveStrategy will save the metadata of the crypto contents to the header of
// the object.
type HeaderV2SaveStrategy struct{}
// Save will save the envelope to the request's header.
func (strat HeaderV2SaveStrategy) Save(env Envelope, req *request.Request) error {
	input := req.Params.(*s3.PutObjectInput)
	if input.Metadata == nil {
		input.Metadata = map[string]*string{}
	}
	input.Metadata[http.CanonicalHeaderKey(keyV2Header)] = &env.CipherKey
	input.Metadata[http.CanonicalHeaderKey(ivHeader)] = &env.IV
	input.Metadata[http.CanonicalHeaderKey(matDescHeader)] = &env.MatDesc
	input.Metadata[http.CanonicalHeaderKey(wrapAlgorithmHeader)] = &env.WrapAlg
	input.Metadata[http.CanonicalHeaderKey(cekAlgorithmHeader)] = &env.CEKAlg
	input.Metadata[http.CanonicalHeaderKey(unencryptedMD5Header)] = &env.UnencryptedMD5
	input.Metadata[http.CanonicalHeaderKey(unencryptedContentLengthHeader)] = &env.UnencryptedContentLen
	if len(env.TagLen) > 0 {
		input.Metadata[http.CanonicalHeaderKey(tagLengthHeader)] = &env.TagLen
	}
	return nil
}
// LoadStrategy ...
type LoadStrategy interface {
	Load(*request.Request) (Envelope, error)
}
// S3LoadStrategy will load the instruction file from s3
type S3LoadStrategy struct {
	Client                *s3.S3
	InstructionFileSuffix string
}
// Load from a given instruction file suffix
func (load S3LoadStrategy) Load(req *request.Request) (Envelope, error) {
	env := Envelope{}
	if load.InstructionFileSuffix == """" {
		load.InstructionFileSuffix = DefaultInstructionKeySuffix
	}
	input := req.Params.(*s3.GetObjectInput)
	out, err := load.Client.GetObject(&s3.GetObjectInput{
		Key:    aws.String(strings.Join([]string{*input.Key, load.InstructionFileSuffix}, """")),
		Bucket: input.Bucket,
	})
	if err != nil {
		return env, err
	}
	b, err := ioutil.ReadAll(out.Body)
	if err != nil {
		return env, err
	}
	err = json.Unmarshal(b, &env)
	return env, err
}
// HeaderV2LoadStrategy will load the envelope from the metadata
type HeaderV2LoadStrategy struct{}
// Load from a given object's header
func (load HeaderV2LoadStrategy) Load(req *request.Request) (Envelope, error) {
	env := Envelope{}
	env.CipherKey = req.HTTPResponse.Header.Get(strings.Join([]string{metaHeader, keyV2Header}, ""-""))
	env.IV = req.HTTPResponse.Header.Get(strings.Join([]string{metaHeader, ivHeader}, ""-""))
	env.MatDesc = req.HTTPResponse.Header.Get(strings.Join([]string{metaHeader, matDescHeader}, ""-""))
	env.WrapAlg = req.HTTPResponse.Header.Get(strings.Join([]string{metaHeader, wrapAlgorithmHeader}, ""-""))
	env.CEKAlg = req.HTTPResponse.Header.Get(strings.Join([]string{metaHeader, cekAlgorithmHeader}, ""-""))
	env.TagLen = req.HTTPResponse.Header.Get(strings.Join([]string{metaHeader, tagLengthHeader}, ""-""))
	env.UnencryptedMD5 = req.HTTPResponse.Header.Get(strings.Join([]string{metaHeader, unencryptedMD5Header}, ""-""))
	env.UnencryptedContentLen = req.HTTPResponse.Header.Get(strings.Join([]string{metaHeader, unencryptedContentLengthHeader}, ""-""))
	return env, nil
}
type defaultV2LoadStrategy struct {
	client *s3.S3
	suffix string
}
func (load defaultV2LoadStrategy) Load(req *request.Request) (Envelope, error) {
	if value := req.HTTPResponse.Header.Get(strings.Join([]string{metaHeader, keyV2Header}, ""-"")); value != """" {
		strat := HeaderV2LoadStrategy{}
		return strat.Load(req)
	} else if value = req.HTTPResponse.Header.Get(strings.Join([]string{metaHeader, keyV1Header}, ""-"")); value != """" {
		return Envelope{}, awserr.New(""V1NotSupportedError"", ""The AWS SDK for Go does not support version 1"", nil)
	}
	strat := S3LoadStrategy{
		Client:                load.client,
		InstructionFileSuffix: load.suffix,
	}
	return strat.Load(req)
}
",CWE-326,146.0,1
"package s3crypto_test
import (
	""reflect""
	""testing""
	""github.com/aws/aws-sdk-go/aws""
	""github.com/aws/aws-sdk-go/aws/request""
	""github.com/aws/aws-sdk-go/service/s3""
	""github.com/aws/aws-sdk-go/service/s3/s3crypto""
)
func TestHeaderV2SaveStrategy(t *testing.T) {
	cases := []struct {
		env      s3crypto.Envelope
		expected map[string]*string
	}{
		{
			s3crypto.Envelope{
				CipherKey:             ""Foo"",
				IV:                    ""Bar"",
				MatDesc:               ""{}"",
				WrapAlg:               s3crypto.KMSWrap,
				CEKAlg:                s3crypto.AESGCMNoPadding,
				TagLen:                ""128"",
				UnencryptedMD5:        ""hello"",
				UnencryptedContentLen: ""0"",
			},
			map[string]*string{
				""X-Amz-Key-V2"":                     aws.String(""Foo""),
				""X-Amz-Iv"":                         aws.String(""Bar""),
				""X-Amz-Matdesc"":                    aws.String(""{}""),
				""X-Amz-Wrap-Alg"":                   aws.String(s3crypto.KMSWrap),
				""X-Amz-Cek-Alg"":                    aws.String(s3crypto.AESGCMNoPadding),
				""X-Amz-Tag-Len"":                    aws.String(""128""),
				""X-Amz-Unencrypted-Content-Md5"":    aws.String(""hello""),
				""X-Amz-Unencrypted-Content-Length"": aws.String(""0""),
			},
		},
		{
			s3crypto.Envelope{
				CipherKey:             ""Foo"",
				IV:                    ""Bar"",
				MatDesc:               ""{}"",
				WrapAlg:               s3crypto.KMSWrap,
				CEKAlg:                s3crypto.AESGCMNoPadding,
				UnencryptedMD5:        ""hello"",
				UnencryptedContentLen: ""0"",
			},
			map[string]*string{
				""X-Amz-Key-V2"":                     aws.String(""Foo""),
				""X-Amz-Iv"":                         aws.String(""Bar""),
				""X-Amz-Matdesc"":                    aws.String(""{}""),
				""X-Amz-Wrap-Alg"":                   aws.String(s3crypto.KMSWrap),
				""X-Amz-Cek-Alg"":                    aws.String(s3crypto.AESGCMNoPadding),
				""X-Amz-Unencrypted-Content-Md5"":    aws.String(""hello""),
				""X-Amz-Unencrypted-Content-Length"": aws.String(""0""),
			},
		},
	}
	for _, c := range cases {
		params := &s3.PutObjectInput{}
		req := &request.Request{
			Params: params,
		}
		strat := s3crypto.HeaderV2SaveStrategy{}
		err := strat.Save(c.env, req)
		if err != nil {
			t.Errorf(""expected no error, but received %v"", err)
		}
		if !reflect.DeepEqual(c.expected, params.Metadata) {
			t.Errorf(""expected %v, but received %v"", c.expected, params.Metadata)
		}
	}
}
",CWE-326,78.0,1
"package main
import (
	""flag""
	""log""
	""github.com/hoppscotch/proxyscotch/libproxy""
)
func main() {
	hostPtr := flag.String(""host"", ""localhost:9159"", ""the hostname that the server should listen on."")
	tokenPtr := flag.String(""token"", """", ""the Proxy Access Token used to restrict access to the server."")
	allowedOriginsPtr := flag.String(""allowed-origins"", ""*"", ""a comma separated list of allowed origins."")
	bannedOutputsPtr := flag.String(""banned-outputs"", """", ""a comma separated list of banned outputs."")
	flag.Parse()
	finished := make(chan bool)
	libproxy.Initialize(*tokenPtr, *hostPtr, *allowedOriginsPtr, *bannedOutputsPtr, onProxyStateChangeServer, false, finished)
	<-finished
}
func onProxyStateChangeServer(status string, isListening bool) {
	log.Printf(""[ready=%v] %s"", isListening, status)
}
",CWE-918,26.0,1
"package api
import (
	""encoding/json""
	""fmt""
)
type SystemSettingName string
const (
	// SystemSettingAllowSignUpName is the key type of allow signup setting.
	SystemSettingAllowSignUpName SystemSettingName = ""allowSignUp""
	// SystemSettingAdditionalStyleName is the key type of additional style.
	SystemSettingAdditionalStyleName SystemSettingName = ""additionalStyle""
	// SystemSettingAdditionalScriptName is the key type of additional script.
	SystemSettingAdditionalScriptName SystemSettingName = ""additionalScript""
	// SystemSettingCustomizedProfileName is the key type of customized server profile.
	SystemSettingCustomizedProfileName SystemSettingName = ""customizedProfile""
)
// CustomizedProfile is the struct definition for SystemSettingCustomizedProfileName system setting item.
type CustomizedProfile struct {
	// Name is the server name, default is `memos`
	Name string `json:""name""`
	// IconURL is the url of icon image.
	IconURL string `json:""iconUrl""`
	// ExternalURL is the external url of server. e.g. https://usermemos.com
	ExternalURL string `json:""externalUrl""`
}
func (key SystemSettingName) String() string {
	switch key {
	case SystemSettingAllowSignUpName:
		return ""allowSignUp""
	case SystemSettingAdditionalStyleName:
		return ""additionalStyle""
	case SystemSettingAdditionalScriptName:
		return ""additionalScript""
	case SystemSettingCustomizedProfileName:
		return ""customizedProfile""
	}
	return """"
}
var (
	SystemSettingAllowSignUpValue = []bool{true, false}
)
type SystemSetting struct {
	Name SystemSettingName
	// Value is a JSON string with basic value
	Value       string
	Description string
}
type SystemSettingUpsert struct {
	Name        SystemSettingName `json:""name""`
	Value       string            `json:""value""`
	Description string            `json:""description""`
}
func (upsert SystemSettingUpsert) Validate() error {
	if upsert.Name == SystemSettingAllowSignUpName {
		value := false
		err := json.Unmarshal([]byte(upsert.Value), &value)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal system setting allow signup value"")
		}
		invalid := true
		for _, v := range SystemSettingAllowSignUpValue {
			if value == v {
				invalid = false
				break
			}
		}
		if invalid {
			return fmt.Errorf(""invalid system setting allow signup value"")
		}
	} else if upsert.Name == SystemSettingAdditionalStyleName {
		value := """"
		err := json.Unmarshal([]byte(upsert.Value), &value)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal system setting additional style value"")
		}
	} else if upsert.Name == SystemSettingAdditionalScriptName {
		value := """"
		err := json.Unmarshal([]byte(upsert.Value), &value)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal system setting additional script value"")
		}
	} else if upsert.Name == SystemSettingCustomizedProfileName {
		value := CustomizedProfile{
			Name:        ""memos"",
			IconURL:     """",
			ExternalURL: """",
		}
		err := json.Unmarshal([]byte(upsert.Value), &value)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal system setting customized profile value"")
		}
	} else {
		return fmt.Errorf(""invalid system setting name"")
	}
	return nil
}
type SystemSettingFind struct {
	Name *SystemSettingName `json:""name""`
}
",CWE-311,112.0,1
"package api
import (
	""encoding/json""
	""fmt""
)
type UserSettingKey string
const (
	// UserSettingLocaleKey is the key type for user locale.
	UserSettingLocaleKey UserSettingKey = ""locale""
	// UserSettingAppearanceKey is the key type for user appearance.
	UserSettingAppearanceKey UserSettingKey = ""appearance""
	// UserSettingMemoVisibilityKey is the key type for user preference memo default visibility.
	UserSettingMemoVisibilityKey UserSettingKey = ""memoVisibility""
	// UserSettingMemoDisplayTsOptionKey is the key type for memo display ts option.
	UserSettingMemoDisplayTsOptionKey UserSettingKey = ""memoDisplayTsOption""
)
// String returns the string format of UserSettingKey type.
func (key UserSettingKey) String() string {
	switch key {
	case UserSettingLocaleKey:
		return ""locale""
	case UserSettingAppearanceKey:
		return ""appearance""
	case UserSettingMemoVisibilityKey:
		return ""memoVisibility""
	case UserSettingMemoDisplayTsOptionKey:
		return ""memoDisplayTsOption""
	}
	return """"
}
var (
	UserSettingLocaleValue                 = []string{""en"", ""zh"", ""vi"", ""fr"", ""nl"", ""sv"", ""de"", ""es""}
	UserSettingAppearanceValue             = []string{""system"", ""light"", ""dark""}
	UserSettingMemoVisibilityValue         = []Visibility{Private, Protected, Public}
	UserSettingMemoDisplayTsOptionKeyValue = []string{""created_ts"", ""updated_ts""}
)
type UserSetting struct {
	UserID int
	Key    UserSettingKey `json:""key""`
	// Value is a JSON string with basic value
	Value string `json:""value""`
}
type UserSettingUpsert struct {
	UserID int
	Key    UserSettingKey `json:""key""`
	Value  string         `json:""value""`
}
func (upsert UserSettingUpsert) Validate() error {
	if upsert.Key == UserSettingLocaleKey {
		localeValue := ""en""
		err := json.Unmarshal([]byte(upsert.Value), &localeValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting locale value"")
		}
		invalid := true
		for _, value := range UserSettingLocaleValue {
			if localeValue == value {
				invalid = false
				break
			}
		}
		if invalid {
			return fmt.Errorf(""invalid user setting locale value"")
		}
	} else if upsert.Key == UserSettingAppearanceKey {
		appearanceValue := ""light""
		err := json.Unmarshal([]byte(upsert.Value), &appearanceValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting appearance value"")
		}
		invalid := true
		for _, value := range UserSettingAppearanceValue {
			if appearanceValue == value {
				invalid = false
				break
			}
		}
		if invalid {
			return fmt.Errorf(""invalid user setting appearance value"")
		}
	} else if upsert.Key == UserSettingMemoVisibilityKey {
		memoVisibilityValue := Private
		err := json.Unmarshal([]byte(upsert.Value), &memoVisibilityValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting memo visibility value"")
		}
		invalid := true
		for _, value := range UserSettingMemoVisibilityValue {
			if memoVisibilityValue == value {
				invalid = false
				break
			}
		}
		if invalid {
			return fmt.Errorf(""invalid user setting memo visibility value"")
		}
	} else if upsert.Key == UserSettingMemoDisplayTsOptionKey {
		memoDisplayTsOption := ""created_ts""
		err := json.Unmarshal([]byte(upsert.Value), &memoDisplayTsOption)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting memo display ts option"")
		}
		invalid := true
		for _, value := range UserSettingMemoDisplayTsOptionKeyValue {
			if memoDisplayTsOption == value {
				invalid = false
				break
			}
		}
		if invalid {
			return fmt.Errorf(""invalid user setting memo display ts option value"")
		}
	} else {
		return fmt.Errorf(""invalid user setting key"")
	}
	return nil
}
type UserSettingFind struct {
	UserID int
	Key *UserSettingKey `json:""key""`
}
type UserSettingDelete struct {
	UserID int
}
",CWE-311,141.0,1
"module github.com/usememos/memos
go 1.19
require github.com/mattn/go-sqlite3 v1.14.9
require github.com/google/uuid v1.3.0
require (
	golang.org/x/crypto v0.0.0-20220722155217-630584e8d5aa
	golang.org/x/net v0.0.0-20220728030405-41545e8bf201
)
require github.com/labstack/echo/v4 v4.9.0
require (
	github.com/VictoriaMetrics/fastcache v1.10.0
	github.com/gorilla/feeds v1.1.1
	github.com/gorilla/securecookie v1.1.1
	github.com/gorilla/sessions v1.2.1
	github.com/labstack/echo-contrib v0.13.0
	github.com/stretchr/testify v1.8.1
)
require (
	github.com/bmizerany/assert v0.0.0-20160611221934-b7ed37b82869 // indirect
	github.com/cespare/xxhash/v2 v2.1.2 // indirect
	github.com/davecgh/go-spew v1.1.1 // indirect
	github.com/golang-jwt/jwt v3.2.2+incompatible // indirect
	github.com/golang/snappy v0.0.4 // indirect
	github.com/gorilla/context v1.1.1 // indirect
	github.com/kr/pretty v0.3.1 // indirect
	github.com/labstack/gommon v0.3.1 // indirect
	github.com/mattn/go-colorable v0.1.12 // indirect
	github.com/mattn/go-isatty v0.0.14 // indirect
	github.com/pmezard/go-difflib v1.0.0 // indirect
	github.com/segmentio/backo-go v1.0.1 // indirect
	github.com/valyala/bytebufferpool v1.0.0 // indirect
	github.com/valyala/fasttemplate v1.2.1 // indirect
	github.com/xtgo/uuid v0.0.0-20140804021211-a0b114877d4c // indirect
	golang.org/x/sys v0.0.0-20220728004956-3c1f35247d10 // indirect
	golang.org/x/text v0.3.7 // indirect
	golang.org/x/time v0.0.0-20220722155302-e5dcc9cfc0b9 // indirect
	gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
)
require github.com/segmentio/analytics-go v3.1.0+incompatible
",CWE-311,49.0,1
"github.com/VictoriaMetrics/fastcache v1.10.0 h1:5hDJnLsKLpnUEToub7ETuRu8RCkb40woBZAUiKonXzY=
github.com/VictoriaMetrics/fastcache v1.10.0/go.mod h1:tjiYeEfYXCqacuvYw/7UoDIeJaNxq6132xHICNP77w8=
github.com/allegro/bigcache v1.2.1-0.20190218064605-e24eb225f156 h1:eMwmnE/GDgah4HI848JfFxHt+iPb26b4zyfspmqY0/8=
github.com/allegro/bigcache v1.2.1-0.20190218064605-e24eb225f156/go.mod h1:Cb/ax3seSYIx7SuZdm2G2xzfwmv3TPSk2ucNfQESPXM=
github.com/bmizerany/assert v0.0.0-20160611221934-b7ed37b82869 h1:DDGfHa7BWjL4YnC6+E63dPcxHo2sUxDIu8g3QgEJdRY=
github.com/bmizerany/assert v0.0.0-20160611221934-b7ed37b82869/go.mod h1:Ekp36dRnpXw/yCqJaO+ZrUyxD+3VXMFFr56k5XYrpB4=
github.com/cespare/xxhash/v2 v2.1.2 h1:YRXhKfTDauu4ajMg1TPgFO5jnlC2HCbmLXMcTG5cbYE=
github.com/cespare/xxhash/v2 v2.1.2/go.mod h1:VGX0DQ3Q6kWi7AoAeZDth3/j3BFtOZR5XLFGgcrjCOs=
github.com/creack/pty v1.1.9/go.mod h1:oKZEueFk5CKHvIhNR5MUki03XCEU+Q6VDXinZuGJ33E=
github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/golang-jwt/jwt v3.2.2+incompatible h1:IfV12K8xAKAnZqdXVzCZ+TOjboZ2keLg81eXfW3O+oY=
github.com/golang-jwt/jwt v3.2.2+incompatible/go.mod h1:8pz2t5EyA70fFQQSrl6XZXzqecmYZeUEB8OUGHkxJ+I=
github.com/golang/snappy v0.0.4 h1:yAGX7huGHXlcLOEtBnF4w7FQwA26wojNCwOYAEhLjQM=
github.com/golang/snappy v0.0.4/go.mod h1:/XxbfmMg8lxefKM7IXC3fBNl/7bRcc72aCRzEWrmP2Q=
github.com/google/uuid v1.3.0 h1:t6JiXgmwXMjEs8VusXIJk2BXHsn+wx8BZdTaoZ5fu7I=
github.com/google/uuid v1.3.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
github.com/gorilla/context v1.1.1 h1:AWwleXJkX/nhcU9bZSnZoi3h/qGYqQAGhq6zZe/aQW8=
github.com/gorilla/context v1.1.1/go.mod h1:kBGZzfjB9CEq2AlWe17Uuf7NDRt0dE0s8S51q0aT7Yg=
github.com/gorilla/feeds v1.1.1 h1:HwKXxqzcRNg9to+BbvJog4+f3s/xzvtZXICcQGutYfY=
github.com/gorilla/feeds v1.1.1/go.mod h1:Nk0jZrvPFZX1OBe5NPiddPw7CfwF6Q9eqzaBbaightA=
github.com/gorilla/securecookie v1.1.1 h1:miw7JPhV+b/lAHSXz4qd/nN9jRiAFV5FwjeKyCS8BvQ=
github.com/gorilla/securecookie v1.1.1/go.mod h1:ra0sb63/xPlUeL+yeDciTfxMRAA+MP+HVt/4epWDjd4=
github.com/gorilla/sessions v1.2.1 h1:DHd3rPN5lE3Ts3D8rKkQ8x/0kqfeNmBAaiSi+o7FsgI=
github.com/gorilla/sessions v1.2.1/go.mod h1:dk2InVEVJ0sfLlnXv9EAgkf6ecYs/i80K/zI+bUmuGM=
github.com/kr/pretty v0.2.1/go.mod h1:ipq/a2n7PKx3OHsz4KJII5eveXtPO4qwEXGdVfWzfnI=
github.com/kr/pretty v0.3.1 h1:flRD4NNwYAUpkphVc1HcthR4KEIFJ65n8Mw5qdRn3LE=
github.com/kr/pretty v0.3.1/go.mod h1:hoEshYVHaxMs3cyo3Yncou5ZscifuDolrwPKZanG3xk=
github.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=
github.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=
github.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=
github.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=
github.com/labstack/echo-contrib v0.13.0 h1:bzSG0SpuZZd7BmJLvsWtPfU23W0Enh3K0tok3aENVKA=
github.com/labstack/echo-contrib v0.13.0/go.mod h1:IF9+MJu22ADOZEHD+bAV67XMIO3vNXUy7Naz/ABPHEs=
github.com/labstack/echo/v4 v4.9.0 h1:wPOF1CE6gvt/kmbMR4dGzWvHMPT+sAEUJOwOTtvITVY=
github.com/labstack/echo/v4 v4.9.0/go.mod h1:xkCDAdFCIf8jsFQ5NnbK7oqaF/yU1A1X20Ltm0OvSks=
github.com/labstack/gommon v0.3.1 h1:OomWaJXm7xR6L1HmEtGyQf26TEn7V6X88mktX9kee9o=
github.com/labstack/gommon v0.3.1/go.mod h1:uW6kP17uPlLJsD3ijUYn3/M5bAxtlZhMI6m3MFxTMTM=
github.com/mattn/go-colorable v0.1.11/go.mod h1:u5H1YNBxpqRaxsYJYSkiCWKzEfiAb1Gb520KVy5xxl4=
github.com/mattn/go-colorable v0.1.12 h1:jF+Du6AlPIjs2BiUiQlKOX0rt3SujHxPnksPKZbaA40=
github.com/mattn/go-colorable v0.1.12/go.mod h1:u5H1YNBxpqRaxsYJYSkiCWKzEfiAb1Gb520KVy5xxl4=
github.com/mattn/go-isatty v0.0.14 h1:yVuAays6BHfxijgZPzw+3Zlu5yQgKGP2/hcQbHb7S9Y=
github.com/mattn/go-isatty v0.0.14/go.mod h1:7GGIvUiUoEMVVmxf/4nioHXj79iQHKdU27kJ6hsGG94=
github.com/mattn/go-sqlite3 v1.14.9 h1:10HX2Td0ocZpYEjhilsuo6WWtUqttj2Kb0KtD86/KYA=
github.com/mattn/go-sqlite3 v1.14.9/go.mod h1:NyWgC/yNuGj7Q9rpYnZvas74GogHl5/Z4A/KQRfk6bU=
github.com/pkg/diff v0.0.0-20210226163009-20ebb0f2a09e/go.mod h1:pJLUxLENpZxwdsKMEsNbx1VGcRFpLqf3715MtcvvzbA=
github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/rogpeppe/go-internal v1.9.0 h1:73kH8U+JUqXU8lRuOHeVHaa/SZPifC7BkcraZVejAe8=
github.com/rogpeppe/go-internal v1.9.0/go.mod h1:WtVeX8xhTBvf0smdhujwtBcq4Qrzq/fJaraNFVN+nFs=
github.com/segmentio/analytics-go v3.1.0+incompatible h1:IyiOfUgQFVHvsykKKbdI7ZsH374uv3/DfZUo9+G0Z80=
github.com/segmentio/analytics-go v3.1.0+incompatible/go.mod h1:C7CYBtQWk4vRk2RyLu0qOcbHJ18E3F1HV2C/8JvKN48=
github.com/segmentio/backo-go v1.0.1 h1:68RQccglxZeyURy93ASB/2kc9QudzgIDexJ927N++y4=
github.com/segmentio/backo-go v1.0.1/go.mod h1:9/Rh6yILuLysoQnZ2oNooD2g7aBnvM7r/fNVxRNWfBc=
github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
github.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=
github.com/stretchr/objx v0.5.0/go.mod h1:Yh+to48EsGEfYuaHDzXPcE3xhTkx73EhmCGUpEOglKo=
github.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=
github.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=
github.com/stretchr/testify v1.8.1 h1:w7B6lhMri9wdJUVmEZPGGhZzrYTPvgJArz7wNPgYKsk=
github.com/stretchr/testify v1.8.1/go.mod h1:w2LPCIKwWwSfY2zedu0+kehJoqGctiVI29o6fzry7u4=
github.com/valyala/bytebufferpool v1.0.0 h1:GqA5TC/0021Y/b9FG4Oi9Mr3q7XYx6KllzawFIhcdPw=
github.com/valyala/bytebufferpool v1.0.0/go.mod h1:6bBcMArwyJ5K/AmCkWv1jt77kVWyCJ6HpOuEn7z0Csc=
github.com/valyala/fasttemplate v1.2.1 h1:TVEnxayobAdVkhQfrfes2IzOB6o+z4roRkPF52WA1u4=
github.com/valyala/fasttemplate v1.2.1/go.mod h1:KHLXt3tVN2HBp8eijSv/kGJopbvo7S+qRAEEKiv+SiQ=
github.com/xtgo/uuid v0.0.0-20140804021211-a0b114877d4c h1:3lbZUMbMiGUW/LMkfsEABsc5zNT9+b1CvsJx47JzJ8g=
github.com/xtgo/uuid v0.0.0-20140804021211-a0b114877d4c/go.mod h1:UrdRz5enIKZ63MEE3IF9l2/ebyx59GyGgPi+tICQdmM=
golang.org/x/crypto v0.0.0-20220722155217-630584e8d5aa h1:zuSxTR4o9y82ebqCUJYNGJbGPo6sKVl54f/TVDObg1c=
golang.org/x/crypto v0.0.0-20220722155217-630584e8d5aa/go.mod h1:IxCIyHEi3zRg3s0A5j5BB6A9Jmi73HwBIUl50j+osU4=
golang.org/x/net v0.0.0-20220728030405-41545e8bf201 h1:bvOltf3SADAfG05iRml8lAB3qjoEX5RCyN4K6G5v3N0=
golang.org/x/net v0.0.0-20220728030405-41545e8bf201/go.mod h1:YDH+HFinaLZZlnHAfSS6ZXJJ9M9t4Dl22yv3iI2vPwk=
golang.org/x/sys v0.0.0-20210630005230-0f9fa26af87c/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20210927094055-39ccf1dd6fa6/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20211103235746-7861aae1554b/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220405052023-b1e9470b6e64/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220728004956-3c1f35247d10 h1:WIoqL4EROvwiPdUtaip4VcDdpZ4kha7wBWZrbVKCIZg=
golang.org/x/sys v0.0.0-20220728004956-3c1f35247d10/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/text v0.3.7 h1:olpwvP2KacW1ZWvsR7uQhoyTYvKAupfQrRGBFM352Gk=
golang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=
golang.org/x/time v0.0.0-20220722155302-e5dcc9cfc0b9 h1:ftMN5LMiBFjbzleLqtoBZk7KdJwhuybIU+FckUHgoyQ=
golang.org/x/time v0.0.0-20220722155302-e5dcc9cfc0b9/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c h1:Hei/4ADfdWqJk1ZMxUNpqntNwaWcugrBjAiHlqqRiVk=
gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c/go.mod h1:JHkPIbrfpd72SG/EVd6muEfDQjcINNoR0C8j2r3qZ4Q=
gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
gopkg.in/yaml.v3 v3.0.0-20210107192922-496545a6307b/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
",CWE-311,92.0,1
"package server
import (
	""fmt""
	""net/http""
	""strconv""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	""github.com/gorilla/sessions""
	""github.com/labstack/echo-contrib/session""
	""github.com/labstack/echo/v4""
)
var (
	userIDContextKey = ""user-id""
)
func getUserIDContextKey() string {
	return userIDContextKey
}
func setUserSession(ctx echo.Context, user *api.User) error {
	sess, _ := session.Get(""memos_session"", ctx)
	sess.Options = &sessions.Options{
		Path:     ""/"",
		MaxAge:   3600 * 24 * 30,
		HttpOnly: true,
	}
	sess.Values[userIDContextKey] = user.ID
	err := sess.Save(ctx.Request(), ctx.Response())
	if err != nil {
		return fmt.Errorf(""failed to set session, err: %w"", err)
	}
	return nil
}
func removeUserSession(ctx echo.Context) error {
	sess, _ := session.Get(""memos_session"", ctx)
	sess.Options = &sessions.Options{
		Path:     ""/"",
		MaxAge:   0,
		HttpOnly: true,
	}
	sess.Values[userIDContextKey] = nil
	err := sess.Save(ctx.Request(), ctx.Response())
	if err != nil {
		return fmt.Errorf(""failed to set session, err: %w"", err)
	}
	return nil
}
func aclMiddleware(s *Server, next echo.HandlerFunc) echo.HandlerFunc {
	return func(c echo.Context) error {
		ctx := c.Request().Context()
		path := c.Path()
		// Skip auth.
		if common.HasPrefixes(path, ""/api/auth"") {
			return next(c)
		}
		{
			// If there is openId in query string and related user is found, then skip auth.
			openID := c.QueryParam(""openId"")
			if openID != """" {
				userFind := &api.UserFind{
					OpenID: &openID,
				}
				user, err := s.Store.FindUser(ctx, userFind)
				if err != nil && common.ErrorCode(err) != common.NotFound {
					return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find user by open_id"").SetInternal(err)
				}
				if user != nil {
					// Stores userID into context.
					c.Set(getUserIDContextKey(), user.ID)
					return next(c)
				}
			}
		}
		{
			sess, _ := session.Get(""memos_session"", c)
			userIDValue := sess.Values[userIDContextKey]
			if userIDValue != nil {
				userID, _ := strconv.Atoi(fmt.Sprintf(""%v"", userIDValue))
				userFind := &api.UserFind{
					ID: &userID,
				}
				user, err := s.Store.FindUser(ctx, userFind)
				if err != nil && common.ErrorCode(err) != common.NotFound {
					return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to find user by ID: %d"", userID)).SetInternal(err)
				}
				if user != nil {
					if user.RowStatus == api.Archived {
						return echo.NewHTTPError(http.StatusForbidden, fmt.Sprintf(""User has been archived with username %s"", user.Username))
					}
					c.Set(getUserIDContextKey(), userID)
				}
			}
		}
		if common.HasPrefixes(path, ""/api/ping"", ""/api/status"", ""/api/user/:id"", ""/api/memo/all"", ""/api/memo/:memoId"", ""/api/memo/amount"") && c.Request().Method == http.MethodGet {
			return next(c)
		}
		if common.HasPrefixes(path, ""/api/memo"", ""/api/tag"", ""/api/shortcut"") && c.Request().Method == http.MethodGet {
			if _, err := strconv.Atoi(c.QueryParam(""creatorId"")); err == nil {
				return next(c)
			}
		}
		userID := c.Get(getUserIDContextKey())
		if userID == nil {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		return next(c)
	}
}
",CWE-311,122.0,1
"package server
import (
	""encoding/json""
	""net/http""
	""os""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
)
func (s *Server) registerSystemRoutes(g *echo.Group) {
	g.GET(""/ping"", func(c echo.Context) error {
		data := s.Profile
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(data)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to compose system profile"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/status"", func(c echo.Context) error {
		ctx := c.Request().Context()
		hostUserType := api.Host
		hostUserFind := api.UserFind{
			Role: &hostUserType,
		}
		hostUser, err := s.Store.FindUser(ctx, &hostUserFind)
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find host user"").SetInternal(err)
		}
		if hostUser != nil {
			// data desensitize
			hostUser.OpenID = """"
		}
		systemStatus := api.SystemStatus{
			Host:             hostUser,
			Profile:          *s.Profile,
			DBSize:           0,
			AllowSignUp:      false,
			AdditionalStyle:  """",
			AdditionalScript: """",
			CustomizedProfile: api.CustomizedProfile{
				Name: ""memos"",
			},
		}
		systemSettingList, err := s.Store.FindSystemSettingList(ctx, &api.SystemSettingFind{})
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find system setting list"").SetInternal(err)
		}
		for _, systemSetting := range systemSettingList {
			var value interface{}
			err := json.Unmarshal([]byte(systemSetting.Value), &value)
			if err != nil {
				return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to unmarshal system setting"").SetInternal(err)
			}
			if systemSetting.Name == api.SystemSettingAllowSignUpName {
				systemStatus.AllowSignUp = value.(bool)
			} else if systemSetting.Name == api.SystemSettingAdditionalStyleName {
				systemStatus.AdditionalStyle = value.(string)
			} else if systemSetting.Name == api.SystemSettingAdditionalScriptName {
				systemStatus.AdditionalScript = value.(string)
			} else if systemSetting.Name == api.SystemSettingCustomizedProfileName {
				valueMap := value.(map[string]interface{})
				systemStatus.CustomizedProfile = api.CustomizedProfile{
					Name:        valueMap[""name""].(string),
					IconURL:     valueMap[""iconUrl""].(string),
					ExternalURL: valueMap[""externalUrl""].(string),
				}
			}
		}
		userID, ok := c.Get(getUserIDContextKey()).(int)
		// Get database size for host user.
		if ok {
			user, err := s.Store.FindUser(ctx, &api.UserFind{
				ID: &userID,
			})
			if err != nil {
				return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find user"").SetInternal(err)
			}
			if user != nil && user.Role == api.Host {
				fi, err := os.Stat(s.Profile.DSN)
				if err != nil {
					return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to read database fileinfo"").SetInternal(err)
				}
				systemStatus.DBSize = fi.Size()
			}
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(systemStatus)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode system status response"").SetInternal(err)
		}
		return nil
	})
	g.POST(""/system/setting"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		user, err := s.Store.FindUser(ctx, &api.UserFind{
			ID: &userID,
		})
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find user"").SetInternal(err)
		}
		if user == nil {
			return echo.NewHTTPError(http.StatusNotFound, ""Current signin user not found"")
		} else if user.Role != api.Host {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Unauthorized"")
		}
		systemSettingUpsert := &api.SystemSettingUpsert{}
		if err := json.NewDecoder(c.Request().Body).Decode(systemSettingUpsert); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted post system setting request"").SetInternal(err)
		}
		if err := systemSettingUpsert.Validate(); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""system setting invalidate"").SetInternal(err)
		}
		systemSetting, err := s.Store.UpsertSystemSetting(ctx, systemSettingUpsert)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to upsert system setting"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name:   ""systemSetting updated"",
			Labels: map[string]string{""field"": string(systemSettingUpsert.Name)},
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(systemSetting)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode system setting response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/system/setting"", func(c echo.Context) error {
		ctx := c.Request().Context()
		systemSettingList, err := s.Store.FindSystemSettingList(ctx, &api.SystemSettingFind{})
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find system setting list"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(systemSettingList)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode system setting list response"").SetInternal(err)
		}
		return nil
	})
	g.POST(""/system/vacuum"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		user, err := s.Store.FindUser(ctx, &api.UserFind{
			ID: &userID,
		})
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find user"").SetInternal(err)
		}
		if user == nil || user.Role != api.Host {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Unauthorized"")
		}
		if err := s.Store.Vacuum(ctx); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to vacuum database"").SetInternal(err)
		}
		c.Response().WriteHeader(http.StatusOK)
		return nil
	})
}
",CWE-311,185.0,1
"package api
// Visibility is the type of a visibility.
type Visibility string
const (
	// Public is the PUBLIC visibility.
	Public Visibility = ""PUBLIC""
	// Protected is the PROTECTED visibility.
	Protected Visibility = ""PROTECTED""
	// Private is the PRIVATE visibility.
	Private Visibility = ""PRIVATE""
)
func (e Visibility) String() string {
	switch e {
	case Public:
		return ""PUBLIC""
	case Protected:
		return ""PROTECTED""
	case Private:
		return ""PRIVATE""
	}
	return ""PRIVATE""
}
type Memo struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatorID int       `json:""creatorId""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Content    string     `json:""content""`
	Visibility Visibility `json:""visibility""`
	Pinned     bool       `json:""pinned""`
	DisplayTs  int64      `json:""displayTs""`
	// Related fields
	Creator      *User       `json:""creator""`
	ResourceList []*Resource `json:""resourceList""`
}
type MemoCreate struct {
	// Standard fields
	CreatorID int
	// Domain specific fields
	Visibility Visibility `json:""visibility""`
	Content    string     `json:""content""`
	// Related fields
	ResourceIDList []int `json:""resourceIdList""`
}
type MemoPatch struct {
	ID int
	// Standard fields
	CreatedTs *int64 `json:""createdTs""`
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Content    *string     `json:""content""`
	Visibility *Visibility `json:""visibility""`
	// Related fields
	ResourceIDList []int `json:""resourceIdList""`
}
type MemoFind struct {
	ID *int `json:""id""`
	// Standard fields
	RowStatus *RowStatus `json:""rowStatus""`
	CreatorID *int       `json:""creatorId""`
	// Domain specific fields
	Pinned         *bool
	ContentSearch  *string
	VisibilityList []Visibility
	// Pagination
	Limit  int
	Offset int
}
type MemoDelete struct {
	ID int
}
",CWE-284,95.0,1
"package api
// Visibility is the type of a visibility.
type Visibility string
const (
	// Public is the PUBLIC visibility.
	Public Visibility = ""PUBLIC""
	// Protected is the PROTECTED visibility.
	Protected Visibility = ""PROTECTED""
	// Private is the PRIVATE visibility.
	Private Visibility = ""PRIVATE""
)
func (e Visibility) String() string {
	switch e {
	case Public:
		return ""PUBLIC""
	case Protected:
		return ""PROTECTED""
	case Private:
		return ""PRIVATE""
	}
	return ""PRIVATE""
}
type Memo struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatorID int       `json:""creatorId""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Content    string     `json:""content""`
	Visibility Visibility `json:""visibility""`
	Pinned     bool       `json:""pinned""`
	DisplayTs  int64      `json:""displayTs""`
	// Related fields
	Creator      *User       `json:""creator""`
	ResourceList []*Resource `json:""resourceList""`
}
type MemoCreate struct {
	// Standard fields
	CreatorID int
	// Domain specific fields
	Visibility Visibility `json:""visibility""`
	Content    string     `json:""content""`
	// Related fields
	ResourceIDList []int `json:""resourceIdList""`
}
type MemoPatch struct {
	ID int
	// Standard fields
	CreatedTs *int64 `json:""createdTs""`
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Content    *string     `json:""content""`
	Visibility *Visibility `json:""visibility""`
	// Related fields
	ResourceIDList []int `json:""resourceIdList""`
}
type MemoFind struct {
	ID *int `json:""id""`
	// Standard fields
	RowStatus *RowStatus `json:""rowStatus""`
	CreatorID *int       `json:""creatorId""`
	// Domain specific fields
	Pinned         *bool
	ContentSearch  *string
	VisibilityList []Visibility
	// Pagination
	Limit  int
	Offset int
}
type MemoDelete struct {
	ID int
}
",CWE-639,95.0,1
"package api
// Visibility is the type of a visibility.
type Visibility string
const (
	// Public is the PUBLIC visibility.
	Public Visibility = ""PUBLIC""
	// Protected is the PROTECTED visibility.
	Protected Visibility = ""PROTECTED""
	// Private is the PRIVATE visibility.
	Private Visibility = ""PRIVATE""
)
func (e Visibility) String() string {
	switch e {
	case Public:
		return ""PUBLIC""
	case Protected:
		return ""PROTECTED""
	case Private:
		return ""PRIVATE""
	}
	return ""PRIVATE""
}
type Memo struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatorID int       `json:""creatorId""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Content    string     `json:""content""`
	Visibility Visibility `json:""visibility""`
	Pinned     bool       `json:""pinned""`
	DisplayTs  int64      `json:""displayTs""`
	// Related fields
	Creator      *User       `json:""creator""`
	ResourceList []*Resource `json:""resourceList""`
}
type MemoCreate struct {
	// Standard fields
	CreatorID int
	// Domain specific fields
	Visibility Visibility `json:""visibility""`
	Content    string     `json:""content""`
	// Related fields
	ResourceIDList []int `json:""resourceIdList""`
}
type MemoPatch struct {
	ID int
	// Standard fields
	CreatedTs *int64 `json:""createdTs""`
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Content    *string     `json:""content""`
	Visibility *Visibility `json:""visibility""`
	// Related fields
	ResourceIDList []int `json:""resourceIdList""`
}
type MemoFind struct {
	ID *int `json:""id""`
	// Standard fields
	RowStatus *RowStatus `json:""rowStatus""`
	CreatorID *int       `json:""creatorId""`
	// Domain specific fields
	Pinned         *bool
	ContentSearch  *string
	VisibilityList []Visibility
	// Pagination
	Limit  int
	Offset int
}
type MemoDelete struct {
	ID int
}
",CWE-269,95.0,1
"package api
// Visibility is the type of a visibility.
type Visibility string
const (
	// Public is the PUBLIC visibility.
	Public Visibility = ""PUBLIC""
	// Protected is the PROTECTED visibility.
	Protected Visibility = ""PROTECTED""
	// Private is the PRIVATE visibility.
	Private Visibility = ""PRIVATE""
)
func (e Visibility) String() string {
	switch e {
	case Public:
		return ""PUBLIC""
	case Protected:
		return ""PROTECTED""
	case Private:
		return ""PRIVATE""
	}
	return ""PRIVATE""
}
type Memo struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatorID int       `json:""creatorId""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Content    string     `json:""content""`
	Visibility Visibility `json:""visibility""`
	Pinned     bool       `json:""pinned""`
	DisplayTs  int64      `json:""displayTs""`
	// Related fields
	Creator      *User       `json:""creator""`
	ResourceList []*Resource `json:""resourceList""`
}
type MemoCreate struct {
	// Standard fields
	CreatorID int
	// Domain specific fields
	Visibility Visibility `json:""visibility""`
	Content    string     `json:""content""`
	// Related fields
	ResourceIDList []int `json:""resourceIdList""`
}
type MemoPatch struct {
	ID int
	// Standard fields
	CreatedTs *int64 `json:""createdTs""`
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Content    *string     `json:""content""`
	Visibility *Visibility `json:""visibility""`
	// Related fields
	ResourceIDList []int `json:""resourceIdList""`
}
type MemoFind struct {
	ID *int `json:""id""`
	// Standard fields
	RowStatus *RowStatus `json:""rowStatus""`
	CreatorID *int       `json:""creatorId""`
	// Domain specific fields
	Pinned         *bool
	ContentSearch  *string
	VisibilityList []Visibility
	// Pagination
	Limit  int
	Offset int
}
type MemoDelete struct {
	ID int
}
",CWE-285,95.0,1
"package api
type Resource struct {
	ID int `json:""id""`
	// Standard fields
	CreatorID int   `json:""creatorId""`
	CreatedTs int64 `json:""createdTs""`
	UpdatedTs int64 `json:""updatedTs""`
	// Domain specific fields
	Filename string `json:""filename""`
	Blob     []byte `json:""-""`
	Type     string `json:""type""`
	Size     int64  `json:""size""`
	// Related fields
	LinkedMemoAmount int `json:""linkedMemoAmount""`
}
type ResourceCreate struct {
	// Standard fields
	CreatorID int
	// Domain specific fields
	Filename string `json:""filename""`
	Blob     []byte `json:""blob""`
	Type     string `json:""type""`
	Size     int64  `json:""size""`
}
type ResourceFind struct {
	ID *int `json:""id""`
	// Standard fields
	CreatorID *int `json:""creatorId""`
	// Domain specific fields
	Filename *string `json:""filename""`
	MemoID   *int
}
type ResourcePatch struct {
	ID int
	// Standard fields
	UpdatedTs *int64
	// Domain specific fields
	Filename *string `json:""filename""`
}
type ResourceDelete struct {
	ID int
}
",CWE-284,56.0,1
"package api
type Resource struct {
	ID int `json:""id""`
	// Standard fields
	CreatorID int   `json:""creatorId""`
	CreatedTs int64 `json:""createdTs""`
	UpdatedTs int64 `json:""updatedTs""`
	// Domain specific fields
	Filename string `json:""filename""`
	Blob     []byte `json:""-""`
	Type     string `json:""type""`
	Size     int64  `json:""size""`
	// Related fields
	LinkedMemoAmount int `json:""linkedMemoAmount""`
}
type ResourceCreate struct {
	// Standard fields
	CreatorID int
	// Domain specific fields
	Filename string `json:""filename""`
	Blob     []byte `json:""blob""`
	Type     string `json:""type""`
	Size     int64  `json:""size""`
}
type ResourceFind struct {
	ID *int `json:""id""`
	// Standard fields
	CreatorID *int `json:""creatorId""`
	// Domain specific fields
	Filename *string `json:""filename""`
	MemoID   *int
}
type ResourcePatch struct {
	ID int
	// Standard fields
	UpdatedTs *int64
	// Domain specific fields
	Filename *string `json:""filename""`
}
type ResourceDelete struct {
	ID int
}
",CWE-639,56.0,1
"package api
type Resource struct {
	ID int `json:""id""`
	// Standard fields
	CreatorID int   `json:""creatorId""`
	CreatedTs int64 `json:""createdTs""`
	UpdatedTs int64 `json:""updatedTs""`
	// Domain specific fields
	Filename string `json:""filename""`
	Blob     []byte `json:""-""`
	Type     string `json:""type""`
	Size     int64  `json:""size""`
	// Related fields
	LinkedMemoAmount int `json:""linkedMemoAmount""`
}
type ResourceCreate struct {
	// Standard fields
	CreatorID int
	// Domain specific fields
	Filename string `json:""filename""`
	Blob     []byte `json:""blob""`
	Type     string `json:""type""`
	Size     int64  `json:""size""`
}
type ResourceFind struct {
	ID *int `json:""id""`
	// Standard fields
	CreatorID *int `json:""creatorId""`
	// Domain specific fields
	Filename *string `json:""filename""`
	MemoID   *int
}
type ResourcePatch struct {
	ID int
	// Standard fields
	UpdatedTs *int64
	// Domain specific fields
	Filename *string `json:""filename""`
}
type ResourceDelete struct {
	ID int
}
",CWE-269,56.0,1
"package api
type Resource struct {
	ID int `json:""id""`
	// Standard fields
	CreatorID int   `json:""creatorId""`
	CreatedTs int64 `json:""createdTs""`
	UpdatedTs int64 `json:""updatedTs""`
	// Domain specific fields
	Filename string `json:""filename""`
	Blob     []byte `json:""-""`
	Type     string `json:""type""`
	Size     int64  `json:""size""`
	// Related fields
	LinkedMemoAmount int `json:""linkedMemoAmount""`
}
type ResourceCreate struct {
	// Standard fields
	CreatorID int
	// Domain specific fields
	Filename string `json:""filename""`
	Blob     []byte `json:""blob""`
	Type     string `json:""type""`
	Size     int64  `json:""size""`
}
type ResourceFind struct {
	ID *int `json:""id""`
	// Standard fields
	CreatorID *int `json:""creatorId""`
	// Domain specific fields
	Filename *string `json:""filename""`
	MemoID   *int
}
type ResourcePatch struct {
	ID int
	// Standard fields
	UpdatedTs *int64
	// Domain specific fields
	Filename *string `json:""filename""`
}
type ResourceDelete struct {
	ID int
}
",CWE-285,56.0,1
"package api
type Shortcut struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatorID int       `json:""creatorId""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Title   string `json:""title""`
	Payload string `json:""payload""`
}
type ShortcutCreate struct {
	// Standard fields
	CreatorID int
	// Domain specific fields
	Title   string `json:""title""`
	Payload string `json:""payload""`
}
type ShortcutPatch struct {
	ID int
	// Standard fields
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Title   *string `json:""title""`
	Payload *string `json:""payload""`
}
type ShortcutFind struct {
	ID *int
	// Standard fields
	CreatorID *int
	// Domain specific fields
	Title *string `json:""title""`
}
type ShortcutDelete struct {
	ID *int
	// Standard fields
	CreatorID *int
}
",CWE-284,54.0,1
"package api
type Shortcut struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatorID int       `json:""creatorId""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Title   string `json:""title""`
	Payload string `json:""payload""`
}
type ShortcutCreate struct {
	// Standard fields
	CreatorID int
	// Domain specific fields
	Title   string `json:""title""`
	Payload string `json:""payload""`
}
type ShortcutPatch struct {
	ID int
	// Standard fields
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Title   *string `json:""title""`
	Payload *string `json:""payload""`
}
type ShortcutFind struct {
	ID *int
	// Standard fields
	CreatorID *int
	// Domain specific fields
	Title *string `json:""title""`
}
type ShortcutDelete struct {
	ID *int
	// Standard fields
	CreatorID *int
}
",CWE-639,54.0,1
"package api
type Shortcut struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatorID int       `json:""creatorId""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Title   string `json:""title""`
	Payload string `json:""payload""`
}
type ShortcutCreate struct {
	// Standard fields
	CreatorID int
	// Domain specific fields
	Title   string `json:""title""`
	Payload string `json:""payload""`
}
type ShortcutPatch struct {
	ID int
	// Standard fields
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Title   *string `json:""title""`
	Payload *string `json:""payload""`
}
type ShortcutFind struct {
	ID *int
	// Standard fields
	CreatorID *int
	// Domain specific fields
	Title *string `json:""title""`
}
type ShortcutDelete struct {
	ID *int
	// Standard fields
	CreatorID *int
}
",CWE-269,54.0,1
"package api
type Shortcut struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatorID int       `json:""creatorId""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Title   string `json:""title""`
	Payload string `json:""payload""`
}
type ShortcutCreate struct {
	// Standard fields
	CreatorID int
	// Domain specific fields
	Title   string `json:""title""`
	Payload string `json:""payload""`
}
type ShortcutPatch struct {
	ID int
	// Standard fields
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Title   *string `json:""title""`
	Payload *string `json:""payload""`
}
type ShortcutFind struct {
	ID *int
	// Standard fields
	CreatorID *int
	// Domain specific fields
	Title *string `json:""title""`
}
type ShortcutDelete struct {
	ID *int
	// Standard fields
	CreatorID *int
}
",CWE-285,54.0,1
"package api
import (
	""fmt""
)
// Role is the type of a role.
type Role string
const (
	// Host is the HOST role.
	Host Role = ""HOST""
	// Admin is the ADMIN role.
	Admin Role = ""ADMIN""
	// NormalUser is the USER role.
	NormalUser Role = ""USER""
)
func (e Role) String() string {
	switch e {
	case Host:
		return ""HOST""
	case Admin:
		return ""ADMIN""
	case NormalUser:
		return ""USER""
	}
	return ""USER""
}
type User struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Username        string         `json:""username""`
	Role            Role           `json:""role""`
	Email           string         `json:""email""`
	Nickname        string         `json:""nickname""`
	PasswordHash    string         `json:""-""`
	OpenID          string         `json:""openId""`
	UserSettingList []*UserSetting `json:""userSettingList""`
}
type UserCreate struct {
	// Domain specific fields
	Username     string `json:""username""`
	Role         Role   `json:""role""`
	Email        string `json:""email""`
	Nickname     string `json:""nickname""`
	Password     string `json:""password""`
	PasswordHash string
	OpenID       string
}
func (create UserCreate) Validate() error {
	if len(create.Username) < 4 {
		return fmt.Errorf(""username is too short, minimum length is 4"")
	}
	if len(create.Password) < 4 {
		return fmt.Errorf(""password is too short, minimum length is 4"")
	}
	return nil
}
type UserPatch struct {
	ID int
	// Standard fields
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Username     *string `json:""username""`
	Email        *string `json:""email""`
	Nickname     *string `json:""nickname""`
	Password     *string `json:""password""`
	ResetOpenID  *bool   `json:""resetOpenId""`
	PasswordHash *string
	OpenID       *string
}
type UserFind struct {
	ID *int `json:""id""`
	// Standard fields
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Username *string `json:""username""`
	Role     *Role
	Email    *string `json:""email""`
	Nickname *string `json:""nickname""`
	OpenID   *string
}
type UserDelete struct {
	ID int
}
",CWE-284,105.0,1
"package api
import (
	""fmt""
)
// Role is the type of a role.
type Role string
const (
	// Host is the HOST role.
	Host Role = ""HOST""
	// Admin is the ADMIN role.
	Admin Role = ""ADMIN""
	// NormalUser is the USER role.
	NormalUser Role = ""USER""
)
func (e Role) String() string {
	switch e {
	case Host:
		return ""HOST""
	case Admin:
		return ""ADMIN""
	case NormalUser:
		return ""USER""
	}
	return ""USER""
}
type User struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Username        string         `json:""username""`
	Role            Role           `json:""role""`
	Email           string         `json:""email""`
	Nickname        string         `json:""nickname""`
	PasswordHash    string         `json:""-""`
	OpenID          string         `json:""openId""`
	UserSettingList []*UserSetting `json:""userSettingList""`
}
type UserCreate struct {
	// Domain specific fields
	Username     string `json:""username""`
	Role         Role   `json:""role""`
	Email        string `json:""email""`
	Nickname     string `json:""nickname""`
	Password     string `json:""password""`
	PasswordHash string
	OpenID       string
}
func (create UserCreate) Validate() error {
	if len(create.Username) < 4 {
		return fmt.Errorf(""username is too short, minimum length is 4"")
	}
	if len(create.Password) < 4 {
		return fmt.Errorf(""password is too short, minimum length is 4"")
	}
	return nil
}
type UserPatch struct {
	ID int
	// Standard fields
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Username     *string `json:""username""`
	Email        *string `json:""email""`
	Nickname     *string `json:""nickname""`
	Password     *string `json:""password""`
	ResetOpenID  *bool   `json:""resetOpenId""`
	PasswordHash *string
	OpenID       *string
}
type UserFind struct {
	ID *int `json:""id""`
	// Standard fields
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Username *string `json:""username""`
	Role     *Role
	Email    *string `json:""email""`
	Nickname *string `json:""nickname""`
	OpenID   *string
}
type UserDelete struct {
	ID int
}
",CWE-639,105.0,1
"package api
import (
	""fmt""
)
// Role is the type of a role.
type Role string
const (
	// Host is the HOST role.
	Host Role = ""HOST""
	// Admin is the ADMIN role.
	Admin Role = ""ADMIN""
	// NormalUser is the USER role.
	NormalUser Role = ""USER""
)
func (e Role) String() string {
	switch e {
	case Host:
		return ""HOST""
	case Admin:
		return ""ADMIN""
	case NormalUser:
		return ""USER""
	}
	return ""USER""
}
type User struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Username        string         `json:""username""`
	Role            Role           `json:""role""`
	Email           string         `json:""email""`
	Nickname        string         `json:""nickname""`
	PasswordHash    string         `json:""-""`
	OpenID          string         `json:""openId""`
	UserSettingList []*UserSetting `json:""userSettingList""`
}
type UserCreate struct {
	// Domain specific fields
	Username     string `json:""username""`
	Role         Role   `json:""role""`
	Email        string `json:""email""`
	Nickname     string `json:""nickname""`
	Password     string `json:""password""`
	PasswordHash string
	OpenID       string
}
func (create UserCreate) Validate() error {
	if len(create.Username) < 4 {
		return fmt.Errorf(""username is too short, minimum length is 4"")
	}
	if len(create.Password) < 4 {
		return fmt.Errorf(""password is too short, minimum length is 4"")
	}
	return nil
}
type UserPatch struct {
	ID int
	// Standard fields
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Username     *string `json:""username""`
	Email        *string `json:""email""`
	Nickname     *string `json:""nickname""`
	Password     *string `json:""password""`
	ResetOpenID  *bool   `json:""resetOpenId""`
	PasswordHash *string
	OpenID       *string
}
type UserFind struct {
	ID *int `json:""id""`
	// Standard fields
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Username *string `json:""username""`
	Role     *Role
	Email    *string `json:""email""`
	Nickname *string `json:""nickname""`
	OpenID   *string
}
type UserDelete struct {
	ID int
}
",CWE-269,105.0,1
"package api
import (
	""fmt""
)
// Role is the type of a role.
type Role string
const (
	// Host is the HOST role.
	Host Role = ""HOST""
	// Admin is the ADMIN role.
	Admin Role = ""ADMIN""
	// NormalUser is the USER role.
	NormalUser Role = ""USER""
)
func (e Role) String() string {
	switch e {
	case Host:
		return ""HOST""
	case Admin:
		return ""ADMIN""
	case NormalUser:
		return ""USER""
	}
	return ""USER""
}
type User struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Username        string         `json:""username""`
	Role            Role           `json:""role""`
	Email           string         `json:""email""`
	Nickname        string         `json:""nickname""`
	PasswordHash    string         `json:""-""`
	OpenID          string         `json:""openId""`
	UserSettingList []*UserSetting `json:""userSettingList""`
}
type UserCreate struct {
	// Domain specific fields
	Username     string `json:""username""`
	Role         Role   `json:""role""`
	Email        string `json:""email""`
	Nickname     string `json:""nickname""`
	Password     string `json:""password""`
	PasswordHash string
	OpenID       string
}
func (create UserCreate) Validate() error {
	if len(create.Username) < 4 {
		return fmt.Errorf(""username is too short, minimum length is 4"")
	}
	if len(create.Password) < 4 {
		return fmt.Errorf(""password is too short, minimum length is 4"")
	}
	return nil
}
type UserPatch struct {
	ID int
	// Standard fields
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Username     *string `json:""username""`
	Email        *string `json:""email""`
	Nickname     *string `json:""nickname""`
	Password     *string `json:""password""`
	ResetOpenID  *bool   `json:""resetOpenId""`
	PasswordHash *string
	OpenID       *string
}
type UserFind struct {
	ID *int `json:""id""`
	// Standard fields
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Username *string `json:""username""`
	Role     *Role
	Email    *string `json:""email""`
	Nickname *string `json:""nickname""`
	OpenID   *string
}
type UserDelete struct {
	ID int
}
",CWE-285,105.0,1
"package server
import (
	""fmt""
	""time""
	""github.com/usememos/memos/server/profile""
	""github.com/usememos/memos/store""
	""github.com/gorilla/securecookie""
	""github.com/gorilla/sessions""
	""github.com/labstack/echo-contrib/session""
	""github.com/labstack/echo/v4""
	""github.com/labstack/echo/v4/middleware""
)
type Server struct {
	e *echo.Echo
	Collector *MetricCollector
	Profile *profile.Profile
	Store *store.Store
}
func NewServer(profile *profile.Profile) *Server {
	e := echo.New()
	e.Debug = true
	e.HideBanner = true
	e.HidePort = true
	e.Use(middleware.LoggerWithConfig(middleware.LoggerConfig{
		Format: `{""time"":""${time_rfc3339}"",` +
			`""method"":""${method}"",""uri"":""${uri}"",` +
			`""status"":${status},""error"":""${error}""}` + ""\n"",
	}))
	e.Use(middleware.CORS())
	e.Use(middleware.TimeoutWithConfig(middleware.TimeoutConfig{
		Skipper:      middleware.DefaultSkipper,
		ErrorMessage: ""Request timeout"",
		Timeout:      30 * time.Second,
	}))
	embedFrontend(e)
	// In dev mode, set the const secret key to make signin session persistence.
	secret := []byte(""usememos"")
	if profile.Mode == ""prod"" {
		secret = securecookie.GenerateRandomKey(16)
	}
	e.Use(session.Middleware(sessions.NewCookieStore(secret)))
	s := &Server{
		e:       e,
		Profile: profile,
	}
	rootGroup := e.Group("""")
	s.registerRSSRoutes(rootGroup)
	webhookGroup := e.Group(""/h"")
	s.registerResourcePublicRoutes(webhookGroup)
	publicGroup := e.Group(""/o"")
	s.registerResourcePublicRoutes(publicGroup)
	s.registerGetterPublicRoutes(publicGroup)
	apiGroup := e.Group(""/api"")
	apiGroup.Use(func(next echo.HandlerFunc) echo.HandlerFunc {
		return aclMiddleware(s, next)
	})
	s.registerSystemRoutes(apiGroup)
	s.registerAuthRoutes(apiGroup)
	s.registerUserRoutes(apiGroup)
	s.registerMemoRoutes(apiGroup)
	s.registerShortcutRoutes(apiGroup)
	s.registerResourceRoutes(apiGroup)
	s.registerTagRoutes(apiGroup)
	return s
}
func (server *Server) Run() error {
	return server.e.Start(fmt.Sprintf("":%d"", server.Profile.Port))
}
",CWE-79,89.0,1
"package server
import (
	""encoding/json""
	""net/http""
	""os""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
)
func (s *Server) registerSystemRoutes(g *echo.Group) {
	g.GET(""/ping"", func(c echo.Context) error {
		data := s.Profile
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(data)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to compose system profile"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/status"", func(c echo.Context) error {
		ctx := c.Request().Context()
		hostUserType := api.Host
		hostUserFind := api.UserFind{
			Role: &hostUserType,
		}
		hostUser, err := s.Store.FindUser(ctx, &hostUserFind)
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find host user"").SetInternal(err)
		}
		if hostUser != nil {
			// data desensitize
			hostUser.OpenID = """"
		}
		systemStatus := api.SystemStatus{
			Host:             hostUser,
			Profile:          *s.Profile,
			DBSize:           0,
			AllowSignUp:      false,
			AdditionalStyle:  """",
			AdditionalScript: """",
			CustomizedProfile: api.CustomizedProfile{
				Name:        ""memos"",
				LogoURL:     """",
				Description: """",
				Locale:      ""en"",
				Appearance:  ""system"",
				ExternalURL: """",
			},
		}
		systemSettingList, err := s.Store.FindSystemSettingList(ctx, &api.SystemSettingFind{})
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find system setting list"").SetInternal(err)
		}
		for _, systemSetting := range systemSettingList {
			var value interface{}
			err := json.Unmarshal([]byte(systemSetting.Value), &value)
			if err != nil {
				return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to unmarshal system setting"").SetInternal(err)
			}
			if systemSetting.Name == api.SystemSettingAllowSignUpName {
				systemStatus.AllowSignUp = value.(bool)
			} else if systemSetting.Name == api.SystemSettingAdditionalStyleName {
				systemStatus.AdditionalStyle = value.(string)
			} else if systemSetting.Name == api.SystemSettingAdditionalScriptName {
				systemStatus.AdditionalScript = value.(string)
			} else if systemSetting.Name == api.SystemSettingCustomizedProfileName {
				valueMap := value.(map[string]interface{})
				systemStatus.CustomizedProfile = api.CustomizedProfile{
					Name:        valueMap[""name""].(string),
					LogoURL:     valueMap[""logoUrl""].(string),
					Description: valueMap[""description""].(string),
					Locale:      valueMap[""locale""].(string),
					Appearance:  valueMap[""appearance""].(string),
					ExternalURL: valueMap[""externalUrl""].(string),
				}
			}
		}
		userID, ok := c.Get(getUserIDContextKey()).(int)
		// Get database size for host user.
		if ok {
			user, err := s.Store.FindUser(ctx, &api.UserFind{
				ID: &userID,
			})
			if err != nil {
				return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find user"").SetInternal(err)
			}
			if user != nil && user.Role == api.Host {
				fi, err := os.Stat(s.Profile.DSN)
				if err != nil {
					return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to read database fileinfo"").SetInternal(err)
				}
				systemStatus.DBSize = fi.Size()
			}
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(systemStatus)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode system status response"").SetInternal(err)
		}
		return nil
	})
	g.POST(""/system/setting"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		user, err := s.Store.FindUser(ctx, &api.UserFind{
			ID: &userID,
		})
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find user"").SetInternal(err)
		}
		if user == nil {
			return echo.NewHTTPError(http.StatusNotFound, ""Current signin user not found"")
		} else if user.Role != api.Host {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Unauthorized"")
		}
		systemSettingUpsert := &api.SystemSettingUpsert{}
		if err := json.NewDecoder(c.Request().Body).Decode(systemSettingUpsert); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted post system setting request"").SetInternal(err)
		}
		if err := systemSettingUpsert.Validate(); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""system setting invalidate"").SetInternal(err)
		}
		systemSetting, err := s.Store.UpsertSystemSetting(ctx, systemSettingUpsert)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to upsert system setting"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name:   ""systemSetting updated"",
			Labels: map[string]string{""field"": string(systemSettingUpsert.Name)},
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(systemSetting)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode system setting response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/system/setting"", func(c echo.Context) error {
		ctx := c.Request().Context()
		systemSettingList, err := s.Store.FindSystemSettingList(ctx, &api.SystemSettingFind{})
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find system setting list"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(systemSettingList)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode system setting list response"").SetInternal(err)
		}
		return nil
	})
	g.POST(""/system/vacuum"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		user, err := s.Store.FindUser(ctx, &api.UserFind{
			ID: &userID,
		})
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find user"").SetInternal(err)
		}
		if user == nil || user.Role != api.Host {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Unauthorized"")
		}
		if err := s.Store.Vacuum(ctx); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to vacuum database"").SetInternal(err)
		}
		c.Response().WriteHeader(http.StatusOK)
		return nil
	})
}
",CWE-212,193.0,1
"package api
import (
	""fmt""
)
// Role is the type of a role.
type Role string
const (
	// Host is the HOST role.
	Host Role = ""HOST""
	// Admin is the ADMIN role.
	Admin Role = ""ADMIN""
	// NormalUser is the USER role.
	NormalUser Role = ""USER""
)
func (e Role) String() string {
	switch e {
	case Host:
		return ""HOST""
	case Admin:
		return ""ADMIN""
	case NormalUser:
		return ""USER""
	}
	return ""USER""
}
type User struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Username        string         `json:""username""`
	Role            Role           `json:""role""`
	Email           string         `json:""email""`
	Nickname        string         `json:""nickname""`
	PasswordHash    string         `json:""-""`
	OpenID          string         `json:""openId""`
	UserSettingList []*UserSetting `json:""userSettingList""`
}
type UserCreate struct {
	// Domain specific fields
	Username     string `json:""username""`
	Role         Role   `json:""role""`
	Email        string `json:""email""`
	Nickname     string `json:""nickname""`
	Password     string `json:""password""`
	PasswordHash string
	OpenID       string
}
func (create UserCreate) Validate() error {
	if len(create.Username) < 4 {
		return fmt.Errorf(""username is too short, minimum length is 4"")
	}
	if len(create.Password) < 4 {
		return fmt.Errorf(""password is too short, minimum length is 4"")
	}
	return nil
}
type UserPatch struct {
	ID int `json:""-""`
	// Standard fields
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Username     *string `json:""username""`
	Email        *string `json:""email""`
	Nickname     *string `json:""nickname""`
	Password     *string `json:""password""`
	ResetOpenID  *bool   `json:""resetOpenId""`
	PasswordHash *string
	OpenID       *string
}
type UserFind struct {
	ID *int `json:""id""`
	// Standard fields
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Username *string `json:""username""`
	Role     *Role
	Email    *string `json:""email""`
	Nickname *string `json:""nickname""`
	OpenID   *string
}
type UserDelete struct {
	ID int
}
",CWE-400,105.0,1
"package api
// Visibility is the type of a visibility.
type Visibility string
const (
	// Public is the PUBLIC visibility.
	Public Visibility = ""PUBLIC""
	// Protected is the PROTECTED visibility.
	Protected Visibility = ""PROTECTED""
	// Private is the PRIVATE visibility.
	Private Visibility = ""PRIVATE""
)
func (e Visibility) String() string {
	switch e {
	case Public:
		return ""PUBLIC""
	case Protected:
		return ""PROTECTED""
	case Private:
		return ""PRIVATE""
	}
	return ""PRIVATE""
}
type Memo struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatorID int       `json:""creatorId""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Content    string     `json:""content""`
	Visibility Visibility `json:""visibility""`
	Pinned     bool       `json:""pinned""`
	DisplayTs  int64      `json:""displayTs""`
	// Related fields
	Creator      *User       `json:""creator""`
	ResourceList []*Resource `json:""resourceList""`
}
type MemoCreate struct {
	// Standard fields
	CreatorID int
	// Domain specific fields
	Visibility Visibility `json:""visibility""`
	Content    string     `json:""content""`
	// Related fields
	ResourceIDList []int `json:""resourceIdList""`
}
type MemoPatch struct {
	ID int `json:""-""`
	// Standard fields
	CreatedTs *int64 `json:""createdTs""`
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Content    *string     `json:""content""`
	Visibility *Visibility `json:""visibility""`
	// Related fields
	ResourceIDList []int `json:""resourceIdList""`
}
type MemoFind struct {
	ID *int `json:""id""`
	// Standard fields
	RowStatus *RowStatus `json:""rowStatus""`
	CreatorID *int       `json:""creatorId""`
	// Domain specific fields
	Pinned         *bool
	ContentSearch  *string
	VisibilityList []Visibility
	// Pagination
	Limit  int
	Offset int
}
type MemoDelete struct {
	ID int
}
",CWE-648,95.0,1
"package api
// Visibility is the type of a visibility.
type Visibility string
const (
	// Public is the PUBLIC visibility.
	Public Visibility = ""PUBLIC""
	// Protected is the PROTECTED visibility.
	Protected Visibility = ""PROTECTED""
	// Private is the PRIVATE visibility.
	Private Visibility = ""PRIVATE""
)
func (e Visibility) String() string {
	switch e {
	case Public:
		return ""PUBLIC""
	case Protected:
		return ""PROTECTED""
	case Private:
		return ""PRIVATE""
	}
	return ""PRIVATE""
}
type Memo struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatorID int       `json:""creatorId""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Content    string     `json:""content""`
	Visibility Visibility `json:""visibility""`
	Pinned     bool       `json:""pinned""`
	DisplayTs  int64      `json:""displayTs""`
	// Related fields
	Creator      *User       `json:""creator""`
	ResourceList []*Resource `json:""resourceList""`
}
type MemoCreate struct {
	// Standard fields
	CreatorID int
	// Domain specific fields
	Visibility Visibility `json:""visibility""`
	Content    string     `json:""content""`
	// Related fields
	ResourceIDList []int `json:""resourceIdList""`
}
type MemoPatch struct {
	ID int `json:""-""`
	// Standard fields
	CreatedTs *int64 `json:""createdTs""`
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Content    *string     `json:""content""`
	Visibility *Visibility `json:""visibility""`
	// Related fields
	ResourceIDList []int `json:""resourceIdList""`
}
type MemoFind struct {
	ID *int `json:""id""`
	// Standard fields
	RowStatus *RowStatus `json:""rowStatus""`
	CreatorID *int       `json:""creatorId""`
	// Domain specific fields
	Pinned         *bool
	ContentSearch  *string
	VisibilityList []Visibility
	// Pagination
	Limit  int
	Offset int
}
type MemoDelete struct {
	ID int
}
",CWE-307,95.0,1
"package api
// Visibility is the type of a visibility.
type Visibility string
const (
	// Public is the PUBLIC visibility.
	Public Visibility = ""PUBLIC""
	// Protected is the PROTECTED visibility.
	Protected Visibility = ""PROTECTED""
	// Private is the PRIVATE visibility.
	Private Visibility = ""PRIVATE""
)
func (e Visibility) String() string {
	switch e {
	case Public:
		return ""PUBLIC""
	case Protected:
		return ""PROTECTED""
	case Private:
		return ""PRIVATE""
	}
	return ""PRIVATE""
}
type Memo struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatorID int       `json:""creatorId""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Content    string     `json:""content""`
	Visibility Visibility `json:""visibility""`
	Pinned     bool       `json:""pinned""`
	DisplayTs  int64      `json:""displayTs""`
	// Related fields
	Creator      *User       `json:""creator""`
	ResourceList []*Resource `json:""resourceList""`
}
type MemoCreate struct {
	// Standard fields
	CreatorID int
	// Domain specific fields
	Visibility Visibility `json:""visibility""`
	Content    string     `json:""content""`
	// Related fields
	ResourceIDList []int `json:""resourceIdList""`
}
type MemoPatch struct {
	ID int `json:""-""`
	// Standard fields
	CreatedTs *int64 `json:""createdTs""`
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Content    *string     `json:""content""`
	Visibility *Visibility `json:""visibility""`
	// Related fields
	ResourceIDList []int `json:""resourceIdList""`
}
type MemoFind struct {
	ID *int `json:""id""`
	// Standard fields
	RowStatus *RowStatus `json:""rowStatus""`
	CreatorID *int       `json:""creatorId""`
	// Domain specific fields
	Pinned         *bool
	ContentSearch  *string
	VisibilityList []Visibility
	// Pagination
	Limit  int
	Offset int
}
type MemoDelete struct {
	ID int
}
",CWE-639,95.0,1
"package api
// Visibility is the type of a visibility.
type Visibility string
const (
	// Public is the PUBLIC visibility.
	Public Visibility = ""PUBLIC""
	// Protected is the PROTECTED visibility.
	Protected Visibility = ""PROTECTED""
	// Private is the PRIVATE visibility.
	Private Visibility = ""PRIVATE""
)
func (e Visibility) String() string {
	switch e {
	case Public:
		return ""PUBLIC""
	case Protected:
		return ""PROTECTED""
	case Private:
		return ""PRIVATE""
	}
	return ""PRIVATE""
}
type Memo struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatorID int       `json:""creatorId""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Content    string     `json:""content""`
	Visibility Visibility `json:""visibility""`
	Pinned     bool       `json:""pinned""`
	DisplayTs  int64      `json:""displayTs""`
	// Related fields
	Creator      *User       `json:""creator""`
	ResourceList []*Resource `json:""resourceList""`
}
type MemoCreate struct {
	// Standard fields
	CreatorID int
	// Domain specific fields
	Visibility Visibility `json:""visibility""`
	Content    string     `json:""content""`
	// Related fields
	ResourceIDList []int `json:""resourceIdList""`
}
type MemoPatch struct {
	ID int `json:""-""`
	// Standard fields
	CreatedTs *int64 `json:""createdTs""`
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Content    *string     `json:""content""`
	Visibility *Visibility `json:""visibility""`
	// Related fields
	ResourceIDList []int `json:""resourceIdList""`
}
type MemoFind struct {
	ID *int `json:""id""`
	// Standard fields
	RowStatus *RowStatus `json:""rowStatus""`
	CreatorID *int       `json:""creatorId""`
	// Domain specific fields
	Pinned         *bool
	ContentSearch  *string
	VisibilityList []Visibility
	// Pagination
	Limit  int
	Offset int
}
type MemoDelete struct {
	ID int
}
",CWE-940,95.0,1
"package api
// Visibility is the type of a visibility.
type Visibility string
const (
	// Public is the PUBLIC visibility.
	Public Visibility = ""PUBLIC""
	// Protected is the PROTECTED visibility.
	Protected Visibility = ""PROTECTED""
	// Private is the PRIVATE visibility.
	Private Visibility = ""PRIVATE""
)
func (e Visibility) String() string {
	switch e {
	case Public:
		return ""PUBLIC""
	case Protected:
		return ""PROTECTED""
	case Private:
		return ""PRIVATE""
	}
	return ""PRIVATE""
}
type Memo struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatorID int       `json:""creatorId""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Content    string     `json:""content""`
	Visibility Visibility `json:""visibility""`
	Pinned     bool       `json:""pinned""`
	DisplayTs  int64      `json:""displayTs""`
	// Related fields
	Creator      *User       `json:""creator""`
	ResourceList []*Resource `json:""resourceList""`
}
type MemoCreate struct {
	// Standard fields
	CreatorID int
	// Domain specific fields
	Visibility Visibility `json:""visibility""`
	Content    string     `json:""content""`
	// Related fields
	ResourceIDList []int `json:""resourceIdList""`
}
type MemoPatch struct {
	ID int `json:""-""`
	// Standard fields
	CreatedTs *int64 `json:""createdTs""`
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Content    *string     `json:""content""`
	Visibility *Visibility `json:""visibility""`
	// Related fields
	ResourceIDList []int `json:""resourceIdList""`
}
type MemoFind struct {
	ID *int `json:""id""`
	// Standard fields
	RowStatus *RowStatus `json:""rowStatus""`
	CreatorID *int       `json:""creatorId""`
	// Domain specific fields
	Pinned         *bool
	ContentSearch  *string
	VisibilityList []Visibility
	// Pagination
	Limit  int
	Offset int
}
type MemoDelete struct {
	ID int
}
",CWE-1220,95.0,1
"package api
// Visibility is the type of a visibility.
type Visibility string
const (
	// Public is the PUBLIC visibility.
	Public Visibility = ""PUBLIC""
	// Protected is the PROTECTED visibility.
	Protected Visibility = ""PROTECTED""
	// Private is the PRIVATE visibility.
	Private Visibility = ""PRIVATE""
)
func (e Visibility) String() string {
	switch e {
	case Public:
		return ""PUBLIC""
	case Protected:
		return ""PROTECTED""
	case Private:
		return ""PRIVATE""
	}
	return ""PRIVATE""
}
type Memo struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatorID int       `json:""creatorId""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Content    string     `json:""content""`
	Visibility Visibility `json:""visibility""`
	Pinned     bool       `json:""pinned""`
	DisplayTs  int64      `json:""displayTs""`
	// Related fields
	Creator      *User       `json:""creator""`
	ResourceList []*Resource `json:""resourceList""`
}
type MemoCreate struct {
	// Standard fields
	CreatorID int
	// Domain specific fields
	Visibility Visibility `json:""visibility""`
	Content    string     `json:""content""`
	// Related fields
	ResourceIDList []int `json:""resourceIdList""`
}
type MemoPatch struct {
	ID int `json:""-""`
	// Standard fields
	CreatedTs *int64 `json:""createdTs""`
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Content    *string     `json:""content""`
	Visibility *Visibility `json:""visibility""`
	// Related fields
	ResourceIDList []int `json:""resourceIdList""`
}
type MemoFind struct {
	ID *int `json:""id""`
	// Standard fields
	RowStatus *RowStatus `json:""rowStatus""`
	CreatorID *int       `json:""creatorId""`
	// Domain specific fields
	Pinned         *bool
	ContentSearch  *string
	VisibilityList []Visibility
	// Pagination
	Limit  int
	Offset int
}
type MemoDelete struct {
	ID int
}
",CWE-285,95.0,1
"package api
// Visibility is the type of a visibility.
type Visibility string
const (
	// Public is the PUBLIC visibility.
	Public Visibility = ""PUBLIC""
	// Protected is the PROTECTED visibility.
	Protected Visibility = ""PROTECTED""
	// Private is the PRIVATE visibility.
	Private Visibility = ""PRIVATE""
)
func (e Visibility) String() string {
	switch e {
	case Public:
		return ""PUBLIC""
	case Protected:
		return ""PROTECTED""
	case Private:
		return ""PRIVATE""
	}
	return ""PRIVATE""
}
type Memo struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatorID int       `json:""creatorId""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Content    string     `json:""content""`
	Visibility Visibility `json:""visibility""`
	Pinned     bool       `json:""pinned""`
	DisplayTs  int64      `json:""displayTs""`
	// Related fields
	Creator      *User       `json:""creator""`
	ResourceList []*Resource `json:""resourceList""`
}
type MemoCreate struct {
	// Standard fields
	CreatorID int
	// Domain specific fields
	Visibility Visibility `json:""visibility""`
	Content    string     `json:""content""`
	// Related fields
	ResourceIDList []int `json:""resourceIdList""`
}
type MemoPatch struct {
	ID int `json:""-""`
	// Standard fields
	CreatedTs *int64 `json:""createdTs""`
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Content    *string     `json:""content""`
	Visibility *Visibility `json:""visibility""`
	// Related fields
	ResourceIDList []int `json:""resourceIdList""`
}
type MemoFind struct {
	ID *int `json:""id""`
	// Standard fields
	RowStatus *RowStatus `json:""rowStatus""`
	CreatorID *int       `json:""creatorId""`
	// Domain specific fields
	Pinned         *bool
	ContentSearch  *string
	VisibilityList []Visibility
	// Pagination
	Limit  int
	Offset int
}
type MemoDelete struct {
	ID int
}
",CWE-284,95.0,1
"package api
// Visibility is the type of a visibility.
type Visibility string
const (
	// Public is the PUBLIC visibility.
	Public Visibility = ""PUBLIC""
	// Protected is the PROTECTED visibility.
	Protected Visibility = ""PROTECTED""
	// Private is the PRIVATE visibility.
	Private Visibility = ""PRIVATE""
)
func (e Visibility) String() string {
	switch e {
	case Public:
		return ""PUBLIC""
	case Protected:
		return ""PROTECTED""
	case Private:
		return ""PRIVATE""
	}
	return ""PRIVATE""
}
type Memo struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatorID int       `json:""creatorId""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Content    string     `json:""content""`
	Visibility Visibility `json:""visibility""`
	Pinned     bool       `json:""pinned""`
	DisplayTs  int64      `json:""displayTs""`
	// Related fields
	Creator      *User       `json:""creator""`
	ResourceList []*Resource `json:""resourceList""`
}
type MemoCreate struct {
	// Standard fields
	CreatorID int
	// Domain specific fields
	Visibility Visibility `json:""visibility""`
	Content    string     `json:""content""`
	// Related fields
	ResourceIDList []int `json:""resourceIdList""`
}
type MemoPatch struct {
	ID int `json:""-""`
	// Standard fields
	CreatedTs *int64 `json:""createdTs""`
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Content    *string     `json:""content""`
	Visibility *Visibility `json:""visibility""`
	// Related fields
	ResourceIDList []int `json:""resourceIdList""`
}
type MemoFind struct {
	ID *int `json:""id""`
	// Standard fields
	RowStatus *RowStatus `json:""rowStatus""`
	CreatorID *int       `json:""creatorId""`
	// Domain specific fields
	Pinned         *bool
	ContentSearch  *string
	VisibilityList []Visibility
	// Pagination
	Limit  int
	Offset int
}
type MemoDelete struct {
	ID int
}
",CWE-229,95.0,1
"package api
// Visibility is the type of a visibility.
type Visibility string
const (
	// Public is the PUBLIC visibility.
	Public Visibility = ""PUBLIC""
	// Protected is the PROTECTED visibility.
	Protected Visibility = ""PROTECTED""
	// Private is the PRIVATE visibility.
	Private Visibility = ""PRIVATE""
)
func (e Visibility) String() string {
	switch e {
	case Public:
		return ""PUBLIC""
	case Protected:
		return ""PROTECTED""
	case Private:
		return ""PRIVATE""
	}
	return ""PRIVATE""
}
type Memo struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatorID int       `json:""creatorId""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Content    string     `json:""content""`
	Visibility Visibility `json:""visibility""`
	Pinned     bool       `json:""pinned""`
	DisplayTs  int64      `json:""displayTs""`
	// Related fields
	Creator      *User       `json:""creator""`
	ResourceList []*Resource `json:""resourceList""`
}
type MemoCreate struct {
	// Standard fields
	CreatorID int
	// Domain specific fields
	Visibility Visibility `json:""visibility""`
	Content    string     `json:""content""`
	// Related fields
	ResourceIDList []int `json:""resourceIdList""`
}
type MemoPatch struct {
	ID int `json:""-""`
	// Standard fields
	CreatedTs *int64 `json:""createdTs""`
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Content    *string     `json:""content""`
	Visibility *Visibility `json:""visibility""`
	// Related fields
	ResourceIDList []int `json:""resourceIdList""`
}
type MemoFind struct {
	ID *int `json:""id""`
	// Standard fields
	RowStatus *RowStatus `json:""rowStatus""`
	CreatorID *int       `json:""creatorId""`
	// Domain specific fields
	Pinned         *bool
	ContentSearch  *string
	VisibilityList []Visibility
	// Pagination
	Limit  int
	Offset int
}
type MemoDelete struct {
	ID int
}
",CWE-280,95.0,1
"package api
type MemoOrganizer struct {
	ID int
	// Domain specific fields
	MemoID int
	UserID int
	Pinned bool
}
type MemoOrganizerFind struct {
	MemoID int
	UserID int
}
type MemoOrganizerUpsert struct {
	MemoID int
	UserID int
	Pinned bool `json:""pinned""`
}
type MemoOrganizerDelete struct {
	MemoID *int
	UserID *int
}
",CWE-648,27.0,1
"package api
type MemoOrganizer struct {
	ID int
	// Domain specific fields
	MemoID int
	UserID int
	Pinned bool
}
type MemoOrganizerFind struct {
	MemoID int
	UserID int
}
type MemoOrganizerUpsert struct {
	MemoID int
	UserID int
	Pinned bool `json:""pinned""`
}
type MemoOrganizerDelete struct {
	MemoID *int
	UserID *int
}
",CWE-307,27.0,1
"package api
type MemoOrganizer struct {
	ID int
	// Domain specific fields
	MemoID int
	UserID int
	Pinned bool
}
type MemoOrganizerFind struct {
	MemoID int
	UserID int
}
type MemoOrganizerUpsert struct {
	MemoID int
	UserID int
	Pinned bool `json:""pinned""`
}
type MemoOrganizerDelete struct {
	MemoID *int
	UserID *int
}
",CWE-639,27.0,1
"package api
type MemoOrganizer struct {
	ID int
	// Domain specific fields
	MemoID int
	UserID int
	Pinned bool
}
type MemoOrganizerFind struct {
	MemoID int
	UserID int
}
type MemoOrganizerUpsert struct {
	MemoID int
	UserID int
	Pinned bool `json:""pinned""`
}
type MemoOrganizerDelete struct {
	MemoID *int
	UserID *int
}
",CWE-940,27.0,1
"package api
type MemoOrganizer struct {
	ID int
	// Domain specific fields
	MemoID int
	UserID int
	Pinned bool
}
type MemoOrganizerFind struct {
	MemoID int
	UserID int
}
type MemoOrganizerUpsert struct {
	MemoID int
	UserID int
	Pinned bool `json:""pinned""`
}
type MemoOrganizerDelete struct {
	MemoID *int
	UserID *int
}
",CWE-1220,27.0,1
"package api
type MemoOrganizer struct {
	ID int
	// Domain specific fields
	MemoID int
	UserID int
	Pinned bool
}
type MemoOrganizerFind struct {
	MemoID int
	UserID int
}
type MemoOrganizerUpsert struct {
	MemoID int
	UserID int
	Pinned bool `json:""pinned""`
}
type MemoOrganizerDelete struct {
	MemoID *int
	UserID *int
}
",CWE-285,27.0,1
"package api
type MemoOrganizer struct {
	ID int
	// Domain specific fields
	MemoID int
	UserID int
	Pinned bool
}
type MemoOrganizerFind struct {
	MemoID int
	UserID int
}
type MemoOrganizerUpsert struct {
	MemoID int
	UserID int
	Pinned bool `json:""pinned""`
}
type MemoOrganizerDelete struct {
	MemoID *int
	UserID *int
}
",CWE-284,27.0,1
"package api
type MemoOrganizer struct {
	ID int
	// Domain specific fields
	MemoID int
	UserID int
	Pinned bool
}
type MemoOrganizerFind struct {
	MemoID int
	UserID int
}
type MemoOrganizerUpsert struct {
	MemoID int
	UserID int
	Pinned bool `json:""pinned""`
}
type MemoOrganizerDelete struct {
	MemoID *int
	UserID *int
}
",CWE-229,27.0,1
"package api
type MemoOrganizer struct {
	ID int
	// Domain specific fields
	MemoID int
	UserID int
	Pinned bool
}
type MemoOrganizerFind struct {
	MemoID int
	UserID int
}
type MemoOrganizerUpsert struct {
	MemoID int
	UserID int
	Pinned bool `json:""pinned""`
}
type MemoOrganizerDelete struct {
	MemoID *int
	UserID *int
}
",CWE-280,27.0,1
"package api
type MemoResource struct {
	MemoID     int
	ResourceID int
	CreatedTs  int64
	UpdatedTs  int64
}
type MemoResourceUpsert struct {
	MemoID     int
	ResourceID int
	UpdatedTs  *int64
}
type MemoResourceFind struct {
	MemoID     *int
	ResourceID *int
}
type MemoResourceDelete struct {
	MemoID     *int
	ResourceID *int
}
",CWE-648,25.0,1
"package api
type MemoResource struct {
	MemoID     int
	ResourceID int
	CreatedTs  int64
	UpdatedTs  int64
}
type MemoResourceUpsert struct {
	MemoID     int
	ResourceID int
	UpdatedTs  *int64
}
type MemoResourceFind struct {
	MemoID     *int
	ResourceID *int
}
type MemoResourceDelete struct {
	MemoID     *int
	ResourceID *int
}
",CWE-307,25.0,1
"package api
type MemoResource struct {
	MemoID     int
	ResourceID int
	CreatedTs  int64
	UpdatedTs  int64
}
type MemoResourceUpsert struct {
	MemoID     int
	ResourceID int
	UpdatedTs  *int64
}
type MemoResourceFind struct {
	MemoID     *int
	ResourceID *int
}
type MemoResourceDelete struct {
	MemoID     *int
	ResourceID *int
}
",CWE-639,25.0,1
"package api
type MemoResource struct {
	MemoID     int
	ResourceID int
	CreatedTs  int64
	UpdatedTs  int64
}
type MemoResourceUpsert struct {
	MemoID     int
	ResourceID int
	UpdatedTs  *int64
}
type MemoResourceFind struct {
	MemoID     *int
	ResourceID *int
}
type MemoResourceDelete struct {
	MemoID     *int
	ResourceID *int
}
",CWE-940,25.0,1
"package api
type MemoResource struct {
	MemoID     int
	ResourceID int
	CreatedTs  int64
	UpdatedTs  int64
}
type MemoResourceUpsert struct {
	MemoID     int
	ResourceID int
	UpdatedTs  *int64
}
type MemoResourceFind struct {
	MemoID     *int
	ResourceID *int
}
type MemoResourceDelete struct {
	MemoID     *int
	ResourceID *int
}
",CWE-1220,25.0,1
"package api
type MemoResource struct {
	MemoID     int
	ResourceID int
	CreatedTs  int64
	UpdatedTs  int64
}
type MemoResourceUpsert struct {
	MemoID     int
	ResourceID int
	UpdatedTs  *int64
}
type MemoResourceFind struct {
	MemoID     *int
	ResourceID *int
}
type MemoResourceDelete struct {
	MemoID     *int
	ResourceID *int
}
",CWE-285,25.0,1
"package api
type MemoResource struct {
	MemoID     int
	ResourceID int
	CreatedTs  int64
	UpdatedTs  int64
}
type MemoResourceUpsert struct {
	MemoID     int
	ResourceID int
	UpdatedTs  *int64
}
type MemoResourceFind struct {
	MemoID     *int
	ResourceID *int
}
type MemoResourceDelete struct {
	MemoID     *int
	ResourceID *int
}
",CWE-284,25.0,1
"package api
type MemoResource struct {
	MemoID     int
	ResourceID int
	CreatedTs  int64
	UpdatedTs  int64
}
type MemoResourceUpsert struct {
	MemoID     int
	ResourceID int
	UpdatedTs  *int64
}
type MemoResourceFind struct {
	MemoID     *int
	ResourceID *int
}
type MemoResourceDelete struct {
	MemoID     *int
	ResourceID *int
}
",CWE-229,25.0,1
"package api
type MemoResource struct {
	MemoID     int
	ResourceID int
	CreatedTs  int64
	UpdatedTs  int64
}
type MemoResourceUpsert struct {
	MemoID     int
	ResourceID int
	UpdatedTs  *int64
}
type MemoResourceFind struct {
	MemoID     *int
	ResourceID *int
}
type MemoResourceDelete struct {
	MemoID     *int
	ResourceID *int
}
",CWE-280,25.0,1
"package api
type Resource struct {
	ID int `json:""id""`
	// Standard fields
	CreatorID int   `json:""creatorId""`
	CreatedTs int64 `json:""createdTs""`
	UpdatedTs int64 `json:""updatedTs""`
	// Domain specific fields
	Filename string `json:""filename""`
	Blob     []byte `json:""-""`
	Type     string `json:""type""`
	Size     int64  `json:""size""`
	// Related fields
	LinkedMemoAmount int `json:""linkedMemoAmount""`
}
type ResourceCreate struct {
	// Standard fields
	CreatorID int
	// Domain specific fields
	Filename string `json:""filename""`
	Blob     []byte `json:""blob""`
	Type     string `json:""type""`
	Size     int64  `json:""size""`
}
type ResourceFind struct {
	ID *int `json:""id""`
	// Standard fields
	CreatorID *int `json:""creatorId""`
	// Domain specific fields
	Filename *string `json:""filename""`
	MemoID   *int
}
type ResourcePatch struct {
	ID int `json:""-""`
	// Standard fields
	UpdatedTs *int64
	// Domain specific fields
	Filename *string `json:""filename""`
}
type ResourceDelete struct {
	ID int
}
",CWE-648,56.0,1
"package api
type Resource struct {
	ID int `json:""id""`
	// Standard fields
	CreatorID int   `json:""creatorId""`
	CreatedTs int64 `json:""createdTs""`
	UpdatedTs int64 `json:""updatedTs""`
	// Domain specific fields
	Filename string `json:""filename""`
	Blob     []byte `json:""-""`
	Type     string `json:""type""`
	Size     int64  `json:""size""`
	// Related fields
	LinkedMemoAmount int `json:""linkedMemoAmount""`
}
type ResourceCreate struct {
	// Standard fields
	CreatorID int
	// Domain specific fields
	Filename string `json:""filename""`
	Blob     []byte `json:""blob""`
	Type     string `json:""type""`
	Size     int64  `json:""size""`
}
type ResourceFind struct {
	ID *int `json:""id""`
	// Standard fields
	CreatorID *int `json:""creatorId""`
	// Domain specific fields
	Filename *string `json:""filename""`
	MemoID   *int
}
type ResourcePatch struct {
	ID int `json:""-""`
	// Standard fields
	UpdatedTs *int64
	// Domain specific fields
	Filename *string `json:""filename""`
}
type ResourceDelete struct {
	ID int
}
",CWE-307,56.0,1
"package api
type Resource struct {
	ID int `json:""id""`
	// Standard fields
	CreatorID int   `json:""creatorId""`
	CreatedTs int64 `json:""createdTs""`
	UpdatedTs int64 `json:""updatedTs""`
	// Domain specific fields
	Filename string `json:""filename""`
	Blob     []byte `json:""-""`
	Type     string `json:""type""`
	Size     int64  `json:""size""`
	// Related fields
	LinkedMemoAmount int `json:""linkedMemoAmount""`
}
type ResourceCreate struct {
	// Standard fields
	CreatorID int
	// Domain specific fields
	Filename string `json:""filename""`
	Blob     []byte `json:""blob""`
	Type     string `json:""type""`
	Size     int64  `json:""size""`
}
type ResourceFind struct {
	ID *int `json:""id""`
	// Standard fields
	CreatorID *int `json:""creatorId""`
	// Domain specific fields
	Filename *string `json:""filename""`
	MemoID   *int
}
type ResourcePatch struct {
	ID int `json:""-""`
	// Standard fields
	UpdatedTs *int64
	// Domain specific fields
	Filename *string `json:""filename""`
}
type ResourceDelete struct {
	ID int
}
",CWE-639,56.0,1
"package api
type Resource struct {
	ID int `json:""id""`
	// Standard fields
	CreatorID int   `json:""creatorId""`
	CreatedTs int64 `json:""createdTs""`
	UpdatedTs int64 `json:""updatedTs""`
	// Domain specific fields
	Filename string `json:""filename""`
	Blob     []byte `json:""-""`
	Type     string `json:""type""`
	Size     int64  `json:""size""`
	// Related fields
	LinkedMemoAmount int `json:""linkedMemoAmount""`
}
type ResourceCreate struct {
	// Standard fields
	CreatorID int
	// Domain specific fields
	Filename string `json:""filename""`
	Blob     []byte `json:""blob""`
	Type     string `json:""type""`
	Size     int64  `json:""size""`
}
type ResourceFind struct {
	ID *int `json:""id""`
	// Standard fields
	CreatorID *int `json:""creatorId""`
	// Domain specific fields
	Filename *string `json:""filename""`
	MemoID   *int
}
type ResourcePatch struct {
	ID int `json:""-""`
	// Standard fields
	UpdatedTs *int64
	// Domain specific fields
	Filename *string `json:""filename""`
}
type ResourceDelete struct {
	ID int
}
",CWE-940,56.0,1
"package api
type Resource struct {
	ID int `json:""id""`
	// Standard fields
	CreatorID int   `json:""creatorId""`
	CreatedTs int64 `json:""createdTs""`
	UpdatedTs int64 `json:""updatedTs""`
	// Domain specific fields
	Filename string `json:""filename""`
	Blob     []byte `json:""-""`
	Type     string `json:""type""`
	Size     int64  `json:""size""`
	// Related fields
	LinkedMemoAmount int `json:""linkedMemoAmount""`
}
type ResourceCreate struct {
	// Standard fields
	CreatorID int
	// Domain specific fields
	Filename string `json:""filename""`
	Blob     []byte `json:""blob""`
	Type     string `json:""type""`
	Size     int64  `json:""size""`
}
type ResourceFind struct {
	ID *int `json:""id""`
	// Standard fields
	CreatorID *int `json:""creatorId""`
	// Domain specific fields
	Filename *string `json:""filename""`
	MemoID   *int
}
type ResourcePatch struct {
	ID int `json:""-""`
	// Standard fields
	UpdatedTs *int64
	// Domain specific fields
	Filename *string `json:""filename""`
}
type ResourceDelete struct {
	ID int
}
",CWE-1220,56.0,1
"package api
type Resource struct {
	ID int `json:""id""`
	// Standard fields
	CreatorID int   `json:""creatorId""`
	CreatedTs int64 `json:""createdTs""`
	UpdatedTs int64 `json:""updatedTs""`
	// Domain specific fields
	Filename string `json:""filename""`
	Blob     []byte `json:""-""`
	Type     string `json:""type""`
	Size     int64  `json:""size""`
	// Related fields
	LinkedMemoAmount int `json:""linkedMemoAmount""`
}
type ResourceCreate struct {
	// Standard fields
	CreatorID int
	// Domain specific fields
	Filename string `json:""filename""`
	Blob     []byte `json:""blob""`
	Type     string `json:""type""`
	Size     int64  `json:""size""`
}
type ResourceFind struct {
	ID *int `json:""id""`
	// Standard fields
	CreatorID *int `json:""creatorId""`
	// Domain specific fields
	Filename *string `json:""filename""`
	MemoID   *int
}
type ResourcePatch struct {
	ID int `json:""-""`
	// Standard fields
	UpdatedTs *int64
	// Domain specific fields
	Filename *string `json:""filename""`
}
type ResourceDelete struct {
	ID int
}
",CWE-285,56.0,1
"package api
type Resource struct {
	ID int `json:""id""`
	// Standard fields
	CreatorID int   `json:""creatorId""`
	CreatedTs int64 `json:""createdTs""`
	UpdatedTs int64 `json:""updatedTs""`
	// Domain specific fields
	Filename string `json:""filename""`
	Blob     []byte `json:""-""`
	Type     string `json:""type""`
	Size     int64  `json:""size""`
	// Related fields
	LinkedMemoAmount int `json:""linkedMemoAmount""`
}
type ResourceCreate struct {
	// Standard fields
	CreatorID int
	// Domain specific fields
	Filename string `json:""filename""`
	Blob     []byte `json:""blob""`
	Type     string `json:""type""`
	Size     int64  `json:""size""`
}
type ResourceFind struct {
	ID *int `json:""id""`
	// Standard fields
	CreatorID *int `json:""creatorId""`
	// Domain specific fields
	Filename *string `json:""filename""`
	MemoID   *int
}
type ResourcePatch struct {
	ID int `json:""-""`
	// Standard fields
	UpdatedTs *int64
	// Domain specific fields
	Filename *string `json:""filename""`
}
type ResourceDelete struct {
	ID int
}
",CWE-284,56.0,1
"package api
type Resource struct {
	ID int `json:""id""`
	// Standard fields
	CreatorID int   `json:""creatorId""`
	CreatedTs int64 `json:""createdTs""`
	UpdatedTs int64 `json:""updatedTs""`
	// Domain specific fields
	Filename string `json:""filename""`
	Blob     []byte `json:""-""`
	Type     string `json:""type""`
	Size     int64  `json:""size""`
	// Related fields
	LinkedMemoAmount int `json:""linkedMemoAmount""`
}
type ResourceCreate struct {
	// Standard fields
	CreatorID int
	// Domain specific fields
	Filename string `json:""filename""`
	Blob     []byte `json:""blob""`
	Type     string `json:""type""`
	Size     int64  `json:""size""`
}
type ResourceFind struct {
	ID *int `json:""id""`
	// Standard fields
	CreatorID *int `json:""creatorId""`
	// Domain specific fields
	Filename *string `json:""filename""`
	MemoID   *int
}
type ResourcePatch struct {
	ID int `json:""-""`
	// Standard fields
	UpdatedTs *int64
	// Domain specific fields
	Filename *string `json:""filename""`
}
type ResourceDelete struct {
	ID int
}
",CWE-229,56.0,1
"package api
type Resource struct {
	ID int `json:""id""`
	// Standard fields
	CreatorID int   `json:""creatorId""`
	CreatedTs int64 `json:""createdTs""`
	UpdatedTs int64 `json:""updatedTs""`
	// Domain specific fields
	Filename string `json:""filename""`
	Blob     []byte `json:""-""`
	Type     string `json:""type""`
	Size     int64  `json:""size""`
	// Related fields
	LinkedMemoAmount int `json:""linkedMemoAmount""`
}
type ResourceCreate struct {
	// Standard fields
	CreatorID int
	// Domain specific fields
	Filename string `json:""filename""`
	Blob     []byte `json:""blob""`
	Type     string `json:""type""`
	Size     int64  `json:""size""`
}
type ResourceFind struct {
	ID *int `json:""id""`
	// Standard fields
	CreatorID *int `json:""creatorId""`
	// Domain specific fields
	Filename *string `json:""filename""`
	MemoID   *int
}
type ResourcePatch struct {
	ID int `json:""-""`
	// Standard fields
	UpdatedTs *int64
	// Domain specific fields
	Filename *string `json:""filename""`
}
type ResourceDelete struct {
	ID int
}
",CWE-280,56.0,1
"package api
type Shortcut struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatorID int       `json:""creatorId""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Title   string `json:""title""`
	Payload string `json:""payload""`
}
type ShortcutCreate struct {
	// Standard fields
	CreatorID int
	// Domain specific fields
	Title   string `json:""title""`
	Payload string `json:""payload""`
}
type ShortcutPatch struct {
	ID int `json:""-""`
	// Standard fields
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Title   *string `json:""title""`
	Payload *string `json:""payload""`
}
type ShortcutFind struct {
	ID *int
	// Standard fields
	CreatorID *int
	// Domain specific fields
	Title *string `json:""title""`
}
type ShortcutDelete struct {
	ID *int
	// Standard fields
	CreatorID *int
}
",CWE-648,54.0,1
"package api
type Shortcut struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatorID int       `json:""creatorId""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Title   string `json:""title""`
	Payload string `json:""payload""`
}
type ShortcutCreate struct {
	// Standard fields
	CreatorID int
	// Domain specific fields
	Title   string `json:""title""`
	Payload string `json:""payload""`
}
type ShortcutPatch struct {
	ID int `json:""-""`
	// Standard fields
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Title   *string `json:""title""`
	Payload *string `json:""payload""`
}
type ShortcutFind struct {
	ID *int
	// Standard fields
	CreatorID *int
	// Domain specific fields
	Title *string `json:""title""`
}
type ShortcutDelete struct {
	ID *int
	// Standard fields
	CreatorID *int
}
",CWE-307,54.0,1
"package api
type Shortcut struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatorID int       `json:""creatorId""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Title   string `json:""title""`
	Payload string `json:""payload""`
}
type ShortcutCreate struct {
	// Standard fields
	CreatorID int
	// Domain specific fields
	Title   string `json:""title""`
	Payload string `json:""payload""`
}
type ShortcutPatch struct {
	ID int `json:""-""`
	// Standard fields
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Title   *string `json:""title""`
	Payload *string `json:""payload""`
}
type ShortcutFind struct {
	ID *int
	// Standard fields
	CreatorID *int
	// Domain specific fields
	Title *string `json:""title""`
}
type ShortcutDelete struct {
	ID *int
	// Standard fields
	CreatorID *int
}
",CWE-639,54.0,1
"package api
type Shortcut struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatorID int       `json:""creatorId""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Title   string `json:""title""`
	Payload string `json:""payload""`
}
type ShortcutCreate struct {
	// Standard fields
	CreatorID int
	// Domain specific fields
	Title   string `json:""title""`
	Payload string `json:""payload""`
}
type ShortcutPatch struct {
	ID int `json:""-""`
	// Standard fields
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Title   *string `json:""title""`
	Payload *string `json:""payload""`
}
type ShortcutFind struct {
	ID *int
	// Standard fields
	CreatorID *int
	// Domain specific fields
	Title *string `json:""title""`
}
type ShortcutDelete struct {
	ID *int
	// Standard fields
	CreatorID *int
}
",CWE-940,54.0,1
"package api
type Shortcut struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatorID int       `json:""creatorId""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Title   string `json:""title""`
	Payload string `json:""payload""`
}
type ShortcutCreate struct {
	// Standard fields
	CreatorID int
	// Domain specific fields
	Title   string `json:""title""`
	Payload string `json:""payload""`
}
type ShortcutPatch struct {
	ID int `json:""-""`
	// Standard fields
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Title   *string `json:""title""`
	Payload *string `json:""payload""`
}
type ShortcutFind struct {
	ID *int
	// Standard fields
	CreatorID *int
	// Domain specific fields
	Title *string `json:""title""`
}
type ShortcutDelete struct {
	ID *int
	// Standard fields
	CreatorID *int
}
",CWE-1220,54.0,1
"package api
type Shortcut struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatorID int       `json:""creatorId""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Title   string `json:""title""`
	Payload string `json:""payload""`
}
type ShortcutCreate struct {
	// Standard fields
	CreatorID int
	// Domain specific fields
	Title   string `json:""title""`
	Payload string `json:""payload""`
}
type ShortcutPatch struct {
	ID int `json:""-""`
	// Standard fields
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Title   *string `json:""title""`
	Payload *string `json:""payload""`
}
type ShortcutFind struct {
	ID *int
	// Standard fields
	CreatorID *int
	// Domain specific fields
	Title *string `json:""title""`
}
type ShortcutDelete struct {
	ID *int
	// Standard fields
	CreatorID *int
}
",CWE-285,54.0,1
"package api
type Shortcut struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatorID int       `json:""creatorId""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Title   string `json:""title""`
	Payload string `json:""payload""`
}
type ShortcutCreate struct {
	// Standard fields
	CreatorID int
	// Domain specific fields
	Title   string `json:""title""`
	Payload string `json:""payload""`
}
type ShortcutPatch struct {
	ID int `json:""-""`
	// Standard fields
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Title   *string `json:""title""`
	Payload *string `json:""payload""`
}
type ShortcutFind struct {
	ID *int
	// Standard fields
	CreatorID *int
	// Domain specific fields
	Title *string `json:""title""`
}
type ShortcutDelete struct {
	ID *int
	// Standard fields
	CreatorID *int
}
",CWE-284,54.0,1
"package api
type Shortcut struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatorID int       `json:""creatorId""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Title   string `json:""title""`
	Payload string `json:""payload""`
}
type ShortcutCreate struct {
	// Standard fields
	CreatorID int
	// Domain specific fields
	Title   string `json:""title""`
	Payload string `json:""payload""`
}
type ShortcutPatch struct {
	ID int `json:""-""`
	// Standard fields
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Title   *string `json:""title""`
	Payload *string `json:""payload""`
}
type ShortcutFind struct {
	ID *int
	// Standard fields
	CreatorID *int
	// Domain specific fields
	Title *string `json:""title""`
}
type ShortcutDelete struct {
	ID *int
	// Standard fields
	CreatorID *int
}
",CWE-229,54.0,1
"package api
type Shortcut struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatorID int       `json:""creatorId""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Title   string `json:""title""`
	Payload string `json:""payload""`
}
type ShortcutCreate struct {
	// Standard fields
	CreatorID int
	// Domain specific fields
	Title   string `json:""title""`
	Payload string `json:""payload""`
}
type ShortcutPatch struct {
	ID int `json:""-""`
	// Standard fields
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Title   *string `json:""title""`
	Payload *string `json:""payload""`
}
type ShortcutFind struct {
	ID *int
	// Standard fields
	CreatorID *int
	// Domain specific fields
	Title *string `json:""title""`
}
type ShortcutDelete struct {
	ID *int
	// Standard fields
	CreatorID *int
}
",CWE-280,54.0,1
"package api
type Tag struct {
	Name      string
	CreatorID int
}
type TagUpsert struct {
	Name      string
	CreatorID int
}
type TagFind struct {
	CreatorID int
}
type TagDelete struct {
	Name      string
	CreatorID int
}
",CWE-648,21.0,1
"package api
type Tag struct {
	Name      string
	CreatorID int
}
type TagUpsert struct {
	Name      string
	CreatorID int
}
type TagFind struct {
	CreatorID int
}
type TagDelete struct {
	Name      string
	CreatorID int
}
",CWE-307,21.0,1
"package api
type Tag struct {
	Name      string
	CreatorID int
}
type TagUpsert struct {
	Name      string
	CreatorID int
}
type TagFind struct {
	CreatorID int
}
type TagDelete struct {
	Name      string
	CreatorID int
}
",CWE-639,21.0,1
"package api
type Tag struct {
	Name      string
	CreatorID int
}
type TagUpsert struct {
	Name      string
	CreatorID int
}
type TagFind struct {
	CreatorID int
}
type TagDelete struct {
	Name      string
	CreatorID int
}
",CWE-940,21.0,1
"package api
type Tag struct {
	Name      string
	CreatorID int
}
type TagUpsert struct {
	Name      string
	CreatorID int
}
type TagFind struct {
	CreatorID int
}
type TagDelete struct {
	Name      string
	CreatorID int
}
",CWE-1220,21.0,1
"package api
type Tag struct {
	Name      string
	CreatorID int
}
type TagUpsert struct {
	Name      string
	CreatorID int
}
type TagFind struct {
	CreatorID int
}
type TagDelete struct {
	Name      string
	CreatorID int
}
",CWE-285,21.0,1
"package api
type Tag struct {
	Name      string
	CreatorID int
}
type TagUpsert struct {
	Name      string
	CreatorID int
}
type TagFind struct {
	CreatorID int
}
type TagDelete struct {
	Name      string
	CreatorID int
}
",CWE-284,21.0,1
"package api
type Tag struct {
	Name      string
	CreatorID int
}
type TagUpsert struct {
	Name      string
	CreatorID int
}
type TagFind struct {
	CreatorID int
}
type TagDelete struct {
	Name      string
	CreatorID int
}
",CWE-229,21.0,1
"package api
type Tag struct {
	Name      string
	CreatorID int
}
type TagUpsert struct {
	Name      string
	CreatorID int
}
type TagFind struct {
	CreatorID int
}
type TagDelete struct {
	Name      string
	CreatorID int
}
",CWE-280,21.0,1
"package api
import (
	""encoding/json""
	""fmt""
	""golang.org/x/exp/slices""
)
type UserSettingKey string
const (
	// UserSettingLocaleKey is the key type for user locale.
	UserSettingLocaleKey UserSettingKey = ""locale""
	// UserSettingAppearanceKey is the key type for user appearance.
	UserSettingAppearanceKey UserSettingKey = ""appearance""
	// UserSettingMemoVisibilityKey is the key type for user preference memo default visibility.
	UserSettingMemoVisibilityKey UserSettingKey = ""memoVisibility""
	// UserSettingMemoDisplayTsOptionKey is the key type for memo display ts option.
	UserSettingMemoDisplayTsOptionKey UserSettingKey = ""memoDisplayTsOption""
)
// String returns the string format of UserSettingKey type.
func (key UserSettingKey) String() string {
	switch key {
	case UserSettingLocaleKey:
		return ""locale""
	case UserSettingAppearanceKey:
		return ""appearance""
	case UserSettingMemoVisibilityKey:
		return ""memoVisibility""
	case UserSettingMemoDisplayTsOptionKey:
		return ""memoDisplayTsOption""
	}
	return """"
}
var (
	UserSettingLocaleValue                 = []string{""en"", ""zh"", ""vi"", ""fr"", ""nl"", ""sv"", ""de"", ""es"", ""uk""}
	UserSettingAppearanceValue             = []string{""system"", ""light"", ""dark""}
	UserSettingMemoVisibilityValue         = []Visibility{Private, Protected, Public}
	UserSettingMemoDisplayTsOptionKeyValue = []string{""created_ts"", ""updated_ts""}
)
type UserSetting struct {
	UserID int
	Key    UserSettingKey `json:""key""`
	// Value is a JSON string with basic value
	Value string `json:""value""`
}
type UserSettingUpsert struct {
	UserID int
	Key    UserSettingKey `json:""key""`
	Value  string         `json:""value""`
}
func (upsert UserSettingUpsert) Validate() error {
	if upsert.Key == UserSettingLocaleKey {
		localeValue := ""en""
		err := json.Unmarshal([]byte(upsert.Value), &localeValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting locale value"")
		}
		if !slices.Contains(UserSettingLocaleValue, localeValue) {
			return fmt.Errorf(""invalid user setting locale value"")
		}
	} else if upsert.Key == UserSettingAppearanceKey {
		appearanceValue := ""system""
		err := json.Unmarshal([]byte(upsert.Value), &appearanceValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting appearance value"")
		}
		if !slices.Contains(UserSettingAppearanceValue, appearanceValue) {
			return fmt.Errorf(""invalid user setting appearance value"")
		}
	} else if upsert.Key == UserSettingMemoVisibilityKey {
		memoVisibilityValue := Private
		err := json.Unmarshal([]byte(upsert.Value), &memoVisibilityValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting memo visibility value"")
		}
		if !slices.Contains(UserSettingMemoVisibilityValue, memoVisibilityValue) {
			return fmt.Errorf(""invalid user setting memo visibility value"")
		}
	} else if upsert.Key == UserSettingMemoDisplayTsOptionKey {
		memoDisplayTsOption := ""created_ts""
		err := json.Unmarshal([]byte(upsert.Value), &memoDisplayTsOption)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting memo display ts option"")
		}
		if !slices.Contains(UserSettingMemoDisplayTsOptionKeyValue, memoDisplayTsOption) {
			return fmt.Errorf(""invalid user setting memo display ts option value"")
		}
	} else {
		return fmt.Errorf(""invalid user setting key"")
	}
	return nil
}
type UserSettingFind struct {
	UserID int
	Key *UserSettingKey `json:""key""`
}
type UserSettingDelete struct {
	UserID int
}
",CWE-648,111.0,1
"package api
import (
	""encoding/json""
	""fmt""
	""golang.org/x/exp/slices""
)
type UserSettingKey string
const (
	// UserSettingLocaleKey is the key type for user locale.
	UserSettingLocaleKey UserSettingKey = ""locale""
	// UserSettingAppearanceKey is the key type for user appearance.
	UserSettingAppearanceKey UserSettingKey = ""appearance""
	// UserSettingMemoVisibilityKey is the key type for user preference memo default visibility.
	UserSettingMemoVisibilityKey UserSettingKey = ""memoVisibility""
	// UserSettingMemoDisplayTsOptionKey is the key type for memo display ts option.
	UserSettingMemoDisplayTsOptionKey UserSettingKey = ""memoDisplayTsOption""
)
// String returns the string format of UserSettingKey type.
func (key UserSettingKey) String() string {
	switch key {
	case UserSettingLocaleKey:
		return ""locale""
	case UserSettingAppearanceKey:
		return ""appearance""
	case UserSettingMemoVisibilityKey:
		return ""memoVisibility""
	case UserSettingMemoDisplayTsOptionKey:
		return ""memoDisplayTsOption""
	}
	return """"
}
var (
	UserSettingLocaleValue                 = []string{""en"", ""zh"", ""vi"", ""fr"", ""nl"", ""sv"", ""de"", ""es"", ""uk""}
	UserSettingAppearanceValue             = []string{""system"", ""light"", ""dark""}
	UserSettingMemoVisibilityValue         = []Visibility{Private, Protected, Public}
	UserSettingMemoDisplayTsOptionKeyValue = []string{""created_ts"", ""updated_ts""}
)
type UserSetting struct {
	UserID int
	Key    UserSettingKey `json:""key""`
	// Value is a JSON string with basic value
	Value string `json:""value""`
}
type UserSettingUpsert struct {
	UserID int
	Key    UserSettingKey `json:""key""`
	Value  string         `json:""value""`
}
func (upsert UserSettingUpsert) Validate() error {
	if upsert.Key == UserSettingLocaleKey {
		localeValue := ""en""
		err := json.Unmarshal([]byte(upsert.Value), &localeValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting locale value"")
		}
		if !slices.Contains(UserSettingLocaleValue, localeValue) {
			return fmt.Errorf(""invalid user setting locale value"")
		}
	} else if upsert.Key == UserSettingAppearanceKey {
		appearanceValue := ""system""
		err := json.Unmarshal([]byte(upsert.Value), &appearanceValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting appearance value"")
		}
		if !slices.Contains(UserSettingAppearanceValue, appearanceValue) {
			return fmt.Errorf(""invalid user setting appearance value"")
		}
	} else if upsert.Key == UserSettingMemoVisibilityKey {
		memoVisibilityValue := Private
		err := json.Unmarshal([]byte(upsert.Value), &memoVisibilityValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting memo visibility value"")
		}
		if !slices.Contains(UserSettingMemoVisibilityValue, memoVisibilityValue) {
			return fmt.Errorf(""invalid user setting memo visibility value"")
		}
	} else if upsert.Key == UserSettingMemoDisplayTsOptionKey {
		memoDisplayTsOption := ""created_ts""
		err := json.Unmarshal([]byte(upsert.Value), &memoDisplayTsOption)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting memo display ts option"")
		}
		if !slices.Contains(UserSettingMemoDisplayTsOptionKeyValue, memoDisplayTsOption) {
			return fmt.Errorf(""invalid user setting memo display ts option value"")
		}
	} else {
		return fmt.Errorf(""invalid user setting key"")
	}
	return nil
}
type UserSettingFind struct {
	UserID int
	Key *UserSettingKey `json:""key""`
}
type UserSettingDelete struct {
	UserID int
}
",CWE-307,111.0,1
"package api
import (
	""encoding/json""
	""fmt""
	""golang.org/x/exp/slices""
)
type UserSettingKey string
const (
	// UserSettingLocaleKey is the key type for user locale.
	UserSettingLocaleKey UserSettingKey = ""locale""
	// UserSettingAppearanceKey is the key type for user appearance.
	UserSettingAppearanceKey UserSettingKey = ""appearance""
	// UserSettingMemoVisibilityKey is the key type for user preference memo default visibility.
	UserSettingMemoVisibilityKey UserSettingKey = ""memoVisibility""
	// UserSettingMemoDisplayTsOptionKey is the key type for memo display ts option.
	UserSettingMemoDisplayTsOptionKey UserSettingKey = ""memoDisplayTsOption""
)
// String returns the string format of UserSettingKey type.
func (key UserSettingKey) String() string {
	switch key {
	case UserSettingLocaleKey:
		return ""locale""
	case UserSettingAppearanceKey:
		return ""appearance""
	case UserSettingMemoVisibilityKey:
		return ""memoVisibility""
	case UserSettingMemoDisplayTsOptionKey:
		return ""memoDisplayTsOption""
	}
	return """"
}
var (
	UserSettingLocaleValue                 = []string{""en"", ""zh"", ""vi"", ""fr"", ""nl"", ""sv"", ""de"", ""es"", ""uk""}
	UserSettingAppearanceValue             = []string{""system"", ""light"", ""dark""}
	UserSettingMemoVisibilityValue         = []Visibility{Private, Protected, Public}
	UserSettingMemoDisplayTsOptionKeyValue = []string{""created_ts"", ""updated_ts""}
)
type UserSetting struct {
	UserID int
	Key    UserSettingKey `json:""key""`
	// Value is a JSON string with basic value
	Value string `json:""value""`
}
type UserSettingUpsert struct {
	UserID int
	Key    UserSettingKey `json:""key""`
	Value  string         `json:""value""`
}
func (upsert UserSettingUpsert) Validate() error {
	if upsert.Key == UserSettingLocaleKey {
		localeValue := ""en""
		err := json.Unmarshal([]byte(upsert.Value), &localeValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting locale value"")
		}
		if !slices.Contains(UserSettingLocaleValue, localeValue) {
			return fmt.Errorf(""invalid user setting locale value"")
		}
	} else if upsert.Key == UserSettingAppearanceKey {
		appearanceValue := ""system""
		err := json.Unmarshal([]byte(upsert.Value), &appearanceValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting appearance value"")
		}
		if !slices.Contains(UserSettingAppearanceValue, appearanceValue) {
			return fmt.Errorf(""invalid user setting appearance value"")
		}
	} else if upsert.Key == UserSettingMemoVisibilityKey {
		memoVisibilityValue := Private
		err := json.Unmarshal([]byte(upsert.Value), &memoVisibilityValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting memo visibility value"")
		}
		if !slices.Contains(UserSettingMemoVisibilityValue, memoVisibilityValue) {
			return fmt.Errorf(""invalid user setting memo visibility value"")
		}
	} else if upsert.Key == UserSettingMemoDisplayTsOptionKey {
		memoDisplayTsOption := ""created_ts""
		err := json.Unmarshal([]byte(upsert.Value), &memoDisplayTsOption)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting memo display ts option"")
		}
		if !slices.Contains(UserSettingMemoDisplayTsOptionKeyValue, memoDisplayTsOption) {
			return fmt.Errorf(""invalid user setting memo display ts option value"")
		}
	} else {
		return fmt.Errorf(""invalid user setting key"")
	}
	return nil
}
type UserSettingFind struct {
	UserID int
	Key *UserSettingKey `json:""key""`
}
type UserSettingDelete struct {
	UserID int
}
",CWE-639,111.0,1
"package api
import (
	""encoding/json""
	""fmt""
	""golang.org/x/exp/slices""
)
type UserSettingKey string
const (
	// UserSettingLocaleKey is the key type for user locale.
	UserSettingLocaleKey UserSettingKey = ""locale""
	// UserSettingAppearanceKey is the key type for user appearance.
	UserSettingAppearanceKey UserSettingKey = ""appearance""
	// UserSettingMemoVisibilityKey is the key type for user preference memo default visibility.
	UserSettingMemoVisibilityKey UserSettingKey = ""memoVisibility""
	// UserSettingMemoDisplayTsOptionKey is the key type for memo display ts option.
	UserSettingMemoDisplayTsOptionKey UserSettingKey = ""memoDisplayTsOption""
)
// String returns the string format of UserSettingKey type.
func (key UserSettingKey) String() string {
	switch key {
	case UserSettingLocaleKey:
		return ""locale""
	case UserSettingAppearanceKey:
		return ""appearance""
	case UserSettingMemoVisibilityKey:
		return ""memoVisibility""
	case UserSettingMemoDisplayTsOptionKey:
		return ""memoDisplayTsOption""
	}
	return """"
}
var (
	UserSettingLocaleValue                 = []string{""en"", ""zh"", ""vi"", ""fr"", ""nl"", ""sv"", ""de"", ""es"", ""uk""}
	UserSettingAppearanceValue             = []string{""system"", ""light"", ""dark""}
	UserSettingMemoVisibilityValue         = []Visibility{Private, Protected, Public}
	UserSettingMemoDisplayTsOptionKeyValue = []string{""created_ts"", ""updated_ts""}
)
type UserSetting struct {
	UserID int
	Key    UserSettingKey `json:""key""`
	// Value is a JSON string with basic value
	Value string `json:""value""`
}
type UserSettingUpsert struct {
	UserID int
	Key    UserSettingKey `json:""key""`
	Value  string         `json:""value""`
}
func (upsert UserSettingUpsert) Validate() error {
	if upsert.Key == UserSettingLocaleKey {
		localeValue := ""en""
		err := json.Unmarshal([]byte(upsert.Value), &localeValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting locale value"")
		}
		if !slices.Contains(UserSettingLocaleValue, localeValue) {
			return fmt.Errorf(""invalid user setting locale value"")
		}
	} else if upsert.Key == UserSettingAppearanceKey {
		appearanceValue := ""system""
		err := json.Unmarshal([]byte(upsert.Value), &appearanceValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting appearance value"")
		}
		if !slices.Contains(UserSettingAppearanceValue, appearanceValue) {
			return fmt.Errorf(""invalid user setting appearance value"")
		}
	} else if upsert.Key == UserSettingMemoVisibilityKey {
		memoVisibilityValue := Private
		err := json.Unmarshal([]byte(upsert.Value), &memoVisibilityValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting memo visibility value"")
		}
		if !slices.Contains(UserSettingMemoVisibilityValue, memoVisibilityValue) {
			return fmt.Errorf(""invalid user setting memo visibility value"")
		}
	} else if upsert.Key == UserSettingMemoDisplayTsOptionKey {
		memoDisplayTsOption := ""created_ts""
		err := json.Unmarshal([]byte(upsert.Value), &memoDisplayTsOption)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting memo display ts option"")
		}
		if !slices.Contains(UserSettingMemoDisplayTsOptionKeyValue, memoDisplayTsOption) {
			return fmt.Errorf(""invalid user setting memo display ts option value"")
		}
	} else {
		return fmt.Errorf(""invalid user setting key"")
	}
	return nil
}
type UserSettingFind struct {
	UserID int
	Key *UserSettingKey `json:""key""`
}
type UserSettingDelete struct {
	UserID int
}
",CWE-940,111.0,1
"package api
import (
	""encoding/json""
	""fmt""
	""golang.org/x/exp/slices""
)
type UserSettingKey string
const (
	// UserSettingLocaleKey is the key type for user locale.
	UserSettingLocaleKey UserSettingKey = ""locale""
	// UserSettingAppearanceKey is the key type for user appearance.
	UserSettingAppearanceKey UserSettingKey = ""appearance""
	// UserSettingMemoVisibilityKey is the key type for user preference memo default visibility.
	UserSettingMemoVisibilityKey UserSettingKey = ""memoVisibility""
	// UserSettingMemoDisplayTsOptionKey is the key type for memo display ts option.
	UserSettingMemoDisplayTsOptionKey UserSettingKey = ""memoDisplayTsOption""
)
// String returns the string format of UserSettingKey type.
func (key UserSettingKey) String() string {
	switch key {
	case UserSettingLocaleKey:
		return ""locale""
	case UserSettingAppearanceKey:
		return ""appearance""
	case UserSettingMemoVisibilityKey:
		return ""memoVisibility""
	case UserSettingMemoDisplayTsOptionKey:
		return ""memoDisplayTsOption""
	}
	return """"
}
var (
	UserSettingLocaleValue                 = []string{""en"", ""zh"", ""vi"", ""fr"", ""nl"", ""sv"", ""de"", ""es"", ""uk""}
	UserSettingAppearanceValue             = []string{""system"", ""light"", ""dark""}
	UserSettingMemoVisibilityValue         = []Visibility{Private, Protected, Public}
	UserSettingMemoDisplayTsOptionKeyValue = []string{""created_ts"", ""updated_ts""}
)
type UserSetting struct {
	UserID int
	Key    UserSettingKey `json:""key""`
	// Value is a JSON string with basic value
	Value string `json:""value""`
}
type UserSettingUpsert struct {
	UserID int
	Key    UserSettingKey `json:""key""`
	Value  string         `json:""value""`
}
func (upsert UserSettingUpsert) Validate() error {
	if upsert.Key == UserSettingLocaleKey {
		localeValue := ""en""
		err := json.Unmarshal([]byte(upsert.Value), &localeValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting locale value"")
		}
		if !slices.Contains(UserSettingLocaleValue, localeValue) {
			return fmt.Errorf(""invalid user setting locale value"")
		}
	} else if upsert.Key == UserSettingAppearanceKey {
		appearanceValue := ""system""
		err := json.Unmarshal([]byte(upsert.Value), &appearanceValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting appearance value"")
		}
		if !slices.Contains(UserSettingAppearanceValue, appearanceValue) {
			return fmt.Errorf(""invalid user setting appearance value"")
		}
	} else if upsert.Key == UserSettingMemoVisibilityKey {
		memoVisibilityValue := Private
		err := json.Unmarshal([]byte(upsert.Value), &memoVisibilityValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting memo visibility value"")
		}
		if !slices.Contains(UserSettingMemoVisibilityValue, memoVisibilityValue) {
			return fmt.Errorf(""invalid user setting memo visibility value"")
		}
	} else if upsert.Key == UserSettingMemoDisplayTsOptionKey {
		memoDisplayTsOption := ""created_ts""
		err := json.Unmarshal([]byte(upsert.Value), &memoDisplayTsOption)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting memo display ts option"")
		}
		if !slices.Contains(UserSettingMemoDisplayTsOptionKeyValue, memoDisplayTsOption) {
			return fmt.Errorf(""invalid user setting memo display ts option value"")
		}
	} else {
		return fmt.Errorf(""invalid user setting key"")
	}
	return nil
}
type UserSettingFind struct {
	UserID int
	Key *UserSettingKey `json:""key""`
}
type UserSettingDelete struct {
	UserID int
}
",CWE-1220,111.0,1
"package api
import (
	""encoding/json""
	""fmt""
	""golang.org/x/exp/slices""
)
type UserSettingKey string
const (
	// UserSettingLocaleKey is the key type for user locale.
	UserSettingLocaleKey UserSettingKey = ""locale""
	// UserSettingAppearanceKey is the key type for user appearance.
	UserSettingAppearanceKey UserSettingKey = ""appearance""
	// UserSettingMemoVisibilityKey is the key type for user preference memo default visibility.
	UserSettingMemoVisibilityKey UserSettingKey = ""memoVisibility""
	// UserSettingMemoDisplayTsOptionKey is the key type for memo display ts option.
	UserSettingMemoDisplayTsOptionKey UserSettingKey = ""memoDisplayTsOption""
)
// String returns the string format of UserSettingKey type.
func (key UserSettingKey) String() string {
	switch key {
	case UserSettingLocaleKey:
		return ""locale""
	case UserSettingAppearanceKey:
		return ""appearance""
	case UserSettingMemoVisibilityKey:
		return ""memoVisibility""
	case UserSettingMemoDisplayTsOptionKey:
		return ""memoDisplayTsOption""
	}
	return """"
}
var (
	UserSettingLocaleValue                 = []string{""en"", ""zh"", ""vi"", ""fr"", ""nl"", ""sv"", ""de"", ""es"", ""uk""}
	UserSettingAppearanceValue             = []string{""system"", ""light"", ""dark""}
	UserSettingMemoVisibilityValue         = []Visibility{Private, Protected, Public}
	UserSettingMemoDisplayTsOptionKeyValue = []string{""created_ts"", ""updated_ts""}
)
type UserSetting struct {
	UserID int
	Key    UserSettingKey `json:""key""`
	// Value is a JSON string with basic value
	Value string `json:""value""`
}
type UserSettingUpsert struct {
	UserID int
	Key    UserSettingKey `json:""key""`
	Value  string         `json:""value""`
}
func (upsert UserSettingUpsert) Validate() error {
	if upsert.Key == UserSettingLocaleKey {
		localeValue := ""en""
		err := json.Unmarshal([]byte(upsert.Value), &localeValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting locale value"")
		}
		if !slices.Contains(UserSettingLocaleValue, localeValue) {
			return fmt.Errorf(""invalid user setting locale value"")
		}
	} else if upsert.Key == UserSettingAppearanceKey {
		appearanceValue := ""system""
		err := json.Unmarshal([]byte(upsert.Value), &appearanceValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting appearance value"")
		}
		if !slices.Contains(UserSettingAppearanceValue, appearanceValue) {
			return fmt.Errorf(""invalid user setting appearance value"")
		}
	} else if upsert.Key == UserSettingMemoVisibilityKey {
		memoVisibilityValue := Private
		err := json.Unmarshal([]byte(upsert.Value), &memoVisibilityValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting memo visibility value"")
		}
		if !slices.Contains(UserSettingMemoVisibilityValue, memoVisibilityValue) {
			return fmt.Errorf(""invalid user setting memo visibility value"")
		}
	} else if upsert.Key == UserSettingMemoDisplayTsOptionKey {
		memoDisplayTsOption := ""created_ts""
		err := json.Unmarshal([]byte(upsert.Value), &memoDisplayTsOption)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting memo display ts option"")
		}
		if !slices.Contains(UserSettingMemoDisplayTsOptionKeyValue, memoDisplayTsOption) {
			return fmt.Errorf(""invalid user setting memo display ts option value"")
		}
	} else {
		return fmt.Errorf(""invalid user setting key"")
	}
	return nil
}
type UserSettingFind struct {
	UserID int
	Key *UserSettingKey `json:""key""`
}
type UserSettingDelete struct {
	UserID int
}
",CWE-285,111.0,1
"package api
import (
	""encoding/json""
	""fmt""
	""golang.org/x/exp/slices""
)
type UserSettingKey string
const (
	// UserSettingLocaleKey is the key type for user locale.
	UserSettingLocaleKey UserSettingKey = ""locale""
	// UserSettingAppearanceKey is the key type for user appearance.
	UserSettingAppearanceKey UserSettingKey = ""appearance""
	// UserSettingMemoVisibilityKey is the key type for user preference memo default visibility.
	UserSettingMemoVisibilityKey UserSettingKey = ""memoVisibility""
	// UserSettingMemoDisplayTsOptionKey is the key type for memo display ts option.
	UserSettingMemoDisplayTsOptionKey UserSettingKey = ""memoDisplayTsOption""
)
// String returns the string format of UserSettingKey type.
func (key UserSettingKey) String() string {
	switch key {
	case UserSettingLocaleKey:
		return ""locale""
	case UserSettingAppearanceKey:
		return ""appearance""
	case UserSettingMemoVisibilityKey:
		return ""memoVisibility""
	case UserSettingMemoDisplayTsOptionKey:
		return ""memoDisplayTsOption""
	}
	return """"
}
var (
	UserSettingLocaleValue                 = []string{""en"", ""zh"", ""vi"", ""fr"", ""nl"", ""sv"", ""de"", ""es"", ""uk""}
	UserSettingAppearanceValue             = []string{""system"", ""light"", ""dark""}
	UserSettingMemoVisibilityValue         = []Visibility{Private, Protected, Public}
	UserSettingMemoDisplayTsOptionKeyValue = []string{""created_ts"", ""updated_ts""}
)
type UserSetting struct {
	UserID int
	Key    UserSettingKey `json:""key""`
	// Value is a JSON string with basic value
	Value string `json:""value""`
}
type UserSettingUpsert struct {
	UserID int
	Key    UserSettingKey `json:""key""`
	Value  string         `json:""value""`
}
func (upsert UserSettingUpsert) Validate() error {
	if upsert.Key == UserSettingLocaleKey {
		localeValue := ""en""
		err := json.Unmarshal([]byte(upsert.Value), &localeValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting locale value"")
		}
		if !slices.Contains(UserSettingLocaleValue, localeValue) {
			return fmt.Errorf(""invalid user setting locale value"")
		}
	} else if upsert.Key == UserSettingAppearanceKey {
		appearanceValue := ""system""
		err := json.Unmarshal([]byte(upsert.Value), &appearanceValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting appearance value"")
		}
		if !slices.Contains(UserSettingAppearanceValue, appearanceValue) {
			return fmt.Errorf(""invalid user setting appearance value"")
		}
	} else if upsert.Key == UserSettingMemoVisibilityKey {
		memoVisibilityValue := Private
		err := json.Unmarshal([]byte(upsert.Value), &memoVisibilityValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting memo visibility value"")
		}
		if !slices.Contains(UserSettingMemoVisibilityValue, memoVisibilityValue) {
			return fmt.Errorf(""invalid user setting memo visibility value"")
		}
	} else if upsert.Key == UserSettingMemoDisplayTsOptionKey {
		memoDisplayTsOption := ""created_ts""
		err := json.Unmarshal([]byte(upsert.Value), &memoDisplayTsOption)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting memo display ts option"")
		}
		if !slices.Contains(UserSettingMemoDisplayTsOptionKeyValue, memoDisplayTsOption) {
			return fmt.Errorf(""invalid user setting memo display ts option value"")
		}
	} else {
		return fmt.Errorf(""invalid user setting key"")
	}
	return nil
}
type UserSettingFind struct {
	UserID int
	Key *UserSettingKey `json:""key""`
}
type UserSettingDelete struct {
	UserID int
}
",CWE-284,111.0,1
"package api
import (
	""encoding/json""
	""fmt""
	""golang.org/x/exp/slices""
)
type UserSettingKey string
const (
	// UserSettingLocaleKey is the key type for user locale.
	UserSettingLocaleKey UserSettingKey = ""locale""
	// UserSettingAppearanceKey is the key type for user appearance.
	UserSettingAppearanceKey UserSettingKey = ""appearance""
	// UserSettingMemoVisibilityKey is the key type for user preference memo default visibility.
	UserSettingMemoVisibilityKey UserSettingKey = ""memoVisibility""
	// UserSettingMemoDisplayTsOptionKey is the key type for memo display ts option.
	UserSettingMemoDisplayTsOptionKey UserSettingKey = ""memoDisplayTsOption""
)
// String returns the string format of UserSettingKey type.
func (key UserSettingKey) String() string {
	switch key {
	case UserSettingLocaleKey:
		return ""locale""
	case UserSettingAppearanceKey:
		return ""appearance""
	case UserSettingMemoVisibilityKey:
		return ""memoVisibility""
	case UserSettingMemoDisplayTsOptionKey:
		return ""memoDisplayTsOption""
	}
	return """"
}
var (
	UserSettingLocaleValue                 = []string{""en"", ""zh"", ""vi"", ""fr"", ""nl"", ""sv"", ""de"", ""es"", ""uk""}
	UserSettingAppearanceValue             = []string{""system"", ""light"", ""dark""}
	UserSettingMemoVisibilityValue         = []Visibility{Private, Protected, Public}
	UserSettingMemoDisplayTsOptionKeyValue = []string{""created_ts"", ""updated_ts""}
)
type UserSetting struct {
	UserID int
	Key    UserSettingKey `json:""key""`
	// Value is a JSON string with basic value
	Value string `json:""value""`
}
type UserSettingUpsert struct {
	UserID int
	Key    UserSettingKey `json:""key""`
	Value  string         `json:""value""`
}
func (upsert UserSettingUpsert) Validate() error {
	if upsert.Key == UserSettingLocaleKey {
		localeValue := ""en""
		err := json.Unmarshal([]byte(upsert.Value), &localeValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting locale value"")
		}
		if !slices.Contains(UserSettingLocaleValue, localeValue) {
			return fmt.Errorf(""invalid user setting locale value"")
		}
	} else if upsert.Key == UserSettingAppearanceKey {
		appearanceValue := ""system""
		err := json.Unmarshal([]byte(upsert.Value), &appearanceValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting appearance value"")
		}
		if !slices.Contains(UserSettingAppearanceValue, appearanceValue) {
			return fmt.Errorf(""invalid user setting appearance value"")
		}
	} else if upsert.Key == UserSettingMemoVisibilityKey {
		memoVisibilityValue := Private
		err := json.Unmarshal([]byte(upsert.Value), &memoVisibilityValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting memo visibility value"")
		}
		if !slices.Contains(UserSettingMemoVisibilityValue, memoVisibilityValue) {
			return fmt.Errorf(""invalid user setting memo visibility value"")
		}
	} else if upsert.Key == UserSettingMemoDisplayTsOptionKey {
		memoDisplayTsOption := ""created_ts""
		err := json.Unmarshal([]byte(upsert.Value), &memoDisplayTsOption)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting memo display ts option"")
		}
		if !slices.Contains(UserSettingMemoDisplayTsOptionKeyValue, memoDisplayTsOption) {
			return fmt.Errorf(""invalid user setting memo display ts option value"")
		}
	} else {
		return fmt.Errorf(""invalid user setting key"")
	}
	return nil
}
type UserSettingFind struct {
	UserID int
	Key *UserSettingKey `json:""key""`
}
type UserSettingDelete struct {
	UserID int
}
",CWE-229,111.0,1
"package api
import (
	""encoding/json""
	""fmt""
	""golang.org/x/exp/slices""
)
type UserSettingKey string
const (
	// UserSettingLocaleKey is the key type for user locale.
	UserSettingLocaleKey UserSettingKey = ""locale""
	// UserSettingAppearanceKey is the key type for user appearance.
	UserSettingAppearanceKey UserSettingKey = ""appearance""
	// UserSettingMemoVisibilityKey is the key type for user preference memo default visibility.
	UserSettingMemoVisibilityKey UserSettingKey = ""memoVisibility""
	// UserSettingMemoDisplayTsOptionKey is the key type for memo display ts option.
	UserSettingMemoDisplayTsOptionKey UserSettingKey = ""memoDisplayTsOption""
)
// String returns the string format of UserSettingKey type.
func (key UserSettingKey) String() string {
	switch key {
	case UserSettingLocaleKey:
		return ""locale""
	case UserSettingAppearanceKey:
		return ""appearance""
	case UserSettingMemoVisibilityKey:
		return ""memoVisibility""
	case UserSettingMemoDisplayTsOptionKey:
		return ""memoDisplayTsOption""
	}
	return """"
}
var (
	UserSettingLocaleValue                 = []string{""en"", ""zh"", ""vi"", ""fr"", ""nl"", ""sv"", ""de"", ""es"", ""uk""}
	UserSettingAppearanceValue             = []string{""system"", ""light"", ""dark""}
	UserSettingMemoVisibilityValue         = []Visibility{Private, Protected, Public}
	UserSettingMemoDisplayTsOptionKeyValue = []string{""created_ts"", ""updated_ts""}
)
type UserSetting struct {
	UserID int
	Key    UserSettingKey `json:""key""`
	// Value is a JSON string with basic value
	Value string `json:""value""`
}
type UserSettingUpsert struct {
	UserID int
	Key    UserSettingKey `json:""key""`
	Value  string         `json:""value""`
}
func (upsert UserSettingUpsert) Validate() error {
	if upsert.Key == UserSettingLocaleKey {
		localeValue := ""en""
		err := json.Unmarshal([]byte(upsert.Value), &localeValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting locale value"")
		}
		if !slices.Contains(UserSettingLocaleValue, localeValue) {
			return fmt.Errorf(""invalid user setting locale value"")
		}
	} else if upsert.Key == UserSettingAppearanceKey {
		appearanceValue := ""system""
		err := json.Unmarshal([]byte(upsert.Value), &appearanceValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting appearance value"")
		}
		if !slices.Contains(UserSettingAppearanceValue, appearanceValue) {
			return fmt.Errorf(""invalid user setting appearance value"")
		}
	} else if upsert.Key == UserSettingMemoVisibilityKey {
		memoVisibilityValue := Private
		err := json.Unmarshal([]byte(upsert.Value), &memoVisibilityValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting memo visibility value"")
		}
		if !slices.Contains(UserSettingMemoVisibilityValue, memoVisibilityValue) {
			return fmt.Errorf(""invalid user setting memo visibility value"")
		}
	} else if upsert.Key == UserSettingMemoDisplayTsOptionKey {
		memoDisplayTsOption := ""created_ts""
		err := json.Unmarshal([]byte(upsert.Value), &memoDisplayTsOption)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting memo display ts option"")
		}
		if !slices.Contains(UserSettingMemoDisplayTsOptionKeyValue, memoDisplayTsOption) {
			return fmt.Errorf(""invalid user setting memo display ts option value"")
		}
	} else {
		return fmt.Errorf(""invalid user setting key"")
	}
	return nil
}
type UserSettingFind struct {
	UserID int
	Key *UserSettingKey `json:""key""`
}
type UserSettingDelete struct {
	UserID int
}
",CWE-280,111.0,1
"package server
import (
	""encoding/json""
	""fmt""
	""net/http""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
	""golang.org/x/crypto/bcrypt""
)
func (s *Server) registerAuthRoutes(g *echo.Group) {
	g.POST(""/auth/signin"", func(c echo.Context) error {
		ctx := c.Request().Context()
		signin := &api.Signin{}
		if err := json.NewDecoder(c.Request().Body).Decode(signin); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted signin request"").SetInternal(err)
		}
		userFind := &api.UserFind{
			Username: &signin.Username,
		}
		user, err := s.Store.FindUser(ctx, userFind)
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to find user by username %s"", signin.Username)).SetInternal(err)
		}
		if user == nil {
			return echo.NewHTTPError(http.StatusUnauthorized, fmt.Sprintf(""User not found with username %s"", signin.Username))
		} else if user.RowStatus == api.Archived {
			return echo.NewHTTPError(http.StatusForbidden, fmt.Sprintf(""User has been archived with username %s"", signin.Username))
		}
		// Compare the stored hashed password, with the hashed version of the password that was received.
		if err := bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(signin.Password)); err != nil {
			// If the two passwords don't match, return a 401 status.
			return echo.NewHTTPError(http.StatusUnauthorized, ""Incorrect password"").SetInternal(err)
		}
		if err = setUserSession(c, user); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to set signin session"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""user signed in"",
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(user)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode user response"").SetInternal(err)
		}
		return nil
	})
	g.POST(""/auth/logout"", func(c echo.Context) error {
		ctx := c.Request().Context()
		err := removeUserSession(c)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to set logout session"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""user logout"",
		})
		c.Response().WriteHeader(http.StatusOK)
		return nil
	})
	g.POST(""/auth/signup"", func(c echo.Context) error {
		ctx := c.Request().Context()
		signup := &api.Signup{}
		if err := json.NewDecoder(c.Request().Body).Decode(signup); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted signup request"").SetInternal(err)
		}
		hostUserType := api.Host
		hostUserFind := api.UserFind{
			Role: &hostUserType,
		}
		hostUser, err := s.Store.FindUser(ctx, &hostUserFind)
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find host user"").SetInternal(err)
		}
		if signup.Role == api.Host && hostUser != nil {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Site Host existed, please contact the site host to signin account firstly."").SetInternal(err)
		}
		systemSettingAllowSignUpName := api.SystemSettingAllowSignUpName
		allowSignUpSetting, err := s.Store.FindSystemSetting(ctx, &api.SystemSettingFind{
			Name: &systemSettingAllowSignUpName,
		})
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find system setting"").SetInternal(err)
		}
		allowSignUpSettingValue := false
		if allowSignUpSetting != nil {
			err = json.Unmarshal([]byte(allowSignUpSetting.Value), &allowSignUpSettingValue)
			if err != nil {
				return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to unmarshal system setting allow signup"").SetInternal(err)
			}
		}
		if !allowSignUpSettingValue && hostUser != nil {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Site Host existed, please contact the site host to signin account firstly."").SetInternal(err)
		}
		userCreate := &api.UserCreate{
			Username: signup.Username,
			Role:     api.Role(signup.Role),
			Nickname: signup.Username,
			Password: signup.Password,
			OpenID:   common.GenUUID(),
		}
		if err := userCreate.Validate(); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Invalid user create format."").SetInternal(err)
		}
		passwordHash, err := bcrypt.GenerateFromPassword([]byte(signup.Password), bcrypt.DefaultCost)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to generate password hash"").SetInternal(err)
		}
		userCreate.PasswordHash = string(passwordHash)
		user, err := s.Store.CreateUser(ctx, userCreate)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to create user"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""user signed up"",
		})
		err = setUserSession(c, user)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to set signup session"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(user)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode created user response"").SetInternal(err)
		}
		return nil
	})
}
",CWE-648,147.0,1
"package server
import (
	""encoding/json""
	""fmt""
	""net/http""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
	""golang.org/x/crypto/bcrypt""
)
func (s *Server) registerAuthRoutes(g *echo.Group) {
	g.POST(""/auth/signin"", func(c echo.Context) error {
		ctx := c.Request().Context()
		signin := &api.Signin{}
		if err := json.NewDecoder(c.Request().Body).Decode(signin); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted signin request"").SetInternal(err)
		}
		userFind := &api.UserFind{
			Username: &signin.Username,
		}
		user, err := s.Store.FindUser(ctx, userFind)
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to find user by username %s"", signin.Username)).SetInternal(err)
		}
		if user == nil {
			return echo.NewHTTPError(http.StatusUnauthorized, fmt.Sprintf(""User not found with username %s"", signin.Username))
		} else if user.RowStatus == api.Archived {
			return echo.NewHTTPError(http.StatusForbidden, fmt.Sprintf(""User has been archived with username %s"", signin.Username))
		}
		// Compare the stored hashed password, with the hashed version of the password that was received.
		if err := bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(signin.Password)); err != nil {
			// If the two passwords don't match, return a 401 status.
			return echo.NewHTTPError(http.StatusUnauthorized, ""Incorrect password"").SetInternal(err)
		}
		if err = setUserSession(c, user); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to set signin session"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""user signed in"",
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(user)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode user response"").SetInternal(err)
		}
		return nil
	})
	g.POST(""/auth/logout"", func(c echo.Context) error {
		ctx := c.Request().Context()
		err := removeUserSession(c)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to set logout session"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""user logout"",
		})
		c.Response().WriteHeader(http.StatusOK)
		return nil
	})
	g.POST(""/auth/signup"", func(c echo.Context) error {
		ctx := c.Request().Context()
		signup := &api.Signup{}
		if err := json.NewDecoder(c.Request().Body).Decode(signup); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted signup request"").SetInternal(err)
		}
		hostUserType := api.Host
		hostUserFind := api.UserFind{
			Role: &hostUserType,
		}
		hostUser, err := s.Store.FindUser(ctx, &hostUserFind)
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find host user"").SetInternal(err)
		}
		if signup.Role == api.Host && hostUser != nil {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Site Host existed, please contact the site host to signin account firstly."").SetInternal(err)
		}
		systemSettingAllowSignUpName := api.SystemSettingAllowSignUpName
		allowSignUpSetting, err := s.Store.FindSystemSetting(ctx, &api.SystemSettingFind{
			Name: &systemSettingAllowSignUpName,
		})
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find system setting"").SetInternal(err)
		}
		allowSignUpSettingValue := false
		if allowSignUpSetting != nil {
			err = json.Unmarshal([]byte(allowSignUpSetting.Value), &allowSignUpSettingValue)
			if err != nil {
				return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to unmarshal system setting allow signup"").SetInternal(err)
			}
		}
		if !allowSignUpSettingValue && hostUser != nil {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Site Host existed, please contact the site host to signin account firstly."").SetInternal(err)
		}
		userCreate := &api.UserCreate{
			Username: signup.Username,
			Role:     api.Role(signup.Role),
			Nickname: signup.Username,
			Password: signup.Password,
			OpenID:   common.GenUUID(),
		}
		if err := userCreate.Validate(); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Invalid user create format."").SetInternal(err)
		}
		passwordHash, err := bcrypt.GenerateFromPassword([]byte(signup.Password), bcrypt.DefaultCost)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to generate password hash"").SetInternal(err)
		}
		userCreate.PasswordHash = string(passwordHash)
		user, err := s.Store.CreateUser(ctx, userCreate)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to create user"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""user signed up"",
		})
		err = setUserSession(c, user)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to set signup session"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(user)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode created user response"").SetInternal(err)
		}
		return nil
	})
}
",CWE-307,147.0,1
"package server
import (
	""encoding/json""
	""fmt""
	""net/http""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
	""golang.org/x/crypto/bcrypt""
)
func (s *Server) registerAuthRoutes(g *echo.Group) {
	g.POST(""/auth/signin"", func(c echo.Context) error {
		ctx := c.Request().Context()
		signin := &api.Signin{}
		if err := json.NewDecoder(c.Request().Body).Decode(signin); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted signin request"").SetInternal(err)
		}
		userFind := &api.UserFind{
			Username: &signin.Username,
		}
		user, err := s.Store.FindUser(ctx, userFind)
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to find user by username %s"", signin.Username)).SetInternal(err)
		}
		if user == nil {
			return echo.NewHTTPError(http.StatusUnauthorized, fmt.Sprintf(""User not found with username %s"", signin.Username))
		} else if user.RowStatus == api.Archived {
			return echo.NewHTTPError(http.StatusForbidden, fmt.Sprintf(""User has been archived with username %s"", signin.Username))
		}
		// Compare the stored hashed password, with the hashed version of the password that was received.
		if err := bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(signin.Password)); err != nil {
			// If the two passwords don't match, return a 401 status.
			return echo.NewHTTPError(http.StatusUnauthorized, ""Incorrect password"").SetInternal(err)
		}
		if err = setUserSession(c, user); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to set signin session"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""user signed in"",
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(user)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode user response"").SetInternal(err)
		}
		return nil
	})
	g.POST(""/auth/logout"", func(c echo.Context) error {
		ctx := c.Request().Context()
		err := removeUserSession(c)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to set logout session"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""user logout"",
		})
		c.Response().WriteHeader(http.StatusOK)
		return nil
	})
	g.POST(""/auth/signup"", func(c echo.Context) error {
		ctx := c.Request().Context()
		signup := &api.Signup{}
		if err := json.NewDecoder(c.Request().Body).Decode(signup); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted signup request"").SetInternal(err)
		}
		hostUserType := api.Host
		hostUserFind := api.UserFind{
			Role: &hostUserType,
		}
		hostUser, err := s.Store.FindUser(ctx, &hostUserFind)
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find host user"").SetInternal(err)
		}
		if signup.Role == api.Host && hostUser != nil {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Site Host existed, please contact the site host to signin account firstly."").SetInternal(err)
		}
		systemSettingAllowSignUpName := api.SystemSettingAllowSignUpName
		allowSignUpSetting, err := s.Store.FindSystemSetting(ctx, &api.SystemSettingFind{
			Name: &systemSettingAllowSignUpName,
		})
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find system setting"").SetInternal(err)
		}
		allowSignUpSettingValue := false
		if allowSignUpSetting != nil {
			err = json.Unmarshal([]byte(allowSignUpSetting.Value), &allowSignUpSettingValue)
			if err != nil {
				return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to unmarshal system setting allow signup"").SetInternal(err)
			}
		}
		if !allowSignUpSettingValue && hostUser != nil {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Site Host existed, please contact the site host to signin account firstly."").SetInternal(err)
		}
		userCreate := &api.UserCreate{
			Username: signup.Username,
			Role:     api.Role(signup.Role),
			Nickname: signup.Username,
			Password: signup.Password,
			OpenID:   common.GenUUID(),
		}
		if err := userCreate.Validate(); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Invalid user create format."").SetInternal(err)
		}
		passwordHash, err := bcrypt.GenerateFromPassword([]byte(signup.Password), bcrypt.DefaultCost)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to generate password hash"").SetInternal(err)
		}
		userCreate.PasswordHash = string(passwordHash)
		user, err := s.Store.CreateUser(ctx, userCreate)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to create user"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""user signed up"",
		})
		err = setUserSession(c, user)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to set signup session"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(user)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode created user response"").SetInternal(err)
		}
		return nil
	})
}
",CWE-639,147.0,1
"package server
import (
	""encoding/json""
	""fmt""
	""net/http""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
	""golang.org/x/crypto/bcrypt""
)
func (s *Server) registerAuthRoutes(g *echo.Group) {
	g.POST(""/auth/signin"", func(c echo.Context) error {
		ctx := c.Request().Context()
		signin := &api.Signin{}
		if err := json.NewDecoder(c.Request().Body).Decode(signin); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted signin request"").SetInternal(err)
		}
		userFind := &api.UserFind{
			Username: &signin.Username,
		}
		user, err := s.Store.FindUser(ctx, userFind)
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to find user by username %s"", signin.Username)).SetInternal(err)
		}
		if user == nil {
			return echo.NewHTTPError(http.StatusUnauthorized, fmt.Sprintf(""User not found with username %s"", signin.Username))
		} else if user.RowStatus == api.Archived {
			return echo.NewHTTPError(http.StatusForbidden, fmt.Sprintf(""User has been archived with username %s"", signin.Username))
		}
		// Compare the stored hashed password, with the hashed version of the password that was received.
		if err := bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(signin.Password)); err != nil {
			// If the two passwords don't match, return a 401 status.
			return echo.NewHTTPError(http.StatusUnauthorized, ""Incorrect password"").SetInternal(err)
		}
		if err = setUserSession(c, user); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to set signin session"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""user signed in"",
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(user)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode user response"").SetInternal(err)
		}
		return nil
	})
	g.POST(""/auth/logout"", func(c echo.Context) error {
		ctx := c.Request().Context()
		err := removeUserSession(c)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to set logout session"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""user logout"",
		})
		c.Response().WriteHeader(http.StatusOK)
		return nil
	})
	g.POST(""/auth/signup"", func(c echo.Context) error {
		ctx := c.Request().Context()
		signup := &api.Signup{}
		if err := json.NewDecoder(c.Request().Body).Decode(signup); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted signup request"").SetInternal(err)
		}
		hostUserType := api.Host
		hostUserFind := api.UserFind{
			Role: &hostUserType,
		}
		hostUser, err := s.Store.FindUser(ctx, &hostUserFind)
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find host user"").SetInternal(err)
		}
		if signup.Role == api.Host && hostUser != nil {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Site Host existed, please contact the site host to signin account firstly."").SetInternal(err)
		}
		systemSettingAllowSignUpName := api.SystemSettingAllowSignUpName
		allowSignUpSetting, err := s.Store.FindSystemSetting(ctx, &api.SystemSettingFind{
			Name: &systemSettingAllowSignUpName,
		})
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find system setting"").SetInternal(err)
		}
		allowSignUpSettingValue := false
		if allowSignUpSetting != nil {
			err = json.Unmarshal([]byte(allowSignUpSetting.Value), &allowSignUpSettingValue)
			if err != nil {
				return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to unmarshal system setting allow signup"").SetInternal(err)
			}
		}
		if !allowSignUpSettingValue && hostUser != nil {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Site Host existed, please contact the site host to signin account firstly."").SetInternal(err)
		}
		userCreate := &api.UserCreate{
			Username: signup.Username,
			Role:     api.Role(signup.Role),
			Nickname: signup.Username,
			Password: signup.Password,
			OpenID:   common.GenUUID(),
		}
		if err := userCreate.Validate(); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Invalid user create format."").SetInternal(err)
		}
		passwordHash, err := bcrypt.GenerateFromPassword([]byte(signup.Password), bcrypt.DefaultCost)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to generate password hash"").SetInternal(err)
		}
		userCreate.PasswordHash = string(passwordHash)
		user, err := s.Store.CreateUser(ctx, userCreate)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to create user"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""user signed up"",
		})
		err = setUserSession(c, user)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to set signup session"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(user)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode created user response"").SetInternal(err)
		}
		return nil
	})
}
",CWE-940,147.0,1
"package server
import (
	""encoding/json""
	""fmt""
	""net/http""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
	""golang.org/x/crypto/bcrypt""
)
func (s *Server) registerAuthRoutes(g *echo.Group) {
	g.POST(""/auth/signin"", func(c echo.Context) error {
		ctx := c.Request().Context()
		signin := &api.Signin{}
		if err := json.NewDecoder(c.Request().Body).Decode(signin); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted signin request"").SetInternal(err)
		}
		userFind := &api.UserFind{
			Username: &signin.Username,
		}
		user, err := s.Store.FindUser(ctx, userFind)
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to find user by username %s"", signin.Username)).SetInternal(err)
		}
		if user == nil {
			return echo.NewHTTPError(http.StatusUnauthorized, fmt.Sprintf(""User not found with username %s"", signin.Username))
		} else if user.RowStatus == api.Archived {
			return echo.NewHTTPError(http.StatusForbidden, fmt.Sprintf(""User has been archived with username %s"", signin.Username))
		}
		// Compare the stored hashed password, with the hashed version of the password that was received.
		if err := bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(signin.Password)); err != nil {
			// If the two passwords don't match, return a 401 status.
			return echo.NewHTTPError(http.StatusUnauthorized, ""Incorrect password"").SetInternal(err)
		}
		if err = setUserSession(c, user); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to set signin session"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""user signed in"",
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(user)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode user response"").SetInternal(err)
		}
		return nil
	})
	g.POST(""/auth/logout"", func(c echo.Context) error {
		ctx := c.Request().Context()
		err := removeUserSession(c)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to set logout session"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""user logout"",
		})
		c.Response().WriteHeader(http.StatusOK)
		return nil
	})
	g.POST(""/auth/signup"", func(c echo.Context) error {
		ctx := c.Request().Context()
		signup := &api.Signup{}
		if err := json.NewDecoder(c.Request().Body).Decode(signup); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted signup request"").SetInternal(err)
		}
		hostUserType := api.Host
		hostUserFind := api.UserFind{
			Role: &hostUserType,
		}
		hostUser, err := s.Store.FindUser(ctx, &hostUserFind)
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find host user"").SetInternal(err)
		}
		if signup.Role == api.Host && hostUser != nil {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Site Host existed, please contact the site host to signin account firstly."").SetInternal(err)
		}
		systemSettingAllowSignUpName := api.SystemSettingAllowSignUpName
		allowSignUpSetting, err := s.Store.FindSystemSetting(ctx, &api.SystemSettingFind{
			Name: &systemSettingAllowSignUpName,
		})
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find system setting"").SetInternal(err)
		}
		allowSignUpSettingValue := false
		if allowSignUpSetting != nil {
			err = json.Unmarshal([]byte(allowSignUpSetting.Value), &allowSignUpSettingValue)
			if err != nil {
				return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to unmarshal system setting allow signup"").SetInternal(err)
			}
		}
		if !allowSignUpSettingValue && hostUser != nil {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Site Host existed, please contact the site host to signin account firstly."").SetInternal(err)
		}
		userCreate := &api.UserCreate{
			Username: signup.Username,
			Role:     api.Role(signup.Role),
			Nickname: signup.Username,
			Password: signup.Password,
			OpenID:   common.GenUUID(),
		}
		if err := userCreate.Validate(); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Invalid user create format."").SetInternal(err)
		}
		passwordHash, err := bcrypt.GenerateFromPassword([]byte(signup.Password), bcrypt.DefaultCost)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to generate password hash"").SetInternal(err)
		}
		userCreate.PasswordHash = string(passwordHash)
		user, err := s.Store.CreateUser(ctx, userCreate)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to create user"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""user signed up"",
		})
		err = setUserSession(c, user)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to set signup session"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(user)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode created user response"").SetInternal(err)
		}
		return nil
	})
}
",CWE-1220,147.0,1
"package server
import (
	""encoding/json""
	""fmt""
	""net/http""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
	""golang.org/x/crypto/bcrypt""
)
func (s *Server) registerAuthRoutes(g *echo.Group) {
	g.POST(""/auth/signin"", func(c echo.Context) error {
		ctx := c.Request().Context()
		signin := &api.Signin{}
		if err := json.NewDecoder(c.Request().Body).Decode(signin); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted signin request"").SetInternal(err)
		}
		userFind := &api.UserFind{
			Username: &signin.Username,
		}
		user, err := s.Store.FindUser(ctx, userFind)
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to find user by username %s"", signin.Username)).SetInternal(err)
		}
		if user == nil {
			return echo.NewHTTPError(http.StatusUnauthorized, fmt.Sprintf(""User not found with username %s"", signin.Username))
		} else if user.RowStatus == api.Archived {
			return echo.NewHTTPError(http.StatusForbidden, fmt.Sprintf(""User has been archived with username %s"", signin.Username))
		}
		// Compare the stored hashed password, with the hashed version of the password that was received.
		if err := bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(signin.Password)); err != nil {
			// If the two passwords don't match, return a 401 status.
			return echo.NewHTTPError(http.StatusUnauthorized, ""Incorrect password"").SetInternal(err)
		}
		if err = setUserSession(c, user); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to set signin session"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""user signed in"",
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(user)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode user response"").SetInternal(err)
		}
		return nil
	})
	g.POST(""/auth/logout"", func(c echo.Context) error {
		ctx := c.Request().Context()
		err := removeUserSession(c)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to set logout session"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""user logout"",
		})
		c.Response().WriteHeader(http.StatusOK)
		return nil
	})
	g.POST(""/auth/signup"", func(c echo.Context) error {
		ctx := c.Request().Context()
		signup := &api.Signup{}
		if err := json.NewDecoder(c.Request().Body).Decode(signup); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted signup request"").SetInternal(err)
		}
		hostUserType := api.Host
		hostUserFind := api.UserFind{
			Role: &hostUserType,
		}
		hostUser, err := s.Store.FindUser(ctx, &hostUserFind)
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find host user"").SetInternal(err)
		}
		if signup.Role == api.Host && hostUser != nil {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Site Host existed, please contact the site host to signin account firstly."").SetInternal(err)
		}
		systemSettingAllowSignUpName := api.SystemSettingAllowSignUpName
		allowSignUpSetting, err := s.Store.FindSystemSetting(ctx, &api.SystemSettingFind{
			Name: &systemSettingAllowSignUpName,
		})
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find system setting"").SetInternal(err)
		}
		allowSignUpSettingValue := false
		if allowSignUpSetting != nil {
			err = json.Unmarshal([]byte(allowSignUpSetting.Value), &allowSignUpSettingValue)
			if err != nil {
				return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to unmarshal system setting allow signup"").SetInternal(err)
			}
		}
		if !allowSignUpSettingValue && hostUser != nil {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Site Host existed, please contact the site host to signin account firstly."").SetInternal(err)
		}
		userCreate := &api.UserCreate{
			Username: signup.Username,
			Role:     api.Role(signup.Role),
			Nickname: signup.Username,
			Password: signup.Password,
			OpenID:   common.GenUUID(),
		}
		if err := userCreate.Validate(); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Invalid user create format."").SetInternal(err)
		}
		passwordHash, err := bcrypt.GenerateFromPassword([]byte(signup.Password), bcrypt.DefaultCost)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to generate password hash"").SetInternal(err)
		}
		userCreate.PasswordHash = string(passwordHash)
		user, err := s.Store.CreateUser(ctx, userCreate)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to create user"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""user signed up"",
		})
		err = setUserSession(c, user)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to set signup session"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(user)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode created user response"").SetInternal(err)
		}
		return nil
	})
}
",CWE-285,147.0,1
"package server
import (
	""encoding/json""
	""fmt""
	""net/http""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
	""golang.org/x/crypto/bcrypt""
)
func (s *Server) registerAuthRoutes(g *echo.Group) {
	g.POST(""/auth/signin"", func(c echo.Context) error {
		ctx := c.Request().Context()
		signin := &api.Signin{}
		if err := json.NewDecoder(c.Request().Body).Decode(signin); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted signin request"").SetInternal(err)
		}
		userFind := &api.UserFind{
			Username: &signin.Username,
		}
		user, err := s.Store.FindUser(ctx, userFind)
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to find user by username %s"", signin.Username)).SetInternal(err)
		}
		if user == nil {
			return echo.NewHTTPError(http.StatusUnauthorized, fmt.Sprintf(""User not found with username %s"", signin.Username))
		} else if user.RowStatus == api.Archived {
			return echo.NewHTTPError(http.StatusForbidden, fmt.Sprintf(""User has been archived with username %s"", signin.Username))
		}
		// Compare the stored hashed password, with the hashed version of the password that was received.
		if err := bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(signin.Password)); err != nil {
			// If the two passwords don't match, return a 401 status.
			return echo.NewHTTPError(http.StatusUnauthorized, ""Incorrect password"").SetInternal(err)
		}
		if err = setUserSession(c, user); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to set signin session"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""user signed in"",
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(user)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode user response"").SetInternal(err)
		}
		return nil
	})
	g.POST(""/auth/logout"", func(c echo.Context) error {
		ctx := c.Request().Context()
		err := removeUserSession(c)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to set logout session"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""user logout"",
		})
		c.Response().WriteHeader(http.StatusOK)
		return nil
	})
	g.POST(""/auth/signup"", func(c echo.Context) error {
		ctx := c.Request().Context()
		signup := &api.Signup{}
		if err := json.NewDecoder(c.Request().Body).Decode(signup); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted signup request"").SetInternal(err)
		}
		hostUserType := api.Host
		hostUserFind := api.UserFind{
			Role: &hostUserType,
		}
		hostUser, err := s.Store.FindUser(ctx, &hostUserFind)
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find host user"").SetInternal(err)
		}
		if signup.Role == api.Host && hostUser != nil {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Site Host existed, please contact the site host to signin account firstly."").SetInternal(err)
		}
		systemSettingAllowSignUpName := api.SystemSettingAllowSignUpName
		allowSignUpSetting, err := s.Store.FindSystemSetting(ctx, &api.SystemSettingFind{
			Name: &systemSettingAllowSignUpName,
		})
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find system setting"").SetInternal(err)
		}
		allowSignUpSettingValue := false
		if allowSignUpSetting != nil {
			err = json.Unmarshal([]byte(allowSignUpSetting.Value), &allowSignUpSettingValue)
			if err != nil {
				return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to unmarshal system setting allow signup"").SetInternal(err)
			}
		}
		if !allowSignUpSettingValue && hostUser != nil {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Site Host existed, please contact the site host to signin account firstly."").SetInternal(err)
		}
		userCreate := &api.UserCreate{
			Username: signup.Username,
			Role:     api.Role(signup.Role),
			Nickname: signup.Username,
			Password: signup.Password,
			OpenID:   common.GenUUID(),
		}
		if err := userCreate.Validate(); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Invalid user create format."").SetInternal(err)
		}
		passwordHash, err := bcrypt.GenerateFromPassword([]byte(signup.Password), bcrypt.DefaultCost)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to generate password hash"").SetInternal(err)
		}
		userCreate.PasswordHash = string(passwordHash)
		user, err := s.Store.CreateUser(ctx, userCreate)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to create user"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""user signed up"",
		})
		err = setUserSession(c, user)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to set signup session"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(user)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode created user response"").SetInternal(err)
		}
		return nil
	})
}
",CWE-284,147.0,1
"package server
import (
	""encoding/json""
	""fmt""
	""net/http""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
	""golang.org/x/crypto/bcrypt""
)
func (s *Server) registerAuthRoutes(g *echo.Group) {
	g.POST(""/auth/signin"", func(c echo.Context) error {
		ctx := c.Request().Context()
		signin := &api.Signin{}
		if err := json.NewDecoder(c.Request().Body).Decode(signin); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted signin request"").SetInternal(err)
		}
		userFind := &api.UserFind{
			Username: &signin.Username,
		}
		user, err := s.Store.FindUser(ctx, userFind)
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to find user by username %s"", signin.Username)).SetInternal(err)
		}
		if user == nil {
			return echo.NewHTTPError(http.StatusUnauthorized, fmt.Sprintf(""User not found with username %s"", signin.Username))
		} else if user.RowStatus == api.Archived {
			return echo.NewHTTPError(http.StatusForbidden, fmt.Sprintf(""User has been archived with username %s"", signin.Username))
		}
		// Compare the stored hashed password, with the hashed version of the password that was received.
		if err := bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(signin.Password)); err != nil {
			// If the two passwords don't match, return a 401 status.
			return echo.NewHTTPError(http.StatusUnauthorized, ""Incorrect password"").SetInternal(err)
		}
		if err = setUserSession(c, user); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to set signin session"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""user signed in"",
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(user)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode user response"").SetInternal(err)
		}
		return nil
	})
	g.POST(""/auth/logout"", func(c echo.Context) error {
		ctx := c.Request().Context()
		err := removeUserSession(c)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to set logout session"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""user logout"",
		})
		c.Response().WriteHeader(http.StatusOK)
		return nil
	})
	g.POST(""/auth/signup"", func(c echo.Context) error {
		ctx := c.Request().Context()
		signup := &api.Signup{}
		if err := json.NewDecoder(c.Request().Body).Decode(signup); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted signup request"").SetInternal(err)
		}
		hostUserType := api.Host
		hostUserFind := api.UserFind{
			Role: &hostUserType,
		}
		hostUser, err := s.Store.FindUser(ctx, &hostUserFind)
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find host user"").SetInternal(err)
		}
		if signup.Role == api.Host && hostUser != nil {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Site Host existed, please contact the site host to signin account firstly."").SetInternal(err)
		}
		systemSettingAllowSignUpName := api.SystemSettingAllowSignUpName
		allowSignUpSetting, err := s.Store.FindSystemSetting(ctx, &api.SystemSettingFind{
			Name: &systemSettingAllowSignUpName,
		})
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find system setting"").SetInternal(err)
		}
		allowSignUpSettingValue := false
		if allowSignUpSetting != nil {
			err = json.Unmarshal([]byte(allowSignUpSetting.Value), &allowSignUpSettingValue)
			if err != nil {
				return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to unmarshal system setting allow signup"").SetInternal(err)
			}
		}
		if !allowSignUpSettingValue && hostUser != nil {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Site Host existed, please contact the site host to signin account firstly."").SetInternal(err)
		}
		userCreate := &api.UserCreate{
			Username: signup.Username,
			Role:     api.Role(signup.Role),
			Nickname: signup.Username,
			Password: signup.Password,
			OpenID:   common.GenUUID(),
		}
		if err := userCreate.Validate(); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Invalid user create format."").SetInternal(err)
		}
		passwordHash, err := bcrypt.GenerateFromPassword([]byte(signup.Password), bcrypt.DefaultCost)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to generate password hash"").SetInternal(err)
		}
		userCreate.PasswordHash = string(passwordHash)
		user, err := s.Store.CreateUser(ctx, userCreate)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to create user"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""user signed up"",
		})
		err = setUserSession(c, user)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to set signup session"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(user)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode created user response"").SetInternal(err)
		}
		return nil
	})
}
",CWE-229,147.0,1
"package server
import (
	""encoding/json""
	""fmt""
	""net/http""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
	""golang.org/x/crypto/bcrypt""
)
func (s *Server) registerAuthRoutes(g *echo.Group) {
	g.POST(""/auth/signin"", func(c echo.Context) error {
		ctx := c.Request().Context()
		signin := &api.Signin{}
		if err := json.NewDecoder(c.Request().Body).Decode(signin); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted signin request"").SetInternal(err)
		}
		userFind := &api.UserFind{
			Username: &signin.Username,
		}
		user, err := s.Store.FindUser(ctx, userFind)
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to find user by username %s"", signin.Username)).SetInternal(err)
		}
		if user == nil {
			return echo.NewHTTPError(http.StatusUnauthorized, fmt.Sprintf(""User not found with username %s"", signin.Username))
		} else if user.RowStatus == api.Archived {
			return echo.NewHTTPError(http.StatusForbidden, fmt.Sprintf(""User has been archived with username %s"", signin.Username))
		}
		// Compare the stored hashed password, with the hashed version of the password that was received.
		if err := bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(signin.Password)); err != nil {
			// If the two passwords don't match, return a 401 status.
			return echo.NewHTTPError(http.StatusUnauthorized, ""Incorrect password"").SetInternal(err)
		}
		if err = setUserSession(c, user); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to set signin session"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""user signed in"",
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(user)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode user response"").SetInternal(err)
		}
		return nil
	})
	g.POST(""/auth/logout"", func(c echo.Context) error {
		ctx := c.Request().Context()
		err := removeUserSession(c)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to set logout session"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""user logout"",
		})
		c.Response().WriteHeader(http.StatusOK)
		return nil
	})
	g.POST(""/auth/signup"", func(c echo.Context) error {
		ctx := c.Request().Context()
		signup := &api.Signup{}
		if err := json.NewDecoder(c.Request().Body).Decode(signup); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted signup request"").SetInternal(err)
		}
		hostUserType := api.Host
		hostUserFind := api.UserFind{
			Role: &hostUserType,
		}
		hostUser, err := s.Store.FindUser(ctx, &hostUserFind)
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find host user"").SetInternal(err)
		}
		if signup.Role == api.Host && hostUser != nil {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Site Host existed, please contact the site host to signin account firstly."").SetInternal(err)
		}
		systemSettingAllowSignUpName := api.SystemSettingAllowSignUpName
		allowSignUpSetting, err := s.Store.FindSystemSetting(ctx, &api.SystemSettingFind{
			Name: &systemSettingAllowSignUpName,
		})
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find system setting"").SetInternal(err)
		}
		allowSignUpSettingValue := false
		if allowSignUpSetting != nil {
			err = json.Unmarshal([]byte(allowSignUpSetting.Value), &allowSignUpSettingValue)
			if err != nil {
				return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to unmarshal system setting allow signup"").SetInternal(err)
			}
		}
		if !allowSignUpSettingValue && hostUser != nil {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Site Host existed, please contact the site host to signin account firstly."").SetInternal(err)
		}
		userCreate := &api.UserCreate{
			Username: signup.Username,
			Role:     api.Role(signup.Role),
			Nickname: signup.Username,
			Password: signup.Password,
			OpenID:   common.GenUUID(),
		}
		if err := userCreate.Validate(); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Invalid user create format."").SetInternal(err)
		}
		passwordHash, err := bcrypt.GenerateFromPassword([]byte(signup.Password), bcrypt.DefaultCost)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to generate password hash"").SetInternal(err)
		}
		userCreate.PasswordHash = string(passwordHash)
		user, err := s.Store.CreateUser(ctx, userCreate)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to create user"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""user signed up"",
		})
		err = setUserSession(c, user)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to set signup session"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(user)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode created user response"").SetInternal(err)
		}
		return nil
	})
}
",CWE-280,147.0,1
"package server
import (
	""encoding/json""
	""fmt""
	""net/http""
	""strconv""
	""time""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
)
func (s *Server) registerShortcutRoutes(g *echo.Group) {
	g.POST(""/shortcut"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		shortcutCreate := &api.ShortcutCreate{
			CreatorID: userID,
		}
		if err := json.NewDecoder(c.Request().Body).Decode(shortcutCreate); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted post shortcut request"").SetInternal(err)
		}
		shortcut, err := s.Store.CreateShortcut(ctx, shortcutCreate)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to create shortcut"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""shortcut created"",
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut response"").SetInternal(err)
		}
		return nil
	})
	g.PATCH(""/shortcut/:shortcutId"", func(c echo.Context) error {
		ctx := c.Request().Context()
		shortcutID, err := strconv.Atoi(c.Param(""shortcutId""))
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(""ID is not a number: %s"", c.Param(""shortcutId""))).SetInternal(err)
		}
		currentTs := time.Now().Unix()
		shortcutPatch := &api.ShortcutPatch{
			ID:        shortcutID,
			UpdatedTs: &currentTs,
		}
		if err := json.NewDecoder(c.Request().Body).Decode(shortcutPatch); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted patch shortcut request"").SetInternal(err)
		}
		shortcut, err := s.Store.PatchShortcut(ctx, shortcutPatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to patch shortcut"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/shortcut"", func(c echo.Context) error {
		ctx := c.Request().Context()
		shortcutFind := &api.ShortcutFind{}
		if userID, err := strconv.Atoi(c.QueryParam(""creatorId"")); err == nil {
			shortcutFind.CreatorID = &userID
		} else {
			userID, ok := c.Get(getUserIDContextKey()).(int)
			if !ok {
				return echo.NewHTTPError(http.StatusBadRequest, ""Missing user id to find shortcut"")
			}
			shortcutFind.CreatorID = &userID
		}
		list, err := s.Store.FindShortcutList(ctx, shortcutFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to fetch shortcut list"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(list)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut list response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/shortcut/:shortcutId"", func(c echo.Context) error {
		ctx := c.Request().Context()
		shortcutID, err := strconv.Atoi(c.Param(""shortcutId""))
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(""ID is not a number: %s"", c.Param(""shortcutId""))).SetInternal(err)
		}
		shortcutFind := &api.ShortcutFind{
			ID: &shortcutID,
		}
		shortcut, err := s.Store.FindShortcut(ctx, shortcutFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to fetch shortcut by ID %d"", *shortcutFind.ID)).SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut response"").SetInternal(err)
		}
		return nil
	})
	g.DELETE(""/shortcut/:shortcutId"", func(c echo.Context) error {
		ctx := c.Request().Context()
		shortcutID, err := strconv.Atoi(c.Param(""shortcutId""))
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(""ID is not a number: %s"", c.Param(""shortcutId""))).SetInternal(err)
		}
		shortcutDelete := &api.ShortcutDelete{
			ID: &shortcutID,
		}
		if err := s.Store.DeleteShortcut(ctx, shortcutDelete); err != nil {
			if common.ErrorCode(err) == common.NotFound {
				return echo.NewHTTPError(http.StatusNotFound, fmt.Sprintf(""Shortcut ID not found: %d"", shortcutID))
			}
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to delete shortcut"").SetInternal(err)
		}
		return c.JSON(http.StatusOK, true)
	})
}
",CWE-648,143.0,1
"package server
import (
	""encoding/json""
	""fmt""
	""net/http""
	""strconv""
	""time""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
)
func (s *Server) registerShortcutRoutes(g *echo.Group) {
	g.POST(""/shortcut"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		shortcutCreate := &api.ShortcutCreate{
			CreatorID: userID,
		}
		if err := json.NewDecoder(c.Request().Body).Decode(shortcutCreate); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted post shortcut request"").SetInternal(err)
		}
		shortcut, err := s.Store.CreateShortcut(ctx, shortcutCreate)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to create shortcut"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""shortcut created"",
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut response"").SetInternal(err)
		}
		return nil
	})
	g.PATCH(""/shortcut/:shortcutId"", func(c echo.Context) error {
		ctx := c.Request().Context()
		shortcutID, err := strconv.Atoi(c.Param(""shortcutId""))
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(""ID is not a number: %s"", c.Param(""shortcutId""))).SetInternal(err)
		}
		currentTs := time.Now().Unix()
		shortcutPatch := &api.ShortcutPatch{
			ID:        shortcutID,
			UpdatedTs: &currentTs,
		}
		if err := json.NewDecoder(c.Request().Body).Decode(shortcutPatch); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted patch shortcut request"").SetInternal(err)
		}
		shortcut, err := s.Store.PatchShortcut(ctx, shortcutPatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to patch shortcut"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/shortcut"", func(c echo.Context) error {
		ctx := c.Request().Context()
		shortcutFind := &api.ShortcutFind{}
		if userID, err := strconv.Atoi(c.QueryParam(""creatorId"")); err == nil {
			shortcutFind.CreatorID = &userID
		} else {
			userID, ok := c.Get(getUserIDContextKey()).(int)
			if !ok {
				return echo.NewHTTPError(http.StatusBadRequest, ""Missing user id to find shortcut"")
			}
			shortcutFind.CreatorID = &userID
		}
		list, err := s.Store.FindShortcutList(ctx, shortcutFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to fetch shortcut list"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(list)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut list response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/shortcut/:shortcutId"", func(c echo.Context) error {
		ctx := c.Request().Context()
		shortcutID, err := strconv.Atoi(c.Param(""shortcutId""))
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(""ID is not a number: %s"", c.Param(""shortcutId""))).SetInternal(err)
		}
		shortcutFind := &api.ShortcutFind{
			ID: &shortcutID,
		}
		shortcut, err := s.Store.FindShortcut(ctx, shortcutFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to fetch shortcut by ID %d"", *shortcutFind.ID)).SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut response"").SetInternal(err)
		}
		return nil
	})
	g.DELETE(""/shortcut/:shortcutId"", func(c echo.Context) error {
		ctx := c.Request().Context()
		shortcutID, err := strconv.Atoi(c.Param(""shortcutId""))
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(""ID is not a number: %s"", c.Param(""shortcutId""))).SetInternal(err)
		}
		shortcutDelete := &api.ShortcutDelete{
			ID: &shortcutID,
		}
		if err := s.Store.DeleteShortcut(ctx, shortcutDelete); err != nil {
			if common.ErrorCode(err) == common.NotFound {
				return echo.NewHTTPError(http.StatusNotFound, fmt.Sprintf(""Shortcut ID not found: %d"", shortcutID))
			}
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to delete shortcut"").SetInternal(err)
		}
		return c.JSON(http.StatusOK, true)
	})
}
",CWE-307,143.0,1
"package server
import (
	""encoding/json""
	""fmt""
	""net/http""
	""strconv""
	""time""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
)
func (s *Server) registerShortcutRoutes(g *echo.Group) {
	g.POST(""/shortcut"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		shortcutCreate := &api.ShortcutCreate{
			CreatorID: userID,
		}
		if err := json.NewDecoder(c.Request().Body).Decode(shortcutCreate); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted post shortcut request"").SetInternal(err)
		}
		shortcut, err := s.Store.CreateShortcut(ctx, shortcutCreate)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to create shortcut"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""shortcut created"",
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut response"").SetInternal(err)
		}
		return nil
	})
	g.PATCH(""/shortcut/:shortcutId"", func(c echo.Context) error {
		ctx := c.Request().Context()
		shortcutID, err := strconv.Atoi(c.Param(""shortcutId""))
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(""ID is not a number: %s"", c.Param(""shortcutId""))).SetInternal(err)
		}
		currentTs := time.Now().Unix()
		shortcutPatch := &api.ShortcutPatch{
			ID:        shortcutID,
			UpdatedTs: &currentTs,
		}
		if err := json.NewDecoder(c.Request().Body).Decode(shortcutPatch); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted patch shortcut request"").SetInternal(err)
		}
		shortcut, err := s.Store.PatchShortcut(ctx, shortcutPatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to patch shortcut"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/shortcut"", func(c echo.Context) error {
		ctx := c.Request().Context()
		shortcutFind := &api.ShortcutFind{}
		if userID, err := strconv.Atoi(c.QueryParam(""creatorId"")); err == nil {
			shortcutFind.CreatorID = &userID
		} else {
			userID, ok := c.Get(getUserIDContextKey()).(int)
			if !ok {
				return echo.NewHTTPError(http.StatusBadRequest, ""Missing user id to find shortcut"")
			}
			shortcutFind.CreatorID = &userID
		}
		list, err := s.Store.FindShortcutList(ctx, shortcutFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to fetch shortcut list"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(list)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut list response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/shortcut/:shortcutId"", func(c echo.Context) error {
		ctx := c.Request().Context()
		shortcutID, err := strconv.Atoi(c.Param(""shortcutId""))
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(""ID is not a number: %s"", c.Param(""shortcutId""))).SetInternal(err)
		}
		shortcutFind := &api.ShortcutFind{
			ID: &shortcutID,
		}
		shortcut, err := s.Store.FindShortcut(ctx, shortcutFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to fetch shortcut by ID %d"", *shortcutFind.ID)).SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut response"").SetInternal(err)
		}
		return nil
	})
	g.DELETE(""/shortcut/:shortcutId"", func(c echo.Context) error {
		ctx := c.Request().Context()
		shortcutID, err := strconv.Atoi(c.Param(""shortcutId""))
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(""ID is not a number: %s"", c.Param(""shortcutId""))).SetInternal(err)
		}
		shortcutDelete := &api.ShortcutDelete{
			ID: &shortcutID,
		}
		if err := s.Store.DeleteShortcut(ctx, shortcutDelete); err != nil {
			if common.ErrorCode(err) == common.NotFound {
				return echo.NewHTTPError(http.StatusNotFound, fmt.Sprintf(""Shortcut ID not found: %d"", shortcutID))
			}
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to delete shortcut"").SetInternal(err)
		}
		return c.JSON(http.StatusOK, true)
	})
}
",CWE-639,143.0,1
"package server
import (
	""encoding/json""
	""fmt""
	""net/http""
	""strconv""
	""time""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
)
func (s *Server) registerShortcutRoutes(g *echo.Group) {
	g.POST(""/shortcut"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		shortcutCreate := &api.ShortcutCreate{
			CreatorID: userID,
		}
		if err := json.NewDecoder(c.Request().Body).Decode(shortcutCreate); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted post shortcut request"").SetInternal(err)
		}
		shortcut, err := s.Store.CreateShortcut(ctx, shortcutCreate)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to create shortcut"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""shortcut created"",
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut response"").SetInternal(err)
		}
		return nil
	})
	g.PATCH(""/shortcut/:shortcutId"", func(c echo.Context) error {
		ctx := c.Request().Context()
		shortcutID, err := strconv.Atoi(c.Param(""shortcutId""))
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(""ID is not a number: %s"", c.Param(""shortcutId""))).SetInternal(err)
		}
		currentTs := time.Now().Unix()
		shortcutPatch := &api.ShortcutPatch{
			ID:        shortcutID,
			UpdatedTs: &currentTs,
		}
		if err := json.NewDecoder(c.Request().Body).Decode(shortcutPatch); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted patch shortcut request"").SetInternal(err)
		}
		shortcut, err := s.Store.PatchShortcut(ctx, shortcutPatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to patch shortcut"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/shortcut"", func(c echo.Context) error {
		ctx := c.Request().Context()
		shortcutFind := &api.ShortcutFind{}
		if userID, err := strconv.Atoi(c.QueryParam(""creatorId"")); err == nil {
			shortcutFind.CreatorID = &userID
		} else {
			userID, ok := c.Get(getUserIDContextKey()).(int)
			if !ok {
				return echo.NewHTTPError(http.StatusBadRequest, ""Missing user id to find shortcut"")
			}
			shortcutFind.CreatorID = &userID
		}
		list, err := s.Store.FindShortcutList(ctx, shortcutFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to fetch shortcut list"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(list)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut list response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/shortcut/:shortcutId"", func(c echo.Context) error {
		ctx := c.Request().Context()
		shortcutID, err := strconv.Atoi(c.Param(""shortcutId""))
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(""ID is not a number: %s"", c.Param(""shortcutId""))).SetInternal(err)
		}
		shortcutFind := &api.ShortcutFind{
			ID: &shortcutID,
		}
		shortcut, err := s.Store.FindShortcut(ctx, shortcutFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to fetch shortcut by ID %d"", *shortcutFind.ID)).SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut response"").SetInternal(err)
		}
		return nil
	})
	g.DELETE(""/shortcut/:shortcutId"", func(c echo.Context) error {
		ctx := c.Request().Context()
		shortcutID, err := strconv.Atoi(c.Param(""shortcutId""))
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(""ID is not a number: %s"", c.Param(""shortcutId""))).SetInternal(err)
		}
		shortcutDelete := &api.ShortcutDelete{
			ID: &shortcutID,
		}
		if err := s.Store.DeleteShortcut(ctx, shortcutDelete); err != nil {
			if common.ErrorCode(err) == common.NotFound {
				return echo.NewHTTPError(http.StatusNotFound, fmt.Sprintf(""Shortcut ID not found: %d"", shortcutID))
			}
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to delete shortcut"").SetInternal(err)
		}
		return c.JSON(http.StatusOK, true)
	})
}
",CWE-940,143.0,1
"package server
import (
	""encoding/json""
	""fmt""
	""net/http""
	""strconv""
	""time""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
)
func (s *Server) registerShortcutRoutes(g *echo.Group) {
	g.POST(""/shortcut"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		shortcutCreate := &api.ShortcutCreate{
			CreatorID: userID,
		}
		if err := json.NewDecoder(c.Request().Body).Decode(shortcutCreate); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted post shortcut request"").SetInternal(err)
		}
		shortcut, err := s.Store.CreateShortcut(ctx, shortcutCreate)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to create shortcut"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""shortcut created"",
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut response"").SetInternal(err)
		}
		return nil
	})
	g.PATCH(""/shortcut/:shortcutId"", func(c echo.Context) error {
		ctx := c.Request().Context()
		shortcutID, err := strconv.Atoi(c.Param(""shortcutId""))
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(""ID is not a number: %s"", c.Param(""shortcutId""))).SetInternal(err)
		}
		currentTs := time.Now().Unix()
		shortcutPatch := &api.ShortcutPatch{
			ID:        shortcutID,
			UpdatedTs: &currentTs,
		}
		if err := json.NewDecoder(c.Request().Body).Decode(shortcutPatch); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted patch shortcut request"").SetInternal(err)
		}
		shortcut, err := s.Store.PatchShortcut(ctx, shortcutPatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to patch shortcut"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/shortcut"", func(c echo.Context) error {
		ctx := c.Request().Context()
		shortcutFind := &api.ShortcutFind{}
		if userID, err := strconv.Atoi(c.QueryParam(""creatorId"")); err == nil {
			shortcutFind.CreatorID = &userID
		} else {
			userID, ok := c.Get(getUserIDContextKey()).(int)
			if !ok {
				return echo.NewHTTPError(http.StatusBadRequest, ""Missing user id to find shortcut"")
			}
			shortcutFind.CreatorID = &userID
		}
		list, err := s.Store.FindShortcutList(ctx, shortcutFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to fetch shortcut list"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(list)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut list response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/shortcut/:shortcutId"", func(c echo.Context) error {
		ctx := c.Request().Context()
		shortcutID, err := strconv.Atoi(c.Param(""shortcutId""))
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(""ID is not a number: %s"", c.Param(""shortcutId""))).SetInternal(err)
		}
		shortcutFind := &api.ShortcutFind{
			ID: &shortcutID,
		}
		shortcut, err := s.Store.FindShortcut(ctx, shortcutFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to fetch shortcut by ID %d"", *shortcutFind.ID)).SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut response"").SetInternal(err)
		}
		return nil
	})
	g.DELETE(""/shortcut/:shortcutId"", func(c echo.Context) error {
		ctx := c.Request().Context()
		shortcutID, err := strconv.Atoi(c.Param(""shortcutId""))
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(""ID is not a number: %s"", c.Param(""shortcutId""))).SetInternal(err)
		}
		shortcutDelete := &api.ShortcutDelete{
			ID: &shortcutID,
		}
		if err := s.Store.DeleteShortcut(ctx, shortcutDelete); err != nil {
			if common.ErrorCode(err) == common.NotFound {
				return echo.NewHTTPError(http.StatusNotFound, fmt.Sprintf(""Shortcut ID not found: %d"", shortcutID))
			}
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to delete shortcut"").SetInternal(err)
		}
		return c.JSON(http.StatusOK, true)
	})
}
",CWE-1220,143.0,1
"package server
import (
	""encoding/json""
	""fmt""
	""net/http""
	""strconv""
	""time""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
)
func (s *Server) registerShortcutRoutes(g *echo.Group) {
	g.POST(""/shortcut"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		shortcutCreate := &api.ShortcutCreate{
			CreatorID: userID,
		}
		if err := json.NewDecoder(c.Request().Body).Decode(shortcutCreate); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted post shortcut request"").SetInternal(err)
		}
		shortcut, err := s.Store.CreateShortcut(ctx, shortcutCreate)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to create shortcut"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""shortcut created"",
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut response"").SetInternal(err)
		}
		return nil
	})
	g.PATCH(""/shortcut/:shortcutId"", func(c echo.Context) error {
		ctx := c.Request().Context()
		shortcutID, err := strconv.Atoi(c.Param(""shortcutId""))
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(""ID is not a number: %s"", c.Param(""shortcutId""))).SetInternal(err)
		}
		currentTs := time.Now().Unix()
		shortcutPatch := &api.ShortcutPatch{
			ID:        shortcutID,
			UpdatedTs: &currentTs,
		}
		if err := json.NewDecoder(c.Request().Body).Decode(shortcutPatch); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted patch shortcut request"").SetInternal(err)
		}
		shortcut, err := s.Store.PatchShortcut(ctx, shortcutPatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to patch shortcut"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/shortcut"", func(c echo.Context) error {
		ctx := c.Request().Context()
		shortcutFind := &api.ShortcutFind{}
		if userID, err := strconv.Atoi(c.QueryParam(""creatorId"")); err == nil {
			shortcutFind.CreatorID = &userID
		} else {
			userID, ok := c.Get(getUserIDContextKey()).(int)
			if !ok {
				return echo.NewHTTPError(http.StatusBadRequest, ""Missing user id to find shortcut"")
			}
			shortcutFind.CreatorID = &userID
		}
		list, err := s.Store.FindShortcutList(ctx, shortcutFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to fetch shortcut list"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(list)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut list response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/shortcut/:shortcutId"", func(c echo.Context) error {
		ctx := c.Request().Context()
		shortcutID, err := strconv.Atoi(c.Param(""shortcutId""))
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(""ID is not a number: %s"", c.Param(""shortcutId""))).SetInternal(err)
		}
		shortcutFind := &api.ShortcutFind{
			ID: &shortcutID,
		}
		shortcut, err := s.Store.FindShortcut(ctx, shortcutFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to fetch shortcut by ID %d"", *shortcutFind.ID)).SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut response"").SetInternal(err)
		}
		return nil
	})
	g.DELETE(""/shortcut/:shortcutId"", func(c echo.Context) error {
		ctx := c.Request().Context()
		shortcutID, err := strconv.Atoi(c.Param(""shortcutId""))
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(""ID is not a number: %s"", c.Param(""shortcutId""))).SetInternal(err)
		}
		shortcutDelete := &api.ShortcutDelete{
			ID: &shortcutID,
		}
		if err := s.Store.DeleteShortcut(ctx, shortcutDelete); err != nil {
			if common.ErrorCode(err) == common.NotFound {
				return echo.NewHTTPError(http.StatusNotFound, fmt.Sprintf(""Shortcut ID not found: %d"", shortcutID))
			}
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to delete shortcut"").SetInternal(err)
		}
		return c.JSON(http.StatusOK, true)
	})
}
",CWE-285,143.0,1
"package server
import (
	""encoding/json""
	""fmt""
	""net/http""
	""strconv""
	""time""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
)
func (s *Server) registerShortcutRoutes(g *echo.Group) {
	g.POST(""/shortcut"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		shortcutCreate := &api.ShortcutCreate{
			CreatorID: userID,
		}
		if err := json.NewDecoder(c.Request().Body).Decode(shortcutCreate); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted post shortcut request"").SetInternal(err)
		}
		shortcut, err := s.Store.CreateShortcut(ctx, shortcutCreate)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to create shortcut"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""shortcut created"",
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut response"").SetInternal(err)
		}
		return nil
	})
	g.PATCH(""/shortcut/:shortcutId"", func(c echo.Context) error {
		ctx := c.Request().Context()
		shortcutID, err := strconv.Atoi(c.Param(""shortcutId""))
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(""ID is not a number: %s"", c.Param(""shortcutId""))).SetInternal(err)
		}
		currentTs := time.Now().Unix()
		shortcutPatch := &api.ShortcutPatch{
			ID:        shortcutID,
			UpdatedTs: &currentTs,
		}
		if err := json.NewDecoder(c.Request().Body).Decode(shortcutPatch); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted patch shortcut request"").SetInternal(err)
		}
		shortcut, err := s.Store.PatchShortcut(ctx, shortcutPatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to patch shortcut"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/shortcut"", func(c echo.Context) error {
		ctx := c.Request().Context()
		shortcutFind := &api.ShortcutFind{}
		if userID, err := strconv.Atoi(c.QueryParam(""creatorId"")); err == nil {
			shortcutFind.CreatorID = &userID
		} else {
			userID, ok := c.Get(getUserIDContextKey()).(int)
			if !ok {
				return echo.NewHTTPError(http.StatusBadRequest, ""Missing user id to find shortcut"")
			}
			shortcutFind.CreatorID = &userID
		}
		list, err := s.Store.FindShortcutList(ctx, shortcutFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to fetch shortcut list"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(list)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut list response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/shortcut/:shortcutId"", func(c echo.Context) error {
		ctx := c.Request().Context()
		shortcutID, err := strconv.Atoi(c.Param(""shortcutId""))
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(""ID is not a number: %s"", c.Param(""shortcutId""))).SetInternal(err)
		}
		shortcutFind := &api.ShortcutFind{
			ID: &shortcutID,
		}
		shortcut, err := s.Store.FindShortcut(ctx, shortcutFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to fetch shortcut by ID %d"", *shortcutFind.ID)).SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut response"").SetInternal(err)
		}
		return nil
	})
	g.DELETE(""/shortcut/:shortcutId"", func(c echo.Context) error {
		ctx := c.Request().Context()
		shortcutID, err := strconv.Atoi(c.Param(""shortcutId""))
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(""ID is not a number: %s"", c.Param(""shortcutId""))).SetInternal(err)
		}
		shortcutDelete := &api.ShortcutDelete{
			ID: &shortcutID,
		}
		if err := s.Store.DeleteShortcut(ctx, shortcutDelete); err != nil {
			if common.ErrorCode(err) == common.NotFound {
				return echo.NewHTTPError(http.StatusNotFound, fmt.Sprintf(""Shortcut ID not found: %d"", shortcutID))
			}
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to delete shortcut"").SetInternal(err)
		}
		return c.JSON(http.StatusOK, true)
	})
}
",CWE-284,143.0,1
"package server
import (
	""encoding/json""
	""fmt""
	""net/http""
	""strconv""
	""time""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
)
func (s *Server) registerShortcutRoutes(g *echo.Group) {
	g.POST(""/shortcut"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		shortcutCreate := &api.ShortcutCreate{
			CreatorID: userID,
		}
		if err := json.NewDecoder(c.Request().Body).Decode(shortcutCreate); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted post shortcut request"").SetInternal(err)
		}
		shortcut, err := s.Store.CreateShortcut(ctx, shortcutCreate)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to create shortcut"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""shortcut created"",
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut response"").SetInternal(err)
		}
		return nil
	})
	g.PATCH(""/shortcut/:shortcutId"", func(c echo.Context) error {
		ctx := c.Request().Context()
		shortcutID, err := strconv.Atoi(c.Param(""shortcutId""))
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(""ID is not a number: %s"", c.Param(""shortcutId""))).SetInternal(err)
		}
		currentTs := time.Now().Unix()
		shortcutPatch := &api.ShortcutPatch{
			ID:        shortcutID,
			UpdatedTs: &currentTs,
		}
		if err := json.NewDecoder(c.Request().Body).Decode(shortcutPatch); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted patch shortcut request"").SetInternal(err)
		}
		shortcut, err := s.Store.PatchShortcut(ctx, shortcutPatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to patch shortcut"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/shortcut"", func(c echo.Context) error {
		ctx := c.Request().Context()
		shortcutFind := &api.ShortcutFind{}
		if userID, err := strconv.Atoi(c.QueryParam(""creatorId"")); err == nil {
			shortcutFind.CreatorID = &userID
		} else {
			userID, ok := c.Get(getUserIDContextKey()).(int)
			if !ok {
				return echo.NewHTTPError(http.StatusBadRequest, ""Missing user id to find shortcut"")
			}
			shortcutFind.CreatorID = &userID
		}
		list, err := s.Store.FindShortcutList(ctx, shortcutFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to fetch shortcut list"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(list)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut list response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/shortcut/:shortcutId"", func(c echo.Context) error {
		ctx := c.Request().Context()
		shortcutID, err := strconv.Atoi(c.Param(""shortcutId""))
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(""ID is not a number: %s"", c.Param(""shortcutId""))).SetInternal(err)
		}
		shortcutFind := &api.ShortcutFind{
			ID: &shortcutID,
		}
		shortcut, err := s.Store.FindShortcut(ctx, shortcutFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to fetch shortcut by ID %d"", *shortcutFind.ID)).SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut response"").SetInternal(err)
		}
		return nil
	})
	g.DELETE(""/shortcut/:shortcutId"", func(c echo.Context) error {
		ctx := c.Request().Context()
		shortcutID, err := strconv.Atoi(c.Param(""shortcutId""))
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(""ID is not a number: %s"", c.Param(""shortcutId""))).SetInternal(err)
		}
		shortcutDelete := &api.ShortcutDelete{
			ID: &shortcutID,
		}
		if err := s.Store.DeleteShortcut(ctx, shortcutDelete); err != nil {
			if common.ErrorCode(err) == common.NotFound {
				return echo.NewHTTPError(http.StatusNotFound, fmt.Sprintf(""Shortcut ID not found: %d"", shortcutID))
			}
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to delete shortcut"").SetInternal(err)
		}
		return c.JSON(http.StatusOK, true)
	})
}
",CWE-229,143.0,1
"package server
import (
	""encoding/json""
	""fmt""
	""net/http""
	""strconv""
	""time""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
)
func (s *Server) registerShortcutRoutes(g *echo.Group) {
	g.POST(""/shortcut"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		shortcutCreate := &api.ShortcutCreate{
			CreatorID: userID,
		}
		if err := json.NewDecoder(c.Request().Body).Decode(shortcutCreate); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted post shortcut request"").SetInternal(err)
		}
		shortcut, err := s.Store.CreateShortcut(ctx, shortcutCreate)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to create shortcut"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""shortcut created"",
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut response"").SetInternal(err)
		}
		return nil
	})
	g.PATCH(""/shortcut/:shortcutId"", func(c echo.Context) error {
		ctx := c.Request().Context()
		shortcutID, err := strconv.Atoi(c.Param(""shortcutId""))
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(""ID is not a number: %s"", c.Param(""shortcutId""))).SetInternal(err)
		}
		currentTs := time.Now().Unix()
		shortcutPatch := &api.ShortcutPatch{
			ID:        shortcutID,
			UpdatedTs: &currentTs,
		}
		if err := json.NewDecoder(c.Request().Body).Decode(shortcutPatch); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted patch shortcut request"").SetInternal(err)
		}
		shortcut, err := s.Store.PatchShortcut(ctx, shortcutPatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to patch shortcut"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/shortcut"", func(c echo.Context) error {
		ctx := c.Request().Context()
		shortcutFind := &api.ShortcutFind{}
		if userID, err := strconv.Atoi(c.QueryParam(""creatorId"")); err == nil {
			shortcutFind.CreatorID = &userID
		} else {
			userID, ok := c.Get(getUserIDContextKey()).(int)
			if !ok {
				return echo.NewHTTPError(http.StatusBadRequest, ""Missing user id to find shortcut"")
			}
			shortcutFind.CreatorID = &userID
		}
		list, err := s.Store.FindShortcutList(ctx, shortcutFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to fetch shortcut list"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(list)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut list response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/shortcut/:shortcutId"", func(c echo.Context) error {
		ctx := c.Request().Context()
		shortcutID, err := strconv.Atoi(c.Param(""shortcutId""))
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(""ID is not a number: %s"", c.Param(""shortcutId""))).SetInternal(err)
		}
		shortcutFind := &api.ShortcutFind{
			ID: &shortcutID,
		}
		shortcut, err := s.Store.FindShortcut(ctx, shortcutFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to fetch shortcut by ID %d"", *shortcutFind.ID)).SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut response"").SetInternal(err)
		}
		return nil
	})
	g.DELETE(""/shortcut/:shortcutId"", func(c echo.Context) error {
		ctx := c.Request().Context()
		shortcutID, err := strconv.Atoi(c.Param(""shortcutId""))
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(""ID is not a number: %s"", c.Param(""shortcutId""))).SetInternal(err)
		}
		shortcutDelete := &api.ShortcutDelete{
			ID: &shortcutID,
		}
		if err := s.Store.DeleteShortcut(ctx, shortcutDelete); err != nil {
			if common.ErrorCode(err) == common.NotFound {
				return echo.NewHTTPError(http.StatusNotFound, fmt.Sprintf(""Shortcut ID not found: %d"", shortcutID))
			}
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to delete shortcut"").SetInternal(err)
		}
		return c.JSON(http.StatusOK, true)
	})
}
",CWE-280,143.0,1
"package server
import (
	""encoding/json""
	""fmt""
	""net/http""
	""regexp""
	""sort""
	""strconv""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
)
func (s *Server) registerTagRoutes(g *echo.Group) {
	g.POST(""/tag"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		tagUpsert := &api.TagUpsert{
			CreatorID: userID,
		}
		if err := json.NewDecoder(c.Request().Body).Decode(tagUpsert); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted post tag request"").SetInternal(err)
		}
		if tagUpsert.Name == """" {
			return echo.NewHTTPError(http.StatusBadRequest, ""Tag name shouldn't be empty"")
		}
		tag, err := s.Store.UpsertTag(ctx, tagUpsert)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to upsert tag"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""tag created"",
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tag.Name)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode tag response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/tag"", func(c echo.Context) error {
		ctx := c.Request().Context()
		tagFind := &api.TagFind{}
		if userID, err := strconv.Atoi(c.QueryParam(""creatorId"")); err == nil {
			tagFind.CreatorID = userID
		}
		if tagFind.CreatorID == 0 {
			currentUserID, ok := c.Get(getUserIDContextKey()).(int)
			if !ok {
				return echo.NewHTTPError(http.StatusBadRequest, ""Missing user id to find tag"")
			}
			tagFind.CreatorID = currentUserID
		}
		tagList, err := s.Store.FindTagList(ctx, tagFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find tag list"").SetInternal(err)
		}
		tagNameList := []string{}
		for _, tag := range tagList {
			tagNameList = append(tagNameList, tag.Name)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tagNameList)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode tags response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/tag/suggestion"", func(c echo.Context) error {
		ctx := c.Request().Context()
		contentSearch := ""
		normalRowStatus := api.Normal
		memoFind := api.MemoFind{
			ContentSearch: &contentSearch,
			RowStatus:     &normalRowStatus,
		}
		if userID, err := strconv.Atoi(c.QueryParam(""creatorId"")); err == nil {
			memoFind.CreatorID = &userID
		}
		currentUserID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			if memoFind.CreatorID == nil {
				return echo.NewHTTPError(http.StatusBadRequest, ""Missing user id to find memo"")
			}
			memoFind.VisibilityList = []api.Visibility{api.Public}
		} else {
			if memoFind.CreatorID == nil {
				memoFind.CreatorID = &currentUserID
			} else {
				memoFind.VisibilityList = []api.Visibility{api.Public, api.Protected}
			}
		}
		memoList, err := s.Store.FindMemoList(ctx, &memoFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find memo list"").SetInternal(err)
		}
		tagMapSet := make(map[string]bool)
		for _, memo := range memoList {
			for _, tag := range findTagListFromMemoContent(memo.Content) {
				tagMapSet[tag] = true
			}
		}
		tagList := []string{}
		for tag := range tagMapSet {
			tagList = append(tagList, tag)
		}
		sort.Strings(tagList)
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tagList)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode tags response"").SetInternal(err)
		}
		return nil
	})
	g.DELETE(""/tag/:tagName"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		tagName := c.Param(""tagName"")
		if tagName == """" {
			return echo.NewHTTPError(http.StatusBadRequest, ""Tag name cannot be empty"")
		}
		tagDelete := &api.TagDelete{
			Name:      tagName,
			CreatorID: userID,
		}
		if err := s.Store.DeleteTag(ctx, tagDelete); err != nil {
			if common.ErrorCode(err) == common.NotFound {
				return echo.NewHTTPError(http.StatusNotFound, fmt.Sprintf(""Tag name not found: %s"", tagName))
			}
			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to delete tag name: %v"", tagName)).SetInternal(err)
		}
		return c.JSON(http.StatusOK, true)
	})
}
var tagRegexp = regexp.MustCompile(`
func findTagListFromMemoContent(memoContent string) []string {
	tagMapSet := make(map[string]bool)
	matches := tagRegexp.FindAllStringSubmatch(memoContent, -1)
	for _, v := range matches {
		tagName := v[1]
		tagMapSet[tagName] = true
	}
	tagList := []string{}
	for tag := range tagMapSet {
		tagList = append(tagList, tag)
	}
	sort.Strings(tagList)
	return tagList
}
",CWE-648,178.0,1
"package server
import (
	""encoding/json""
	""fmt""
	""net/http""
	""regexp""
	""sort""
	""strconv""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
)
func (s *Server) registerTagRoutes(g *echo.Group) {
	g.POST(""/tag"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		tagUpsert := &api.TagUpsert{
			CreatorID: userID,
		}
		if err := json.NewDecoder(c.Request().Body).Decode(tagUpsert); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted post tag request"").SetInternal(err)
		}
		if tagUpsert.Name == """" {
			return echo.NewHTTPError(http.StatusBadRequest, ""Tag name shouldn't be empty"")
		}
		tag, err := s.Store.UpsertTag(ctx, tagUpsert)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to upsert tag"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""tag created"",
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tag.Name)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode tag response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/tag"", func(c echo.Context) error {
		ctx := c.Request().Context()
		tagFind := &api.TagFind{}
		if userID, err := strconv.Atoi(c.QueryParam(""creatorId"")); err == nil {
			tagFind.CreatorID = userID
		}
		if tagFind.CreatorID == 0 {
			currentUserID, ok := c.Get(getUserIDContextKey()).(int)
			if !ok {
				return echo.NewHTTPError(http.StatusBadRequest, ""Missing user id to find tag"")
			}
			tagFind.CreatorID = currentUserID
		}
		tagList, err := s.Store.FindTagList(ctx, tagFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find tag list"").SetInternal(err)
		}
		tagNameList := []string{}
		for _, tag := range tagList {
			tagNameList = append(tagNameList, tag.Name)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tagNameList)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode tags response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/tag/suggestion"", func(c echo.Context) error {
		ctx := c.Request().Context()
		contentSearch := ""
		normalRowStatus := api.Normal
		memoFind := api.MemoFind{
			ContentSearch: &contentSearch,
			RowStatus:     &normalRowStatus,
		}
		if userID, err := strconv.Atoi(c.QueryParam(""creatorId"")); err == nil {
			memoFind.CreatorID = &userID
		}
		currentUserID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			if memoFind.CreatorID == nil {
				return echo.NewHTTPError(http.StatusBadRequest, ""Missing user id to find memo"")
			}
			memoFind.VisibilityList = []api.Visibility{api.Public}
		} else {
			if memoFind.CreatorID == nil {
				memoFind.CreatorID = &currentUserID
			} else {
				memoFind.VisibilityList = []api.Visibility{api.Public, api.Protected}
			}
		}
		memoList, err := s.Store.FindMemoList(ctx, &memoFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find memo list"").SetInternal(err)
		}
		tagMapSet := make(map[string]bool)
		for _, memo := range memoList {
			for _, tag := range findTagListFromMemoContent(memo.Content) {
				tagMapSet[tag] = true
			}
		}
		tagList := []string{}
		for tag := range tagMapSet {
			tagList = append(tagList, tag)
		}
		sort.Strings(tagList)
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tagList)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode tags response"").SetInternal(err)
		}
		return nil
	})
	g.DELETE(""/tag/:tagName"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		tagName := c.Param(""tagName"")
		if tagName == """" {
			return echo.NewHTTPError(http.StatusBadRequest, ""Tag name cannot be empty"")
		}
		tagDelete := &api.TagDelete{
			Name:      tagName,
			CreatorID: userID,
		}
		if err := s.Store.DeleteTag(ctx, tagDelete); err != nil {
			if common.ErrorCode(err) == common.NotFound {
				return echo.NewHTTPError(http.StatusNotFound, fmt.Sprintf(""Tag name not found: %s"", tagName))
			}
			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to delete tag name: %v"", tagName)).SetInternal(err)
		}
		return c.JSON(http.StatusOK, true)
	})
}
var tagRegexp = regexp.MustCompile(`
func findTagListFromMemoContent(memoContent string) []string {
	tagMapSet := make(map[string]bool)
	matches := tagRegexp.FindAllStringSubmatch(memoContent, -1)
	for _, v := range matches {
		tagName := v[1]
		tagMapSet[tagName] = true
	}
	tagList := []string{}
	for tag := range tagMapSet {
		tagList = append(tagList, tag)
	}
	sort.Strings(tagList)
	return tagList
}
",CWE-307,178.0,1
"package server
import (
	""encoding/json""
	""fmt""
	""net/http""
	""regexp""
	""sort""
	""strconv""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
)
func (s *Server) registerTagRoutes(g *echo.Group) {
	g.POST(""/tag"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		tagUpsert := &api.TagUpsert{
			CreatorID: userID,
		}
		if err := json.NewDecoder(c.Request().Body).Decode(tagUpsert); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted post tag request"").SetInternal(err)
		}
		if tagUpsert.Name == """" {
			return echo.NewHTTPError(http.StatusBadRequest, ""Tag name shouldn't be empty"")
		}
		tag, err := s.Store.UpsertTag(ctx, tagUpsert)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to upsert tag"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""tag created"",
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tag.Name)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode tag response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/tag"", func(c echo.Context) error {
		ctx := c.Request().Context()
		tagFind := &api.TagFind{}
		if userID, err := strconv.Atoi(c.QueryParam(""creatorId"")); err == nil {
			tagFind.CreatorID = userID
		}
		if tagFind.CreatorID == 0 {
			currentUserID, ok := c.Get(getUserIDContextKey()).(int)
			if !ok {
				return echo.NewHTTPError(http.StatusBadRequest, ""Missing user id to find tag"")
			}
			tagFind.CreatorID = currentUserID
		}
		tagList, err := s.Store.FindTagList(ctx, tagFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find tag list"").SetInternal(err)
		}
		tagNameList := []string{}
		for _, tag := range tagList {
			tagNameList = append(tagNameList, tag.Name)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tagNameList)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode tags response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/tag/suggestion"", func(c echo.Context) error {
		ctx := c.Request().Context()
		contentSearch := ""
		normalRowStatus := api.Normal
		memoFind := api.MemoFind{
			ContentSearch: &contentSearch,
			RowStatus:     &normalRowStatus,
		}
		if userID, err := strconv.Atoi(c.QueryParam(""creatorId"")); err == nil {
			memoFind.CreatorID = &userID
		}
		currentUserID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			if memoFind.CreatorID == nil {
				return echo.NewHTTPError(http.StatusBadRequest, ""Missing user id to find memo"")
			}
			memoFind.VisibilityList = []api.Visibility{api.Public}
		} else {
			if memoFind.CreatorID == nil {
				memoFind.CreatorID = &currentUserID
			} else {
				memoFind.VisibilityList = []api.Visibility{api.Public, api.Protected}
			}
		}
		memoList, err := s.Store.FindMemoList(ctx, &memoFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find memo list"").SetInternal(err)
		}
		tagMapSet := make(map[string]bool)
		for _, memo := range memoList {
			for _, tag := range findTagListFromMemoContent(memo.Content) {
				tagMapSet[tag] = true
			}
		}
		tagList := []string{}
		for tag := range tagMapSet {
			tagList = append(tagList, tag)
		}
		sort.Strings(tagList)
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tagList)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode tags response"").SetInternal(err)
		}
		return nil
	})
	g.DELETE(""/tag/:tagName"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		tagName := c.Param(""tagName"")
		if tagName == """" {
			return echo.NewHTTPError(http.StatusBadRequest, ""Tag name cannot be empty"")
		}
		tagDelete := &api.TagDelete{
			Name:      tagName,
			CreatorID: userID,
		}
		if err := s.Store.DeleteTag(ctx, tagDelete); err != nil {
			if common.ErrorCode(err) == common.NotFound {
				return echo.NewHTTPError(http.StatusNotFound, fmt.Sprintf(""Tag name not found: %s"", tagName))
			}
			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to delete tag name: %v"", tagName)).SetInternal(err)
		}
		return c.JSON(http.StatusOK, true)
	})
}
var tagRegexp = regexp.MustCompile(`
func findTagListFromMemoContent(memoContent string) []string {
	tagMapSet := make(map[string]bool)
	matches := tagRegexp.FindAllStringSubmatch(memoContent, -1)
	for _, v := range matches {
		tagName := v[1]
		tagMapSet[tagName] = true
	}
	tagList := []string{}
	for tag := range tagMapSet {
		tagList = append(tagList, tag)
	}
	sort.Strings(tagList)
	return tagList
}
",CWE-639,178.0,1
"package server
import (
	""encoding/json""
	""fmt""
	""net/http""
	""regexp""
	""sort""
	""strconv""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
)
func (s *Server) registerTagRoutes(g *echo.Group) {
	g.POST(""/tag"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		tagUpsert := &api.TagUpsert{
			CreatorID: userID,
		}
		if err := json.NewDecoder(c.Request().Body).Decode(tagUpsert); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted post tag request"").SetInternal(err)
		}
		if tagUpsert.Name == """" {
			return echo.NewHTTPError(http.StatusBadRequest, ""Tag name shouldn't be empty"")
		}
		tag, err := s.Store.UpsertTag(ctx, tagUpsert)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to upsert tag"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""tag created"",
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tag.Name)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode tag response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/tag"", func(c echo.Context) error {
		ctx := c.Request().Context()
		tagFind := &api.TagFind{}
		if userID, err := strconv.Atoi(c.QueryParam(""creatorId"")); err == nil {
			tagFind.CreatorID = userID
		}
		if tagFind.CreatorID == 0 {
			currentUserID, ok := c.Get(getUserIDContextKey()).(int)
			if !ok {
				return echo.NewHTTPError(http.StatusBadRequest, ""Missing user id to find tag"")
			}
			tagFind.CreatorID = currentUserID
		}
		tagList, err := s.Store.FindTagList(ctx, tagFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find tag list"").SetInternal(err)
		}
		tagNameList := []string{}
		for _, tag := range tagList {
			tagNameList = append(tagNameList, tag.Name)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tagNameList)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode tags response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/tag/suggestion"", func(c echo.Context) error {
		ctx := c.Request().Context()
		contentSearch := ""
		normalRowStatus := api.Normal
		memoFind := api.MemoFind{
			ContentSearch: &contentSearch,
			RowStatus:     &normalRowStatus,
		}
		if userID, err := strconv.Atoi(c.QueryParam(""creatorId"")); err == nil {
			memoFind.CreatorID = &userID
		}
		currentUserID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			if memoFind.CreatorID == nil {
				return echo.NewHTTPError(http.StatusBadRequest, ""Missing user id to find memo"")
			}
			memoFind.VisibilityList = []api.Visibility{api.Public}
		} else {
			if memoFind.CreatorID == nil {
				memoFind.CreatorID = &currentUserID
			} else {
				memoFind.VisibilityList = []api.Visibility{api.Public, api.Protected}
			}
		}
		memoList, err := s.Store.FindMemoList(ctx, &memoFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find memo list"").SetInternal(err)
		}
		tagMapSet := make(map[string]bool)
		for _, memo := range memoList {
			for _, tag := range findTagListFromMemoContent(memo.Content) {
				tagMapSet[tag] = true
			}
		}
		tagList := []string{}
		for tag := range tagMapSet {
			tagList = append(tagList, tag)
		}
		sort.Strings(tagList)
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tagList)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode tags response"").SetInternal(err)
		}
		return nil
	})
	g.DELETE(""/tag/:tagName"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		tagName := c.Param(""tagName"")
		if tagName == """" {
			return echo.NewHTTPError(http.StatusBadRequest, ""Tag name cannot be empty"")
		}
		tagDelete := &api.TagDelete{
			Name:      tagName,
			CreatorID: userID,
		}
		if err := s.Store.DeleteTag(ctx, tagDelete); err != nil {
			if common.ErrorCode(err) == common.NotFound {
				return echo.NewHTTPError(http.StatusNotFound, fmt.Sprintf(""Tag name not found: %s"", tagName))
			}
			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to delete tag name: %v"", tagName)).SetInternal(err)
		}
		return c.JSON(http.StatusOK, true)
	})
}
var tagRegexp = regexp.MustCompile(`
func findTagListFromMemoContent(memoContent string) []string {
	tagMapSet := make(map[string]bool)
	matches := tagRegexp.FindAllStringSubmatch(memoContent, -1)
	for _, v := range matches {
		tagName := v[1]
		tagMapSet[tagName] = true
	}
	tagList := []string{}
	for tag := range tagMapSet {
		tagList = append(tagList, tag)
	}
	sort.Strings(tagList)
	return tagList
}
",CWE-940,178.0,1
"package server
import (
	""encoding/json""
	""fmt""
	""net/http""
	""regexp""
	""sort""
	""strconv""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
)
func (s *Server) registerTagRoutes(g *echo.Group) {
	g.POST(""/tag"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		tagUpsert := &api.TagUpsert{
			CreatorID: userID,
		}
		if err := json.NewDecoder(c.Request().Body).Decode(tagUpsert); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted post tag request"").SetInternal(err)
		}
		if tagUpsert.Name == """" {
			return echo.NewHTTPError(http.StatusBadRequest, ""Tag name shouldn't be empty"")
		}
		tag, err := s.Store.UpsertTag(ctx, tagUpsert)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to upsert tag"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""tag created"",
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tag.Name)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode tag response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/tag"", func(c echo.Context) error {
		ctx := c.Request().Context()
		tagFind := &api.TagFind{}
		if userID, err := strconv.Atoi(c.QueryParam(""creatorId"")); err == nil {
			tagFind.CreatorID = userID
		}
		if tagFind.CreatorID == 0 {
			currentUserID, ok := c.Get(getUserIDContextKey()).(int)
			if !ok {
				return echo.NewHTTPError(http.StatusBadRequest, ""Missing user id to find tag"")
			}
			tagFind.CreatorID = currentUserID
		}
		tagList, err := s.Store.FindTagList(ctx, tagFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find tag list"").SetInternal(err)
		}
		tagNameList := []string{}
		for _, tag := range tagList {
			tagNameList = append(tagNameList, tag.Name)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tagNameList)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode tags response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/tag/suggestion"", func(c echo.Context) error {
		ctx := c.Request().Context()
		contentSearch := ""
		normalRowStatus := api.Normal
		memoFind := api.MemoFind{
			ContentSearch: &contentSearch,
			RowStatus:     &normalRowStatus,
		}
		if userID, err := strconv.Atoi(c.QueryParam(""creatorId"")); err == nil {
			memoFind.CreatorID = &userID
		}
		currentUserID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			if memoFind.CreatorID == nil {
				return echo.NewHTTPError(http.StatusBadRequest, ""Missing user id to find memo"")
			}
			memoFind.VisibilityList = []api.Visibility{api.Public}
		} else {
			if memoFind.CreatorID == nil {
				memoFind.CreatorID = &currentUserID
			} else {
				memoFind.VisibilityList = []api.Visibility{api.Public, api.Protected}
			}
		}
		memoList, err := s.Store.FindMemoList(ctx, &memoFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find memo list"").SetInternal(err)
		}
		tagMapSet := make(map[string]bool)
		for _, memo := range memoList {
			for _, tag := range findTagListFromMemoContent(memo.Content) {
				tagMapSet[tag] = true
			}
		}
		tagList := []string{}
		for tag := range tagMapSet {
			tagList = append(tagList, tag)
		}
		sort.Strings(tagList)
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tagList)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode tags response"").SetInternal(err)
		}
		return nil
	})
	g.DELETE(""/tag/:tagName"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		tagName := c.Param(""tagName"")
		if tagName == """" {
			return echo.NewHTTPError(http.StatusBadRequest, ""Tag name cannot be empty"")
		}
		tagDelete := &api.TagDelete{
			Name:      tagName,
			CreatorID: userID,
		}
		if err := s.Store.DeleteTag(ctx, tagDelete); err != nil {
			if common.ErrorCode(err) == common.NotFound {
				return echo.NewHTTPError(http.StatusNotFound, fmt.Sprintf(""Tag name not found: %s"", tagName))
			}
			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to delete tag name: %v"", tagName)).SetInternal(err)
		}
		return c.JSON(http.StatusOK, true)
	})
}
var tagRegexp = regexp.MustCompile(`
func findTagListFromMemoContent(memoContent string) []string {
	tagMapSet := make(map[string]bool)
	matches := tagRegexp.FindAllStringSubmatch(memoContent, -1)
	for _, v := range matches {
		tagName := v[1]
		tagMapSet[tagName] = true
	}
	tagList := []string{}
	for tag := range tagMapSet {
		tagList = append(tagList, tag)
	}
	sort.Strings(tagList)
	return tagList
}
",CWE-1220,178.0,1
"package server
import (
	""encoding/json""
	""fmt""
	""net/http""
	""regexp""
	""sort""
	""strconv""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
)
func (s *Server) registerTagRoutes(g *echo.Group) {
	g.POST(""/tag"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		tagUpsert := &api.TagUpsert{
			CreatorID: userID,
		}
		if err := json.NewDecoder(c.Request().Body).Decode(tagUpsert); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted post tag request"").SetInternal(err)
		}
		if tagUpsert.Name == """" {
			return echo.NewHTTPError(http.StatusBadRequest, ""Tag name shouldn't be empty"")
		}
		tag, err := s.Store.UpsertTag(ctx, tagUpsert)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to upsert tag"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""tag created"",
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tag.Name)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode tag response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/tag"", func(c echo.Context) error {
		ctx := c.Request().Context()
		tagFind := &api.TagFind{}
		if userID, err := strconv.Atoi(c.QueryParam(""creatorId"")); err == nil {
			tagFind.CreatorID = userID
		}
		if tagFind.CreatorID == 0 {
			currentUserID, ok := c.Get(getUserIDContextKey()).(int)
			if !ok {
				return echo.NewHTTPError(http.StatusBadRequest, ""Missing user id to find tag"")
			}
			tagFind.CreatorID = currentUserID
		}
		tagList, err := s.Store.FindTagList(ctx, tagFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find tag list"").SetInternal(err)
		}
		tagNameList := []string{}
		for _, tag := range tagList {
			tagNameList = append(tagNameList, tag.Name)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tagNameList)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode tags response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/tag/suggestion"", func(c echo.Context) error {
		ctx := c.Request().Context()
		contentSearch := ""
		normalRowStatus := api.Normal
		memoFind := api.MemoFind{
			ContentSearch: &contentSearch,
			RowStatus:     &normalRowStatus,
		}
		if userID, err := strconv.Atoi(c.QueryParam(""creatorId"")); err == nil {
			memoFind.CreatorID = &userID
		}
		currentUserID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			if memoFind.CreatorID == nil {
				return echo.NewHTTPError(http.StatusBadRequest, ""Missing user id to find memo"")
			}
			memoFind.VisibilityList = []api.Visibility{api.Public}
		} else {
			if memoFind.CreatorID == nil {
				memoFind.CreatorID = &currentUserID
			} else {
				memoFind.VisibilityList = []api.Visibility{api.Public, api.Protected}
			}
		}
		memoList, err := s.Store.FindMemoList(ctx, &memoFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find memo list"").SetInternal(err)
		}
		tagMapSet := make(map[string]bool)
		for _, memo := range memoList {
			for _, tag := range findTagListFromMemoContent(memo.Content) {
				tagMapSet[tag] = true
			}
		}
		tagList := []string{}
		for tag := range tagMapSet {
			tagList = append(tagList, tag)
		}
		sort.Strings(tagList)
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tagList)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode tags response"").SetInternal(err)
		}
		return nil
	})
	g.DELETE(""/tag/:tagName"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		tagName := c.Param(""tagName"")
		if tagName == """" {
			return echo.NewHTTPError(http.StatusBadRequest, ""Tag name cannot be empty"")
		}
		tagDelete := &api.TagDelete{
			Name:      tagName,
			CreatorID: userID,
		}
		if err := s.Store.DeleteTag(ctx, tagDelete); err != nil {
			if common.ErrorCode(err) == common.NotFound {
				return echo.NewHTTPError(http.StatusNotFound, fmt.Sprintf(""Tag name not found: %s"", tagName))
			}
			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to delete tag name: %v"", tagName)).SetInternal(err)
		}
		return c.JSON(http.StatusOK, true)
	})
}
var tagRegexp = regexp.MustCompile(`
func findTagListFromMemoContent(memoContent string) []string {
	tagMapSet := make(map[string]bool)
	matches := tagRegexp.FindAllStringSubmatch(memoContent, -1)
	for _, v := range matches {
		tagName := v[1]
		tagMapSet[tagName] = true
	}
	tagList := []string{}
	for tag := range tagMapSet {
		tagList = append(tagList, tag)
	}
	sort.Strings(tagList)
	return tagList
}
",CWE-285,178.0,1
"package server
import (
	""encoding/json""
	""fmt""
	""net/http""
	""regexp""
	""sort""
	""strconv""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
)
func (s *Server) registerTagRoutes(g *echo.Group) {
	g.POST(""/tag"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		tagUpsert := &api.TagUpsert{
			CreatorID: userID,
		}
		if err := json.NewDecoder(c.Request().Body).Decode(tagUpsert); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted post tag request"").SetInternal(err)
		}
		if tagUpsert.Name == """" {
			return echo.NewHTTPError(http.StatusBadRequest, ""Tag name shouldn't be empty"")
		}
		tag, err := s.Store.UpsertTag(ctx, tagUpsert)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to upsert tag"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""tag created"",
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tag.Name)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode tag response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/tag"", func(c echo.Context) error {
		ctx := c.Request().Context()
		tagFind := &api.TagFind{}
		if userID, err := strconv.Atoi(c.QueryParam(""creatorId"")); err == nil {
			tagFind.CreatorID = userID
		}
		if tagFind.CreatorID == 0 {
			currentUserID, ok := c.Get(getUserIDContextKey()).(int)
			if !ok {
				return echo.NewHTTPError(http.StatusBadRequest, ""Missing user id to find tag"")
			}
			tagFind.CreatorID = currentUserID
		}
		tagList, err := s.Store.FindTagList(ctx, tagFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find tag list"").SetInternal(err)
		}
		tagNameList := []string{}
		for _, tag := range tagList {
			tagNameList = append(tagNameList, tag.Name)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tagNameList)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode tags response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/tag/suggestion"", func(c echo.Context) error {
		ctx := c.Request().Context()
		contentSearch := ""
		normalRowStatus := api.Normal
		memoFind := api.MemoFind{
			ContentSearch: &contentSearch,
			RowStatus:     &normalRowStatus,
		}
		if userID, err := strconv.Atoi(c.QueryParam(""creatorId"")); err == nil {
			memoFind.CreatorID = &userID
		}
		currentUserID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			if memoFind.CreatorID == nil {
				return echo.NewHTTPError(http.StatusBadRequest, ""Missing user id to find memo"")
			}
			memoFind.VisibilityList = []api.Visibility{api.Public}
		} else {
			if memoFind.CreatorID == nil {
				memoFind.CreatorID = &currentUserID
			} else {
				memoFind.VisibilityList = []api.Visibility{api.Public, api.Protected}
			}
		}
		memoList, err := s.Store.FindMemoList(ctx, &memoFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find memo list"").SetInternal(err)
		}
		tagMapSet := make(map[string]bool)
		for _, memo := range memoList {
			for _, tag := range findTagListFromMemoContent(memo.Content) {
				tagMapSet[tag] = true
			}
		}
		tagList := []string{}
		for tag := range tagMapSet {
			tagList = append(tagList, tag)
		}
		sort.Strings(tagList)
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tagList)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode tags response"").SetInternal(err)
		}
		return nil
	})
	g.DELETE(""/tag/:tagName"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		tagName := c.Param(""tagName"")
		if tagName == """" {
			return echo.NewHTTPError(http.StatusBadRequest, ""Tag name cannot be empty"")
		}
		tagDelete := &api.TagDelete{
			Name:      tagName,
			CreatorID: userID,
		}
		if err := s.Store.DeleteTag(ctx, tagDelete); err != nil {
			if common.ErrorCode(err) == common.NotFound {
				return echo.NewHTTPError(http.StatusNotFound, fmt.Sprintf(""Tag name not found: %s"", tagName))
			}
			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to delete tag name: %v"", tagName)).SetInternal(err)
		}
		return c.JSON(http.StatusOK, true)
	})
}
var tagRegexp = regexp.MustCompile(`
func findTagListFromMemoContent(memoContent string) []string {
	tagMapSet := make(map[string]bool)
	matches := tagRegexp.FindAllStringSubmatch(memoContent, -1)
	for _, v := range matches {
		tagName := v[1]
		tagMapSet[tagName] = true
	}
	tagList := []string{}
	for tag := range tagMapSet {
		tagList = append(tagList, tag)
	}
	sort.Strings(tagList)
	return tagList
}
",CWE-284,178.0,1
"package server
import (
	""encoding/json""
	""fmt""
	""net/http""
	""regexp""
	""sort""
	""strconv""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
)
func (s *Server) registerTagRoutes(g *echo.Group) {
	g.POST(""/tag"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		tagUpsert := &api.TagUpsert{
			CreatorID: userID,
		}
		if err := json.NewDecoder(c.Request().Body).Decode(tagUpsert); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted post tag request"").SetInternal(err)
		}
		if tagUpsert.Name == """" {
			return echo.NewHTTPError(http.StatusBadRequest, ""Tag name shouldn't be empty"")
		}
		tag, err := s.Store.UpsertTag(ctx, tagUpsert)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to upsert tag"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""tag created"",
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tag.Name)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode tag response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/tag"", func(c echo.Context) error {
		ctx := c.Request().Context()
		tagFind := &api.TagFind{}
		if userID, err := strconv.Atoi(c.QueryParam(""creatorId"")); err == nil {
			tagFind.CreatorID = userID
		}
		if tagFind.CreatorID == 0 {
			currentUserID, ok := c.Get(getUserIDContextKey()).(int)
			if !ok {
				return echo.NewHTTPError(http.StatusBadRequest, ""Missing user id to find tag"")
			}
			tagFind.CreatorID = currentUserID
		}
		tagList, err := s.Store.FindTagList(ctx, tagFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find tag list"").SetInternal(err)
		}
		tagNameList := []string{}
		for _, tag := range tagList {
			tagNameList = append(tagNameList, tag.Name)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tagNameList)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode tags response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/tag/suggestion"", func(c echo.Context) error {
		ctx := c.Request().Context()
		contentSearch := ""
		normalRowStatus := api.Normal
		memoFind := api.MemoFind{
			ContentSearch: &contentSearch,
			RowStatus:     &normalRowStatus,
		}
		if userID, err := strconv.Atoi(c.QueryParam(""creatorId"")); err == nil {
			memoFind.CreatorID = &userID
		}
		currentUserID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			if memoFind.CreatorID == nil {
				return echo.NewHTTPError(http.StatusBadRequest, ""Missing user id to find memo"")
			}
			memoFind.VisibilityList = []api.Visibility{api.Public}
		} else {
			if memoFind.CreatorID == nil {
				memoFind.CreatorID = &currentUserID
			} else {
				memoFind.VisibilityList = []api.Visibility{api.Public, api.Protected}
			}
		}
		memoList, err := s.Store.FindMemoList(ctx, &memoFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find memo list"").SetInternal(err)
		}
		tagMapSet := make(map[string]bool)
		for _, memo := range memoList {
			for _, tag := range findTagListFromMemoContent(memo.Content) {
				tagMapSet[tag] = true
			}
		}
		tagList := []string{}
		for tag := range tagMapSet {
			tagList = append(tagList, tag)
		}
		sort.Strings(tagList)
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tagList)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode tags response"").SetInternal(err)
		}
		return nil
	})
	g.DELETE(""/tag/:tagName"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		tagName := c.Param(""tagName"")
		if tagName == """" {
			return echo.NewHTTPError(http.StatusBadRequest, ""Tag name cannot be empty"")
		}
		tagDelete := &api.TagDelete{
			Name:      tagName,
			CreatorID: userID,
		}
		if err := s.Store.DeleteTag(ctx, tagDelete); err != nil {
			if common.ErrorCode(err) == common.NotFound {
				return echo.NewHTTPError(http.StatusNotFound, fmt.Sprintf(""Tag name not found: %s"", tagName))
			}
			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to delete tag name: %v"", tagName)).SetInternal(err)
		}
		return c.JSON(http.StatusOK, true)
	})
}
var tagRegexp = regexp.MustCompile(`
func findTagListFromMemoContent(memoContent string) []string {
	tagMapSet := make(map[string]bool)
	matches := tagRegexp.FindAllStringSubmatch(memoContent, -1)
	for _, v := range matches {
		tagName := v[1]
		tagMapSet[tagName] = true
	}
	tagList := []string{}
	for tag := range tagMapSet {
		tagList = append(tagList, tag)
	}
	sort.Strings(tagList)
	return tagList
}
",CWE-229,178.0,1
"package server
import (
	""encoding/json""
	""fmt""
	""net/http""
	""regexp""
	""sort""
	""strconv""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
)
func (s *Server) registerTagRoutes(g *echo.Group) {
	g.POST(""/tag"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		tagUpsert := &api.TagUpsert{
			CreatorID: userID,
		}
		if err := json.NewDecoder(c.Request().Body).Decode(tagUpsert); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted post tag request"").SetInternal(err)
		}
		if tagUpsert.Name == """" {
			return echo.NewHTTPError(http.StatusBadRequest, ""Tag name shouldn't be empty"")
		}
		tag, err := s.Store.UpsertTag(ctx, tagUpsert)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to upsert tag"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""tag created"",
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tag.Name)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode tag response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/tag"", func(c echo.Context) error {
		ctx := c.Request().Context()
		tagFind := &api.TagFind{}
		if userID, err := strconv.Atoi(c.QueryParam(""creatorId"")); err == nil {
			tagFind.CreatorID = userID
		}
		if tagFind.CreatorID == 0 {
			currentUserID, ok := c.Get(getUserIDContextKey()).(int)
			if !ok {
				return echo.NewHTTPError(http.StatusBadRequest, ""Missing user id to find tag"")
			}
			tagFind.CreatorID = currentUserID
		}
		tagList, err := s.Store.FindTagList(ctx, tagFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find tag list"").SetInternal(err)
		}
		tagNameList := []string{}
		for _, tag := range tagList {
			tagNameList = append(tagNameList, tag.Name)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tagNameList)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode tags response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/tag/suggestion"", func(c echo.Context) error {
		ctx := c.Request().Context()
		contentSearch := ""
		normalRowStatus := api.Normal
		memoFind := api.MemoFind{
			ContentSearch: &contentSearch,
			RowStatus:     &normalRowStatus,
		}
		if userID, err := strconv.Atoi(c.QueryParam(""creatorId"")); err == nil {
			memoFind.CreatorID = &userID
		}
		currentUserID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			if memoFind.CreatorID == nil {
				return echo.NewHTTPError(http.StatusBadRequest, ""Missing user id to find memo"")
			}
			memoFind.VisibilityList = []api.Visibility{api.Public}
		} else {
			if memoFind.CreatorID == nil {
				memoFind.CreatorID = &currentUserID
			} else {
				memoFind.VisibilityList = []api.Visibility{api.Public, api.Protected}
			}
		}
		memoList, err := s.Store.FindMemoList(ctx, &memoFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find memo list"").SetInternal(err)
		}
		tagMapSet := make(map[string]bool)
		for _, memo := range memoList {
			for _, tag := range findTagListFromMemoContent(memo.Content) {
				tagMapSet[tag] = true
			}
		}
		tagList := []string{}
		for tag := range tagMapSet {
			tagList = append(tagList, tag)
		}
		sort.Strings(tagList)
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tagList)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode tags response"").SetInternal(err)
		}
		return nil
	})
	g.DELETE(""/tag/:tagName"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		tagName := c.Param(""tagName"")
		if tagName == """" {
			return echo.NewHTTPError(http.StatusBadRequest, ""Tag name cannot be empty"")
		}
		tagDelete := &api.TagDelete{
			Name:      tagName,
			CreatorID: userID,
		}
		if err := s.Store.DeleteTag(ctx, tagDelete); err != nil {
			if common.ErrorCode(err) == common.NotFound {
				return echo.NewHTTPError(http.StatusNotFound, fmt.Sprintf(""Tag name not found: %s"", tagName))
			}
			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to delete tag name: %v"", tagName)).SetInternal(err)
		}
		return c.JSON(http.StatusOK, true)
	})
}
var tagRegexp = regexp.MustCompile(`
func findTagListFromMemoContent(memoContent string) []string {
	tagMapSet := make(map[string]bool)
	matches := tagRegexp.FindAllStringSubmatch(memoContent, -1)
	for _, v := range matches {
		tagName := v[1]
		tagMapSet[tagName] = true
	}
	tagList := []string{}
	for tag := range tagMapSet {
		tagList = append(tagList, tag)
	}
	sort.Strings(tagList)
	return tagList
}
",CWE-280,178.0,1
"package server
import (
	""fmt""
	""net/http""
	""strconv""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	""github.com/gorilla/sessions""
	""github.com/labstack/echo-contrib/session""
	""github.com/labstack/echo/v4""
)
var (
	userIDContextKey = ""user-id""
)
func getUserIDContextKey() string {
	return userIDContextKey
}
func setUserSession(ctx echo.Context, user *api.User) error {
	sess, _ := session.Get(""memos_session"", ctx)
	sess.Options = &sessions.Options{
		Path:     ""/"",
		MaxAge:   3600 * 24 * 30,
		HttpOnly: true,
	}
	sess.Values[userIDContextKey] = user.ID
	err := sess.Save(ctx.Request(), ctx.Response())
	if err != nil {
		return fmt.Errorf(""failed to set session, err: %w"", err)
	}
	return nil
}
func removeUserSession(ctx echo.Context) error {
	sess, _ := session.Get(""memos_session"", ctx)
	sess.Options = &sessions.Options{
		Path:     ""/"",
		MaxAge:   0,
		HttpOnly: true,
	}
	sess.Values[userIDContextKey] = nil
	err := sess.Save(ctx.Request(), ctx.Response())
	if err != nil {
		return fmt.Errorf(""failed to set session, err: %w"", err)
	}
	return nil
}
func aclMiddleware(s *Server, next echo.HandlerFunc) echo.HandlerFunc {
	return func(c echo.Context) error {
		ctx := c.Request().Context()
		path := c.Path()
		// Skip auth.
		if common.HasPrefixes(path, ""/api/auth"") {
			return next(c)
		}
		{
			// If there is openId in query string and related user is found, then skip auth.
			openID := c.QueryParam(""openId"")
			if openID != """" {
				userFind := &api.UserFind{
					OpenID: &openID,
				}
				user, err := s.Store.FindUser(ctx, userFind)
				if err != nil && common.ErrorCode(err) != common.NotFound {
					return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find user by open_id"").SetInternal(err)
				}
				if user != nil {
					// Stores userID into context.
					c.Set(getUserIDContextKey(), user.ID)
					return next(c)
				}
			}
		}
		{
			sess, _ := session.Get(""memos_session"", c)
			userIDValue := sess.Values[userIDContextKey]
			if userIDValue != nil {
				userID, _ := strconv.Atoi(fmt.Sprintf(""%v"", userIDValue))
				userFind := &api.UserFind{
					ID: &userID,
				}
				user, err := s.Store.FindUser(ctx, userFind)
				if err != nil && common.ErrorCode(err) != common.NotFound {
					return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to find user by ID: %d"", userID)).SetInternal(err)
				}
				if user != nil {
					if user.RowStatus == api.Archived {
						return echo.NewHTTPError(http.StatusForbidden, fmt.Sprintf(""User has been archived with username %s"", user.Username))
					}
					c.Set(getUserIDContextKey(), userID)
				}
			}
		}
		if common.HasPrefixes(path, ""/api/ping"", ""/api/status"", ""/api/user/:id"", ""/api/memo/all"", ""/api/memo/:memoId"", ""/api/memo/amount"") && c.Request().Method == http.MethodGet {
			return next(c)
		}
		if common.HasPrefixes(path, ""/api/memo"", ""/api/tag"", ""/api/shortcut"") && c.Request().Method == http.MethodGet {
			if _, err := strconv.Atoi(c.QueryParam(""creatorId"")); err == nil {
				return next(c)
			}
		}
		userID := c.Get(getUserIDContextKey())
		if userID == nil {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		return next(c)
	}
}
",CWE-352,122.0,1
"package server
import (
	""fmt""
	""net/http""
	""strconv""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	""github.com/gorilla/sessions""
	""github.com/labstack/echo-contrib/session""
	""github.com/labstack/echo/v4""
)
var (
	userIDContextKey = ""user-id""
)
func getUserIDContextKey() string {
	return userIDContextKey
}
func setUserSession(ctx echo.Context, user *api.User) error {
	sess, _ := session.Get(""memos_session"", ctx)
	sess.Options = &sessions.Options{
		Path:     ""/"",
		MaxAge:   3600 * 24 * 30,
		HttpOnly: true,
	}
	sess.Values[userIDContextKey] = user.ID
	err := sess.Save(ctx.Request(), ctx.Response())
	if err != nil {
		return fmt.Errorf(""failed to set session, err: %w"", err)
	}
	return nil
}
func removeUserSession(ctx echo.Context) error {
	sess, _ := session.Get(""memos_session"", ctx)
	sess.Options = &sessions.Options{
		Path:     ""/"",
		MaxAge:   0,
		HttpOnly: true,
	}
	sess.Values[userIDContextKey] = nil
	err := sess.Save(ctx.Request(), ctx.Response())
	if err != nil {
		return fmt.Errorf(""failed to set session, err: %w"", err)
	}
	return nil
}
func aclMiddleware(s *Server, next echo.HandlerFunc) echo.HandlerFunc {
	return func(c echo.Context) error {
		ctx := c.Request().Context()
		path := c.Path()
		// Skip auth.
		if common.HasPrefixes(path, ""/api/auth"") {
			return next(c)
		}
		{
			// If there is openId in query string and related user is found, then skip auth.
			openID := c.QueryParam(""openId"")
			if openID != """" {
				userFind := &api.UserFind{
					OpenID: &openID,
				}
				user, err := s.Store.FindUser(ctx, userFind)
				if err != nil && common.ErrorCode(err) != common.NotFound {
					return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find user by open_id"").SetInternal(err)
				}
				if user != nil {
					// Stores userID into context.
					c.Set(getUserIDContextKey(), user.ID)
					return next(c)
				}
			}
		}
		{
			sess, _ := session.Get(""memos_session"", c)
			userIDValue := sess.Values[userIDContextKey]
			if userIDValue != nil {
				userID, _ := strconv.Atoi(fmt.Sprintf(""%v"", userIDValue))
				userFind := &api.UserFind{
					ID: &userID,
				}
				user, err := s.Store.FindUser(ctx, userFind)
				if err != nil && common.ErrorCode(err) != common.NotFound {
					return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to find user by ID: %d"", userID)).SetInternal(err)
				}
				if user != nil {
					if user.RowStatus == api.Archived {
						return echo.NewHTTPError(http.StatusForbidden, fmt.Sprintf(""User has been archived with username %s"", user.Username))
					}
					c.Set(getUserIDContextKey(), userID)
				}
			}
		}
		if common.HasPrefixes(path, ""/api/ping"", ""/api/status"", ""/api/user/:id"", ""/api/memo/all"", ""/api/memo/:memoId"", ""/api/memo/amount"") && c.Request().Method == http.MethodGet {
			return next(c)
		}
		if common.HasPrefixes(path, ""/api/memo"", ""/api/tag"", ""/api/shortcut"") && c.Request().Method == http.MethodGet {
			if _, err := strconv.Atoi(c.QueryParam(""creatorId"")); err == nil {
				return next(c)
			}
		}
		userID := c.Get(getUserIDContextKey())
		if userID == nil {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		return next(c)
	}
}
",CWE-941,122.0,1
"package server
import (
	""fmt""
	""net/http""
	""strconv""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	""github.com/gorilla/sessions""
	""github.com/labstack/echo-contrib/session""
	""github.com/labstack/echo/v4""
)
var (
	userIDContextKey = ""user-id""
)
func getUserIDContextKey() string {
	return userIDContextKey
}
func setUserSession(ctx echo.Context, user *api.User) error {
	sess, _ := session.Get(""memos_session"", ctx)
	sess.Options = &sessions.Options{
		Path:     ""/"",
		MaxAge:   3600 * 24 * 30,
		HttpOnly: true,
	}
	sess.Values[userIDContextKey] = user.ID
	err := sess.Save(ctx.Request(), ctx.Response())
	if err != nil {
		return fmt.Errorf(""failed to set session, err: %w"", err)
	}
	return nil
}
func removeUserSession(ctx echo.Context) error {
	sess, _ := session.Get(""memos_session"", ctx)
	sess.Options = &sessions.Options{
		Path:     ""/"",
		MaxAge:   0,
		HttpOnly: true,
	}
	sess.Values[userIDContextKey] = nil
	err := sess.Save(ctx.Request(), ctx.Response())
	if err != nil {
		return fmt.Errorf(""failed to set session, err: %w"", err)
	}
	return nil
}
func aclMiddleware(s *Server, next echo.HandlerFunc) echo.HandlerFunc {
	return func(c echo.Context) error {
		ctx := c.Request().Context()
		path := c.Path()
		// Skip auth.
		if common.HasPrefixes(path, ""/api/auth"") {
			return next(c)
		}
		{
			// If there is openId in query string and related user is found, then skip auth.
			openID := c.QueryParam(""openId"")
			if openID != """" {
				userFind := &api.UserFind{
					OpenID: &openID,
				}
				user, err := s.Store.FindUser(ctx, userFind)
				if err != nil && common.ErrorCode(err) != common.NotFound {
					return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find user by open_id"").SetInternal(err)
				}
				if user != nil {
					// Stores userID into context.
					c.Set(getUserIDContextKey(), user.ID)
					return next(c)
				}
			}
		}
		{
			sess, _ := session.Get(""memos_session"", c)
			userIDValue := sess.Values[userIDContextKey]
			if userIDValue != nil {
				userID, _ := strconv.Atoi(fmt.Sprintf(""%v"", userIDValue))
				userFind := &api.UserFind{
					ID: &userID,
				}
				user, err := s.Store.FindUser(ctx, userFind)
				if err != nil && common.ErrorCode(err) != common.NotFound {
					return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to find user by ID: %d"", userID)).SetInternal(err)
				}
				if user != nil {
					if user.RowStatus == api.Archived {
						return echo.NewHTTPError(http.StatusForbidden, fmt.Sprintf(""User has been archived with username %s"", user.Username))
					}
					c.Set(getUserIDContextKey(), userID)
				}
			}
		}
		if common.HasPrefixes(path, ""/api/ping"", ""/api/status"", ""/api/user/:id"", ""/api/memo/all"", ""/api/memo/:memoId"", ""/api/memo/amount"") && c.Request().Method == http.MethodGet {
			return next(c)
		}
		if common.HasPrefixes(path, ""/api/memo"", ""/api/tag"", ""/api/shortcut"") && c.Request().Method == http.MethodGet {
			if _, err := strconv.Atoi(c.QueryParam(""creatorId"")); err == nil {
				return next(c)
			}
		}
		userID := c.Get(getUserIDContextKey())
		if userID == nil {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		return next(c)
	}
}
",CWE-940,122.0,1
"package server
import (
	""fmt""
	""time""
	""github.com/usememos/memos/server/profile""
	""github.com/usememos/memos/store""
	""github.com/gorilla/securecookie""
	""github.com/gorilla/sessions""
	""github.com/labstack/echo-contrib/session""
	""github.com/labstack/echo/v4""
	""github.com/labstack/echo/v4/middleware""
)
type Server struct {
	e *echo.Echo
	Collector *MetricCollector
	Profile *profile.Profile
	Store *store.Store
}
func NewServer(profile *profile.Profile) *Server {
	e := echo.New()
	e.Debug = true
	e.HideBanner = true
	e.HidePort = true
	e.Use(middleware.LoggerWithConfig(middleware.LoggerConfig{
		Format: `{""time"":""${time_rfc3339}"",` +
			`""method"":""${method}"",""uri"":""${uri}"",` +
			`""status"":${status},""error"":""${error}""}` + ""\n"",
	}))
	e.Use(middleware.CORS())
	e.Use(middleware.TimeoutWithConfig(middleware.TimeoutConfig{
		Skipper:      middleware.DefaultSkipper,
		ErrorMessage: ""Request timeout"",
		Timeout:      30 * time.Second,
	}))
	embedFrontend(e)
	// In dev mode, set the const secret key to make signin session persistence.
	secret := []byte(""usememos"")
	if profile.Mode == ""prod"" {
		secret = securecookie.GenerateRandomKey(16)
	}
	e.Use(session.Middleware(sessions.NewCookieStore(secret)))
	s := &Server{
		e:       e,
		Profile: profile,
	}
	rootGroup := e.Group("""")
	s.registerRSSRoutes(rootGroup)
	webhookGroup := e.Group(""/h"")
	s.registerResourcePublicRoutes(webhookGroup)
	publicGroup := e.Group(""/o"")
	s.registerResourcePublicRoutes(publicGroup)
	s.registerGetterPublicRoutes(publicGroup)
	apiGroup := e.Group(""/api"")
	apiGroup.Use(func(next echo.HandlerFunc) echo.HandlerFunc {
		return aclMiddleware(s, next)
	})
	s.registerSystemRoutes(apiGroup)
	s.registerAuthRoutes(apiGroup)
	s.registerUserRoutes(apiGroup)
	s.registerMemoRoutes(apiGroup)
	s.registerShortcutRoutes(apiGroup)
	s.registerResourceRoutes(apiGroup)
	s.registerTagRoutes(apiGroup)
	return s
}
func (server *Server) Run() error {
	return server.e.Start(fmt.Sprintf("":%d"", server.Profile.Port))
}
",CWE-352,89.0,1
"package server
import (
	""fmt""
	""time""
	""github.com/usememos/memos/server/profile""
	""github.com/usememos/memos/store""
	""github.com/gorilla/securecookie""
	""github.com/gorilla/sessions""
	""github.com/labstack/echo-contrib/session""
	""github.com/labstack/echo/v4""
	""github.com/labstack/echo/v4/middleware""
)
type Server struct {
	e *echo.Echo
	Collector *MetricCollector
	Profile *profile.Profile
	Store *store.Store
}
func NewServer(profile *profile.Profile) *Server {
	e := echo.New()
	e.Debug = true
	e.HideBanner = true
	e.HidePort = true
	e.Use(middleware.LoggerWithConfig(middleware.LoggerConfig{
		Format: `{""time"":""${time_rfc3339}"",` +
			`""method"":""${method}"",""uri"":""${uri}"",` +
			`""status"":${status},""error"":""${error}""}` + ""\n"",
	}))
	e.Use(middleware.CORS())
	e.Use(middleware.TimeoutWithConfig(middleware.TimeoutConfig{
		Skipper:      middleware.DefaultSkipper,
		ErrorMessage: ""Request timeout"",
		Timeout:      30 * time.Second,
	}))
	embedFrontend(e)
	// In dev mode, set the const secret key to make signin session persistence.
	secret := []byte(""usememos"")
	if profile.Mode == ""prod"" {
		secret = securecookie.GenerateRandomKey(16)
	}
	e.Use(session.Middleware(sessions.NewCookieStore(secret)))
	s := &Server{
		e:       e,
		Profile: profile,
	}
	rootGroup := e.Group("""")
	s.registerRSSRoutes(rootGroup)
	webhookGroup := e.Group(""/h"")
	s.registerResourcePublicRoutes(webhookGroup)
	publicGroup := e.Group(""/o"")
	s.registerResourcePublicRoutes(publicGroup)
	s.registerGetterPublicRoutes(publicGroup)
	apiGroup := e.Group(""/api"")
	apiGroup.Use(func(next echo.HandlerFunc) echo.HandlerFunc {
		return aclMiddleware(s, next)
	})
	s.registerSystemRoutes(apiGroup)
	s.registerAuthRoutes(apiGroup)
	s.registerUserRoutes(apiGroup)
	s.registerMemoRoutes(apiGroup)
	s.registerShortcutRoutes(apiGroup)
	s.registerResourceRoutes(apiGroup)
	s.registerTagRoutes(apiGroup)
	return s
}
func (server *Server) Run() error {
	return server.e.Start(fmt.Sprintf("":%d"", server.Profile.Port))
}
",CWE-941,89.0,1
"package server
import (
	""fmt""
	""time""
	""github.com/usememos/memos/server/profile""
	""github.com/usememos/memos/store""
	""github.com/gorilla/securecookie""
	""github.com/gorilla/sessions""
	""github.com/labstack/echo-contrib/session""
	""github.com/labstack/echo/v4""
	""github.com/labstack/echo/v4/middleware""
)
type Server struct {
	e *echo.Echo
	Collector *MetricCollector
	Profile *profile.Profile
	Store *store.Store
}
func NewServer(profile *profile.Profile) *Server {
	e := echo.New()
	e.Debug = true
	e.HideBanner = true
	e.HidePort = true
	e.Use(middleware.LoggerWithConfig(middleware.LoggerConfig{
		Format: `{""time"":""${time_rfc3339}"",` +
			`""method"":""${method}"",""uri"":""${uri}"",` +
			`""status"":${status},""error"":""${error}""}` + ""\n"",
	}))
	e.Use(middleware.CORS())
	e.Use(middleware.TimeoutWithConfig(middleware.TimeoutConfig{
		Skipper:      middleware.DefaultSkipper,
		ErrorMessage: ""Request timeout"",
		Timeout:      30 * time.Second,
	}))
	embedFrontend(e)
	// In dev mode, set the const secret key to make signin session persistence.
	secret := []byte(""usememos"")
	if profile.Mode == ""prod"" {
		secret = securecookie.GenerateRandomKey(16)
	}
	e.Use(session.Middleware(sessions.NewCookieStore(secret)))
	s := &Server{
		e:       e,
		Profile: profile,
	}
	rootGroup := e.Group("""")
	s.registerRSSRoutes(rootGroup)
	webhookGroup := e.Group(""/h"")
	s.registerResourcePublicRoutes(webhookGroup)
	publicGroup := e.Group(""/o"")
	s.registerResourcePublicRoutes(publicGroup)
	s.registerGetterPublicRoutes(publicGroup)
	apiGroup := e.Group(""/api"")
	apiGroup.Use(func(next echo.HandlerFunc) echo.HandlerFunc {
		return aclMiddleware(s, next)
	})
	s.registerSystemRoutes(apiGroup)
	s.registerAuthRoutes(apiGroup)
	s.registerUserRoutes(apiGroup)
	s.registerMemoRoutes(apiGroup)
	s.registerShortcutRoutes(apiGroup)
	s.registerResourceRoutes(apiGroup)
	s.registerTagRoutes(apiGroup)
	return s
}
func (server *Server) Run() error {
	return server.e.Start(fmt.Sprintf("":%d"", server.Profile.Port))
}
",CWE-940,89.0,1
"package server
import (
	""github.com/labstack/echo/v4""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
)
type response struct {
	Data interface{} `json:""data""`
}
func composeResponse(data interface{}) response {
	return response{
		Data: data,
	}
}
func (server *Server) DefaultAuthSkipper(c echo.Context) bool {
	ctx := c.Request().Context()
	path := c.Path()
	// Skip auth.
	if common.HasPrefixes(path, ""/api/auth"") {
		return true
	}
	// If there is openId in query string and related user is found, then skip auth.
	openID := c.QueryParam(""openId"")
	if openID != """" {
		userFind := &api.UserFind{
			OpenID: &openID,
		}
		user, err := server.Store.FindUser(ctx, userFind)
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return false
		}
		if user != nil {
			// Stores userID into context.
			c.Set(getUserIDContextKey(), user.ID)
			return true
		}
	}
	return false
}
",CWE-79,47.0,1
"package server
import (
	""context""
	""encoding/json""
	""fmt""
	""time""
	""github.com/pkg/errors""
	""github.com/usememos/memos/api""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/usememos/memos/server/profile""
	""github.com/usememos/memos/store""
	""github.com/usememos/memos/store/db""
	""github.com/gorilla/sessions""
	""github.com/labstack/echo-contrib/session""
	""github.com/labstack/echo/v4""
	""github.com/labstack/echo/v4/middleware""
)
type Server struct {
	e *echo.Echo
	ID        string
	Profile   *profile.Profile
	Store     *store.Store
	Collector *MetricCollector
}
func NewServer(ctx context.Context, profile *profile.Profile) (*Server, error) {
	e := echo.New()
	e.Debug = true
	e.HideBanner = true
	e.HidePort = true
	s := &Server{
		e:       e,
		Profile: profile,
	}
	db := db.NewDB(profile)
	if err := db.Open(ctx); err != nil {
		return nil, errors.Wrap(err, ""cannot open db"")
	}
	storeInstance := store.New(db.DBInstance, profile)
	s.Store = storeInstance
	e.Use(middleware.LoggerWithConfig(middleware.LoggerConfig{
		Format: `{""time"":""${time_rfc3339}"",` +
			`""method"":""${method}"",""uri"":""${uri}"",` +
			`""status"":${status},""error"":""${error}""}` + ""\n"",
	}))
	e.Use(middleware.Gzip())
	e.Use(middleware.CSRFWithConfig(middleware.CSRFConfig{
		Skipper: func(c echo.Context) bool {
			return s.DefaultAuthSkipper(c)
		},
		TokenLookup: ""cookie:_csrf"",
	}))
	e.Use(middleware.CORS())
	e.Use(middleware.Secure())
	e.Use(middleware.TimeoutWithConfig(middleware.TimeoutConfig{
		Skipper:      middleware.DefaultSkipper,
		ErrorMessage: ""Request timeout"",
		Timeout:      30 * time.Second,
	}))
	serverID, err := s.getSystemServerID(ctx)
	if err != nil {
		return nil, err
	}
	s.ID = serverID
	secretSessionName := ""usememos""
	if profile.Mode == ""prod"" {
		secretSessionName, err = s.getSystemSecretSessionName(ctx)
		if err != nil {
			return nil, err
		}
	}
	e.Use(session.Middleware(sessions.NewCookieStore([]byte(secretSessionName))))
	embedFrontend(e)
	// Register MetricCollector to server.
	s.registerMetricCollector()
	rootGroup := e.Group("""")
	s.registerRSSRoutes(rootGroup)
	webhookGroup := e.Group(""/h"")
	s.registerResourcePublicRoutes(webhookGroup)
	publicGroup := e.Group(""/o"")
	s.registerResourcePublicRoutes(publicGroup)
	registerGetterPublicRoutes(publicGroup)
	apiGroup := e.Group(""/api"")
	apiGroup.Use(func(next echo.HandlerFunc) echo.HandlerFunc {
		return aclMiddleware(s, next)
	})
	s.registerSystemRoutes(apiGroup)
	s.registerAuthRoutes(apiGroup)
	s.registerUserRoutes(apiGroup)
	s.registerMemoRoutes(apiGroup)
	s.registerShortcutRoutes(apiGroup)
	s.registerResourceRoutes(apiGroup)
	s.registerTagRoutes(apiGroup)
	return s, nil
}
func (s *Server) Run(ctx context.Context) error {
	if err := s.createServerStartActivity(ctx); err != nil {
		return errors.Wrap(err, ""failed to create activity"")
	}
	s.Collector.Identify(ctx)
	return s.e.Start(fmt.Sprintf("":%d"", s.Profile.Port))
}
func (s *Server) createServerStartActivity(ctx context.Context) error {
	payload := api.ActivityServerStartPayload{
		ServerID: s.ID,
		Profile:  s.Profile,
	}
	payloadStr, err := json.Marshal(payload)
	if err != nil {
		return errors.Wrap(err, ""failed to marshal activity payload"")
	}
	activity, err := s.Store.CreateActivity(ctx, &api.ActivityCreate{
		CreatorID: api.UnknownID,
		Type:      api.ActivityServerStart,
		Level:     api.ActivityInfo,
		Payload:   string(payloadStr),
	})
	s.Collector.Collect(ctx, &metric.Metric{
		Name: string(activity.Type),
	})
	return err
}
",CWE-79,148.0,1
"package version
import (
	""strconv""
	""strings""
)
// Version is the service current released version.
// Semantic versioning: https://semver.org/
var Version = ""0.9.1""
// DevVersion is the service current development version.
var DevVersion = ""0.9.1""
func GetCurrentVersion(mode string) string {
	if mode == ""dev"" {
		return DevVersion
	}
	return Version
}
func GetMinorVersion(version string) string {
	versionList := strings.Split(version, ""."")
	if len(versionList) < 3 {
		return """"
	}
	return versionList[0] + ""."" + versionList[1]
}
func GetSchemaVersion(version string) string {
	minorVersion := GetMinorVersion(version)
	return minorVersion + "".0""
}
// convSemanticVersionToInt converts version string to int.
func convSemanticVersionToInt(version string) int {
	versionList := strings.Split(version, ""."")
	if len(versionList) < 3 {
		return 0
	}
	major, err := strconv.Atoi(versionList[0])
	if err != nil {
		return 0
	}
	minor, err := strconv.Atoi(versionList[1])
	if err != nil {
		return 0
	}
	patch, err := strconv.Atoi(versionList[2])
	if err != nil {
		return 0
	}
	return major*10000 + minor*100 + patch
}
// IsVersionGreaterThanOrEqualTo returns true if version is greater than or equal to target.
func IsVersionGreaterOrEqualThan(version, target string) bool {
	return convSemanticVersionToInt(version) >= convSemanticVersionToInt(target)
}
// IsVersionGreaterThan returns true if version is greater than target.
func IsVersionGreaterThan(version, target string) bool {
	return convSemanticVersionToInt(version) > convSemanticVersionToInt(target)
}
",CWE-79,68.0,1
"module github.com/usememos/memos
go 1.21
require (
	github.com/aws/aws-sdk-go-v2 v1.17.4
	github.com/aws/aws-sdk-go-v2/config v1.18.12
	github.com/aws/aws-sdk-go-v2/credentials v1.13.12
	github.com/aws/aws-sdk-go-v2/feature/s3/manager v1.11.51
	github.com/aws/aws-sdk-go-v2/service/s3 v1.30.3
	github.com/disintegration/imaging v1.6.2
	github.com/google/cel-go v0.17.1
	github.com/google/uuid v1.3.0
	github.com/gorilla/feeds v1.1.1
	github.com/grpc-ecosystem/grpc-gateway/v2 v2.16.2
	github.com/improbable-eng/grpc-web v0.15.0
	github.com/labstack/echo/v4 v4.11.1
	github.com/pkg/errors v0.9.1
	github.com/spf13/cobra v1.6.1
	github.com/spf13/viper v1.15.0
	github.com/stretchr/testify v1.8.4
	github.com/swaggo/echo-swagger v1.4.0
	github.com/swaggo/swag v1.16.1
	github.com/yuin/goldmark v1.5.4
	go.uber.org/zap v1.24.0
	golang.org/x/crypto v0.12.0
	golang.org/x/exp v0.0.0-20230111222715-75897c7a292a
	golang.org/x/mod v0.12.0
	golang.org/x/net v0.14.0
	golang.org/x/oauth2 v0.10.0
	google.golang.org/genproto/googleapis/api v0.0.0-20230726155614-23370e0ffb3e
	google.golang.org/grpc v1.57.0
	modernc.org/sqlite v1.24.0
)
require (
	github.com/KyleBanks/depth v1.2.1 // indirect
	github.com/antlr/antlr4/runtime/Go/antlr/v4 v4.0.0-20230305170008-8188dc5388df // indirect
	github.com/cenkalti/backoff/v4 v4.1.1 // indirect
	github.com/desertbit/timer v0.0.0-20180107155436-c41aec40b27f // indirect
	github.com/dustin/go-humanize v1.0.1 // indirect
	github.com/go-openapi/jsonpointer v0.20.0 // indirect
	github.com/go-openapi/jsonreference v0.20.2 // indirect
	github.com/go-openapi/spec v0.20.9 // indirect
	github.com/go-openapi/swag v0.22.4 // indirect
	github.com/josharian/intern v1.0.0 // indirect
	github.com/kballard/go-shellquote v0.0.0-20180428030007-95032a82bc51 // indirect
	github.com/klauspost/compress v1.11.7 // indirect
	github.com/mailru/easyjson v0.7.7 // indirect
	github.com/remyoudompheng/bigfft v0.0.0-20230129092748-24d4a6f8daec // indirect
	github.com/rogpeppe/go-internal v1.9.0 // indirect
	github.com/rs/cors v1.7.0 // indirect
	github.com/stoewer/go-strcase v1.2.0 // indirect
	github.com/swaggo/files/v2 v2.0.0 // indirect
	golang.org/x/image v0.7.0 // indirect
	golang.org/x/tools v0.11.1 // indirect
	google.golang.org/genproto v0.0.0-20230706204954-ccb25ca9f130 // indirect
	google.golang.org/genproto/googleapis/rpc v0.0.0-20230726155614-23370e0ffb3e // indirect
	lukechampine.com/uint128 v1.2.0 // indirect
	modernc.org/cc/v3 v3.40.0 // indirect
	modernc.org/ccgo/v3 v3.16.13 // indirect
	modernc.org/libc v1.22.5 // indirect
	modernc.org/mathutil v1.5.0 // indirect
	modernc.org/memory v1.5.0 // indirect
	modernc.org/opt v0.1.3 // indirect
	modernc.org/strutil v1.1.3 // indirect
	modernc.org/token v1.0.1 // indirect
	nhooyr.io/websocket v1.8.6 // indirect
)
require (
	github.com/aws/aws-sdk-go-v2/aws/protocol/eventstream v1.4.10 // indirect
	github.com/aws/aws-sdk-go-v2/feature/ec2/imds v1.12.22 // indirect
	github.com/aws/aws-sdk-go-v2/internal/configsources v1.1.28 // indirect
	github.com/aws/aws-sdk-go-v2/internal/endpoints/v2 v2.4.22 // indirect
	github.com/aws/aws-sdk-go-v2/internal/ini v1.3.29 // indirect
	github.com/aws/aws-sdk-go-v2/internal/v4a v1.0.20 // indirect
	github.com/aws/aws-sdk-go-v2/service/internal/accept-encoding v1.9.11 // indirect
	github.com/aws/aws-sdk-go-v2/service/internal/checksum v1.1.23 // indirect
	github.com/aws/aws-sdk-go-v2/service/internal/presigned-url v1.9.22 // indirect
	github.com/aws/aws-sdk-go-v2/service/internal/s3shared v1.13.22 // indirect
	github.com/aws/aws-sdk-go-v2/service/sso v1.12.1 // indirect
	github.com/aws/aws-sdk-go-v2/service/ssooidc v1.14.1 // indirect
	github.com/aws/aws-sdk-go-v2/service/sts v1.18.3 // indirect
	github.com/aws/smithy-go v1.13.5 // indirect
	github.com/davecgh/go-spew v1.1.1 // indirect
	github.com/fsnotify/fsnotify v1.6.0 // indirect
	github.com/golang-jwt/jwt v3.2.2+incompatible // indirect
	github.com/golang-jwt/jwt/v4 v4.5.0
	github.com/golang/protobuf v1.5.3 // indirect
	github.com/hashicorp/hcl v1.0.0 // indirect
	github.com/inconshreveable/mousetrap v1.0.1 // indirect
	github.com/jmespath/go-jmespath v0.4.0 // indirect
	github.com/labstack/gommon v0.4.0 // indirect
	github.com/magiconair/properties v1.8.7 // indirect
	github.com/mattn/go-colorable v0.1.13 // indirect
	github.com/mattn/go-isatty v0.0.19 // indirect
	github.com/mitchellh/mapstructure v1.5.0 // indirect
	github.com/pelletier/go-toml/v2 v2.0.6 // indirect
	github.com/pmezard/go-difflib v1.0.0 // indirect
	github.com/spf13/afero v1.9.3 // indirect
	github.com/spf13/cast v1.5.0 // indirect
	github.com/spf13/jwalterweatherman v1.1.0 // indirect
	github.com/spf13/pflag v1.0.5 // indirect
	github.com/subosito/gotenv v1.4.2 // indirect
	github.com/valyala/bytebufferpool v1.0.0 // indirect
	github.com/valyala/fasttemplate v1.2.2 // indirect
	go.uber.org/atomic v1.9.0 // indirect
	go.uber.org/multierr v1.8.0 // indirect
	golang.org/x/sys v0.11.0 // indirect
	golang.org/x/text v0.12.0 // indirect
	golang.org/x/time v0.3.0 // indirect
	google.golang.org/appengine v1.6.7 // indirect
	google.golang.org/protobuf v1.31.0
	gopkg.in/ini.v1 v1.67.0 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
)
",CWE-352,118.0,1
"package getter
import (
	""errors""
	""io""
	""net/http""
	""net/url""
	""strings""
)
type Image struct {
	Blob      []byte
	Mediatype string
}
func GetImage(urlStr string) (*Image, error) {
	if _, err := url.Parse(urlStr); err != nil {
		return nil, err
	}
	response, err := http.Get(urlStr)
	if err != nil {
		return nil, err
	}
	defer response.Body.Close()
	mediatype, err := getMediatype(response)
	if err != nil {
		return nil, err
	}
	if !strings.HasPrefix(mediatype, ""image/"") {
		return nil, errors.New(""Wrong image mediatype"")
	}
	bodyBytes, err := io.ReadAll(response.Body)
	if err != nil {
		return nil, err
	}
	image := &Image{
		Blob:      bodyBytes,
		Mediatype: mediatype,
	}
	return image, nil
}
",CWE-352,46.0,1
"package client
import (
	""errors""
	""fmt""
)
var (
	ErrNoRootKeys       = errors.New(""tuf: no root keys found in local meta store"")
	ErrInsufficientKeys = errors.New(""tuf: insufficient keys to meet threshold"")
	ErrNoLocalSnapshot  = errors.New(""tuf: no snapshot stored locally"")
)
type ErrMissingRemoteMetadata struct {
	Name string
}
func (e ErrMissingRemoteMetadata) Error() string {
	return fmt.Sprintf(""tuf: missing remote metadata %s"", e.Name)
}
type ErrDownloadFailed struct {
	File string
	Err  error
}
func (e ErrDownloadFailed) Error() string {
	return fmt.Sprintf(""tuf: failed to download %s: %s"", e.File, e.Err)
}
type ErrDecodeFailed struct {
	File string
	Err  error
}
func (e ErrDecodeFailed) Error() string {
	return fmt.Sprintf(""tuf: failed to decode %s: %s"", e.File, e.Err)
}
type ErrMaxDelegations struct {
	Target          string
	MaxDelegations  int
	SnapshotVersion int64
}
func (e ErrMaxDelegations) Error() string {
	return fmt.Sprintf(""tuf: max delegation of %d reached searching for %s with snapshot version %d"", e.MaxDelegations, e.Target, e.SnapshotVersion)
}
type ErrNotFound struct {
	File string
}
func (e ErrNotFound) Error() string {
	return fmt.Sprintf(""tuf: file not found: %s"", e.File)
}
func IsNotFound(err error) bool {
	_, ok := err.(ErrNotFound)
	return ok
}
type ErrWrongSize struct {
	File     string
	Actual   int64
	Expected int64
}
func (e ErrWrongSize) Error() string {
	return fmt.Sprintf(""tuf: unexpected file size: %s (expected %d bytes, got %d bytes)"", e.File, e.Expected, e.Actual)
}
type ErrLatestSnapshot struct {
	Version int64
}
func (e ErrLatestSnapshot) Error() string {
	return fmt.Sprintf(""tuf: the local snapshot version (%d) is the latest"", e.Version)
}
func IsLatestSnapshot(err error) bool {
	_, ok := err.(ErrLatestSnapshot)
	return ok
}
type ErrUnknownTarget struct {
	Name            string
	SnapshotVersion int64
}
func (e ErrUnknownTarget) Error() string {
	return fmt.Sprintf(""tuf: unknown target file: %s with snapshot version %d"", e.Name, e.SnapshotVersion)
}
type ErrMetaTooLarge struct {
	Name    string
	Size    int64
	MaxSize int64
}
func (e ErrMetaTooLarge) Error() string {
	return fmt.Sprintf(""tuf: %s size %d bytes greater than maximum %d bytes"", e.Name, e.Size, e.MaxSize)
}
type ErrInvalidURL struct {
	URL string
}
func (e ErrInvalidURL) Error() string {
	return fmt.Sprintf(""tuf: invalid repository URL %s"", e.URL)
}
type ErrRoleNotInSnapshot struct {
	Role            string
	SnapshotVersion int64
}
func (e ErrRoleNotInSnapshot) Error() string {
	return fmt.Sprintf(""tuf: role %s not in snapshot version %d"", e.Role, e.SnapshotVersion)
}
",CWE-354,121.0,1
"package main
import (
	""io""
	""io/ioutil""
	""os""
	""github.com/flynn/go-docopt""
	tuf ""github.com/theupdateframework/go-tuf/client""
	""github.com/theupdateframework/go-tuf/util""
)
func init() {
	register(""get"", cmdGet, `
usage: tuf-client get [-s|--store=<path>] <url> <target>
Options:
  -s <path>    The path to the local file store [default: tuf.db]
Get a target from the repository.
  `)
}
type tmpFile struct {
	*os.File
}
func (t *tmpFile) Delete() error {
	t.Close()
	return os.Remove(t.Name())
}
func cmdGet(args *docopt.Args, client *tuf.Client) error {
	if _, err := client.Update(); err != nil && !tuf.IsLatestSnapshot(err) {
		return err
	}
	target := util.NormalizeTarget(args.String[""<target>""])
	file, err := ioutil.TempFile("""", ""go-tuf"")
	if err != nil {
		return err
	}
	tmp := tmpFile{file}
	if err := client.Download(target, &tmp); err != nil {
		return err
	}
	defer tmp.Delete()
	if _, err := tmp.Seek(0, io.SeekStart); err != nil {
		return err
	}
	_, err = io.Copy(os.Stdout, file)
	return err
}
",CWE-354,53.0,1
"package main
import (
	""fmt""
	""os""
	""text/tabwriter""
	""github.com/dustin/go-humanize""
	""github.com/flynn/go-docopt""
	tuf ""github.com/theupdateframework/go-tuf/client""
)
func init() {
	register(""list"", cmdList, `
usage: tuf-client list [-s|--store=<path>] <url>
Options:
  -s <path>    The path to the local file store [default: tuf.db]
List available target files.
  `)
}
func cmdList(args *docopt.Args, client *tuf.Client) error {
	if _, err := client.Update(); err != nil && !tuf.IsLatestSnapshot(err) {
		return err
	}
	targets, err := client.Targets()
	if err != nil {
		return err
	}
	w := tabwriter.NewWriter(os.Stdout, 1, 2, 2, ' ', 0)
	defer w.Flush()
	fmt.Fprintln(w, ""PATH\tSIZE"")
	for path, meta := range targets {
		fmt.Fprintf(w, ""%s\t%s\n"", path, humanize.Bytes(uint64(meta.Length)))
	}
	return nil
}
",CWE-354,40.0,1
"package verify
import (
	""errors""
	""fmt""
	""time""
)
var (
	ErrMissingKey           = errors.New(""tuf: missing key"")
	ErrNoSignatures         = errors.New(""tuf: data has no signatures"")
	ErrInvalid              = errors.New(""tuf: signature verification failed"")
	ErrWrongMethod          = errors.New(""tuf: invalid signature type"")
	ErrWrongMetaType        = errors.New(""tuf: meta file has wrong type"")
	ErrExists               = errors.New(""tuf: key already in db"")
	ErrInvalidKey           = errors.New(""tuf: invalid key"")
	ErrInvalidRole          = errors.New(""tuf: invalid role"")
	ErrInvalidDelegatedRole = errors.New(""tuf: invalid delegated role"")
	ErrInvalidKeyID         = errors.New(""tuf: invalid key id"")
	ErrInvalidThreshold     = errors.New(""tuf: invalid role threshold"")
)
type ErrWrongID struct{}
func (ErrWrongID) Error() string {
	return ""tuf: key id mismatch""
}
type ErrUnknownRole struct {
	Role string
}
func (e ErrUnknownRole) Error() string {
	return fmt.Sprintf(""tuf: unknown role %q"", e.Role)
}
type ErrExpired struct {
	Expired time.Time
}
func (e ErrExpired) Error() string {
	return fmt.Sprintf(""expired at %s"", e.Expired)
}
type ErrLowVersion struct {
	Actual  int64
	Current int64
}
func (e ErrLowVersion) Error() string {
	return fmt.Sprintf(""version %d is lower than current version %d"", e.Actual, e.Current)
}
type ErrWrongVersion struct {
	Given    int64
	Expected int64
}
func (e ErrWrongVersion) Error() string {
	return fmt.Sprintf(""version %d does not match the expected version %d"", e.Given, e.Expected)
}
type ErrRoleThreshold struct {
	Expected int
	Actual   int
}
func (e ErrRoleThreshold) Error() string {
	return ""tuf: valid signatures did not meet threshold""
}
",CWE-354,71.0,1
"package verify
import (
	""encoding/json""
	""strings""
	""time""
	""github.com/secure-systems-lab/go-securesystemslib/cjson""
	""github.com/theupdateframework/go-tuf/data""
	""github.com/theupdateframework/go-tuf/internal/roles""
)
type signedMeta struct {
	Type    string    `json:""_type""`
	Expires time.Time `json:""expires""`
	Version int64     `json:""version""`
}
func (db *DB) VerifyIgnoreExpiredCheck(s *data.Signed, role string, minVersion int64) error {
	if err := db.VerifySignatures(s, role); err != nil {
		return err
	}
	sm := &signedMeta{}
	if err := json.Unmarshal(s.Signed, sm); err != nil {
		return err
	}
	if roles.IsTopLevelRole(role) {
		// Top-level roles can only sign metadata of the same type (e.g. snapshot
		// metadata must be signed by the snapshot role).
		if !strings.EqualFold(sm.Type, role) {
			return ErrWrongMetaType
		}
	} else {
		// Delegated (non-top-level) roles may only sign targets metadata.
		if strings.ToLower(sm.Type) != ""targets"" {
			return ErrWrongMetaType
		}
	}
	if sm.Version < minVersion {
		return ErrLowVersion{sm.Version, minVersion}
	}
	return nil
}
func (db *DB) Verify(s *data.Signed, role string, minVersion int64) error {
	err := db.VerifyIgnoreExpiredCheck(s, role, minVersion)
	if err != nil {
		return err
	}
	sm := &signedMeta{}
	if err := json.Unmarshal(s.Signed, sm); err != nil {
		return err
	}
	if IsExpired(sm.Expires) {
		return ErrExpired{sm.Expires}
	}
	return nil
}
var IsExpired = func(t time.Time) bool {
	return time.Until(t) <= 0
}
func (db *DB) VerifySignatures(s *data.Signed, role string) error {
	if len(s.Signatures) == 0 {
		return ErrNoSignatures
	}
	roleData := db.GetRole(role)
	if roleData == nil {
		return ErrUnknownRole{role}
	}
	var decoded map[string]interface{}
	if err := json.Unmarshal(s.Signed, &decoded); err != nil {
		return err
	}
	msg, err := cjson.EncodeCanonical(decoded)
	if err != nil {
		return err
	}
	// Verify that a threshold of keys signed the data. Since keys can have
	// multiple key ids, we need to protect against multiple attached
	// signatures that just differ on the key id.
	seen := make(map[string]struct{})
	valid := 0
	for _, sig := range s.Signatures {
		if !roleData.ValidKey(sig.KeyID) {
			continue
		}
		verifier, err := db.GetVerifier(sig.KeyID)
		if err != nil {
			continue
		}
		if err := verifier.Verify(msg, sig.Signature); err != nil {
			return ErrInvalid
		}
		// Only consider this key valid if we haven't seen any of it's
		// key ids before.
		if _, ok := seen[sig.KeyID]; !ok {
			for _, id := range verifier.MarshalPublicKey().IDs() {
				seen[id] = struct{}{}
			}
			valid++
		}
	}
	if valid < roleData.Threshold {
		return ErrRoleThreshold{roleData.Threshold, valid}
	}
	return nil
}
func (db *DB) Unmarshal(b []byte, v interface{}, role string, minVersion int64) error {
	s := &data.Signed{}
	if err := json.Unmarshal(b, s); err != nil {
		return err
	}
	if err := db.Verify(s, role, minVersion); err != nil {
		return err
	}
	return json.Unmarshal(s.Signed, v)
}
// UnmarshalExpired is exactly like Unmarshal except ignores expired timestamp error.
func (db *DB) UnmarshalIgnoreExpired(b []byte, v interface{}, role string, minVersion int64) error {
	s := &data.Signed{}
	if err := json.Unmarshal(b, s); err != nil {
		return err
	}
	// Note: If verification fails, then we wont attempt to unmarshal
	// unless when verification error is errExpired.
	verifyErr := db.Verify(s, role, minVersion)
	if verifyErr != nil {
		if _, ok := verifyErr.(ErrExpired); !ok {
			return verifyErr
		}
	}
	return json.Unmarshal(s.Signed, v)
}
func (db *DB) UnmarshalTrusted(b []byte, v interface{}, role string) error {
	s := &data.Signed{}
	if err := json.Unmarshal(b, s); err != nil {
		return err
	}
	if err := db.VerifySignatures(s, role); err != nil {
		return err
	}
	return json.Unmarshal(s.Signed, v)
}
",CWE-354,165.0,1
"package getter
import ""net/url""
// RedactURL is a port of url.Redacted from the standard library,
// which is like url.String but replaces any password with ""xxxxx"".
// Only the password in u.URL is redacted. This allows the library
// to maintain compatibility with go1.14.
func RedactURL(u *url.URL) string {
	if u == nil {
		return """"
	}
	ru := *u
	if _, has := ru.User.Password(); has {
		ru.User = url.UserPassword(ru.User.Username(), ""xxxxx"")
	}
	return ru.String()
}
",CWE-532,20.0,1
"package getter
import (
	""net/url""
	""testing""
)
func TestRedactURL(t *testing.T) {
	cases := []struct {
		name string
		url  *url.URL
		want string
	}{
		{
			name: ""non-blank Password"",
			url: &url.URL{
				Scheme: ""http"",
				Host:   ""host.tld"",
				Path:   ""this:that"",
				User:   url.UserPassword(""user"", ""password""),
			},
			want: ""http://user:xxxxx@host.tld/this:that"",
		},
		{
			name: ""blank Password"",
			url: &url.URL{
				Scheme: ""http"",
				Host:   ""host.tld"",
				Path:   ""this:that"",
				User:   url.User(""user""),
			},
			want: ""http://user@host.tld/this:that"",
		},
		{
			name: ""nil User"",
			url: &url.URL{
				Scheme: ""http"",
				Host:   ""host.tld"",
				Path:   ""this:that"",
				User:   url.UserPassword("""", ""password""),
			},
			want: ""http://:xxxxx@host.tld/this:that"",
		},
		{
			name: ""blank Username, blank Password"",
			url: &url.URL{
				Scheme: ""http"",
				Host:   ""host.tld"",
				Path:   ""this:that"",
			},
			want: ""http://host.tld/this:that"",
		},
		{
			name: ""empty URL"",
			url:  &url.URL{},
			want: """",
		},
		{
			name: ""nil URL"",
			url:  nil,
			want: """",
		},
	}
	for _, tt := range cases {
		t := t
		t.Run(tt.name, func(t *testing.T) {
			if g, w := RedactURL(tt.url), tt.want; g != w {
				t.Fatalf(""got: %q\nwant: %q"", g, w)
			}
		})
	}
}
",CWE-532,74.0,1
"{
	""name"": ""froxlor/froxlor"",
	""description"": ""The server administration software for your needs. Developed by experienced server administrators, this panel simplifies the effort of managing your hosting platform."",
	""keywords"": [
		""server"",
		""administration"",
		""php""
	],
	""homepage"": ""https://www.froxlor.org"",
	""license"": ""GPL-2.0-or-later"",
	""authors"": [
		{
			""name"": ""Michael Kaufmann"",
			""email"": ""team@froxlor.org"",
			""role"": ""Lead Developer""
		}
	],
	""support"": {
		""email"": ""team@froxlor.org"",
		""issues"": ""https://github.com/Froxlor/Froxlor/issues"",
		""forum"": ""https://forum.froxlor.org/"",
		""source"": ""https://github.com/Froxlor/Froxlor"",
		""docs"": ""https://docs.froxlor.org/"",
		""chat"": ""https://discord.froxlor.org/""
	},
	""funding"": [
		{
			""type"": ""github"",
			""url"": ""https://github.com/sponsors/d00p""
		}
	],
	""require"": {
		""php"": ""^7.4 || ^8.0"",
		""ext-session"": ""*"",
		""ext-ctype"": ""*"",
		""ext-pdo"": ""*"",
		""ext-pdo_mysql"": ""*"",
		""ext-simplexml"": ""*"",
		""ext-xml"": ""*"",
		""ext-filter"": ""*"",
		""ext-posix"": ""*"",
		""ext-mbstring"": ""*"",
		""ext-curl"": ""*"",
		""ext-json"": ""*"",
		""ext-openssl"": ""*"",
		""ext-fileinfo"": ""*"",
		""ext-gmp"": ""*"",
		""ext-gd"": ""*"",
		""ext-gnupg"": ""*"",
		""phpmailer/phpmailer"": ""~6.0"",
		""monolog/monolog"": ""^1.24"",
		""robthree/twofactorauth"": ""^1.6"",
		""froxlor/idna-convert-legacy"": ""^2.1"",
		""voku/anti-xss"": ""^4.1"",
		""twig/twig"": ""^3.3"",
		""erusev/parsedown"": ""^1.7"",
		""symfony/console"": ""^5.4"",
		""pear/net_dns2"": ""^1.5"",
		""amnuts/opcache-gui"": ""^3.4""
    },
	""require-dev"": {
		""phpunit/phpunit"": ""^9"",
		""ext-pcntl"": ""*"",
		""phpcompatibility/php-compatibility"": ""*"",
		""squizlabs/php_codesniffer"": ""*"",
		""pdepend/pdepend"": ""^2.9"",
		""sebastian/phpcpd"": ""^6.0"",
		""phploc/phploc"": ""^7.0"",
		""phpmd/phpmd"": ""^2.10"",
		""phpunit/php-timer"" : ""^5"",
		""phpstan/phpstan"": ""^1.8""
	},
	""suggest"": {
		""ext-bcmath"": ""*"",
		""ext-zip"": ""*"",
		""ext-apcu"": ""*"",
		""ext-readline"": ""*""
	},
	""autoload"": {
		""psr-4"": {
			""Froxlor\\"": [
				""lib/Froxlor""
			]
		}
	},
	""scripts"": {
		""post-install-cmd"": ""if [ -f ./vendor/bin/phpcs ]; then \""vendor/bin/phpcs\"" --config-set installed_paths vendor/phpcompatibility/php-compatibility ; fi"",
		""post-update-cmd"" : ""if [ -f ./vendor/bin/phpcs ]; then \""vendor/bin/phpcs\"" --config-set installed_paths vendor/phpcompatibility/php-compatibility ; fi""
	}
}
",CWE-79,91.0,1
"// Copyright 2019 PingCAP, Inc.
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package common_test
import (
	""context""
	""database/sql""
	""database/sql/driver""
	""encoding/base64""
	""encoding/json""
	""fmt""
	""io""
	""math/rand""
	""net/http""
	""net/http/httptest""
	""strconv""
	""testing""
	""time""
	""github.com/DATA-DOG/go-sqlmock""
	""github.com/go-sql-driver/mysql""
	""github.com/pingcap/errors""
	""github.com/pingcap/failpoint""
	""github.com/pingcap/tidb/br/pkg/lightning/common""
	""github.com/pingcap/tidb/br/pkg/lightning/log""
	tmysql ""github.com/pingcap/tidb/errno""
	""github.com/stretchr/testify/assert""
	""github.com/stretchr/testify/require""
)
func TestDirNotExist(t *testing.T) {
	require.True(t, common.IsDirExists("".""))
	require.False(t, common.IsDirExists(""not-exists""))
}
func TestGetJSON(t *testing.T) {
	type TestPayload struct {
		Username string `json:""username""`
		Password string `json:""password""`
	}
	request := TestPayload{
		Username: ""lightning"",
		Password: ""lightning-ctl"",
	}
	ctx := context.Background()
	// Mock success response
	handle := func(res http.ResponseWriter, _ *http.Request) {
		res.WriteHeader(http.StatusOK)
		err := json.NewEncoder(res).Encode(request)
		require.NoError(t, err)
	}
	testServer := httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
		handle(res, req)
	}))
	defer testServer.Close()
	client := &http.Client{Timeout: time.Second}
	response := TestPayload{}
	err := common.GetJSON(ctx, client, ""http://not-exists"", &response)
	require.Error(t, err)
	err = common.GetJSON(ctx, client, testServer.URL, &response)
	require.NoError(t, err)
	require.Equal(t, request, response)
	// Mock `StatusNoContent` response
	handle = func(res http.ResponseWriter, _ *http.Request) {
		res.WriteHeader(http.StatusNoContent)
	}
	err = common.GetJSON(ctx, client, testServer.URL, &response)
	require.Error(t, err)
	require.Regexp(t, "".*http status code != 200.*"", err.Error())
}
func TestToDSN(t *testing.T) {
	param := common.MySQLConnectParam{
		Host:             ""127.0.0.1"",
		Port:             4000,
		User:             ""root"",
		Password:         ""123456"",
		SQLMode:          ""strict"",
		MaxAllowedPacket: 1234,
		TLS:              ""cluster"",
		Vars: map[string]string{
			""tidb_distsql_scan_concurrency"": ""1"",
		},
	}
	require.Equal(t, ""root:123456@tcp(127.0.0.1:4000)/?charset=utf8mb4&sql_mode='strict'&maxAllowedPacket=1234&tls=cluster&tidb_distsql_scan_concurrency='1'"", param.ToDSN())
	param.Host = ""::1""
	require.Equal(t, ""root:123456@tcp([::1]:4000)/?charset=utf8mb4&sql_mode='strict'&maxAllowedPacket=1234&tls=cluster&tidb_distsql_scan_concurrency='1'"", param.ToDSN())
}
type mockDriver struct {
	driver.Driver
	plainPsw string
}
func (m *mockDriver) Open(dsn string) (driver.Conn, error) {
	cfg, err := mysql.ParseDSN(dsn)
	if err != nil {
		return nil, err
	}
	accessDenied := cfg.Passwd != m.plainPsw
	return &mockConn{accessDenied: accessDenied}, nil
}
type mockConn struct {
	driver.Conn
	driver.Pinger
	accessDenied bool
}
func (c *mockConn) Ping(ctx context.Context) error {
	if c.accessDenied {
		return &mysql.MySQLError{Number: tmysql.ErrAccessDenied, Message: ""access denied""}
	}
	return nil
}
func (c *mockConn) Close() error {
	return nil
}
func TestConnect(t *testing.T) {
	plainPsw := ""dQAUoDiyb1ucWZk7""
	driverName := ""mysql-mock-"" + strconv.Itoa(rand.Int())
	sql.Register(driverName, &mockDriver{plainPsw: plainPsw})
	require.NoError(t, failpoint.Enable(
		""github.com/pingcap/tidb/br/pkg/lightning/common/MockMySQLDriver"",
		fmt.Sprintf(""return(\""%s\"")"", driverName)))
	defer func() {
		require.NoError(t, failpoint.Disable(""github.com/pingcap/tidb/br/pkg/lightning/common/MockMySQLDriver""))
	}()
	param := common.MySQLConnectParam{
		Host:             ""127.0.0.1"",
		Port:             4000,
		User:             ""root"",
		Password:         plainPsw,
		SQLMode:          ""strict"",
		MaxAllowedPacket: 1234,
	}
	db, err := param.Connect()
	require.NoError(t, err)
	require.NoError(t, db.Close())
	param.Password = base64.StdEncoding.EncodeToString([]byte(plainPsw))
	db, err = param.Connect()
	require.NoError(t, err)
	require.NoError(t, db.Close())
}
func TestIsContextCanceledError(t *testing.T) {
	require.True(t, common.IsContextCanceledError(context.Canceled))
	require.False(t, common.IsContextCanceledError(io.EOF))
}
func TestUniqueTable(t *testing.T) {
	tableName := common.UniqueTable(""test"", ""t1"")
	require.Equal(t, ""`test`.`t1`"", tableName)
	tableName = common.UniqueTable(""test"", ""t`1"")
	require.Equal(t, ""`test`.`t``1`"", tableName)
}
func TestSQLWithRetry(t *testing.T) {
	db, mock, err := sqlmock.New()
	require.NoError(t, err)
	defer db.Close()
	sqlWithRetry := &common.SQLWithRetry{
		DB:     db,
		Logger: log.L(),
	}
	aValue := new(int)
	// retry defaultMaxRetry times and still failed
	for i := 0; i < 3; i++ {
		mock.ExpectQuery(""select a from test.t1"").WillReturnError(errors.Annotate(mysql.ErrInvalidConn, ""mock error""))
	}
	err = sqlWithRetry.QueryRow(context.Background(), """", ""select a from test.t1"", aValue)
	require.Regexp(t, "".*mock error"", err.Error())
	// meet unretryable error and will return directly
	mock.ExpectQuery(""select a from test.t1"").WillReturnError(context.Canceled)
	err = sqlWithRetry.QueryRow(context.Background(), """", ""select a from test.t1"", aValue)
	require.Regexp(t, "".*context canceled"", err.Error())
	// query success
	rows := sqlmock.NewRows([]string{""a""}).AddRow(""1"")
	mock.ExpectQuery(""select a from test.t1"").WillReturnRows(rows)
	err = sqlWithRetry.QueryRow(context.Background(), """", ""select a from test.t1"", aValue)
	require.NoError(t, err)
	require.Equal(t, 1, *aValue)
	// test Exec
	mock.ExpectExec(""delete from"").WillReturnError(context.Canceled)
	err = sqlWithRetry.Exec(context.Background(), """", ""delete from test.t1 where id = ?"", 2)
	require.Regexp(t, "".*context canceled"", err.Error())
	mock.ExpectExec(""delete from"").WillReturnResult(sqlmock.NewResult(0, 1))
	err = sqlWithRetry.Exec(context.Background(), """", ""delete from test.t1 where id = ?"", 2)
	require.NoError(t, err)
	require.Nil(t, mock.ExpectationsWereMet())
}
func TestStringSliceEqual(t *testing.T) {
	assert.True(t, common.StringSliceEqual(nil, nil))
	assert.True(t, common.StringSliceEqual(nil, []string{}))
	assert.False(t, common.StringSliceEqual(nil, []string{""a""}))
	assert.False(t, common.StringSliceEqual([]string{""a""}, nil))
	assert.True(t, common.StringSliceEqual([]string{""a""}, []string{""a""}))
	assert.False(t, common.StringSliceEqual([]string{""a""}, []string{""b""}))
	assert.True(t, common.StringSliceEqual([]string{""a"", ""b"", ""c""}, []string{""a"", ""b"", ""c""}))
	assert.False(t, common.StringSliceEqual([]string{""a""}, []string{""a"", ""b"", ""c""}))
	assert.False(t, common.StringSliceEqual([]string{""a"", ""b"", ""c""}, []string{""a"", ""b""}))
	assert.False(t, common.StringSliceEqual([]string{""a"", ""x"", ""y""}, []string{""a"", ""y"", ""x""}))
}
func TestInterpolateMySQLString(t *testing.T) {
	assert.Equal(t, ""'123'"", common.InterpolateMySQLString(""123""))
	assert.Equal(t, ""'1''23'"", common.InterpolateMySQLString(""1'23""))
	assert.Equal(t, ""'1''2''''3'"", common.InterpolateMySQLString(""1'2''3""))
}
",CWE-134,241.0,1
"// Copyright 2021 PingCAP, Inc. Licensed under Apache-2.0.
package main
import (
	""context""
	""database/sql""
	""fmt""
	""os""
	_ ""github.com/go-sql-driver/mysql""
	""github.com/pingcap/errors""
	""github.com/spf13/cobra""
	""golang.org/x/sync/errgroup""
)
const (
	flagDatabase = ""database""
	flagTable    = ""table""
	flagPort     = ""port""
	flagWorker   = ""worker""
)
var rootCmd *cobra.Command
func main() {
	rootCmd = &cobra.Command{}
	rootCmd.Flags().StringP(flagDatabase, ""B"", ""s3"", ""Database to import"")
	rootCmd.Flags().StringP(flagTable, ""T"", ""t"", ""Table to import"")
	rootCmd.Flags().IntP(flagPort, ""P"", 4000, ""TCP/IP port to connect to"")
	rootCmd.Flags().IntP(flagWorker, ""w"", 16, ""Workers to import synchronously"")
	rootCmd.RunE = func(cmd *cobra.Command, args []string) error {
		database, err := cmd.Flags().GetString(flagDatabase)
		if err != nil {
			return errors.Trace(err)
		}
		table, err := cmd.Flags().GetString(flagTable)
		if err != nil {
			return errors.Trace(err)
		}
		port, err := cmd.Flags().GetInt(flagPort)
		if err != nil {
			return errors.Trace(err)
		}
		worker, err := cmd.Flags().GetInt(flagWorker)
		if err != nil {
			return errors.Trace(err)
		}
		dsn := fmt.Sprintf(""%s:%s@tcp(%s:%d)/%s?charset=utf8mb4"", ""root"", """", ""127.0.0.1"", port, database)
		db, err := sql.Open(""mysql"", dsn)
		if err != nil {
			return errors.Trace(err)
		}
		tableTemp := `CREATE TABLE IF NOT EXISTS %s (
	   a VARCHAR(11)
)`
		_, err = db.Exec(fmt.Sprintf(tableTemp, table))
		if err != nil {
			return errors.Trace(err)
		}
		query := fmt.Sprintf(""insert into %s values('aaaaaaaaaa')"", table) // nolint:gosec
		for i := 1; i < 10000; i++ {
			query += "",('aaaaaaaaaa')""
		}
		ch := make(chan struct{}, worker)
		for i := 0; i < worker; i++ {
			ch <- struct{}{}
		}
		var eg *errgroup.Group
		ctx, cancel := context.WithCancel(context.Background())
		defer cancel()
		eg, ctx = errgroup.WithContext(ctx)
		for i := 0; i < 500; i++ {
			if ctx.Err() != nil {
				break
			}
			<-ch
			eg.Go(func() error {
				_, err := db.ExecContext(ctx, query)
				if err != nil {
					cancel()
					return errors.Trace(err)
				}
				ch <- struct{}{}
				return nil
			})
		}
		return eg.Wait()
	}
	if err := rootCmd.Execute(); err != nil {
		fmt.Printf(""fail to import data, err: %v"", err)
		os.Exit(2)
	}
}
",CWE-134,100.0,1
"/*
Copyright IBM Corp. 2017 All Rights Reserved.
SPDX-License-Identifier: Apache-2.0
*/
package cluster
import (
	""context""
	""io""
	""time""
	""github.com/hyperledger/fabric-protos-go/orderer""
	""github.com/hyperledger/fabric/common/flogging""
	""github.com/hyperledger/fabric/common/util""
	""go.uber.org/zap""
	""google.golang.org/grpc""
)
//go:generate mockery -dir . -name Dispatcher -case underscore -output ./mocks/
// Dispatcher dispatches requests
type Dispatcher interface {
	DispatchSubmit(ctx context.Context, request *orderer.SubmitRequest) error
	DispatchConsensus(ctx context.Context, request *orderer.ConsensusRequest) error
}
//go:generate mockery -dir . -name StepStream -case underscore -output ./mocks/
// StepStream defines the gRPC stream for sending
// transactions, and receiving corresponding responses
type StepStream interface {
	Send(response *orderer.StepResponse) error
	Recv() (*orderer.StepRequest, error)
	grpc.ServerStream
}
// Service defines the raft Service
type Service struct {
	StreamCountReporter              *StreamCountReporter
	Dispatcher                       Dispatcher
	Logger                           *flogging.FabricLogger
	StepLogger                       *flogging.FabricLogger
	MinimumExpirationWarningInterval time.Duration
	CertExpWarningThreshold          time.Duration
}
// Step passes an implementation-specific message to another cluster member.
func (s *Service) Step(stream orderer.Cluster_StepServer) error {
	s.StreamCountReporter.Increment()
	defer s.StreamCountReporter.Decrement()
	addr := util.ExtractRemoteAddress(stream.Context())
	commonName := commonNameFromContext(stream.Context())
	exp := s.initializeExpirationCheck(stream, addr, commonName)
	s.Logger.Debugf(""Connection from %s(%s)"", commonName, addr)
	defer s.Logger.Debugf(""Closing connection from %s(%s)"", commonName, addr)
	for {
		err := s.handleMessage(stream, addr, exp)
		if err == io.EOF {
			s.Logger.Debugf(""%s(%s) disconnected"", commonName, addr)
			return nil
		}
		if err != nil {
			return err
		}
		// Else, no error occurred, so we continue to the next iteration
	}
}
func (s *Service) handleMessage(stream StepStream, addr string, exp *certificateExpirationCheck) error {
	request, err := stream.Recv()
	if err == io.EOF {
		return err
	}
	if err != nil {
		s.Logger.Warningf(""Stream read from %s failed: %v"", addr, err)
		return err
	}
	exp.checkExpiration(time.Now(), extractChannel(request))
	if s.StepLogger.IsEnabledFor(zap.DebugLevel) {
		nodeName := commonNameFromContext(stream.Context())
		s.StepLogger.Debugf(""Received message from %s(%s): %v"", nodeName, addr, requestAsString(request))
	}
	if submitReq := request.GetSubmitRequest(); submitReq != nil {
		nodeName := commonNameFromContext(stream.Context())
		s.Logger.Debugf(""Received message from %s(%s): %v"", nodeName, addr, requestAsString(request))
		return s.handleSubmit(submitReq, stream, addr)
	}
	// Else, it's a consensus message.
	return s.Dispatcher.DispatchConsensus(stream.Context(), request.GetConsensusRequest())
}
func (s *Service) handleSubmit(request *orderer.SubmitRequest, stream StepStream, addr string) error {
	err := s.Dispatcher.DispatchSubmit(stream.Context(), request)
	if err != nil {
		s.Logger.Warningf(""Handling of Submit() from %s failed: %v"", addr, err)
		return err
	}
	return err
}
func (s *Service) initializeExpirationCheck(stream orderer.Cluster_StepServer, endpoint, nodeName string) *certificateExpirationCheck {
	return &certificateExpirationCheck{
		minimumExpirationWarningInterval: s.MinimumExpirationWarningInterval,
		expirationWarningThreshold:       s.CertExpWarningThreshold,
		expiresAt:                        expiresAt(stream),
		endpoint:                         endpoint,
		nodeName:                         nodeName,
		alert: func(template string, args ...interface{}) {
			s.Logger.Warningf(template, args...)
		},
	}
}
func expiresAt(stream orderer.Cluster_StepServer) time.Time {
	cert := util.ExtractCertificateFromContext(stream.Context())
	if cert == nil {
		return time.Time{}
	}
	return cert.NotAfter
}
func extractChannel(msg *orderer.StepRequest) string {
	if consReq := msg.GetConsensusRequest(); consReq != nil {
		return consReq.Channel
	}
	if submitReq := msg.GetSubmitRequest(); submitReq != nil {
		return submitReq.Channel
	}
	return """"
}
",CWE-20,140.0,1
"package authzserver
import (
	""context""
	""crypto/rand""
	""fmt""
	""net/http""
	""net/http/httptest""
	""testing""
	config2 ""github.com/flyteorg/flytestdlib/config""
	""github.com/flyteorg/flyteadmin/auth""
	""github.com/stretchr/testify/mock""
	""github.com/flyteorg/flyteadmin/auth/interfaces/mocks""
	""github.com/flyteorg/flyteadmin/auth/config""
	""github.com/ory/fosite""
	""github.com/stretchr/testify/assert""
)
func TestAuthEndpoint(t *testing.T) {
	t.Run(""Success"", func(t *testing.T) {
		originalURL := ""http://localhost:8088/oauth2/authorize?client_id=my-client&redirect_uri=http%3A%2F%2Flocalhost%3A3846%2Fcallback&response_type=code&scope=photos+openid+offline&state=some-random-state-foobar&nonce=some-random-nonce&code_challenge=p0v_UR0KrXl4--BpxM2BQa7qIW5k3k4WauBhjmkVQw8&code_challenge_method=S256""
		req := httptest.NewRequest(http.MethodGet, originalURL, nil)
		w := httptest.NewRecorder()
		authCtx := &mocks.AuthenticationContext{}
		oauth2Provider := &mocks.OAuth2Provider{}
		oauth2Provider.OnNewAuthorizeRequest(req.Context(), req).Return(fosite.NewAuthorizeRequest(), nil)
		authCtx.OnOAuth2Provider().Return(oauth2Provider)
		cookieManager := &mocks.CookieHandler{}
		cookieManager.OnSetAuthCodeCookie(req.Context(), w, originalURL).Return(nil)
		authCtx.OnCookieManager().Return(cookieManager)
		authEndpoint(authCtx, w, req)
		assert.Equal(t, http.StatusTemporaryRedirect, w.Code)
	})
	t.Run(""Fail to write cookie"", func(t *testing.T) {
		originalURL := ""http://localhost:8088/oauth2/authorize?client_id=my-client&redirect_uri=http%3A%2F%2Flocalhost%3A3846%2Fcallback&response_type=code&scope=photos+openid+offline&state=some-random-state-foobar&nonce=some-random-nonce&code_challenge=p0v_UR0KrXl4--BpxM2BQa7qIW5k3k4WauBhjmkVQw8&code_challenge_method=S256""
		req := httptest.NewRequest(http.MethodGet, originalURL, nil)
		w := httptest.NewRecorder()
		authCtx := &mocks.AuthenticationContext{}
		oauth2Provider := &mocks.OAuth2Provider{}
		requester := fosite.NewAuthorizeRequest()
		oauth2Provider.OnNewAuthorizeRequest(req.Context(), req).Return(requester, nil)
		oauth2Provider.On(""WriteAuthorizeError"", w, requester, mock.Anything).Run(func(args mock.Arguments) {
			rw := args.Get(0).(http.ResponseWriter)
			rw.WriteHeader(http.StatusForbidden)
		})
		authCtx.OnOAuth2Provider().Return(oauth2Provider)
		cookieManager := &mocks.CookieHandler{}
		cookieManager.OnSetAuthCodeCookie(req.Context(), w, originalURL).Return(fmt.Errorf(""failure injection""))
		authCtx.OnCookieManager().Return(cookieManager)
		authEndpoint(authCtx, w, req)
		assert.Equal(t, http.StatusForbidden, w.Code)
	})
}
// 
const sampleIDToken = `eyJraWQiOiJaNmRtWl9UWGhkdXctalVCWjZ1RUV6dm5oLWpoTk8wWWhlbUI3cWFfTE9jIiwiYWxnIjoiUlMyNTYifQ.eyJzdWIiOiIwMHVra2k0OHBzSDhMaWtZVjVkNiIsIm5hbWUiOiJIYXl0aGFtIEFidWVsZnV0dWgiLCJ2ZXIiOjEsImlzcyI6Imh0dHBzOi8vZGV2LTE0MTg2NDIyLm9rdGEuY29tL29hdXRoMi9hdXNrbmdubjd1QlZpUXE2YjVkNiIsImF1ZCI6IjBvYWtraGV0ZU5qQ01FUnN0NWQ2IiwiaWF0IjoxNjE4NDUzNjc5LCJleHAiOjE2MTg0NTcyNzksImp0aSI6IklELmE0YXpLdUphVFM2YzNTeHdpWWdTMHhPbTM2bVFnVlVVN0I4V2dEdk80dFkiLCJhbXIiOlsicHdkIl0sImlkcCI6IjBvYWtrbTFjaTFVZVBwTlUwNWQ2IiwicHJlZmVycmVkX3VzZXJuYW1lIjoiaGF5dGhhbUB1bmlvbi5haSIsImF1dGhfdGltZSI6MTYxODQ0NjI0NywiYXRfaGFzaCI6Ikg5Q0FweWlrQkpGYXJ4d1FUbnB6ZFEifQ.SJ3BTD_MFcrYvTnql181Ddeb_mOm81z_S7ZKQ6P8mMgWqn94LZ2nG8k8-_odaaNAAT-M1nAFKWqZAQGvliwS1_TsD8_j0cen5zYnGcz2Uu5fFlvoHwuPgy5JYYNOXkXYgPnIb3kNkgXKbkdjS9hdbMfvnPd9rr8v0yzqf0AQBnUe-cPrzY-ZJjvh80IWDZgSjoP244tTYppPkx8UtedJLJZ4tzB7aXlEyoRV-DpmOLfJkAmblRm4OsO1qjwmx3HSIy_T-0PANn-g4AS07rpoMYHRcqncdgcAsVfGxjyWiOg3kbymLqpGlkIZgzmev-TmpoDp0QkUVPOntuiB57GZ6g`
//func TestAuthCallbackEndpoint(t *testing.T) {
//	originalURL := ""http://localhost:8088/oauth2/authorize?client_id=my-client&redirect_uri=http%3A%2F%2Flocalhost%3A3846%2Fcallback&response_type=code&scope=photos+openid+offline&state=some-random-state-foobar&nonce=some-random-nonce&code_challenge=p0v_UR0KrXl4--BpxM2BQa7qIW5k3k4WauBhjmkVQw8&code_challenge_method=S256""
//	req := httptest.NewRequest(http.MethodGet, originalURL, nil)
//	w := httptest.NewRecorder()
//
//	authCtx := &mocks.AuthenticationContext{}
//
//	oauth2Provider := &mocks.OAuth2Provider{}
//	requester := fosite.NewAuthorizeRequest()
//	oauth2Provider.OnNewAuthorizeRequest(req.Context(), req).Return(requester, nil)
//	oauth2Provider.On(""WriteAuthorizeError"", w, requester, mock.Anything).Run(func(args mock.Arguments) {
//		rw := args.Get(0).(http.ResponseWriter)
//		rw.WriteHeader(http.StatusForbidden)
//	})
//
//	authCtx.OnOAuth2Provider().Return(oauth2Provider)
//
//	cookieManager := &mocks.CookieHandler{}
//	cookieManager.OnSetAuthCodeCookie(req.Context(), w, originalURL).Return(nil)
//	cookieManager.OnRetrieveTokenValues(req.Context(), req).Return(sampleIDToken, """", """", nil)
//	cookieManager.OnRetrieveUserInfo(req.Context(), req).Return(&service.UserInfoResponse{Subject: ""abc""}, nil)
//	authCtx.OnCookieManager().Return(cookieManager)
//
//	authCtx.OnOptions().Return(&config.Config{
//		UserAuth: config.UserAuthConfig{
//			OpenID: config.OpenIDOptions{
//				//ClientID: ""http://localhost"",
//			},
//		},
//	})
//
//	ctx, cancel := context.WithCancel(context.Background())
//	defer cancel()
//
//	var issuer string
//	hf := func(w http.ResponseWriter, r *http.Request) {
//		if r.URL.Path == ""/.well-known/openid-configuration"" {
//			w.Header().Set(""Content-Type"", ""application/json"")
//			io.WriteString(w, strings.ReplaceAll(`{
//				""issuer"": ""ISSUER"",
//				""authorization_endpoint"": ""https://example.com/auth"",
//				""token_endpoint"": ""https://example.com/token"",
//				""jwks_uri"": ""ISSUER/keys"",
//				""id_token_signing_alg_values_supported"": [""RS256""]
//			}`, ""ISSUER"", issuer))
//			return
//		} else if r.URL.Path == ""/keys"" {
//			w.Header().Set(""Content-Type"", ""application/json"")
//			io.WriteString(w, `{""keys"":[{""kty"":""RSA"",""alg"":""RS256"",""kid"":""Z6dmZ_TXhduw-jUBZ6uEEzvnh-jhNO0YhemB7qa_LOc"",""use"":""sig"",""e"":""AQAB"",""n"":""jyMcudBiz7XqeDIvxfMlmG4fvAUU7cl3R4iSIv_ahHanCcVRvqcXOsIknwn7i4rOUjP6MlH45uIYsaj6MuLYgoaIbC-Z823Tu4asoC-rGbpZgf-bMcJLxtZVBNsSagr_M0n8xA1oogHRF1LGRiD93wNr2b9OkKVbWnyNdASk5_xui024nVzakm2-RAEyaC048nHfnjVBvwo4BdJVDgBEK03fbkBCyuaZyE1ZQF545MTbD4keCv58prSCmbDRJgRk48FzaFnQeYTho-pUxXxM9pvhMykeI62WZ7diDfIc9isOpv6ALFOHgKy7Ihhve6pLIylLRTnn2qhHFkGPtU3djQ""}]}`)
//			return
//		}
//
//		http.NotFound(w, r)
//		return
//
//	}
//
//	s := httptest.NewServer(http.HandlerFunc(hf))
//	defer s.Close()
//
//	issuer = s.URL
//	mockOidcProvider, err := oidc.NewProvider(ctx, issuer)
//	if !assert.NoError(t, err) {
//		t.FailNow()
//	}
//
//	authCtx.OnOidcProvider().Return(mockOidcProvider)
//
//	authCallbackEndpoint(authCtx, w, req)
//	assert.Equal(t, http.StatusTemporaryRedirect, w.Code)
//}
func TestGetIssuer(t *testing.T) {
	t.Run(""SelfAuthServerIssuer wins"", func(t *testing.T) {
		issuer := GetIssuer(context.Background(), nil, &config.Config{
			AppAuth: config.OAuth2Options{
				SelfAuthServer: config.AuthorizationServer{
					Issuer: ""my_issuer"",
				},
			},
			AuthorizedURIs: []config2.URL{{URL: *config.MustParseURL(""http://localhost/"")}},
		})
		assert.Equal(t, ""my_issuer"", issuer)
	})
	t.Run(""Fallback to http public uri"", func(t *testing.T) {
		issuer := GetIssuer(context.Background(), nil, &config.Config{
			AuthorizedURIs: []config2.URL{{URL: *config.MustParseURL(""http://localhost/"")}},
		})
		assert.Equal(t, ""http://localhost/"", issuer)
	})
}
func TestEncryptDecrypt(t *testing.T) {
	cookieHashKey := [auth.SymmetricKeyLength]byte{}
	_, err := rand.Read(cookieHashKey[:])
	assert.NoError(t, err)
	input := ""hello world""
	encrypted, err := encryptString(input, cookieHashKey)
	assert.NoError(t, err)
	decrypted, err := decryptString(encrypted, cookieHashKey)
	assert.NoError(t, err)
	assert.Equal(t, input, decrypted)
	assert.NotEqual(t, input, encrypted)
}
",CWE-613,181.0,1
"package authzserver
import (
	""context""
	""encoding/json""
	""fmt""
	""io/ioutil""
	""mime""
	""net/http""
	""net/url""
	""strings""
	""k8s.io/apimachinery/pkg/util/sets""
	""github.com/flyteorg/flytestdlib/config""
	""github.com/coreos/go-oidc""
	authConfig ""github.com/flyteorg/flyteadmin/auth/config""
	""github.com/flyteorg/flyteadmin/auth/interfaces""
	""github.com/flyteorg/flyteidl/gen/pb-go/flyteidl/service""
	""golang.org/x/oauth2""
)
// ResourceServer authorizes access requests issued by an external Authorization Server.
type ResourceServer struct {
	signatureVerifier oidc.KeySet
	allowedAudience   []string
}
func (r ResourceServer) ValidateAccessToken(ctx context.Context, expectedAudience, tokenStr string) (interfaces.IdentityContext, error) {
	raw, err := r.signatureVerifier.VerifySignature(ctx, tokenStr)
	if err != nil {
		return nil, err
	}
	claimsRaw := map[string]interface{}{}
	if err = json.Unmarshal(raw, &claimsRaw); err != nil {
		return nil, fmt.Errorf(""failed to unmarshal user info claim into UserInfo type. Error: %w"", err)
	}
	return verifyClaims(sets.NewString(append(r.allowedAudience, expectedAudience)...), claimsRaw)
}
func doRequest(ctx context.Context, req *http.Request) (*http.Response, error) {
	client := http.DefaultClient
	if c, ok := ctx.Value(oauth2.HTTPClient).(*http.Client); ok {
		client = c
	}
	return client.Do(req.WithContext(ctx))
}
func unmarshalResp(r *http.Response, body []byte, v interface{}) error {
	err := json.Unmarshal(body, &v)
	if err == nil {
		return nil
	}
	ct := r.Header.Get(""Content-Type"")
	mediaType, _, parseErr := mime.ParseMediaType(ct)
	if parseErr == nil && mediaType == ""application/json"" {
		return fmt.Errorf(""got Content-Type = application/json, but could not unmarshal as JSON: %v"", err)
	}
	return fmt.Errorf(""expected Content-Type = application/json, got %q: %v"", ct, err)
}
func getJwksForIssuer(ctx context.Context, issuerBaseURL url.URL, customMetadataURL url.URL) (keySet oidc.KeySet, err error) {
	issuerBaseURL.Path = strings.TrimSuffix(issuerBaseURL.Path, ""/"") + ""/""
	var wellKnown *url.URL
	if len(customMetadataURL.String()) > 0 {
		wellKnown = issuerBaseURL.ResolveReference(&customMetadataURL)
	} else {
		wellKnown = issuerBaseURL.ResolveReference(oauth2MetadataEndpoint)
	}
	req, err := http.NewRequest(http.MethodGet, wellKnown.String(), nil)
	if err != nil {
		return nil, err
	}
	resp, err := doRequest(ctx, req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf(""unable to read response body: %v"", err)
	}
	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf(""%s: %s"", resp.Status, body)
	}
	p := &service.OAuth2MetadataResponse{}
	err = unmarshalResp(resp, body, &p)
	if err != nil {
		return nil, fmt.Errorf(""failed to decode provider discovery object: %v"", err)
	}
	return oidc.NewRemoteKeySet(ctx, p.JwksUri), nil
}
// NewOAuth2ResourceServer initializes a new OAuth2ResourceServer.
func NewOAuth2ResourceServer(ctx context.Context, cfg authConfig.ExternalAuthorizationServer, fallbackBaseURL config.URL) (ResourceServer, error) {
	u := cfg.BaseURL
	if len(u.String()) == 0 {
		u = fallbackBaseURL
	}
	verifier, err := getJwksForIssuer(ctx, u.URL, cfg.MetadataEndpointURL.URL)
	if err != nil {
		return ResourceServer{}, err
	}
	return ResourceServer{
		signatureVerifier: verifier,
		allowedAudience:   cfg.AllowedAudience,
	}, nil
}
",CWE-613,121.0,1
"package impl
import (
	""context""
	""fmt""
	""github.com/flyteorg/flyteadmin/pkg/clusterresource/interfaces""
	""github.com/flyteorg/flyteidl/gen/pb-go/flyteidl/admin""
	""github.com/flyteorg/flyteidl/gen/pb-go/flyteidl/service""
)
// Implementation of an interfaces.FlyteAdminDataProvider which fetches data using a flyteadmin service client
type serviceAdminProvider struct {
	adminClient service.AdminServiceClient
}
func (p serviceAdminProvider) GetClusterResourceAttributes(ctx context.Context, project, domain string) (*admin.ClusterResourceAttributes, error) {
	resource, err := p.adminClient.GetProjectDomainAttributes(ctx, &admin.ProjectDomainAttributesGetRequest{
		Project:      project,
		Domain:       domain,
		ResourceType: admin.MatchableResource_CLUSTER_RESOURCE,
	})
	if err != nil {
		return nil, err
	}
	if resource != nil && resource.Attributes != nil && resource.Attributes.MatchingAttributes != nil &&
		resource.Attributes.MatchingAttributes.GetClusterResourceAttributes() != nil {
		return resource.Attributes.MatchingAttributes.GetClusterResourceAttributes(), nil
	}
	return nil, NewMissingEntityError(""cluster resource attributes"")
}
var activeProjectsFilter = fmt.Sprintf(""ne(state,%d)"", admin.Project_ARCHIVED)
func (p serviceAdminProvider) GetProjects(ctx context.Context) (*admin.Projects, error) {
	projects := make([]*admin.Project, 0)
	listReq := &admin.ProjectListRequest{
		Limit:   100,
		Filters: activeProjectsFilter,
		// Prefer to sync projects most newly created to ensure their resources get created first when other resources exist.
		SortBy: &descCreatedAtSortParam,
	}
	// Iterate through all pages of projects
	for {
		projectResp, err := p.adminClient.ListProjects(ctx, listReq)
		if err != nil {
			return nil, err
		}
		projects = append(projects, projectResp.Projects...)
		if len(projectResp.Token) == 0 {
			break
		}
		listReq.Token = projectResp.Token
	}
	return &admin.Projects{
		Projects: projects,
	}, nil
}
func NewAdminServiceDataProvider(
	adminClient service.AdminServiceClient) interfaces.FlyteAdminDataProvider {
	return &serviceAdminProvider{
		adminClient: adminClient,
	}
}
",CWE-89,67.0,1
"package impl
import (
	""github.com/flyteorg/flyteadmin/pkg/common""
	""github.com/flyteorg/flyteadmin/pkg/errors""
	""github.com/flyteorg/flyteidl/gen/pb-go/flyteidl/admin""
	""google.golang.org/grpc/codes""
)
func NewMissingEntityError(entity string) error {
	return errors.NewFlyteAdminErrorf(codes.NotFound, ""Failed to find [%s]"", entity)
}
var descCreatedAtSortParam = admin.Sort{
	Direction: admin.Sort_DESCENDING,
	Key:       ""created_at"",
}
var descCreatedAtSortDBParam, _ = common.NewSortParameter(descCreatedAtSortParam)
",CWE-89,20.0,1
"package common
import (
	""fmt""
	""github.com/flyteorg/flyteadmin/pkg/errors""
	""github.com/flyteorg/flyteidl/gen/pb-go/flyteidl/admin""
	""google.golang.org/grpc/codes""
)
const gormDescending = ""%s desc""
const gormAscending = ""%s asc""
type SortParameter interface {
	GetGormOrderExpr() string
}
type sortParamImpl struct {
	gormOrderExpression string
}
func (s *sortParamImpl) GetGormOrderExpr() string {
	return s.gormOrderExpression
}
func NewSortParameter(sort admin.Sort) (SortParameter, error) {
	var gormOrderExpression string
	switch sort.Direction {
	case admin.Sort_DESCENDING:
		gormOrderExpression = fmt.Sprintf(gormDescending, sort.Key)
	case admin.Sort_ASCENDING:
		gormOrderExpression = fmt.Sprintf(gormAscending, sort.Key)
	default:
		return nil, errors.NewFlyteAdminErrorf(codes.InvalidArgument, ""invalid sort order specified: %v"", sort)
	}
	return &sortParamImpl{
		gormOrderExpression: gormOrderExpression,
	}, nil
}
",CWE-89,40.0,1
"package common
import (
	""testing""
	""github.com/flyteorg/flyteidl/gen/pb-go/flyteidl/admin""
	""github.com/stretchr/testify/assert""
)
func TestSortParameter_Ascending(t *testing.T) {
	sortParameter, err := NewSortParameter(admin.Sort{
		Direction: admin.Sort_ASCENDING,
		Key:       ""name"",
	})
	assert.Nil(t, err)
	assert.Equal(t, ""name asc"", sortParameter.GetGormOrderExpr())
}
func TestSortParameter_Descending(t *testing.T) {
	sortParameter, err := NewSortParameter(admin.Sort{
		Direction: admin.Sort_DESCENDING,
		Key:       ""project"",
	})
	assert.Nil(t, err)
	assert.Equal(t, ""project desc"", sortParameter.GetGormOrderExpr())
}
",CWE-89,27.0,1
"package impl
import (
	""context""
	""strconv""
	""github.com/flyteorg/flyteidl/gen/pb-go/flyteidl/core""
	""github.com/flyteorg/flyteadmin/pkg/common""
	""github.com/flyteorg/flyteadmin/pkg/errors""
	""github.com/flyteorg/flyteadmin/pkg/manager/impl/util""
	""github.com/flyteorg/flyteadmin/pkg/manager/impl/validation""
	""github.com/flyteorg/flyteadmin/pkg/manager/interfaces""
	repoInterfaces ""github.com/flyteorg/flyteadmin/pkg/repositories/interfaces""
	""github.com/flyteorg/flyteadmin/pkg/repositories/transformers""
	runtimeInterfaces ""github.com/flyteorg/flyteadmin/pkg/runtime/interfaces""
	""github.com/flyteorg/flyteidl/gen/pb-go/flyteidl/admin""
	""github.com/flyteorg/flytestdlib/contextutils""
	""github.com/flyteorg/flytestdlib/logger""
	""github.com/flyteorg/flytestdlib/promutils""
	""google.golang.org/grpc/codes""
)
type DescriptionEntityMetrics struct {
	Scope promutils.Scope
}
type DescriptionEntityManager struct {
	db      repoInterfaces.Repository
	config  runtimeInterfaces.Configuration
	metrics DescriptionEntityMetrics
}
func (d *DescriptionEntityManager) GetDescriptionEntity(ctx context.Context, request admin.ObjectGetRequest) (
	*admin.DescriptionEntity, error) {
	if err := validation.ValidateDescriptionEntityGetRequest(request); err != nil {
		logger.Errorf(ctx, ""invalid request [%+v]: %v"", request, err)
		return nil, err
	}
	ctx = contextutils.WithProjectDomain(ctx, request.Id.Project, request.Id.Domain)
	return util.GetDescriptionEntity(ctx, d.db, *request.Id)
}
func (d *DescriptionEntityManager) ListDescriptionEntity(ctx context.Context, request admin.DescriptionEntityListRequest) (*admin.DescriptionEntityList, error) {
	// Check required fields
	if err := validation.ValidateDescriptionEntityListRequest(request); err != nil {
		return nil, err
	}
	ctx = contextutils.WithProjectDomain(ctx, request.Id.Project, request.Id.Domain)
	if request.ResourceType == core.ResourceType_WORKFLOW {
		ctx = contextutils.WithWorkflowID(ctx, request.Id.Name)
	} else {
		ctx = contextutils.WithTaskID(ctx, request.Id.Name)
	}
	filters, err := util.GetDbFilters(util.FilterSpec{
		Project:        request.Id.Project,
		Domain:         request.Id.Domain,
		Name:           request.Id.Name,
		RequestFilters: request.Filters,
	}, common.ResourceTypeToEntity[request.ResourceType])
	if err != nil {
		logger.Error(ctx, ""failed to get database filter"")
		return nil, err
	}
	var sortParameter common.SortParameter
	if request.SortBy != nil {
		sortParameter, err = common.NewSortParameter(*request.SortBy)
		if err != nil {
			return nil, err
		}
	}
	offset, err := validation.ValidateToken(request.Token)
	if err != nil {
		return nil, errors.NewFlyteAdminErrorf(codes.InvalidArgument,
			""invalid pagination token %s for ListWorkflows"", request.Token)
	}
	listDescriptionEntitiesInput := repoInterfaces.ListResourceInput{
		Limit:         int(request.Limit),
		Offset:        offset,
		InlineFilters: filters,
		SortParameter: sortParameter,
	}
	output, err := d.db.DescriptionEntityRepo().List(ctx, listDescriptionEntitiesInput)
	if err != nil {
		logger.Debugf(ctx, ""Failed to list workflows with [%+v] with err %v"", request.Id, err)
		return nil, err
	}
	descriptionEntityList, err := transformers.FromDescriptionEntityModels(output.Entities)
	if err != nil {
		logger.Errorf(ctx,
			""Failed to transform workflow models [%+v] with err: %v"", output.Entities, err)
		return nil, err
	}
	var token string
	if len(output.Entities) == int(request.Limit) {
		token = strconv.Itoa(offset + len(output.Entities))
	}
	return &admin.DescriptionEntityList{
		DescriptionEntities: descriptionEntityList,
		Token:               token,
	}, nil
}
func NewDescriptionEntityManager(
	db repoInterfaces.Repository,
	config runtimeInterfaces.Configuration,
	scope promutils.Scope) interfaces.DescriptionEntityInterface {
	metrics := DescriptionEntityMetrics{
		Scope: scope,
	}
	return &DescriptionEntityManager{
		db:      db,
		config:  config,
		metrics: metrics,
	}
}
",CWE-89,121.0,1
"package impl
import (
	""context""
	""strconv""
	""strings""
	""github.com/flyteorg/flyteidl/gen/pb-go/flyteidl/core""
	""github.com/flyteorg/flytestdlib/contextutils""
	""github.com/flyteorg/flyteadmin/pkg/common""
	""github.com/flyteorg/flyteadmin/pkg/errors""
	""google.golang.org/grpc/codes""
	""github.com/flyteorg/flyteadmin/pkg/manager/impl/util""
	""github.com/flyteorg/flyteadmin/pkg/manager/impl/validation""
	""github.com/flyteorg/flyteadmin/pkg/manager/interfaces""
	repoInterfaces ""github.com/flyteorg/flyteadmin/pkg/repositories/interfaces""
	""github.com/flyteorg/flyteadmin/pkg/repositories/transformers""
	runtimeInterfaces ""github.com/flyteorg/flyteadmin/pkg/runtime/interfaces""
	""github.com/flyteorg/flyteidl/gen/pb-go/flyteidl/admin""
	""github.com/flyteorg/flytestdlib/logger""
	""github.com/flyteorg/flytestdlib/promutils""
)
const state = ""state""
// System-generated workflows are meant to be hidden from the user by default. Therefore we always only show
// workflow-type named entities that have been user generated only.
var nonSystemGeneratedWorkflowsFilter, _ = common.NewSingleValueFilter(
	common.NamedEntityMetadata, common.NotEqual, state, admin.NamedEntityState_SYSTEM_GENERATED)
var defaultWorkflowsFilter, _ = common.NewWithDefaultValueFilter(
	strconv.Itoa(int(admin.NamedEntityState_NAMED_ENTITY_ACTIVE)), nonSystemGeneratedWorkflowsFilter)
type NamedEntityMetrics struct {
	Scope promutils.Scope
}
type NamedEntityManager struct {
	db      repoInterfaces.Repository
	config  runtimeInterfaces.Configuration
	metrics NamedEntityMetrics
}
func (m *NamedEntityManager) UpdateNamedEntity(ctx context.Context, request admin.NamedEntityUpdateRequest) (
	*admin.NamedEntityUpdateResponse, error) {
	if err := validation.ValidateNamedEntityUpdateRequest(request); err != nil {
		logger.Debugf(ctx, ""invalid request [%+v]: %v"", request, err)
		return nil, err
	}
	ctx = contextutils.WithProjectDomain(ctx, request.Id.Project, request.Id.Domain)
	// Ensure entity exists before trying to update it
	_, err := util.GetNamedEntity(ctx, m.db, request.ResourceType, *request.Id)
	if err != nil {
		return nil, err
	}
	metadataModel := transformers.CreateNamedEntityModel(&request)
	err = m.db.NamedEntityRepo().Update(ctx, metadataModel)
	if err != nil {
		logger.Debugf(ctx, ""Failed to update named_entity for [%+v] with err %v"", request.Id, err)
		return nil, err
	}
	return &admin.NamedEntityUpdateResponse{}, nil
}
func (m *NamedEntityManager) GetNamedEntity(ctx context.Context, request admin.NamedEntityGetRequest) (
	*admin.NamedEntity, error) {
	if err := validation.ValidateNamedEntityGetRequest(request); err != nil {
		logger.Debugf(ctx, ""invalid request [%+v]: %v"", request, err)
		return nil, err
	}
	ctx = contextutils.WithProjectDomain(ctx, request.Id.Project, request.Id.Domain)
	return util.GetNamedEntity(ctx, m.db, request.ResourceType, *request.Id)
}
func (m *NamedEntityManager) getQueryFilters(referenceEntity core.ResourceType, requestFilters string) ([]common.InlineFilter, error) {
	filters := make([]common.InlineFilter, 0)
	if referenceEntity == core.ResourceType_WORKFLOW {
		filters = append(filters, defaultWorkflowsFilter)
	}
	if len(requestFilters) == 0 {
		return filters, nil
	}
	additionalFilters, err := util.ParseFilters(requestFilters, common.NamedEntity)
	if err != nil {
		return nil, err
	}
	for _, filter := range additionalFilters {
		if strings.Contains(filter.GetField(), state) {
			filterWithDefaultValue, err := common.NewWithDefaultValueFilter(
				strconv.Itoa(int(admin.NamedEntityState_NAMED_ENTITY_ACTIVE)), filter)
			if err != nil {
				return nil, err
			}
			filters = append(filters, filterWithDefaultValue)
		} else {
			filters = append(filters, filter)
		}
	}
	return filters, nil
}
func (m *NamedEntityManager) ListNamedEntities(ctx context.Context, request admin.NamedEntityListRequest) (
	*admin.NamedEntityList, error) {
	if err := validation.ValidateNamedEntityListRequest(request); err != nil {
		logger.Debugf(ctx, ""invalid request [%+v]: %v"", request, err)
		return nil, err
	}
	ctx = contextutils.WithProjectDomain(ctx, request.Project, request.Domain)
	// HACK: In order to filter by state (if requested) - we need to amend the filter to use COALESCE
	// e.g. eq(state, 1) becomes 'WHERE (COALESCE(state, 0) = '1')' since not every NamedEntity necessarily
	// has an entry, and therefore the default state value '0' (active), should be assumed.
	filters, err := m.getQueryFilters(request.ResourceType, request.Filters)
	if err != nil {
		return nil, err
	}
	var sortParameter common.SortParameter
	if request.SortBy != nil {
		sortParameter, err = common.NewSortParameter(*request.SortBy)
		if err != nil {
			return nil, err
		}
	}
	offset, err := validation.ValidateToken(request.Token)
	if err != nil {
		return nil, errors.NewFlyteAdminErrorf(codes.InvalidArgument,
			""invalid pagination token %s for ListNamedEntities"", request.Token)
	}
	listInput := repoInterfaces.ListNamedEntityInput{
		ListResourceInput: repoInterfaces.ListResourceInput{
			Limit:         int(request.Limit),
			Offset:        offset,
			InlineFilters: filters,
			SortParameter: sortParameter,
		},
		Project:      request.Project,
		Domain:       request.Domain,
		ResourceType: request.ResourceType,
	}
	output, err := m.db.NamedEntityRepo().List(ctx, listInput)
	if err != nil {
		logger.Debugf(ctx, ""Failed to list named entities of type: %s with project: %s, domain: %s. Returned error was: %v"",
			request.ResourceType, request.Project, request.Domain, err)
		return nil, err
	}
	var token string
	if len(output.Entities) == int(request.Limit) {
		token = strconv.Itoa(offset + len(output.Entities))
	}
	entities := transformers.FromNamedEntityModels(output.Entities)
	return &admin.NamedEntityList{
		Entities: entities,
		Token:    token,
	}, nil
}
func NewNamedEntityManager(
	db repoInterfaces.Repository,
	config runtimeInterfaces.Configuration,
	scope promutils.Scope) interfaces.NamedEntityInterface {
	metrics := NamedEntityMetrics{
		Scope: scope,
	}
	return &NamedEntityManager{
		db:      db,
		config:  config,
		metrics: metrics,
	}
}
",CWE-89,179.0,1
"package impl
import (
	""context""
	""strconv""
	""github.com/flyteorg/flyteadmin/pkg/common""
	""github.com/flyteorg/flyteadmin/pkg/errors""
	""github.com/flyteorg/flyteadmin/pkg/manager/impl/util""
	""github.com/flyteorg/flyteadmin/pkg/manager/impl/validation""
	""github.com/flyteorg/flyteadmin/pkg/manager/interfaces""
	repoInterfaces ""github.com/flyteorg/flyteadmin/pkg/repositories/interfaces""
	""github.com/flyteorg/flyteadmin/pkg/repositories/transformers""
	runtimeInterfaces ""github.com/flyteorg/flyteadmin/pkg/runtime/interfaces""
	""github.com/flyteorg/flyteidl/gen/pb-go/flyteidl/admin""
	""google.golang.org/grpc/codes""
)
type ProjectManager struct {
	db     repoInterfaces.Repository
	config runtimeInterfaces.Configuration
}
var alphabeticalSortParam, _ = common.NewSortParameter(admin.Sort{
	Direction: admin.Sort_ASCENDING,
	Key:       ""identifier"",
})
func (m *ProjectManager) CreateProject(ctx context.Context, request admin.ProjectRegisterRequest) (
	*admin.ProjectRegisterResponse, error) {
	if err := validation.ValidateProjectRegisterRequest(request); err != nil {
		return nil, err
	}
	projectModel := transformers.CreateProjectModel(request.Project)
	err := m.db.ProjectRepo().Create(ctx, projectModel)
	if err != nil {
		return nil, err
	}
	return &admin.ProjectRegisterResponse{}, nil
}
func (m *ProjectManager) getDomains() []*admin.Domain {
	configDomains := m.config.ApplicationConfiguration().GetDomainsConfig()
	var domains = make([]*admin.Domain, len(*configDomains))
	for index, configDomain := range *configDomains {
		domains[index] = &admin.Domain{
			Id:   configDomain.ID,
			Name: configDomain.Name,
		}
	}
	return domains
}
func (m *ProjectManager) ListProjects(ctx context.Context, request admin.ProjectListRequest) (*admin.Projects, error) {
	spec := util.FilterSpec{
		RequestFilters: request.Filters,
	}
	filters, err := util.GetDbFilters(spec, common.Project)
	if err != nil {
		return nil, err
	}
	var sortParameter common.SortParameter
	if request.SortBy != nil {
		sortParameter, err = common.NewSortParameter(*request.SortBy)
		if err != nil {
			return nil, err
		}
	} else {
		sortParameter = alphabeticalSortParam
	}
	offset, err := validation.ValidateToken(request.Token)
	if err != nil {
		return nil, errors.NewFlyteAdminErrorf(codes.InvalidArgument,
			""invalid pagination token %s for ListProjects"", request.Token)
	}
	// And finally, query the database
	listProjectsInput := repoInterfaces.ListResourceInput{
		Limit:         int(request.Limit),
		Offset:        offset,
		InlineFilters: filters,
		SortParameter: sortParameter,
	}
	projectModels, err := m.db.ProjectRepo().List(ctx, listProjectsInput)
	if err != nil {
		return nil, err
	}
	projects := transformers.FromProjectModels(projectModels, m.getDomains())
	var token string
	if len(projects) == int(request.Limit) {
		token = strconv.Itoa(offset + len(projects))
	}
	return &admin.Projects{
		Projects: projects,
		Token:    token,
	}, nil
}
func (m *ProjectManager) UpdateProject(ctx context.Context, projectUpdate admin.Project) (*admin.ProjectUpdateResponse, error) {
	var response admin.ProjectUpdateResponse
	projectRepo := m.db.ProjectRepo()
	// Fetch the existing project if exists. If not, return err and do not update.
	_, err := projectRepo.Get(ctx, projectUpdate.Id)
	if err != nil {
		return nil, err
	}
	// Run validation on the request and return err if validation does not succeed.
	if err := validation.ValidateProject(projectUpdate); err != nil {
		return nil, err
	}
	// Transform the provided project into a model and apply to the DB.
	projectUpdateModel := transformers.CreateProjectModel(&projectUpdate)
	err = projectRepo.UpdateProject(ctx, projectUpdateModel)
	if err != nil {
		return nil, err
	}
	return &response, nil
}
func NewProjectManager(db repoInterfaces.Repository, config runtimeInterfaces.Configuration) interfaces.ProjectInterface {
	return &ProjectManager{
		db:     db,
		config: config,
	}
}
",CWE-89,136.0,1
"package impl
import (
	""context""
	""strconv""
	""github.com/flyteorg/flytestdlib/contextutils""
	""github.com/flyteorg/flyteadmin/pkg/common""
	""github.com/flyteorg/flyteadmin/pkg/errors""
	""github.com/flyteorg/flyteadmin/pkg/manager/impl/util""
	""github.com/flyteorg/flyteadmin/pkg/manager/impl/validation""
	""github.com/flyteorg/flyteadmin/pkg/manager/interfaces""
	repoInterfaces ""github.com/flyteorg/flyteadmin/pkg/repositories/interfaces""
	""github.com/flyteorg/flyteadmin/pkg/repositories/transformers""
	""github.com/flyteorg/flyteidl/gen/pb-go/flyteidl/admin""
	""github.com/flyteorg/flyteidl/gen/pb-go/flyteidl/core""
	""github.com/flyteorg/flytestdlib/logger""
	""github.com/flyteorg/flytestdlib/promutils""
	""github.com/flyteorg/flytestdlib/promutils/labeled""
	""google.golang.org/grpc/codes""
)
type signalMetrics struct {
	Scope promutils.Scope
	Set   labeled.Counter
}
type SignalManager struct {
	db      repoInterfaces.Repository
	metrics signalMetrics
}
func getSignalContext(ctx context.Context, identifier *core.SignalIdentifier) context.Context {
	ctx = contextutils.WithProjectDomain(ctx, identifier.ExecutionId.Project, identifier.ExecutionId.Domain)
	ctx = contextutils.WithWorkflowID(ctx, identifier.ExecutionId.Name)
	return contextutils.WithSignalID(ctx, identifier.SignalId)
}
func (s *SignalManager) GetOrCreateSignal(ctx context.Context, request admin.SignalGetOrCreateRequest) (*admin.Signal, error) {
	if err := validation.ValidateSignalGetOrCreateRequest(ctx, request); err != nil {
		logger.Debugf(ctx, ""invalid request [%+v]: %v"", request, err)
		return nil, err
	}
	ctx = getSignalContext(ctx, request.Id)
	signalModel, err := transformers.CreateSignalModel(request.Id, request.Type, nil)
	if err != nil {
		logger.Errorf(ctx, ""Failed to transform signal with id [%+v] and type [+%v] with err: %v"", request.Id, request.Type, err)
		return nil, err
	}
	err = s.db.SignalRepo().GetOrCreate(ctx, &signalModel)
	if err != nil {
		return nil, err
	}
	signal, err := transformers.FromSignalModel(signalModel)
	if err != nil {
		logger.Errorf(ctx, ""Failed to transform signal model [%+v] with err: %v"", signalModel, err)
		return nil, err
	}
	return &signal, nil
}
func (s *SignalManager) ListSignals(ctx context.Context, request admin.SignalListRequest) (*admin.SignalList, error) {
	if err := validation.ValidateSignalListRequest(ctx, request); err != nil {
		logger.Debugf(ctx, ""ListSignals request [%+v] is invalid: %v"", request, err)
		return nil, err
	}
	ctx = getExecutionContext(ctx, request.WorkflowExecutionId)
	identifierFilters, err := util.GetWorkflowExecutionIdentifierFilters(ctx, *request.WorkflowExecutionId)
	if err != nil {
		return nil, err
	}
	filters, err := util.AddRequestFilters(request.Filters, common.Signal, identifierFilters)
	if err != nil {
		return nil, err
	}
	var sortParameter common.SortParameter
	if request.SortBy != nil {
		sortParameter, err = common.NewSortParameter(*request.SortBy)
		if err != nil {
			return nil, err
		}
	}
	offset, err := validation.ValidateToken(request.Token)
	if err != nil {
		return nil, errors.NewFlyteAdminErrorf(codes.InvalidArgument,
			""invalid pagination token %s for ListSignals"", request.Token)
	}
	signalModelList, err := s.db.SignalRepo().List(ctx, repoInterfaces.ListResourceInput{
		InlineFilters: filters,
		Offset:        offset,
		Limit:         int(request.Limit),
		SortParameter: sortParameter,
	})
	if err != nil {
		logger.Debugf(ctx, ""Failed to list signals with request [%+v] with err %v"",
			request, err)
		return nil, err
	}
	signalList, err := transformers.FromSignalModels(signalModelList)
	if err != nil {
		logger.Debugf(ctx, ""failed to transform signal models for request [%+v] with err: %v"", request, err)
		return nil, err
	}
	var token string
	if len(signalList) == int(request.Limit) {
		token = strconv.Itoa(offset + len(signalList))
	}
	return &admin.SignalList{
		Signals: signalList,
		Token:   token,
	}, nil
}
func (s *SignalManager) SetSignal(ctx context.Context, request admin.SignalSetRequest) (*admin.SignalSetResponse, error) {
	if err := validation.ValidateSignalSetRequest(ctx, s.db, request); err != nil {
		return nil, err
	}
	ctx = getSignalContext(ctx, request.Id)
	signalModel, err := transformers.CreateSignalModel(request.Id, nil, request.Value)
	if err != nil {
		logger.Errorf(ctx, ""Failed to transform signal with id [%+v] and value [+%v] with err: %v"", request.Id, request.Value, err)
		return nil, err
	}
	err = s.db.SignalRepo().Update(ctx, signalModel.SignalKey, signalModel.Value)
	if err != nil {
		return nil, err
	}
	s.metrics.Set.Inc(ctx)
	return &admin.SignalSetResponse{}, nil
}
func NewSignalManager(
	db repoInterfaces.Repository,
	scope promutils.Scope) interfaces.SignalInterface {
	metrics := signalMetrics{
		Scope: scope,
		Set:   labeled.NewCounter(""num_set"", ""count of set signals"", scope),
	}
	return &SignalManager{
		db:      db,
		metrics: metrics,
	}
}
",CWE-89,161.0,1
"package gormimpl
import (
	""fmt""
	""github.com/flyteorg/flyteadmin/pkg/common""
	adminErrors ""github.com/flyteorg/flyteadmin/pkg/errors""
	""github.com/flyteorg/flyteadmin/pkg/repositories/errors""
	""github.com/flyteorg/flyteadmin/pkg/repositories/interfaces""
	""google.golang.org/grpc/codes""
	""gorm.io/gorm""
)
const Project = ""project""
const Domain = ""domain""
const Name = ""name""
const Version = ""version""
const Description = ""description""
const ResourceType = ""resource_type""
const State = ""state""
const ID = ""id""
const executionTableName = ""executions""
const namedEntityMetadataTableName = ""named_entity_metadata""
const nodeExecutionTableName = ""node_executions""
const taskExecutionTableName = ""task_executions""
const taskTableName = ""tasks""
const workflowTableName = ""workflows""
const descriptionEntityTableName = ""description_entities""
const AdminTagsTableName = ""admin_tags""
const executionAdminTagsTableName = ""execution_admin_tags""
const limit = ""limit""
const filters = ""filters""
var identifierGroupBy = fmt.Sprintf(""%s, %s, %s"", Project, Domain, Name)
var entityToTableName = map[common.Entity]string{
	common.Execution:           ""executions"",
	common.LaunchPlan:          ""launch_plans"",
	common.NodeExecution:       ""node_executions"",
	common.NodeExecutionEvent:  ""node_execution_events"",
	common.Task:                ""tasks"",
	common.TaskExecution:       ""task_executions"",
	common.Workflow:            ""workflows"",
	common.NamedEntity:         ""entities"",
	common.NamedEntityMetadata: ""named_entity_metadata"",
	common.Signal:              ""signals"",
	common.AdminTag:            ""admin_tags"",
	common.ExecutionAdminTag:   ""execution_admin_tags"",
}
var innerJoinExecToNodeExec = fmt.Sprintf(
	""INNER JOIN %s ON %s.execution_project = %s.execution_project AND ""+
		""%s.execution_domain = %s.execution_domain AND %s.execution_name = %s.execution_name"",
	executionTableName, nodeExecutionTableName, executionTableName, nodeExecutionTableName, executionTableName,
	nodeExecutionTableName, executionTableName)
var innerJoinNodeExecToTaskExec = fmt.Sprintf(
	""INNER JOIN %s ON %s.node_id = %s.node_id AND %s.execution_project = %s.execution_project AND ""+
		""%s.execution_domain = %s.execution_domain AND %s.execution_name = %s.execution_name"",
	nodeExecutionTableName, taskExecutionTableName, nodeExecutionTableName, taskExecutionTableName,
	nodeExecutionTableName, taskExecutionTableName, nodeExecutionTableName, taskExecutionTableName,
	nodeExecutionTableName)
// Because dynamic tasks do NOT necessarily register static task definitions, we use a left join to not exclude
// dynamic tasks from list queries.
var leftJoinTaskToTaskExec = fmt.Sprintf(
	""LEFT JOIN %s ON %s.project = %s.project AND %s.domain = %s.domain AND %s.name = %s.name AND ""+
		""%s.version = %s.version"",
	taskTableName, taskExecutionTableName, taskTableName, taskExecutionTableName, taskTableName,
	taskExecutionTableName, taskTableName, taskExecutionTableName, taskTableName)
// Validates there are no missing but required parameters in ListResourceInput
func ValidateListInput(input interfaces.ListResourceInput) adminErrors.FlyteAdminError {
	if input.Limit == 0 {
		return errors.GetInvalidInputError(limit)
	}
	if len(input.InlineFilters) == 0 {
		return errors.GetInvalidInputError(filters)
	}
	return nil
}
func applyFilters(tx *gorm.DB, inlineFilters []common.InlineFilter, mapFilters []common.MapFilter) (*gorm.DB, error) {
	for _, filter := range inlineFilters {
		gormQueryExpr, err := filter.GetGormQueryExpr()
		if err != nil {
			return nil, errors.GetInvalidInputError(err.Error())
		}
		tx = tx.Where(gormQueryExpr.Query, gormQueryExpr.Args)
	}
	for _, mapFilter := range mapFilters {
		tx = tx.Where(mapFilter.GetFilter())
	}
	return tx, nil
}
func applyScopedFilters(tx *gorm.DB, inlineFilters []common.InlineFilter, mapFilters []common.MapFilter) (*gorm.DB, error) {
	for _, filter := range inlineFilters {
		tableName, ok := entityToTableName[filter.GetEntity()]
		if !ok {
			return nil, adminErrors.NewFlyteAdminErrorf(codes.InvalidArgument,
				""unrecognized entity in filter expression: %v"", filter.GetEntity())
		}
		gormQueryExpr, err := filter.GetGormJoinTableQueryExpr(tableName)
		if err != nil {
			return nil, err
		}
		tx = tx.Where(gormQueryExpr.Query, gormQueryExpr.Args)
	}
	for _, mapFilter := range mapFilters {
		tx = tx.Where(mapFilter.GetFilter())
	}
	return tx, nil
}
",CWE-89,118.0,1
"package gormimpl
import (
	""context""
	""github.com/flyteorg/flyteadmin/pkg/common""
	""github.com/flyteorg/flyteidl/gen/pb-go/flyteidl/core""
	""github.com/flyteorg/flytestdlib/promutils""
	flyteAdminDbErrors ""github.com/flyteorg/flyteadmin/pkg/repositories/errors""
	""github.com/flyteorg/flyteadmin/pkg/repositories/interfaces""
	""github.com/flyteorg/flyteadmin/pkg/repositories/models""
	""gorm.io/gorm""
)
// DescriptionEntityRepo Implementation of DescriptionEntityRepoInterface.
type DescriptionEntityRepo struct {
	db               *gorm.DB
	errorTransformer flyteAdminDbErrors.ErrorTransformer
	metrics          gormMetrics
}
func (r *DescriptionEntityRepo) Get(ctx context.Context, input interfaces.GetDescriptionEntityInput) (models.DescriptionEntity, error) {
	var descriptionEntity models.DescriptionEntity
	filters, err := getDescriptionEntityFilters(input.ResourceType, input.Project, input.Domain, input.Name, input.Version)
	if err != nil {
		return models.DescriptionEntity{}, err
	}
	tx := r.db.Table(descriptionEntityTableName)
	// Apply filters
	tx, err = applyFilters(tx, filters, nil)
	if err != nil {
		return models.DescriptionEntity{}, err
	}
	timer := r.metrics.GetDuration.Start()
	tx = tx.Take(&descriptionEntity)
	timer.Stop()
	if tx.Error != nil {
		return models.DescriptionEntity{}, r.errorTransformer.ToFlyteAdminError(tx.Error)
	}
	return descriptionEntity, nil
}
func (r *DescriptionEntityRepo) List(
	ctx context.Context, input interfaces.ListResourceInput) (interfaces.DescriptionEntityCollectionOutput, error) {
	// First validate input.
	if err := ValidateListInput(input); err != nil {
		return interfaces.DescriptionEntityCollectionOutput{}, err
	}
	var descriptionEntities []models.DescriptionEntity
	tx := r.db.Limit(input.Limit).Offset(input.Offset)
	// Apply filters
	tx, err := applyFilters(tx, input.InlineFilters, input.MapFilters)
	if err != nil {
		return interfaces.DescriptionEntityCollectionOutput{}, err
	}
	// Apply sort ordering.
	if input.SortParameter != nil {
		tx = tx.Order(input.SortParameter.GetGormOrderExpr())
	}
	timer := r.metrics.ListDuration.Start()
	tx.Find(&descriptionEntities)
	timer.Stop()
	if tx.Error != nil {
		return interfaces.DescriptionEntityCollectionOutput{}, r.errorTransformer.ToFlyteAdminError(tx.Error)
	}
	return interfaces.DescriptionEntityCollectionOutput{
		Entities: descriptionEntities,
	}, nil
}
func getDescriptionEntityFilters(resourceType core.ResourceType, project string, domain string, name string, version string) ([]common.InlineFilter, error) {
	entity := common.ResourceTypeToEntity[resourceType]
	filters := make([]common.InlineFilter, 0)
	projectFilter, err := common.NewSingleValueFilter(entity, common.Equal, Project, project)
	if err != nil {
		return nil, err
	}
	filters = append(filters, projectFilter)
	domainFilter, err := common.NewSingleValueFilter(entity, common.Equal, Domain, domain)
	if err != nil {
		return nil, err
	}
	filters = append(filters, domainFilter)
	nameFilter, err := common.NewSingleValueFilter(entity, common.Equal, Name, name)
	if err != nil {
		return nil, err
	}
	filters = append(filters, nameFilter)
	versionFilter, err := common.NewSingleValueFilter(entity, common.Equal, Version, version)
	if err != nil {
		return nil, err
	}
	filters = append(filters, versionFilter)
	return filters, nil
}
// NewDescriptionEntityRepo Returns an instance of DescriptionRepoInterface
func NewDescriptionEntityRepo(
	db *gorm.DB, errorTransformer flyteAdminDbErrors.ErrorTransformer, scope promutils.Scope) interfaces.DescriptionEntityRepoInterface {
	metrics := newMetrics(scope)
	return &DescriptionEntityRepo{
		db:               db,
		errorTransformer: errorTransformer,
		metrics:          metrics,
	}
}
",CWE-89,116.0,1
"package gormimpl
import (
	""context""
	""errors""
	""fmt""
	""github.com/flyteorg/flyteadmin/pkg/common""
	adminErrors ""github.com/flyteorg/flyteadmin/pkg/repositories/errors""
	""github.com/flyteorg/flyteadmin/pkg/repositories/interfaces""
	""github.com/flyteorg/flyteadmin/pkg/repositories/models""
	""github.com/flyteorg/flyteidl/gen/pb-go/flyteidl/core""
	""github.com/flyteorg/flytestdlib/promutils""
	""gorm.io/gorm""
)
// Implementation of ExecutionInterface.
type ExecutionRepo struct {
	db               *gorm.DB
	errorTransformer adminErrors.ErrorTransformer
	metrics          gormMetrics
}
func (r *ExecutionRepo) Create(ctx context.Context, input models.Execution) error {
	timer := r.metrics.CreateDuration.Start()
	tx := r.db.Omit(""id"").Create(&input)
	timer.Stop()
	if tx.Error != nil {
		return r.errorTransformer.ToFlyteAdminError(tx.Error)
	}
	return nil
}
func (r *ExecutionRepo) Get(_ context.Context, input interfaces.Identifier) (models.Execution, error) {
	var execution models.Execution
	timer := r.metrics.GetDuration.Start()
	tx := r.db.Where(&models.Execution{
		ExecutionKey: models.ExecutionKey{
			Project: input.Project,
			Domain:  input.Domain,
			Name:    input.Name,
		},
	}).Take(&execution)
	timer.Stop()
	if tx.Error != nil && errors.Is(tx.Error, gorm.ErrRecordNotFound) {
		return models.Execution{}, adminErrors.GetMissingEntityError(""execution"", &core.Identifier{
			Project: input.Project,
			Domain:  input.Domain,
			Name:    input.Name,
		})
	} else if tx.Error != nil {
		return models.Execution{}, r.errorTransformer.ToFlyteAdminError(tx.Error)
	}
	return execution, nil
}
func (r *ExecutionRepo) Update(ctx context.Context, execution models.Execution) error {
	timer := r.metrics.UpdateDuration.Start()
	tx := r.db.Model(&execution).Updates(execution)
	timer.Stop()
	if err := tx.Error; err != nil {
		return r.errorTransformer.ToFlyteAdminError(err)
	}
	return nil
}
func (r *ExecutionRepo) List(_ context.Context, input interfaces.ListResourceInput) (
	interfaces.ExecutionCollectionOutput, error) {
	var err error
	// First validate input.
	if err = ValidateListInput(input); err != nil {
		return interfaces.ExecutionCollectionOutput{}, err
	}
	var executions []models.Execution
	tx := r.db.Limit(input.Limit).Offset(input.Offset)
	// And add join condition as required by user-specified filters (which can potentially include join table attrs).
	if ok := input.JoinTableEntities[common.LaunchPlan]; ok {
		tx = tx.Joins(fmt.Sprintf(""INNER JOIN %s ON %s.launch_plan_id = %s.id"",
			launchPlanTableName, executionTableName, launchPlanTableName))
	}
	if ok := input.JoinTableEntities[common.Workflow]; ok {
		tx = tx.Joins(fmt.Sprintf(""INNER JOIN %s ON %s.workflow_id = %s.id"",
			workflowTableName, executionTableName, workflowTableName))
	}
	if ok := input.JoinTableEntities[common.Task]; ok {
		tx = tx.Joins(fmt.Sprintf(""INNER JOIN %s ON %s.task_id = %s.id"",
			taskTableName, executionTableName, taskTableName))
	}
	if ok := input.JoinTableEntities[common.AdminTag]; ok {
		tx = tx.Joins(fmt.Sprintf(""INNER JOIN %s ON %s.execution_name = %s.execution_name"",
			executionAdminTagsTableName, executionTableName, executionAdminTagsTableName))
		tx = tx.Joins(fmt.Sprintf(""INNER JOIN %s ON %s.id = %s.admin_tag_id"",
			AdminTagsTableName, AdminTagsTableName, executionAdminTagsTableName))
	}
	// Apply filters
	tx, err = applyScopedFilters(tx, input.InlineFilters, input.MapFilters)
	if err != nil {
		return interfaces.ExecutionCollectionOutput{}, err
	}
	// Apply sort ordering.
	if input.SortParameter != nil {
		tx = tx.Order(input.SortParameter.GetGormOrderExpr())
	}
	timer := r.metrics.ListDuration.Start()
	tx = tx.Find(&executions)
	timer.Stop()
	if tx.Error != nil {
		return interfaces.ExecutionCollectionOutput{}, r.errorTransformer.ToFlyteAdminError(tx.Error)
	}
	return interfaces.ExecutionCollectionOutput{
		Executions: executions,
	}, nil
}
func (r *ExecutionRepo) Count(ctx context.Context, input interfaces.CountResourceInput) (int64, error) {
	var err error
	tx := r.db.Model(&models.Execution{})
	// Add join condition as required by user-specified filters (which can potentially include join table attrs).
	if ok := input.JoinTableEntities[common.LaunchPlan]; ok {
		tx = tx.Joins(fmt.Sprintf(""INNER JOIN %s ON %s.launch_plan_id = %s.id"",
			launchPlanTableName, executionTableName, launchPlanTableName))
	}
	if ok := input.JoinTableEntities[common.Workflow]; ok {
		tx = tx.Joins(fmt.Sprintf(""INNER JOIN %s ON %s.workflow_id = %s.id"",
			workflowTableName, executionTableName, workflowTableName))
	}
	if ok := input.JoinTableEntities[common.Task]; ok {
		tx = tx.Joins(fmt.Sprintf(""INNER JOIN %s ON %s.task_id = %s.id"",
			taskTableName, executionTableName, taskTableName))
	}
	// Apply filters
	tx, err = applyScopedFilters(tx, input.InlineFilters, input.MapFilters)
	if err != nil {
		return 0, err
	}
	// Run the query
	timer := r.metrics.CountDuration.Start()
	var count int64
	tx = tx.Count(&count)
	timer.Stop()
	if tx.Error != nil {
		return 0, r.errorTransformer.ToFlyteAdminError(tx.Error)
	}
	return count, nil
}
// Returns an instance of ExecutionRepoInterface
func NewExecutionRepo(
	db *gorm.DB, errorTransformer adminErrors.ErrorTransformer, scope promutils.Scope) interfaces.ExecutionRepoInterface {
	metrics := newMetrics(scope)
	return &ExecutionRepo{
		db:               db,
		errorTransformer: errorTransformer,
		metrics:          metrics,
	}
}
",CWE-89,165.0,1
"package gormimpl
import (
	""context""
	""errors""
	""time""
	""github.com/flyteorg/flyteidl/gen/pb-go/flyteidl/core""
	""github.com/flyteorg/flytestdlib/promutils""
	adminErrors ""github.com/flyteorg/flyteadmin/pkg/repositories/errors""
	""github.com/flyteorg/flyteadmin/pkg/repositories/interfaces""
	""github.com/flyteorg/flyteadmin/pkg/repositories/models""
	""github.com/flyteorg/flytestdlib/logger""
	""gorm.io/gorm""
)
const launchPlanTableName = ""launch_plans""
type launchPlanMetrics struct {
	SetActiveDuration promutils.StopWatch
}
// Implementation of LaunchPlanRepoInterface.
type LaunchPlanRepo struct {
	db                *gorm.DB
	errorTransformer  adminErrors.ErrorTransformer
	metrics           gormMetrics
	launchPlanMetrics launchPlanMetrics
}
func (r *LaunchPlanRepo) Create(ctx context.Context, input models.LaunchPlan) error {
	timer := r.metrics.CreateDuration.Start()
	tx := r.db.Omit(""id"").Create(&input)
	timer.Stop()
	if tx.Error != nil {
		return r.errorTransformer.ToFlyteAdminError(tx.Error)
	}
	return nil
}
func (r *LaunchPlanRepo) Update(ctx context.Context, input models.LaunchPlan) error {
	timer := r.metrics.UpdateDuration.Start()
	tx := r.db.Model(&input).Updates(input)
	timer.Stop()
	if err := tx.Error; err != nil {
		return r.errorTransformer.ToFlyteAdminError(err)
	}
	return nil
}
func (r *LaunchPlanRepo) Get(ctx context.Context, input interfaces.Identifier) (models.LaunchPlan, error) {
	var launchPlan models.LaunchPlan
	timer := r.metrics.GetDuration.Start()
	tx := r.db.Where(&models.LaunchPlan{
		LaunchPlanKey: models.LaunchPlanKey{
			Project: input.Project,
			Domain:  input.Domain,
			Name:    input.Name,
			Version: input.Version,
		},
	}).Take(&launchPlan)
	timer.Stop()
	if tx.Error != nil && errors.Is(tx.Error, gorm.ErrRecordNotFound) {
		return models.LaunchPlan{},
			adminErrors.GetMissingEntityError(core.ResourceType_LAUNCH_PLAN.String(), &core.Identifier{
				Project: input.Project,
				Domain:  input.Domain,
				Name:    input.Name,
				Version: input.Version,
			})
	} else if tx.Error != nil {
		return models.LaunchPlan{}, r.errorTransformer.ToFlyteAdminError(tx.Error)
	}
	return launchPlan, nil
}
// This operation is performed as a two-step transaction because only one launch plan version can be active at a time.
// Transactional semantics are used to guarantee that setting the desired launch plan to active also disables
// the existing launch plan version (if any).
func (r *LaunchPlanRepo) SetActive(
	ctx context.Context, toEnable models.LaunchPlan, toDisable *models.LaunchPlan) error {
	timer := r.launchPlanMetrics.SetActiveDuration.Start()
	defer timer.Stop()
	// Use a transaction to guarantee no partial updates.
	tx := r.db.Begin()
	// There is a launch plan to disable as part of this transaction
	if toDisable != nil {
		tx.Model(&toDisable).UpdateColumns(toDisable)
		if err := tx.Error; err != nil {
			tx.Rollback()
			return r.errorTransformer.ToFlyteAdminError(err)
		}
	}
	// And update the desired version.
	tx.Model(&toEnable).UpdateColumns(toEnable)
	if err := tx.Error; err != nil {
		tx.Rollback()
		return r.errorTransformer.ToFlyteAdminError(err)
	}
	if err := tx.Commit().Error; err != nil {
		return r.errorTransformer.ToFlyteAdminError(err)
	}
	return nil
}
func (r *LaunchPlanRepo) List(ctx context.Context, input interfaces.ListResourceInput) (
	interfaces.LaunchPlanCollectionOutput, error) {
	// First validate input.
	if err := ValidateListInput(input); err != nil {
		return interfaces.LaunchPlanCollectionOutput{}, err
	}
	var launchPlans []models.LaunchPlan
	tx := r.db.Limit(input.Limit).Offset(input.Offset)
	// Add join conditions
	tx = tx.Joins(""inner join workflows on launch_plans.workflow_id = workflows.id"")
	// Apply filters
	tx, err := applyScopedFilters(tx, input.InlineFilters, input.MapFilters)
	if err != nil {
		return interfaces.LaunchPlanCollectionOutput{}, err
	}
	// Apply sort ordering.
	if input.SortParameter != nil {
		tx = tx.Order(input.SortParameter.GetGormOrderExpr())
	}
	timer := r.metrics.ListDuration.Start()
	tx.Find(&launchPlans)
	timer.Stop()
	if tx.Error != nil {
		logger.Warningf(ctx,
			""Failed to list launch plans by workflow with input [%+v] with err: %+v"", input, tx.Error)
		return interfaces.LaunchPlanCollectionOutput{}, r.errorTransformer.ToFlyteAdminError(tx.Error)
	}
	return interfaces.LaunchPlanCollectionOutput{
		LaunchPlans: launchPlans,
	}, nil
}
func (r *LaunchPlanRepo) ListLaunchPlanIdentifiers(ctx context.Context, input interfaces.ListResourceInput) (
	interfaces.LaunchPlanCollectionOutput, error) {
	// Validate input, input must have a limit
	if err := ValidateListInput(input); err != nil {
		return interfaces.LaunchPlanCollectionOutput{}, err
	}
	tx := r.db.Model(models.LaunchPlan{}).Limit(input.Limit).Offset(input.Offset)
	// Apply filters
	tx, err := applyFilters(tx, input.InlineFilters, input.MapFilters)
	if err != nil {
		return interfaces.LaunchPlanCollectionOutput{}, err
	}
	// Apply sort ordering.
	if input.SortParameter != nil {
		tx = tx.Order(input.SortParameter.GetGormOrderExpr())
	}
	// Scan the results into a list of launch plans
	var launchPlans []models.LaunchPlan
	timer := r.metrics.ListIdentifiersDuration.Start()
	tx.Select([]string{Project, Domain, Name}).Group(identifierGroupBy).Scan(&launchPlans)
	timer.Stop()
	if tx.Error != nil {
		return interfaces.LaunchPlanCollectionOutput{}, r.errorTransformer.ToFlyteAdminError(tx.Error)
	}
	return interfaces.LaunchPlanCollectionOutput{
		LaunchPlans: launchPlans,
	}, nil
}
// Returns an instance of LaunchPlanRepoInterface
func NewLaunchPlanRepo(
	db *gorm.DB, errorTransformer adminErrors.ErrorTransformer, scope promutils.Scope) interfaces.LaunchPlanRepoInterface {
	metrics := newMetrics(scope)
	launchPlanMetrics := launchPlanMetrics{
		SetActiveDuration: scope.MustNewStopWatch(
			""set_active"",
			""time taken to set a launch plan to active (and disable the currently active version)"", time.Millisecond),
	}
	return &LaunchPlanRepo{
		db:                db,
		errorTransformer:  errorTransformer,
		metrics:           metrics,
		launchPlanMetrics: launchPlanMetrics,
	}
}
",CWE-89,198.0,1
"package gormimpl
import (
	""context""
	""testing""
	""github.com/flyteorg/flyteadmin/pkg/common""
	""github.com/flyteorg/flyteidl/gen/pb-go/flyteidl/admin""
	mocket ""github.com/Selvatico/go-mocket""
	""github.com/flyteorg/flyteadmin/pkg/repositories/errors""
	""github.com/flyteorg/flyteadmin/pkg/repositories/interfaces""
	""github.com/flyteorg/flyteadmin/pkg/repositories/models""
	mockScope ""github.com/flyteorg/flytestdlib/promutils""
	""github.com/stretchr/testify/assert""
)
func getMockNamedEntityResponseFromDb(expected models.NamedEntity) map[string]interface{} {
	metadata := make(map[string]interface{})
	metadata[""resource_type""] = expected.ResourceType
	metadata[""project""] = expected.Project
	metadata[""domain""] = expected.Domain
	metadata[""name""] = expected.Name
	metadata[""description""] = expected.Description
	metadata[""state""] = expected.State
	return metadata
}
func TestGetNamedEntity(t *testing.T) {
	metadataRepo := NewNamedEntityRepo(GetDbForTest(t), errors.NewTestErrorTransformer(), mockScope.NewTestScope())
	results := make([]map[string]interface{}, 0)
	metadata := getMockNamedEntityResponseFromDb(models.NamedEntity{
		NamedEntityKey: models.NamedEntityKey{
			ResourceType: resourceType,
			Project:      project,
			Domain:       domain,
			Name:         name,
		},
		NamedEntityMetadataFields: models.NamedEntityMetadataFields{
			Description: description,
		},
	})
	results = append(results, metadata)
	GlobalMock := mocket.Catcher.Reset()
	GlobalMock.Logging = true
	GlobalMock.NewMock().WithQuery(
		`SELECT workflows.project,workflows.domain,workflows.name,'2' AS resource_type,named_entity_metadata.description,named_entity_metadata.state FROM ""workflows"" LEFT JOIN named_entity_metadata ON named_entity_metadata.resource_type = 2 AND named_entity_metadata.project = workflows.project AND named_entity_metadata.domain = workflows.domain AND named_entity_metadata.name = workflows.name WHERE workflows.project = $1 AND workflows.domain = $2 AND workflows.name = $3 LIMIT 1`).WithReply(results)
	output, err := metadataRepo.Get(context.Background(), interfaces.GetNamedEntityInput{
		ResourceType: resourceType,
		Project:      project,
		Domain:       domain,
		Name:         name,
	})
	assert.NoError(t, err)
	assert.Equal(t, project, output.Project)
	assert.Equal(t, domain, output.Domain)
	assert.Equal(t, name, output.Name)
	assert.Equal(t, resourceType, output.ResourceType)
	assert.Equal(t, description, output.Description)
}
func TestUpdateNamedEntity_WithExisting(t *testing.T) {
	metadataRepo := NewNamedEntityRepo(GetDbForTest(t), errors.NewTestErrorTransformer(), mockScope.NewTestScope())
	const updatedDescription = ""updated description""
	results := make([]map[string]interface{}, 0)
	activeState := int32(admin.NamedEntityState_NAMED_ENTITY_ACTIVE)
	metadata := getMockNamedEntityResponseFromDb(models.NamedEntity{
		NamedEntityKey: models.NamedEntityKey{
			ResourceType: resourceType,
			Project:      project,
			Domain:       domain,
			Name:         name,
		},
		NamedEntityMetadataFields: models.NamedEntityMetadataFields{
			Description: description,
			State:       &activeState,
		},
	})
	results = append(results, metadata)
	GlobalMock := mocket.Catcher.Reset()
	GlobalMock.Logging = true
	GlobalMock.NewMock().WithQuery(
		`SELECT ""named_entity_metadata"".""created_at"",""named_entity_metadata"".""updated_at"",""named_entity_metadata"".""deleted_at"",""named_entity_metadata"".""resource_type"",""named_entity_metadata"".""project"",""named_entity_metadata"".""domain"",""named_entity_metadata"".""name"",""named_entity_metadata"".""description"",""named_entity_metadata"".""state"" FROM ""named_entity_metadata"" WHERE ""named_entity_metadata"".""resource_type"" = $1 AND ""named_entity_metadata"".""project"" = $2 AND ""named_entity_metadata"".""domain"" = $3 AND ""named_entity_metadata"".""name"" = $4 ORDER BY ""named_entity_metadata"".""id"" LIMIT 1`).WithReply(results)
	mockQuery := GlobalMock.NewMock()
	mockQuery.WithQuery(
		`UPDATE ""named_entity_metadata"" SET ""description""=$1,""state""=$2,""updated_at""=$3 WHERE ""named_entity_metadata"".""resource_type"" = $4 AND ""named_entity_metadata"".""project"" = $5 AND ""named_entity_metadata"".""domain"" = $6 AND ""named_entity_metadata"".""name"" = $7 AND ""resource_type"" = $8 AND ""project"" = $9 AND ""domain"" = $10 AND ""name"" = $11`)
	err := metadataRepo.Update(context.Background(), models.NamedEntity{
		NamedEntityKey: models.NamedEntityKey{
			ResourceType: resourceType,
			Project:      project,
			Domain:       domain,
			Name:         name,
		},
		NamedEntityMetadataFields: models.NamedEntityMetadataFields{
			Description: updatedDescription,
			State:       &activeState,
		},
	})
	assert.NoError(t, err)
	assert.True(t, mockQuery.Triggered)
}
func TestUpdateNamedEntity_CreateNew(t *testing.T) {
	metadataRepo := NewNamedEntityRepo(GetDbForTest(t), errors.NewTestErrorTransformer(), mockScope.NewTestScope())
	const updatedDescription = ""updated description""
	GlobalMock := mocket.Catcher.Reset()
	GlobalMock.Logging = true
	mockQuery := GlobalMock.NewMock()
	mockQuery.WithQuery(
		`INSERT INTO ""named_entity_metadata"" (""created_at"",""updated_at"",""deleted_at"",""resource_type"",""project"",""domain"",""name"",""description"",""state"") VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9)`)
	err := metadataRepo.Update(context.Background(), models.NamedEntity{
		NamedEntityKey: models.NamedEntityKey{
			ResourceType: resourceType,
			Project:      project,
			Domain:       domain,
			Name:         name,
		},
		NamedEntityMetadataFields: models.NamedEntityMetadataFields{
			Description: updatedDescription,
		},
	})
	assert.NoError(t, err)
	assert.True(t, mockQuery.Triggered)
}
func TestListNamedEntity(t *testing.T) {
	metadataRepo := NewNamedEntityRepo(GetDbForTest(t), errors.NewTestErrorTransformer(), mockScope.NewTestScope())
	results := make([]map[string]interface{}, 0)
	metadata := getMockNamedEntityResponseFromDb(models.NamedEntity{
		NamedEntityKey: models.NamedEntityKey{
			ResourceType: resourceType,
			Project:      project,
			Domain:       domain,
			Name:         name,
		},
		NamedEntityMetadataFields: models.NamedEntityMetadataFields{
			Description: description,
		},
	})
	results = append(results, metadata)
	GlobalMock := mocket.Catcher.Reset()
	GlobalMock.Logging = true
	mockQuery := GlobalMock.NewMock()
	mockQuery.WithQuery(
		`SELECT entities.project,entities.domain,entities.name,'2' AS resource_type,named_entity_metadata.description,named_entity_metadata.state FROM ""named_entity_metadata"" RIGHT JOIN (SELECT project,domain,name FROM ""workflows"" WHERE ""domain"" = $1 AND ""project"" = $2 GROUP BY project, domain, name ORDER BY name desc LIMIT 20) AS entities ON named_entity_metadata.resource_type = 2 AND named_entity_metadata.project = entities.project AND named_entity_metadata.domain = entities.domain AND named_entity_metadata.name = entities.name GROUP BY entities.project, entities.domain, entities.name, named_entity_metadata.description, named_entity_metadata.state ORDER BY name desc`).WithReply(results)
	sortParameter, _ := common.NewSortParameter(admin.Sort{
		Direction: admin.Sort_DESCENDING,
		Key:       ""name"",
	})
	output, err := metadataRepo.List(context.Background(), interfaces.ListNamedEntityInput{
		ResourceType: resourceType,
		Project:      ""admintests"",
		Domain:       ""development"",
		ListResourceInput: interfaces.ListResourceInput{
			Limit:         20,
			SortParameter: sortParameter,
		},
	})
	assert.NoError(t, err)
	assert.Len(t, output.Entities, 1)
}
",CWE-89,176.0,1
"package gormimpl
import (
	""context""
	""github.com/flyteorg/flyteadmin/pkg/repositories/errors""
	""github.com/flyteorg/flyteadmin/pkg/repositories/interfaces""
	""github.com/flyteorg/flyteadmin/pkg/repositories/models""
	""github.com/flyteorg/flytestdlib/promutils""
	""gorm.io/gorm""
)
type NodeExecutionEventRepo struct {
	db               *gorm.DB
	errorTransformer errors.ErrorTransformer
	metrics          gormMetrics
}
func (r *NodeExecutionEventRepo) Create(ctx context.Context, input models.NodeExecutionEvent) error {
	timer := r.metrics.CreateDuration.Start()
	tx := r.db.Omit(""id"").Create(&input)
	timer.Stop()
	if tx.Error != nil {
		return r.errorTransformer.ToFlyteAdminError(tx.Error)
	}
	return nil
}
// Returns an instance of NodeExecutionRepoInterface
func NewNodeExecutionEventRepo(
	db *gorm.DB, errorTransformer errors.ErrorTransformer, scope promutils.Scope) interfaces.NodeExecutionEventRepoInterface {
	metrics := newMetrics(scope)
	return &NodeExecutionEventRepo{
		db:               db,
		errorTransformer: errorTransformer,
		metrics:          metrics,
	}
}
",CWE-89,39.0,1
"package gormimpl
import (
	""context""
	""errors""
	flyteAdminErrors ""github.com/flyteorg/flyteadmin/pkg/errors""
	""google.golang.org/grpc/codes""
	""github.com/flyteorg/flyteidl/gen/pb-go/flyteidl/admin""
	""github.com/flyteorg/flytestdlib/promutils""
	""gorm.io/gorm""
	flyteAdminDbErrors ""github.com/flyteorg/flyteadmin/pkg/repositories/errors""
	""github.com/flyteorg/flyteadmin/pkg/repositories/interfaces""
	""github.com/flyteorg/flyteadmin/pkg/repositories/models""
)
type ProjectRepo struct {
	db               *gorm.DB
	errorTransformer flyteAdminDbErrors.ErrorTransformer
	metrics          gormMetrics
}
func (r *ProjectRepo) Create(ctx context.Context, project models.Project) error {
	timer := r.metrics.CreateDuration.Start()
	tx := r.db.Omit(""id"").Create(&project)
	timer.Stop()
	if tx.Error != nil {
		return r.errorTransformer.ToFlyteAdminError(tx.Error)
	}
	return nil
}
func (r *ProjectRepo) Get(ctx context.Context, projectID string) (models.Project, error) {
	var project models.Project
	timer := r.metrics.GetDuration.Start()
	tx := r.db.Where(&models.Project{
		Identifier: projectID,
	}).Take(&project)
	timer.Stop()
	if errors.Is(tx.Error, gorm.ErrRecordNotFound) {
		return models.Project{}, flyteAdminErrors.NewFlyteAdminErrorf(codes.NotFound, ""project [%s] not found"", projectID)
	}
	if tx.Error != nil {
		return models.Project{}, r.errorTransformer.ToFlyteAdminError(tx.Error)
	}
	return project, nil
}
func (r *ProjectRepo) List(ctx context.Context, input interfaces.ListResourceInput) ([]models.Project, error) {
	var projects []models.Project
	tx := r.db.Offset(input.Offset)
	if input.Limit != 0 {
		tx = tx.Limit(input.Limit)
	}
	// Apply filters
	// If no filter provided, default to filtering out archived projects
	if len(input.InlineFilters) == 0 && len(input.MapFilters) == 0 {
		tx = tx.Where(""state != ?"", int32(admin.Project_ARCHIVED))
	} else {
		var err error
		tx, err = applyFilters(tx, input.InlineFilters, input.MapFilters)
		if err != nil {
			return nil, err
		}
	}
	// Apply sort ordering
	if input.SortParameter != nil {
		tx = tx.Order(input.SortParameter.GetGormOrderExpr())
	}
	timer := r.metrics.ListDuration.Start()
	tx.Find(&projects)
	timer.Stop()
	if tx.Error != nil {
		return nil, r.errorTransformer.ToFlyteAdminError(tx.Error)
	}
	return projects, nil
}
func NewProjectRepo(db *gorm.DB, errorTransformer flyteAdminDbErrors.ErrorTransformer,
	scope promutils.Scope) interfaces.ProjectRepoInterface {
	metrics := newMetrics(scope)
	return &ProjectRepo{
		db:               db,
		errorTransformer: errorTransformer,
		metrics:          metrics,
	}
}
func (r *ProjectRepo) UpdateProject(ctx context.Context, projectUpdate models.Project) error {
	// Use gorm client to update the two fields that are changed.
	writeTx := r.db.Model(&projectUpdate).Updates(projectUpdate)
	// Return error if applies.
	if writeTx.Error != nil {
		return r.errorTransformer.ToFlyteAdminError(writeTx.Error)
	}
	return nil
}
",CWE-89,110.0,1
"package gormimpl
import (
	""context""
	""testing""
	mocket ""github.com/Selvatico/go-mocket""
	""github.com/flyteorg/flyteadmin/pkg/common""
	""github.com/flyteorg/flyteadmin/pkg/repositories/errors""
	""github.com/flyteorg/flyteadmin/pkg/repositories/interfaces""
	""github.com/flyteorg/flyteadmin/pkg/repositories/models""
	""github.com/flyteorg/flyteidl/gen/pb-go/flyteidl/admin""
	mockScope ""github.com/flyteorg/flytestdlib/promutils""
	""github.com/stretchr/testify/assert""
)
var alphabeticalSortParam, _ = common.NewSortParameter(admin.Sort{
	Direction: admin.Sort_ASCENDING,
	Key:       ""identifier"",
})
func TestCreateProject(t *testing.T) {
	projectRepo := NewProjectRepo(GetDbForTest(t), errors.NewTestErrorTransformer(), mockScope.NewTestScope())
	GlobalMock := mocket.Catcher.Reset()
	query := GlobalMock.NewMock()
	GlobalMock.Logging = true
	query.WithQuery(
		`INSERT INTO ""projects"" (""created_at"",""updated_at"",""deleted_at"",""name"",""description"",""labels"",""state"",""identifier"") VALUES ($1,$2,$3,$4,$5,$6,$7,$8)`)
	activeState := int32(admin.Project_ACTIVE)
	err := projectRepo.Create(context.Background(), models.Project{
		Identifier:  ""proj"",
		Name:        ""proj"",
		Description: ""projDescription"",
		State:       &activeState,
	})
	assert.NoError(t, err)
	assert.True(t, query.Triggered)
}
func TestGetProject(t *testing.T) {
	projectRepo := NewProjectRepo(GetDbForTest(t), errors.NewTestErrorTransformer(), mockScope.NewTestScope())
	GlobalMock := mocket.Catcher.Reset()
	response := make(map[string]interface{})
	response[""identifier""] = ""project_id""
	response[""name""] = ""project_name""
	response[""description""] = ""project_description""
	response[""state""] = admin.Project_ACTIVE
	output, err := projectRepo.Get(context.Background(), ""project_id"")
	assert.Empty(t, output)
	assert.EqualError(t, err, ""project [project_id] not found"")
	query := GlobalMock.NewMock()
	GlobalMock.Logging = true
	query.WithQuery(`SELECT * FROM ""projects"" WHERE ""projects"".""identifier"" = $1 LIMIT 1`).WithReply(
		[]map[string]interface{}{
			response,
		})
	output, err = projectRepo.Get(context.Background(), ""project_id"")
	assert.Nil(t, err)
	assert.Equal(t, ""project_id"", output.Identifier)
	assert.Equal(t, ""project_name"", output.Name)
	assert.Equal(t, ""project_description"", output.Description)
	assert.Equal(t, int32(admin.Project_ACTIVE), *output.State)
}
func testListProjects(input interfaces.ListResourceInput, sql string, t *testing.T) {
	projectRepo := NewProjectRepo(GetDbForTest(t), errors.NewTestErrorTransformer(), mockScope.NewTestScope())
	projects := make([]map[string]interface{}, 1)
	fooProject := make(map[string]interface{})
	fooProject[""identifier""] = ""foo""
	fooProject[""name""] = ""foo =)""
	fooProject[""description""] = ""foo description""
	fooProject[""state""] = admin.Project_ACTIVE
	projects[0] = fooProject
	GlobalMock := mocket.Catcher.Reset()
	GlobalMock.Logging = true
	GlobalMock.NewMock().WithQuery(sql).
		WithReply(projects)
	output, err := projectRepo.List(context.Background(), input)
	assert.Nil(t, err)
	assert.Len(t, output, 1)
	assert.Equal(t, ""foo"", output[0].Identifier)
	assert.Equal(t, ""foo =)"", output[0].Name)
	assert.Equal(t, ""foo description"", output[0].Description)
	assert.Equal(t, int32(admin.Project_ACTIVE), *output[0].State)
}
func TestListProjects(t *testing.T) {
	filter, err := common.NewSingleValueFilter(common.Project, common.Equal, ""name"", ""foo"")
	assert.Nil(t, err)
	testListProjects(interfaces.ListResourceInput{
		Offset:        0,
		Limit:         1,
		InlineFilters: []common.InlineFilter{filter},
		SortParameter: alphabeticalSortParam,
	}, `SELECT * FROM ""projects"" WHERE name = $1 ORDER BY identifier asc LIMIT 1`, t)
}
func TestListProjects_NoFilters(t *testing.T) {
	testListProjects(interfaces.ListResourceInput{
		Offset:        0,
		Limit:         1,
		SortParameter: alphabeticalSortParam,
	}, `SELECT * FROM ""projects"" WHERE state != $1 ORDER BY identifier asc`, t)
}
func TestListProjects_NoLimit(t *testing.T) {
	testListProjects(interfaces.ListResourceInput{
		Offset:        0,
		SortParameter: alphabeticalSortParam,
	}, `SELECT * FROM ""projects"" WHERE state != $1 ORDER BY identifier asc`, t)
}
func TestUpdateProject(t *testing.T) {
	projectRepo := NewProjectRepo(GetDbForTest(t), errors.NewTestErrorTransformer(), mockScope.NewTestScope())
	GlobalMock := mocket.Catcher.Reset()
	query := GlobalMock.NewMock()
	GlobalMock.Logging = true
	query.WithQuery(`UPDATE ""projects"" SET ""updated_at""=$1,""identifier""=$2,""name""=$3,""description""=$4,""state""=$5 WHERE ""identifier"" = $6`)
	activeState := int32(admin.Project_ACTIVE)
	err := projectRepo.UpdateProject(context.Background(), models.Project{
		Identifier:  ""project_id"",
		Name:        ""project_name"",
		Description: ""project_description"",
		State:       &activeState,
	})
	assert.Nil(t, err)
	assert.True(t, query.Triggered)
}
",CWE-89,139.0,1
"package gormimpl
import (
	""context""
	""errors""
	adminerrors ""github.com/flyteorg/flyteadmin/pkg/errors""
	flyteAdminDbErrors ""github.com/flyteorg/flyteadmin/pkg/repositories/errors""
	""github.com/flyteorg/flyteadmin/pkg/repositories/interfaces""
	""github.com/flyteorg/flyteadmin/pkg/repositories/models""
	""github.com/flyteorg/flytestdlib/promutils""
	""google.golang.org/grpc/codes""
	""gorm.io/gorm""
)
// SignalRepo is an implementation of SignalRepoInterface.
type SignalRepo struct {
	db               *gorm.DB
	errorTransformer flyteAdminDbErrors.ErrorTransformer
	metrics          gormMetrics
}
// Get retrieves a signal model from the database store.
func (s *SignalRepo) Get(ctx context.Context, input models.SignalKey) (models.Signal, error) {
	var signal models.Signal
	timer := s.metrics.GetDuration.Start()
	tx := s.db.Where(&models.Signal{
		SignalKey: input,
	}).Take(&signal)
	timer.Stop()
	if errors.Is(tx.Error, gorm.ErrRecordNotFound) {
		return models.Signal{}, adminerrors.NewFlyteAdminError(codes.NotFound, ""signal does not exist"")
	}
	if tx.Error != nil {
		return models.Signal{}, s.errorTransformer.ToFlyteAdminError(tx.Error)
	}
	return signal, nil
}
// GetOrCreate returns a signal if it already exists, if not it creates a new one given the input
func (s *SignalRepo) GetOrCreate(ctx context.Context, input *models.Signal) error {
	timer := s.metrics.CreateDuration.Start()
	tx := s.db.FirstOrCreate(&input, input)
	timer.Stop()
	if tx.Error != nil {
		return s.errorTransformer.ToFlyteAdminError(tx.Error)
	}
	return nil
}
// List fetches all signals that match the provided input
func (s *SignalRepo) List(ctx context.Context, input interfaces.ListResourceInput) ([]models.Signal, error) {
	// First validate input.
	if err := ValidateListInput(input); err != nil {
		return nil, err
	}
	var signals []models.Signal
	tx := s.db.Limit(input.Limit).Offset(input.Offset)
	// Apply filters
	tx, err := applyFilters(tx, input.InlineFilters, input.MapFilters)
	if err != nil {
		return nil, err
	}
	// Apply sort ordering.
	if input.SortParameter != nil {
		tx = tx.Order(input.SortParameter.GetGormOrderExpr())
	}
	timer := s.metrics.ListDuration.Start()
	tx.Find(&signals)
	timer.Stop()
	if tx.Error != nil {
		return nil, s.errorTransformer.ToFlyteAdminError(tx.Error)
	}
	return signals, nil
}
// Update sets the value field on the specified signal model
func (s *SignalRepo) Update(ctx context.Context, input models.SignalKey, value []byte) error {
	signal := models.Signal{
		SignalKey: input,
		Value:     value,
	}
	timer := s.metrics.GetDuration.Start()
	tx := s.db.Model(&signal).Select(""value"").Updates(signal)
	timer.Stop()
	if tx.Error != nil {
		return s.errorTransformer.ToFlyteAdminError(tx.Error)
	}
	if tx.RowsAffected == 0 {
		return adminerrors.NewFlyteAdminError(codes.NotFound, ""signal does not exist"")
	}
	return nil
}
// Returns an instance of SignalRepoInterface
func NewSignalRepo(
	db *gorm.DB, errorTransformer flyteAdminDbErrors.ErrorTransformer, scope promutils.Scope) interfaces.SignalRepoInterface {
	metrics := newMetrics(scope)
	return &SignalRepo{
		db:               db,
		errorTransformer: errorTransformer,
		metrics:          metrics,
	}
}
",CWE-89,111.0,1
"package gormimpl
import (
	""context""
	""errors""
	""github.com/flyteorg/flyteidl/gen/pb-go/flyteidl/core""
	""github.com/flyteorg/flytestdlib/promutils""
	flyteAdminDbErrors ""github.com/flyteorg/flyteadmin/pkg/repositories/errors""
	""github.com/flyteorg/flyteadmin/pkg/repositories/interfaces""
	""github.com/flyteorg/flyteadmin/pkg/repositories/models""
	""gorm.io/gorm""
)
// Implementation of TaskExecutionInterface.
type TaskExecutionRepo struct {
	db               *gorm.DB
	errorTransformer flyteAdminDbErrors.ErrorTransformer
	metrics          gormMetrics
}
func (r *TaskExecutionRepo) Create(ctx context.Context, input models.TaskExecution) error {
	timer := r.metrics.CreateDuration.Start()
	tx := r.db.Omit(""id"").Create(&input)
	timer.Stop()
	if tx.Error != nil {
		return r.errorTransformer.ToFlyteAdminError(tx.Error)
	}
	return nil
}
func (r *TaskExecutionRepo) Get(ctx context.Context, input interfaces.GetTaskExecutionInput) (models.TaskExecution, error) {
	var taskExecution models.TaskExecution
	timer := r.metrics.GetDuration.Start()
	tx := r.db.Where(&models.TaskExecution{
		TaskExecutionKey: models.TaskExecutionKey{
			TaskKey: models.TaskKey{
				Project: input.TaskExecutionID.TaskId.Project,
				Domain:  input.TaskExecutionID.TaskId.Domain,
				Name:    input.TaskExecutionID.TaskId.Name,
				Version: input.TaskExecutionID.TaskId.Version,
			},
			NodeExecutionKey: models.NodeExecutionKey{
				NodeID: input.TaskExecutionID.NodeExecutionId.NodeId,
				ExecutionKey: models.ExecutionKey{
					Project: input.TaskExecutionID.NodeExecutionId.ExecutionId.Project,
					Domain:  input.TaskExecutionID.NodeExecutionId.ExecutionId.Domain,
					Name:    input.TaskExecutionID.NodeExecutionId.ExecutionId.Name,
				},
			},
			RetryAttempt: &input.TaskExecutionID.RetryAttempt,
		},
	}).Preload(""ChildNodeExecution"").Take(&taskExecution)
	timer.Stop()
	if tx.Error != nil && errors.Is(tx.Error, gorm.ErrRecordNotFound) {
		return models.TaskExecution{},
			flyteAdminDbErrors.GetMissingEntityError(""task execution"", &core.TaskExecutionIdentifier{
				TaskId: &core.Identifier{
					Project: input.TaskExecutionID.TaskId.Project,
					Domain:  input.TaskExecutionID.TaskId.Domain,
					Name:    input.TaskExecutionID.TaskId.Name,
					Version: input.TaskExecutionID.TaskId.Version,
				},
				NodeExecutionId: &core.NodeExecutionIdentifier{
					NodeId: input.TaskExecutionID.NodeExecutionId.NodeId,
					ExecutionId: &core.WorkflowExecutionIdentifier{
						Project: input.TaskExecutionID.NodeExecutionId.ExecutionId.Project,
						Domain:  input.TaskExecutionID.NodeExecutionId.ExecutionId.Domain,
						Name:    input.TaskExecutionID.NodeExecutionId.ExecutionId.Name,
					},
				},
			})
	} else if tx.Error != nil {
		return models.TaskExecution{}, r.errorTransformer.ToFlyteAdminError(tx.Error)
	}
	return taskExecution, nil
}
func (r *TaskExecutionRepo) Update(ctx context.Context, execution models.TaskExecution) error {
	timer := r.metrics.UpdateDuration.Start()
	tx := r.db.Save(&execution)
	timer.Stop()
	if err := tx.Error; err != nil {
		return r.errorTransformer.ToFlyteAdminError(err)
	}
	return nil
}
func (r *TaskExecutionRepo) List(ctx context.Context, input interfaces.ListResourceInput) (interfaces.TaskExecutionCollectionOutput, error) {
	if err := ValidateListInput(input); err != nil {
		return interfaces.TaskExecutionCollectionOutput{}, err
	}
	var taskExecutions []models.TaskExecution
	tx := r.db.Limit(input.Limit).Offset(input.Offset).Preload(""ChildNodeExecution"")
	// And add three join conditions (joining multiple tables is fine even we only filter on a subset of table attributes).
	// We are joining on task -> taskExec -> NodeExec -> Exec.
	// NOTE: the order in which the joins are called below are important because postgres will only know about certain
	// tables as they are joined. So we should do it in the order specified above.
	tx = tx.Joins(leftJoinTaskToTaskExec)
	tx = tx.Joins(innerJoinNodeExecToTaskExec)
	tx = tx.Joins(innerJoinExecToNodeExec)
	// Apply filters
	tx, err := applyScopedFilters(tx, input.InlineFilters, input.MapFilters)
	if err != nil {
		return interfaces.TaskExecutionCollectionOutput{}, err
	}
	// Apply sort ordering.
	if input.SortParameter != nil {
		tx = tx.Order(input.SortParameter.GetGormOrderExpr())
	}
	timer := r.metrics.ListDuration.Start()
	tx = tx.Find(&taskExecutions)
	timer.Stop()
	if tx.Error != nil {
		return interfaces.TaskExecutionCollectionOutput{}, r.errorTransformer.ToFlyteAdminError(tx.Error)
	}
	return interfaces.TaskExecutionCollectionOutput{
		TaskExecutions: taskExecutions,
	}, nil
}
func (r *TaskExecutionRepo) Count(ctx context.Context, input interfaces.CountResourceInput) (int64, error) {
	var err error
	tx := r.db.Model(&models.TaskExecution{})
	// Add three join conditions (joining multiple tables is fine even we only filter on a subset of table attributes).
	// We are joining on task -> taskExec -> NodeExec -> Exec.
	// NOTE: the order in which the joins are called below are important because postgres will only know about certain
	// tables as they are joined. So we should do it in the order specified above.
	tx = tx.Joins(leftJoinTaskToTaskExec)
	tx = tx.Joins(innerJoinNodeExecToTaskExec)
	tx = tx.Joins(innerJoinExecToNodeExec)
	// Apply filters
	tx, err = applyScopedFilters(tx, input.InlineFilters, input.MapFilters)
	if err != nil {
		return 0, err
	}
	// Run the query
	timer := r.metrics.CountDuration.Start()
	var count int64
	tx = tx.Count(&count)
	timer.Stop()
	if tx.Error != nil {
		return 0, r.errorTransformer.ToFlyteAdminError(tx.Error)
	}
	return count, nil
}
// Returns an instance of TaskExecutionRepoInterface
func NewTaskExecutionRepo(
	db *gorm.DB, errorTransformer flyteAdminDbErrors.ErrorTransformer, scope promutils.Scope) interfaces.TaskExecutionRepoInterface {
	metrics := newMetrics(scope)
	return &TaskExecutionRepo{
		db:               db,
		errorTransformer: errorTransformer,
		metrics:          metrics,
	}
}
",CWE-89,171.0,1
"package gormimpl
import (
	""context""
	""errors""
	""github.com/flyteorg/flyteidl/gen/pb-go/flyteidl/core""
	""github.com/flyteorg/flytestdlib/promutils""
	flyteAdminDbErrors ""github.com/flyteorg/flyteadmin/pkg/repositories/errors""
	""github.com/flyteorg/flyteadmin/pkg/repositories/interfaces""
	""github.com/flyteorg/flyteadmin/pkg/repositories/models""
	""gorm.io/gorm""
)
// Implementation of TaskRepoInterface.
type TaskRepo struct {
	db               *gorm.DB
	errorTransformer flyteAdminDbErrors.ErrorTransformer
	metrics          gormMetrics
}
func (r *TaskRepo) Create(_ context.Context, input models.Task, descriptionEntity *models.DescriptionEntity) error {
	timer := r.metrics.CreateDuration.Start()
	err := r.db.Transaction(func(_ *gorm.DB) error {
		if descriptionEntity == nil {
			tx := r.db.Omit(""id"").Create(&input)
			if tx.Error != nil {
				return r.errorTransformer.ToFlyteAdminError(tx.Error)
			}
			return nil
		}
		tx := r.db.Omit(""id"").Create(descriptionEntity)
		if tx.Error != nil {
			return r.errorTransformer.ToFlyteAdminError(tx.Error)
		}
		tx = r.db.Omit(""id"").Create(&input)
		if tx.Error != nil {
			return r.errorTransformer.ToFlyteAdminError(tx.Error)
		}
		return nil
	})
	timer.Stop()
	return err
}
func (r *TaskRepo) Get(ctx context.Context, input interfaces.Identifier) (models.Task, error) {
	var task models.Task
	timer := r.metrics.GetDuration.Start()
	tx := r.db.Where(&models.Task{
		TaskKey: models.TaskKey{
			Project: input.Project,
			Domain:  input.Domain,
			Name:    input.Name,
			Version: input.Version,
		},
	}).Take(&task)
	timer.Stop()
	if errors.Is(tx.Error, gorm.ErrRecordNotFound) {
		return models.Task{}, flyteAdminDbErrors.GetMissingEntityError(core.ResourceType_TASK.String(), &core.Identifier{
			Project: input.Project,
			Domain:  input.Domain,
			Name:    input.Name,
			Version: input.Version,
		})
	}
	if tx.Error != nil {
		return models.Task{}, r.errorTransformer.ToFlyteAdminError(tx.Error)
	}
	return task, nil
}
func (r *TaskRepo) List(
	ctx context.Context, input interfaces.ListResourceInput) (interfaces.TaskCollectionOutput, error) {
	// First validate input.
	if err := ValidateListInput(input); err != nil {
		return interfaces.TaskCollectionOutput{}, err
	}
	var tasks []models.Task
	tx := r.db.Limit(input.Limit).Offset(input.Offset)
	// Apply filters
	tx, err := applyFilters(tx, input.InlineFilters, input.MapFilters)
	if err != nil {
		return interfaces.TaskCollectionOutput{}, err
	}
	// Apply sort ordering.
	if input.SortParameter != nil {
		tx = tx.Order(input.SortParameter.GetGormOrderExpr())
	}
	timer := r.metrics.ListDuration.Start()
	tx.Find(&tasks)
	timer.Stop()
	if tx.Error != nil {
		return interfaces.TaskCollectionOutput{}, r.errorTransformer.ToFlyteAdminError(tx.Error)
	}
	return interfaces.TaskCollectionOutput{
		Tasks: tasks,
	}, nil
}
func (r *TaskRepo) ListTaskIdentifiers(ctx context.Context, input interfaces.ListResourceInput) (
	interfaces.TaskCollectionOutput, error) {
	// Validate input.
	if err := ValidateListInput(input); err != nil {
		return interfaces.TaskCollectionOutput{}, err
	}
	tx := r.db.Model(models.Task{}).Limit(input.Limit).Offset(input.Offset)
	// Apply filters
	tx, err := applyFilters(tx, input.InlineFilters, input.MapFilters)
	if err != nil {
		return interfaces.TaskCollectionOutput{}, err
	}
	for _, mapFilter := range input.MapFilters {
		tx = tx.Where(mapFilter.GetFilter())
	}
	// Apply sort ordering.
	if input.SortParameter != nil {
		tx = tx.Order(input.SortParameter.GetGormOrderExpr())
	}
	// Scan the results into a list of tasks
	var tasks []models.Task
	timer := r.metrics.ListIdentifiersDuration.Start()
	tx.Select([]string{Project, Domain, Name}).Group(identifierGroupBy).Scan(&tasks)
	timer.Stop()
	if tx.Error != nil {
		return interfaces.TaskCollectionOutput{}, r.errorTransformer.ToFlyteAdminError(tx.Error)
	}
	return interfaces.TaskCollectionOutput{
		Tasks: tasks,
	}, nil
}
// Returns an instance of TaskRepoInterface
func NewTaskRepo(
	db *gorm.DB, errorTransformer flyteAdminDbErrors.ErrorTransformer, scope promutils.Scope) interfaces.TaskRepoInterface {
	metrics := newMetrics(scope)
	return &TaskRepo{
		db:               db,
		errorTransformer: errorTransformer,
		metrics:          metrics,
	}
}
",CWE-89,153.0,1
"package gormimpl
import (
	""context""
	""errors""
	flyteAdminDbErrors ""github.com/flyteorg/flyteadmin/pkg/repositories/errors""
	""github.com/flyteorg/flyteadmin/pkg/repositories/interfaces""
	""github.com/flyteorg/flyteadmin/pkg/repositories/models""
	""github.com/flyteorg/flyteidl/gen/pb-go/flyteidl/core""
	""github.com/flyteorg/flytestdlib/promutils""
	""gorm.io/gorm""
)
// Implementation of WorkflowRepoInterface.
type WorkflowRepo struct {
	db               *gorm.DB
	errorTransformer flyteAdminDbErrors.ErrorTransformer
	metrics          gormMetrics
}
func (r *WorkflowRepo) Create(_ context.Context, input models.Workflow, descriptionEntity *models.DescriptionEntity) error {
	timer := r.metrics.CreateDuration.Start()
	err := r.db.Transaction(func(_ *gorm.DB) error {
		if descriptionEntity != nil {
			tx := r.db.Omit(""id"").Create(descriptionEntity)
			if tx.Error != nil {
				return r.errorTransformer.ToFlyteAdminError(tx.Error)
			}
		}
		tx := r.db.Omit(""id"").Create(&input)
		if tx.Error != nil {
			return r.errorTransformer.ToFlyteAdminError(tx.Error)
		}
		return nil
	})
	timer.Stop()
	return err
}
func (r *WorkflowRepo) Get(ctx context.Context, input interfaces.Identifier) (models.Workflow, error) {
	var workflow models.Workflow
	timer := r.metrics.GetDuration.Start()
	tx := r.db.Where(&models.Workflow{
		WorkflowKey: models.WorkflowKey{
			Project: input.Project,
			Domain:  input.Domain,
			Name:    input.Name,
			Version: input.Version,
		},
	}).Take(&workflow)
	timer.Stop()
	if tx.Error != nil && errors.Is(tx.Error, gorm.ErrRecordNotFound) {
		return models.Workflow{}, flyteAdminDbErrors.GetMissingEntityError(core.ResourceType_WORKFLOW.String(), &core.Identifier{
			Project: input.Project,
			Domain:  input.Domain,
			Name:    input.Name,
			Version: input.Version,
		})
	} else if tx.Error != nil {
		return models.Workflow{}, r.errorTransformer.ToFlyteAdminError(tx.Error)
	}
	return workflow, nil
}
func (r *WorkflowRepo) List(
	ctx context.Context, input interfaces.ListResourceInput) (interfaces.WorkflowCollectionOutput, error) {
	// First validate input.
	if err := ValidateListInput(input); err != nil {
		return interfaces.WorkflowCollectionOutput{}, err
	}
	var workflows []models.Workflow
	tx := r.db.Limit(input.Limit).Offset(input.Offset)
	// Apply filters
	tx, err := applyFilters(tx, input.InlineFilters, input.MapFilters)
	if err != nil {
		return interfaces.WorkflowCollectionOutput{}, err
	}
	// Apply sort ordering.
	if input.SortParameter != nil {
		tx = tx.Order(input.SortParameter.GetGormOrderExpr())
	}
	timer := r.metrics.ListDuration.Start()
	tx.Find(&workflows)
	timer.Stop()
	if tx.Error != nil {
		return interfaces.WorkflowCollectionOutput{}, r.errorTransformer.ToFlyteAdminError(tx.Error)
	}
	return interfaces.WorkflowCollectionOutput{
		Workflows: workflows,
	}, nil
}
func (r *WorkflowRepo) ListIdentifiers(ctx context.Context, input interfaces.ListResourceInput) (
	interfaces.WorkflowCollectionOutput, error) {
	// Validate input.
	if err := ValidateListInput(input); err != nil {
		return interfaces.WorkflowCollectionOutput{}, err
	}
	tx := r.db.Model(models.Workflow{}).Limit(input.Limit).Offset(input.Offset)
	// Apply filters
	tx, err := applyFilters(tx, input.InlineFilters, input.MapFilters)
	if err != nil {
		return interfaces.WorkflowCollectionOutput{}, err
	}
	// Apply sort ordering.
	if input.SortParameter != nil {
		tx = tx.Order(input.SortParameter.GetGormOrderExpr())
	}
	// Scan the results into a list of workflows
	var workflows []models.Workflow
	timer := r.metrics.ListIdentifiersDuration.Start()
	tx.Select([]string{Project, Domain, Name}).Group(identifierGroupBy).Scan(&workflows)
	timer.Stop()
	if tx.Error != nil {
		return interfaces.WorkflowCollectionOutput{}, r.errorTransformer.ToFlyteAdminError(tx.Error)
	}
	return interfaces.WorkflowCollectionOutput{
		Workflows: workflows,
	}, nil
}
// Returns an instance of WorkflowRepoInterface
func NewWorkflowRepo(
	db *gorm.DB, errorTransformer flyteAdminDbErrors.ErrorTransformer, scope promutils.Scope) interfaces.WorkflowRepoInterface {
	metrics := newMetrics(scope)
	return &WorkflowRepo{
		db:               db,
		errorTransformer: errorTransformer,
		metrics:          metrics,
	}
}
",CWE-89,142.0,1
"package models
import ""time""
// This is the base model definition every flyteadmin model embeds.
// This is nearly identical to http://doc.gorm.io/models.html
// own primary keys rather than use the ID as the primary key
type BaseModel struct {
	ID        uint `gorm:""index;autoIncrement""`
	CreatedAt time.Time
	UpdatedAt time.Time
	DeletedAt *time.Time `gorm:""index""`
}
",CWE-89,14.0,1
"package models
import ""github.com/flyteorg/flyteidl/gen/pb-go/flyteidl/core""
// DescriptionEntityKey DescriptionEntity primary key
type DescriptionEntityKey struct {
	ResourceType core.ResourceType `gorm:""primary_key;index:description_entity_project_domain_name_version_idx"" valid:""length(0|255)""`
	Project      string            `gorm:""primary_key;index:description_entity_project_domain_name_version_idx"" valid:""length(0|255)""`
	Domain       string            `gorm:""primary_key;index:description_entity_project_domain_name_version_idx"" valid:""length(0|255)""`
	Name         string            `gorm:""primary_key;index:description_entity_project_domain_name_version_idx"" valid:""length(0|255)""`
	Version      string            `gorm:""primary_key;index:description_entity_project_domain_name_version_idx"" valid:""length(0|255)""`
}
// SourceCode Database model to encapsulate a SourceCode.
type SourceCode struct {
	Link string `valid:""length(0|255)""`
}
// DescriptionEntity Database model to encapsulate a DescriptionEntity.
type DescriptionEntity struct {
	DescriptionEntityKey
	BaseModel
	ShortDescription string
	LongDescription []byte
	SourceCode
}
",CWE-89,31.0,1
"package models
import (
	""time""
	""gorm.io/gorm/clause""
	""gorm.io/gorm""
	""github.com/flyteorg/flytestdlib/storage""
)
// IMPORTANT: If you update the model below, be sure to double check model definitions in
// pkg/repositories/config/migration_models.go
// Execution primary key
type ExecutionKey struct {
	Project string `gorm:""primary_key;column:execution_project"" valid:""length(0|255)""`
	Domain  string `gorm:""primary_key;column:execution_domain"" valid:""length(0|255)""`
	Name    string `gorm:""primary_key;column:execution_name"" valid:""length(0|255)""`
}
// Database model to encapsulate a (workflow) execution.
type Execution struct {
	BaseModel
	ExecutionKey
	LaunchPlanID uint   `gorm:""index""`
	WorkflowID   uint   `gorm:""index""`
	TaskID       uint   `gorm:""index""`
	Phase        string `valid:""length(0|255)""`
	Closure      []byte
	Spec         []byte `gorm:""not null""`
	StartedAt    *time.Time
	// Corresponds to the CreatedAt field in the Execution closure.
	// Prefixed with Execution to avoid clashes with gorm.Model CreatedAt
	ExecutionCreatedAt *time.Time `gorm:""index:idx_executions_created_at""`
	// Corresponds to the UpdatedAt field in the Execution closure
	// Prefixed with Execution to avoid clashes with gorm.Model UpdatedAt
	ExecutionUpdatedAt *time.Time
	Duration           time.Duration
	// In the case of an aborted execution this string may be non-empty.
	// It should be ignored for any other value of phase other than aborted.
	AbortCause string `valid:""length(0|255)""`
	// Corresponds to the execution mode used to trigger this execution
	Mode int32
	// The ""parent"" execution (if there is one) that is related to this execution.
	SourceExecutionID uint
	// The parent node execution if this was launched by a node
	ParentNodeExecutionID uint
	// Cluster where execution was triggered
	Cluster string `valid:""length(0|255)""`
	// Offloaded location of inputs LiteralMap. These are the inputs evaluated and contain applied defaults.
	InputsURI storage.DataReference
	// User specified inputs. This map might be incomplete and not include defaults applied
	UserInputsURI storage.DataReference
	// Execution Error Kind. nullable
	ErrorKind *string `gorm:""index""`
	// Execution Error Code nullable
	ErrorCode *string `valid:""length(0|255)""`
	// The user responsible for launching this execution.
	// This is also stored in the spec but promoted as a column for filtering.
	User string `gorm:""index"" valid:""length(0|255)""`
	// GORM doesn't save the zero value for ints, so we use a pointer for the State field
	State *int32 `gorm:""index;default:0""`
	// The resource type of the entity used to launch the execution, one of 'launch_plan' or 'task'
	LaunchEntity string
	// Tags associated with the execution
	Tags []AdminTag `gorm:""many2many:execution_admin_tags;""`
}
type AdminTag struct {
	gorm.Model
	Name string `gorm:""index:,unique;size:255""`
}
func (b *AdminTag) BeforeCreate(tx *gorm.DB) (err error) {
	tx.Statement.AddClause(clause.OnConflict{
		Columns:   []clause.Column{{Name: ""name""}},            // key column
		DoUpdates: clause.AssignmentColumns([]string{""name""}), // column needed to be updated
	})
	return nil
}
",CWE-89,83.0,1
"package models
// Launch plan primary key
type LaunchPlanKey struct {
	Project string `gorm:""primary_key;index:lp_project_domain_name_idx,lp_project_domain_idx"" valid:""length(0|255)""`
	Domain  string `gorm:""primary_key;index:lp_project_domain_name_idx,lp_project_domain_idx"" valid:""length(0|255)""`
	Name    string `gorm:""primary_key;index:lp_project_domain_name_idx"" valid:""length(0|255)""`
	Version string `gorm:""primary_key"" valid:""length(0|255)""`
}
type LaunchPlanScheduleType string
const (
	// LaunchPlanScheduleTypeNONE is the const representing the launch plan does not have a schedule
	LaunchPlanScheduleTypeNONE LaunchPlanScheduleType = ""NONE""
	// LaunchPlanScheduleTypeCRON is the const representing the launch plan has a CRON type of schedule
	LaunchPlanScheduleTypeCRON LaunchPlanScheduleType = ""CRON""
	// LaunchPlanScheduleTypeRATE is the launch plan has a RATE type of schedule
	LaunchPlanScheduleTypeRATE LaunchPlanScheduleType = ""RATE""
)
// Database model to encapsulate a launch plan.
type LaunchPlan struct {
	BaseModel
	LaunchPlanKey
	Spec       []byte `gorm:""not null""`
	WorkflowID uint   `gorm:""index""`
	Closure    []byte `gorm:""not null""`
	// GORM doesn't save the zero value for ints, so we use a pointer for the State field
	State *int32 `gorm:""default:0""`
	// Hash of the launch plan
	Digest       []byte
	ScheduleType LaunchPlanScheduleType
}
",CWE-89,35.0,1
"package models
import (
	""github.com/flyteorg/flyteidl/gen/pb-go/flyteidl/core""
)
// NamedEntityMetadata primary key
type NamedEntityMetadataKey struct {
	ResourceType core.ResourceType `gorm:""primary_key;index:named_entity_metadata_type_project_domain_name_idx"" valid:""length(0|255)""`
	Project      string            `gorm:""primary_key;index:named_entity_metadata_type_project_domain_name_idx"" valid:""length(0|255)""`
	Domain       string            `gorm:""primary_key;index:named_entity_metadata_type_project_domain_name_idx"" valid:""length(0|255)""`
	Name         string            `gorm:""primary_key;index:named_entity_metadata_type_project_domain_name_idx"" valid:""length(0|255)""`
}
// Fields to be composed into any named entity
type NamedEntityMetadataFields struct {
	Description string `gorm:""type:varchar(300)""`
	// GORM doesn't save the zero value for ints, so we use a pointer for the State field
	State *int32 `gorm:""default:0""`
}
// Database model to encapsulate metadata associated with a NamedEntity
type NamedEntityMetadata struct {
	BaseModel
	NamedEntityMetadataKey
	NamedEntityMetadataFields
}
// NamedEntity key. This is used as a lookup for NamedEntityMetadata, so the
// fields here should match the ones in NamedEntityMetadataKey.
type NamedEntityKey struct {
	ResourceType core.ResourceType
	Project      string `valid:""length(0|255)""`
	Domain       string `valid:""length(0|255)""`
	Name         string `valid:""length(0|255)""`
}
// Composes an identifier (NamedEntity) and its associated metadata fields
type NamedEntity struct {
	NamedEntityKey
	NamedEntityMetadataFields
}
",CWE-89,43.0,1
"package models
import (
	""time""
)
// IMPORTANT: If you update the model below, be sure to double check model definitions in
// pkg/repositories/config/migration_models.go
type NodeExecutionKey struct {
	ExecutionKey
	NodeID string `gorm:""primary_key;index"" valid:""length(0|255)""`
}
// By convention, gorm foreign key references are of the form {ModelName}ID
type NodeExecution struct {
	BaseModel
	NodeExecutionKey
	// Also stored in the closure, but defined as a separate column because it's useful for filtering and sorting.
	Phase     string
	InputURI  string
	Closure   []byte
	StartedAt *time.Time
	// Corresponds to the CreatedAt field in the NodeExecution closure
	// Prefixed with NodeExecution to avoid clashes with gorm.Model CreatedAt
	NodeExecutionCreatedAt *time.Time
	// Corresponds to the UpdatedAt field in the NodeExecution closure
	// Prefixed with NodeExecution to avoid clashes with gorm.Model UpdatedAt
	NodeExecutionUpdatedAt *time.Time
	Duration               time.Duration
	// Metadata about the node execution.
	NodeExecutionMetadata []byte
	// Parent that spawned this node execution - value is empty for executions at level 0
	ParentID *uint `sql:""default:null"" gorm:""index""`
	// List of child node executions - for cases like Dynamic task, sub workflow, etc
	ChildNodeExecutions []NodeExecution `gorm:""foreignKey:ParentID;references:ID""`
	// The task execution (if any) which launched this node execution.
	// TO BE DEPRECATED - as we have now introduced ParentID
	ParentTaskExecutionID *uint `sql:""default:null"" gorm:""index""`
	// The workflow execution (if any) which this node execution launched
	// NOTE: LaunchedExecution[foreignkey:ParentNodeExecutionID] refers to Workflow execution launched and is different from ParentID
	LaunchedExecution Execution `gorm:""foreignKey:ParentNodeExecutionID;references:ID""`
	// Execution Error Kind. nullable, can be one of core.ExecutionError_ErrorKind
	ErrorKind *string `gorm:""index""`
	// Execution Error Code nullable. string value, but finite set determined by the execution engine and plugins
	ErrorCode *string
	// If the node is of Type Task, this should always exist for a successful execution, indicating the cache status for the execution
	CacheStatus *string
	// In the case of dynamic workflow nodes, the remote closure is uploaded to the path specified here.
	DynamicWorkflowRemoteClosureReference string
	// Metadata that is only relevant to the flyteadmin service that is used to parse the model and track additional attributes.
	InternalData []byte
}
",CWE-89,54.0,1
"package models
import (
	""time""
)
type NodeExecutionEvent struct {
	BaseModel
	NodeExecutionKey
	RequestID  string
	OccurredAt time.Time
	Phase      string `gorm:""primary_key""`
}
",CWE-89,14.0,1
"package models
type Project struct {
	BaseModel
	Identifier  string `gorm:""primary_key""`
	Name        string `valid:""length(0|255)""` // Human-readable name, not a unique identifier.
	Description string `gorm:""type:varchar(300)""`
	Labels      []byte
	// GORM doesn't save the zero value for ints, so we use a pointer for the State field
	State *int32 `gorm:""default:0;index""`
}
",CWE-89,12.0,1
"package models
// Signal primary key
type SignalKey struct {
	ExecutionKey
	SignalID string `gorm:""primary_key;index"" valid:""length(0|255)""`
}
// Database model to encapsulate a signal.
type Signal struct {
	BaseModel
	SignalKey
	Type  []byte `gorm:""not null""`
	Value []byte
}
",CWE-89,16.0,1
"package models
// IMPORTANT: If you update the model below, be sure to double check model definitions in
// pkg/repositories/config/migration_models.go
// Task primary key
type TaskKey struct {
	Project string `gorm:""primary_key;index:task_project_domain_name_idx;index:task_project_domain_idx"" valid:""length(0|255)""`
	Domain  string `gorm:""primary_key;index:task_project_domain_name_idx;index:task_project_domain_idx"" valid:""length(0|255)""`
	Name    string `gorm:""primary_key;index:task_project_domain_name_idx"" valid:""length(0|255)""`
	Version string `gorm:""primary_key"" valid:""length(0|255)""`
}
// Database model to encapsulate a task.
type Task struct {
	BaseModel
	TaskKey
	Closure []byte `gorm:""not null""`
	// Hash of the compiled task closure
	Digest []byte
	// Task type (also stored in the closure put promoted as a column for filtering).
	Type string `valid:""length(0|255)""`
	// ShortDescription for the task.
	ShortDescription string
}
",CWE-89,26.0,1
"package models
import (
	""time""
)
// IMPORTANT: If you update the model below, be sure to double check model definitions in
// pkg/repositories/config/migration_models.go
// Task execution primary key
type TaskExecutionKey struct {
	TaskKey
	NodeExecutionKey
	// *IMPORTANT* This is a pointer to an int in order to allow setting an empty (""0"") value according to gorm convention.
	// Because RetryAttempt is part of the TaskExecution primary key is should *never* be null.
	RetryAttempt *uint32 `gorm:""primary_key""`
}
// By convention, gorm foreign key references are of the form {ModelName}ID
type TaskExecution struct {
	BaseModel
	TaskExecutionKey
	Phase        string `valid:""length(0|255)""`
	PhaseVersion uint32
	InputURI     string `valid:""length(0|255)""`
	Closure      []byte
	StartedAt    *time.Time
	// Corresponds to the CreatedAt field in the TaskExecution closure
	// This field is prefixed with TaskExecution because it signifies when
	// the execution was createdAt, not to be confused with gorm.Model.CreatedAt
	TaskExecutionCreatedAt *time.Time
	// Corresponds to the UpdatedAt field in the TaskExecution closure
	// This field is prefixed with TaskExecution because it signifies when
	// the execution was UpdatedAt, not to be confused with gorm.Model.UpdatedAt
	TaskExecutionUpdatedAt *time.Time
	Duration               time.Duration
	// The child node executions (if any) launched by this task execution.
	ChildNodeExecution []NodeExecution `gorm:""foreignkey:ParentTaskExecutionID;references:ID""`
}
",CWE-89,40.0,1
"package models
// Workflow primary key
type WorkflowKey struct {
	Project string `gorm:""primary_key;index:workflow_project_domain_name_idx;index:workflow_project_domain_idx""  valid:""length(0|255)""`
	Domain  string `gorm:""primary_key;index:workflow_project_domain_name_idx;index:workflow_project_domain_idx""  valid:""length(0|255)""`
	Name    string `gorm:""primary_key;index:workflow_project_domain_name_idx""  valid:""length(0|255)""`
	Version string `gorm:""primary_key""`
}
// Database model to encapsulate a workflow.
type Workflow struct {
	BaseModel
	WorkflowKey
	TypedInterface          []byte
	RemoteClosureIdentifier string `gorm:""not null"" valid:""length(0|255)""`
	// Hash of the compiled workflow closure
	Digest []byte
	// ShortDescription for the workflow.
	ShortDescription string
}
",CWE-89,22.0,1
"{
	""name"": ""typo3/html-sanitizer"",
	""description"": ""HTML sanitizer aiming to provide XSS-safe markup based on explicitly allowed tags, attributes and values."",
	""type"": ""library"",
	""license"": ""MIT"",
	""authors"": [
		{
			""name"": ""Oliver Hader"",
			""email"": ""oliver@typo3.org""
		}
	],
	""extra"": {
		""branch-alias"": {
			""dev-main"": ""2.x-dev""
		}
	},
	""require"": {
		""ext-dom"": ""*"",
		""masterminds/html5"": ""^2.7"",
		""php"": ""^7.2 || ^8.0"",
		""psr/log"": ""^1.0 || ^2.0 || ^3.0""
	},
	""require-dev"": {
		""phpunit/phpunit"": ""^8.5""
	},
	""scripts"": {
		""test"": ""phpunit""
	},
	""autoload"": {
		""psr-4"": {
			""TYPO3\\HtmlSanitizer\\"": ""src/""
		}
	},
	""autoload-dev"": {
		""psr-4"": {
			""TYPO3\\HtmlSanitizer\\Tests\\"": ""tests/""
		}
	}
}
",CWE-79,40.0,1
"// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.
package reg
import (
	""context""
	""github.com/cosi-project/runtime/pkg/resource""
	""github.com/cosi-project/runtime/pkg/safe""
	""github.com/cosi-project/runtime/pkg/state""
	""github.com/siderolabs/crypto/x509""
	""google.golang.org/grpc""
	securityapi ""github.com/talos-systems/talos/pkg/machinery/api/security""
	""github.com/talos-systems/talos/pkg/machinery/resources/secrets""
)
// Registrator is the concrete type that implements the factory.Registrator and
// securityapi.SecurityServiceServer interfaces.
type Registrator struct {
	securityapi.UnimplementedSecurityServiceServer
	Resources state.State
}
// Register implements the factory.Registrator interface.
//
//nolint:interfacer
func (r *Registrator) Register(s *grpc.Server) {
	securityapi.RegisterSecurityServiceServer(s, r)
}
// Certificate implements the securityapi.SecurityServer interface.
func (r *Registrator) Certificate(ctx context.Context, in *securityapi.CertificateRequest) (resp *securityapi.CertificateResponse, err error) {
	osRoot, err := safe.StateGet[*secrets.OSRoot](ctx, r.Resources, resource.NewMetadata(secrets.NamespaceName, secrets.OSRootType, secrets.OSRootID, resource.VersionUndefined))
	if err != nil {
		return nil, err
	}
	// TODO: Verify that the request is coming from the IP addresss declared in
	// the CSR.
	signed, err := x509.NewCertificateFromCSRBytes(osRoot.TypedSpec().CA.Crt, osRoot.TypedSpec().CA.Key, in.Csr)
	if err != nil {
		return
	}
	resp = &securityapi.CertificateResponse{
		Ca:  osRoot.TypedSpec().CA.Crt,
		Crt: signed.X509CertificatePEM,
	}
	return resp, nil
}
",CWE-863,56.0,1
"// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.
package reg_test
import ""testing""
func TestEmpty(t *testing.T) {
	// added for accurate coverage estimation
	//
	// please remove it once any unit-test is added
	// for this package
}
",CWE-863,15.0,1
"package webfinger
import (
	""encoding/json""
	""fmt""
	""net/http""
	""net/url""
	""strings""
)
// GetWebfingerLinks will return webfinger data for an account.
func GetWebfingerLinks(account string) ([]map[string]interface{}, error) {
	type webfingerResponse struct {
		Links []map[string]interface{} `json:""links""`
	}
	account = strings.TrimLeft(account, ""@"") // remove any leading @
	accountComponents := strings.Split(account, ""@"")
	fediverseServer := accountComponents[1]
	// HTTPS is required.
	requestURL, err := url.Parse(""https://"" + fediverseServer)
	if err != nil {
		return nil, fmt.Errorf(""unable to parse fediverse server host %s"", fediverseServer)
	}
	requestURL.Path = ""/.well-known/webfinger""
	query := requestURL.Query()
	query.Add(""resource"", fmt.Sprintf(""acct:%s"", account))
	requestURL.RawQuery = query.Encode()
	response, err := http.DefaultClient.Get(requestURL.String())
	if err != nil {
		return nil, err
	}
	defer response.Body.Close()
	var links webfingerResponse
	decoder := json.NewDecoder(response.Body)
	if err := decoder.Decode(&links); err != nil {
		return nil, err
	}
	return links.Links, nil
}
",CWE-918,47.0,1
"package indieauth
import (
	""encoding/json""
	""fmt""
	""io""
	""net/http""
	""net/url""
	""strconv""
	""strings""
	""sync""
	""time""
	""github.com/owncast/owncast/core/data""
	""github.com/pkg/errors""
	log ""github.com/sirupsen/logrus""
)
var (
	pendingAuthRequests = make(map[string]*Request)
	lock                = sync.Mutex{}
)
const registrationTimeout = time.Minute * 10
func init() {
	go setupExpiredRequestPruner()
}
// Clear out any pending requests that have been pending for greater than
// the specified timeout value.
func setupExpiredRequestPruner() {
	pruneExpiredRequestsTimer := time.NewTicker(registrationTimeout)
	for range pruneExpiredRequestsTimer.C {
		lock.Lock()
		log.Debugln(""Pruning expired IndieAuth requests."")
		for k, v := range pendingAuthRequests {
			if time.Since(v.Timestamp) > registrationTimeout {
				delete(pendingAuthRequests, k)
			}
		}
		lock.Unlock()
	}
}
// StartAuthFlow will begin the IndieAuth flow by generating an auth request.
func StartAuthFlow(authHost, userID, accessToken, displayName string) (*url.URL, error) {
	if len(pendingAuthRequests) >= maxPendingRequests {
		return nil, errors.New(""Please try again later. Too many pending requests."")
	}
	serverURL := data.GetServerURL()
	if serverURL == """" {
		return nil, errors.New(""Owncast server URL must be set when using auth"")
	}
	r, err := createAuthRequest(authHost, userID, displayName, accessToken, serverURL)
	if err != nil {
		return nil, errors.Wrap(err, ""unable to generate IndieAuth request"")
	}
	pendingAuthRequests[r.State] = r
	return r.Redirect, nil
}
// HandleCallbackCode will handle the callback from the IndieAuth server
// to continue the next step of the auth flow.
func HandleCallbackCode(code, state string) (*Request, *Response, error) {
	request, exists := pendingAuthRequests[state]
	if !exists {
		return nil, nil, errors.New(""no auth requests pending"")
	}
	data := url.Values{}
	data.Set(""grant_type"", ""authorization_code"")
	data.Set(""code"", code)
	data.Set(""client_id"", request.ClientID)
	data.Set(""redirect_uri"", request.Callback.String())
	data.Set(""code_verifier"", request.CodeVerifier)
	client := &http.Client{}
	r, err := http.NewRequest(""POST"", request.Endpoint.String(), strings.NewReader(data.Encode())) // URL-encoded payload
	if err != nil {
		return nil, nil, err
	}
	r.Header.Add(""Content-Type"", ""application/x-www-form-urlencoded"")
	r.Header.Add(""Content-Length"", strconv.Itoa(len(data.Encode())))
	res, err := client.Do(r)
	if err != nil {
		return nil, nil, err
	}
	defer res.Body.Close()
	body, err := io.ReadAll(res.Body)
	if err != nil {
		return nil, nil, err
	}
	var response Response
	if err := json.Unmarshal(body, &response); err != nil {
		return nil, nil, errors.Wrap(err, ""unable to parse IndieAuth response: ""+string(body))
	}
	if response.Error != """" || response.ErrorDescription != """" {
		errorText := makeIndieAuthClientErrorText(response.Error)
		log.Debugln(""IndieAuth error:"", response.Error, response.ErrorDescription)
		return nil, nil, fmt.Errorf(""IndieAuth error: %s - %s"", errorText, response.ErrorDescription)
	}
	// In case this IndieAuth server does not use OAuth error keys or has internal
	// issues resulting in unstructured errors.
	if res.StatusCode < 200 || res.StatusCode > 299 {
		log.Debugln(""IndieAuth error. status code:"", res.StatusCode, ""body:"", string(body))
		return nil, nil, errors.New(""there was an error authenticating against IndieAuth server"")
	}
	// Trim any trailing slash so we can accurately compare the two ""me"" values
	meResponseVerifier := strings.TrimRight(response.Me, ""/"")
	meRequestVerifier := strings.TrimRight(request.Me.String(), ""/"")
	// What we sent and what we got back must match
	if meRequestVerifier != meResponseVerifier {
		return nil, nil, errors.New(""indieauth response does not match the initial anticipated auth destination"")
	}
	return request, &response, nil
}
// Error value should be from this list:
// https://datatracker.ietf.org/doc/html/rfc6749
func makeIndieAuthClientErrorText(err string) string {
	switch err {
	case ""invalid_request"", ""invalid_client"":
		return ""The authentication request was invalid. Please report this to the Owncast project.""
	case ""invalid_grant"", ""unauthorized_client"":
		return ""This authorization request is unauthorized.""
	case ""unsupported_grant_type"":
		return ""The authorization grant type is not supported by the authorization server.""
	default:
		return err
	}
}
",CWE-918,145.0,1
"package gocvss20_test
import (
	""testing""
	gocvss20 ""github.com/pandatix/go-cvss/20""
)
func FuzzParseVector(f *testing.F) {
	for _, tt := range testsParseVector {
		f.Add(tt.Vector)
	}
	f.Fuzz(func(t *testing.T, vector string) {
		cvss20, err := gocvss20.ParseVector(vector)
		if err != nil {
			if cvss20 != nil {
				t.Fatal(""not supposed to get a CVSS20 when an error is returned"")
			}
		} else {
			// This check works because CVSS v2.0 has a predetermined order.
			cvss20vector := cvss20.Vector()
			if vector != cvss20vector {
				t.Fatalf(""vector differs at export: input is %s but output is %s"", vector, cvss20vector)
			}
		}
	})
}
",CWE-125,30.0,1
"package gocvss20
import (
	""errors""
	""fmt""
)
var (
	ErrTooShortVector     = errors.New(""too short vector"")
	ErrInvalidMetricOrder = errors.New(""invalid metric order"")
	ErrInvalidMetricValue = errors.New(""invalid metric value"")
)
// ErrBaseScore is an error returned by ParseVector when the
// given vector have missing base score attributes.
type ErrBaseScore struct {
	Missings []string
}
func (err ErrBaseScore) Error() string {
	return fmt.Sprintf(""base score is missing metrics %v"", err.Missings)
}
var _ error = (*ErrBaseScore)(nil)
// ErrDefinedN is an error return by ParseVector when the
// given vector has metrics abbreviations defined multiple times.
type ErrDefinedN struct {
	Abv []string
}
func (err ErrDefinedN) Error() string {
	return fmt.Sprintf(""given CVSS v3.1 vector has %v metric abbreviations defined multiple times"", err.Abv)
}
var _ error = (*ErrDefinedN)(nil)
// ErrInvalidMetric is an error returned when a given
// metric does not exist.
type ErrInvalidMetric struct {
	Abv string
}
func (err ErrInvalidMetric) Error() string {
	return fmt.Sprintf(""invalid metric abbreviation : %s"", err.Abv)
}
var _ error = (*ErrInvalidMetric)(nil)
",CWE-125,49.0,1
"package ghinstallation
import (
	""bytes""
	""context""
	""encoding/json""
	""fmt""
	""io""
	""io/ioutil""
	""net/http""
	""sync""
	""time""
	""github.com/google/go-github/v30/github""
)
const (
	// acceptHeader is the GitHub Apps Preview Accept header.
	acceptHeader = ""application/vnd.github.machine-man-preview+json""
	apiBaseURL   = ""https://api.github.com""
)
// Transport provides a http.RoundTripper by wrapping an existing
// http.RoundTripper and provides GitHub Apps authentication as an
// installation.
//
// Client can also be overwritten, and is useful to change to one which
// provides retry logic if you do experience retryable errors.
//
// See https://developer.github.com/apps/building-integrations/setting-up-and-registering-github-apps/about-authentication-options-for-github-apps/
type Transport struct {
	BaseURL                  string                           // BaseURL is the scheme and host for GitHub API, defaults to https://api.github.com
	Client                   Client                           // Client to use to refresh tokens, defaults to http.Client with provided transport
	tr                       http.RoundTripper                // tr is the underlying roundtripper being wrapped
	appID                    int64                            // appID is the GitHub App's ID
	installationID           int64                            // installationID is the GitHub App Installation ID
	InstallationTokenOptions *github.InstallationTokenOptions // parameters restrict a token's access
	appsTransport            *AppsTransport
	mu    *sync.Mutex  // mu protects token
	token *accessToken // token is the installation's access token
}
// accessToken is an installation access token response from GitHub
type accessToken struct {
	Token        string                         `json:""token""`
	ExpiresAt    time.Time                      `json:""expires_at""`
	Permissions  github.InstallationPermissions `json:""permissions,omitempty""`
	Repositories []github.Repository            `json:""repositories,omitempty""`
}
var _ http.RoundTripper = &Transport{}
// NewKeyFromFile returns a Transport using a private key from file.
func NewKeyFromFile(tr http.RoundTripper, appID, installationID int64, privateKeyFile string) (*Transport, error) {
	privateKey, err := ioutil.ReadFile(privateKeyFile)
	if err != nil {
		return nil, fmt.Errorf(""could not read private key: %s"", err)
	}
	return New(tr, appID, installationID, privateKey)
}
// Client is a HTTP client which sends a http.Request and returns a http.Response
// or an error.
type Client interface {
	Do(*http.Request) (*http.Response, error)
}
// New returns an Transport using private key. The key is parsed
// and if any errors occur the error is non-nil.
//
// The provided tr http.RoundTripper should be shared between multiple
// installations to ensure reuse of underlying TCP connections.
//
// The returned Transport's RoundTrip method is safe to be used concurrently.
func New(tr http.RoundTripper, appID, installationID int64, privateKey []byte) (*Transport, error) {
	atr, err := NewAppsTransport(tr, appID, privateKey)
	if err != nil {
		return nil, err
	}
	return NewFromAppsTransport(atr, installationID), nil
}
// NewFromAppsTransport returns a Transport using an existing *AppsTransport.
func NewFromAppsTransport(atr *AppsTransport, installationID int64) *Transport {
	return &Transport{
		BaseURL:        atr.BaseURL,
		Client:         &http.Client{Transport: atr.tr},
		tr:             atr.tr,
		appID:          atr.appID,
		installationID: installationID,
		appsTransport:  atr,
		mu:             &sync.Mutex{},
	}
}
// RoundTrip implements http.RoundTripper interface.
func (t *Transport) RoundTrip(req *http.Request) (*http.Response, error) {
	token, err := t.Token(req.Context())
	if err != nil {
		return nil, err
	}
	req.Header.Set(""Authorization"", ""token ""+token)
	req.Header.Add(""Accept"", acceptHeader) // We add to ""Accept"" header to avoid overwriting existing req headers.
	resp, err := t.tr.RoundTrip(req)
	return resp, err
}
// Token checks the active token expiration and renews if necessary. Token returns
// a valid access token. If renewal fails an error is returned.
func (t *Transport) Token(ctx context.Context) (string, error) {
	t.mu.Lock()
	defer t.mu.Unlock()
	if t.token == nil || t.token.ExpiresAt.Add(-time.Minute).Before(time.Now()) {
		// Token is not set or expired/nearly expired, so refresh
		if err := t.refreshToken(ctx); err != nil {
			return """", fmt.Errorf(""could not refresh installation id %v's token: %s"", t.installationID, err)
		}
	}
	return t.token.Token, nil
}
// Permissions returns a transport token's GitHub installation permissions.
func (t *Transport) Permissions() (github.InstallationPermissions, error) {
	if t.token == nil {
		return github.InstallationPermissions{}, fmt.Errorf(""Permissions() = nil, err: nil token"")
	}
	return t.token.Permissions, nil
}
// Repositories returns a transport token's GitHub repositories.
func (t *Transport) Repositories() ([]github.Repository, error) {
	if t.token == nil {
		return nil, fmt.Errorf(""Repositories() = nil, err: nil token"")
	}
	return t.token.Repositories, nil
}
func (t *Transport) refreshToken(ctx context.Context) error {
	// Convert InstallationTokenOptions into a ReadWriter to pass as an argument to http.NewRequest.
	body, err := GetReadWriter(t.InstallationTokenOptions)
	if err != nil {
		return fmt.Errorf(""could not convert installation token parameters into json: %s"", err)
	}
	req, err := http.NewRequest(""POST"", fmt.Sprintf(""%s/app/installations/%v/access_tokens"", t.BaseURL, t.installationID), body)
	if err != nil {
		return fmt.Errorf(""could not create request: %s"", err)
	}
	// Set Content and Accept headers.
	if body != nil {
		req.Header.Set(""Content-Type"", ""application/json"")
	}
	req.Header.Set(""Accept"", acceptHeader)
	if ctx != nil {
		req = req.WithContext(ctx)
	}
	t.appsTransport.BaseURL = t.BaseURL
	t.appsTransport.Client = t.Client
	resp, err := t.appsTransport.RoundTrip(req)
	if err != nil {
		return fmt.Errorf(""could not get access_tokens from GitHub API for installation ID %v: %v"", t.installationID, err)
	}
	defer resp.Body.Close()
	if resp.StatusCode/100 != 2 {
		return fmt.Errorf(""request %+v received non 2xx response status %q with body %+v and TLS %+v"", resp.Request, resp.Body, resp.Request, resp.TLS)
	}
	return json.NewDecoder(resp.Body).Decode(&t.token)
}
// GetReadWriter converts a body interface into an io.ReadWriter object.
func GetReadWriter(i interface{}) (io.ReadWriter, error) {
	var buf io.ReadWriter
	if i != nil {
		buf = new(bytes.Buffer)
		enc := json.NewEncoder(buf)
		err := enc.Encode(i)
		if err != nil {
			return nil, err
		}
	}
	return buf, nil
}
",CWE-209,192.0,1
"package middleware
import (
	""context""
	""github.com/openfga/openfga/pkg/logger""
	serverErrors ""github.com/openfga/openfga/server/errors""
	""go.uber.org/zap""
	""google.golang.org/grpc""
)
func NewErrorLoggingInterceptor(logger logger.Logger) grpc.UnaryServerInterceptor {
	return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {
		resp, err := handler(ctx, req)
		if err != nil {
			var e error
			if internalError, ok := err.(serverErrors.InternalError); ok {
				e = internalError.Internal()
			}
			logger.Error(""grpc_error"", zap.Error(e), zap.String(""public_error"", err.Error()))
			return nil, err
		}
		return resp, nil
	}
}
",CWE-862,28.0,1
"package validatemodels
import (
	""context""
	""encoding/json""
	""fmt""
	""github.com/openfga/openfga/pkg/storage""
	""github.com/openfga/openfga/pkg/storage/mysql""
	""github.com/openfga/openfga/pkg/storage/postgres""
	""github.com/openfga/openfga/pkg/storage/sqlcommon""
	""github.com/openfga/openfga/pkg/typesystem""
	""github.com/spf13/cobra""
	""github.com/spf13/viper""
)
const (
	datastoreEngineFlag = ""datastore-engine""
	datastoreURIFlag    = ""datastore-uri""
)
func NewValidateCommand() *cobra.Command {
	cmd := &cobra.Command{
		Use:   ""validate-models"",
		Short: ""Validate authorization models. NOTE: this command is in beta and may be removed in future releases."",
		Long:  ""List all authorization models across all stores and run validations against them.\nNOTE: this command is in beta and may be removed in future releases."",
		RunE:  runValidate,
		Args:  cobra.NoArgs,
	}
	flags := cmd.Flags()
	flags.String(datastoreEngineFlag, """", ""the datastore engine"")
	flags.String(datastoreURIFlag, """", ""the connection uri to the datastore"")
	// NOTE: if you add a new flag here, update the function below, too
	cmd.PreRun = bindRunFlagsFunc(flags)
	return cmd
}
type validationResult struct {
	StoreID       string `json:""store_id""`
	ModelID       string `json:""model_id""`
	IsLatestModel bool   `json:""is_latest_model""`
	Error         string `json:""error""`
}
func runValidate(_ *cobra.Command, _ []string) error {
	engine := viper.GetString(datastoreEngineFlag)
	uri := viper.GetString(datastoreURIFlag)
	ctx := context.Background()
	var (
		db  storage.OpenFGADatastore
		err error
	)
	switch engine {
	case ""mysql"":
		db, err = mysql.New(uri, sqlcommon.NewConfig())
	case ""postgres"":
		db, err = postgres.New(uri, sqlcommon.NewConfig())
	case """":
		return fmt.Errorf(""missing datastore engine type"")
	case ""memory"":
		fallthrough
	default:
		return fmt.Errorf(""storage engine '%s' is unsupported"", engine)
	}
	if err != nil {
		return fmt.Errorf(""failed to open a connection to the datastore: %v"", err)
	}
	validationResults, err := ValidateAllAuthorizationModels(ctx, db)
	if err != nil {
		return err
	}
	marshalled, err := json.MarshalIndent(validationResults, "" "", ""    "")
	if err != nil {
		return fmt.Errorf(""error gathering validation results: %w"", err)
	}
	fmt.Println(string(marshalled))
	return nil
}
// ValidateAllAuthorizationModels lists all stores and then, for each store, lists all models.
// Then it runs validation on each model.
func ValidateAllAuthorizationModels(ctx context.Context, db storage.OpenFGADatastore) ([]validationResult, error) {
	validationResults := make([]validationResult, 0)
	continuationTokenStores := """"
	for {
		// fetch a page of stores
		stores, tokenStores, err := db.ListStores(ctx, storage.PaginationOptions{
			PageSize: 100,
			From:     continuationTokenStores,
		})
		if err != nil {
			return nil, fmt.Errorf(""error reading stores: %w"", err)
		}
		// validate each store
		for _, store := range stores {
			latestModelID, err := db.FindLatestAuthorizationModelID(ctx, store.Id)
			if err != nil {
				fmt.Printf(""no models in store %s \n"", store.Id)
			}
			continuationTokenModels := """"
			for {
				// fetch a page of models for that store
				models, tokenModels, err := db.ReadAuthorizationModels(ctx, store.Id, storage.PaginationOptions{
					PageSize: 100,
					From:     continuationTokenModels,
				})
				if err != nil {
					return nil, fmt.Errorf(""error reading authorization models: %w"", err)
				}
				// validate each model
				for _, model := range models {
					_, err := typesystem.NewAndValidate(model)
					validationResult := validationResult{
						StoreID:       store.Id,
						ModelID:       model.Id,
						IsLatestModel: model.Id == latestModelID,
					}
					if err != nil {
						validationResult.Error = err.Error()
					}
					validationResults = append(validationResults, validationResult)
				}
				continuationTokenModels = string(tokenModels)
				if continuationTokenModels == """" {
					break
				}
			}
		}
		// next page of stores
		continuationTokenStores = string(tokenStores)
		if continuationTokenStores == """" {
			break
		}
	}
	return validationResults, nil
}
",CWE-835,161.0,1
"package commands
import (
	""context""
	""github.com/oklog/ulid/v2""
	""github.com/openfga/openfga/pkg/logger""
	serverErrors ""github.com/openfga/openfga/pkg/server/errors""
	""github.com/openfga/openfga/pkg/storage""
	""github.com/openfga/openfga/pkg/typesystem""
	openfgapb ""go.buf.build/openfga/go/openfga/api/openfga/v1""
)
// WriteAuthorizationModelCommand performs updates of the store authorization model.
type WriteAuthorizationModelCommand struct {
	backend storage.TypeDefinitionWriteBackend
	logger  logger.Logger
}
func NewWriteAuthorizationModelCommand(
	backend storage.TypeDefinitionWriteBackend,
	logger logger.Logger,
) *WriteAuthorizationModelCommand {
	return &WriteAuthorizationModelCommand{
		backend: backend,
		logger:  logger,
	}
}
// Execute the command using the supplied request.
func (w *WriteAuthorizationModelCommand) Execute(ctx context.Context, req *openfgapb.WriteAuthorizationModelRequest) (*openfgapb.WriteAuthorizationModelResponse, error) {
	// Until this is solved: https://github.com/envoyproxy/protoc-gen-validate/issues/74
	if len(req.GetTypeDefinitions()) > w.backend.MaxTypesPerAuthorizationModel() {
		return nil, serverErrors.ExceededEntityLimit(""type definitions in an authorization model"", w.backend.MaxTypesPerAuthorizationModel())
	}
	// Fill in the schema version for old requests, which don't contain it, while we migrate to the new schema version.
	if req.SchemaVersion == """" {
		req.SchemaVersion = typesystem.SchemaVersion1_1
	}
	model := &openfgapb.AuthorizationModel{
		Id:              ulid.Make().String(),
		SchemaVersion:   req.GetSchemaVersion(),
		TypeDefinitions: req.GetTypeDefinitions(),
	}
	_, err := typesystem.NewAndValidate(model)
	if err != nil {
		return nil, serverErrors.InvalidAuthorizationModelInput(err)
	}
	err = w.backend.WriteAuthorizationModel(ctx, req.GetStoreId(), model)
	if err != nil {
		return nil, serverErrors.NewInternalError(""Error writing authorization model configuration"", err)
	}
	return &openfgapb.WriteAuthorizationModelResponse{
		AuthorizationModelId: model.Id,
	}, nil
}
",CWE-835,62.0,1
"package test
import (
	""testing""
	""github.com/openfga/openfga/pkg/storage""
)
const (
	defaultResolveNodeLimit = 25
)
func RunAllTests(t *testing.T, ds storage.OpenFGADatastore) {
	RunQueryTests(t, ds)
	RunCommandTests(t, ds)
}
func RunQueryTests(t *testing.T, ds storage.OpenFGADatastore) {
	t.Run(""TestReadAuthorizationModelQueryErrors"", func(t *testing.T) { TestReadAuthorizationModelQueryErrors(t, ds) })
	t.Run(""TestSuccessfulReadAuthorizationModelQuery"", func(t *testing.T) { TestSuccessfulReadAuthorizationModelQuery(t, ds) })
	t.Run(""TestReadAuthorizationModel"", func(t *testing.T) { ReadAuthorizationModelTest(t, ds) })
	t.Run(""TestExpandQuery"", func(t *testing.T) { TestExpandQuery(t, ds) })
	t.Run(""TestExpandQueryErrors"", func(t *testing.T) { TestExpandQueryErrors(t, ds) })
	t.Run(""TestGetStoreQuery"", func(t *testing.T) { TestGetStoreQuery(t, ds) })
	t.Run(""TestGetStoreSucceeds"", func(t *testing.T) { TestGetStoreSucceeds(t, ds) })
	t.Run(""TestListStores"", func(t *testing.T) { TestListStores(t, ds) })
	t.Run(""TestReadAssertionQuery"", func(t *testing.T) { TestReadAssertionQuery(t, ds) })
	t.Run(""TestReadQuerySuccess"", func(t *testing.T) { ReadQuerySuccessTest(t, ds) })
	t.Run(""TestReadQueryError"", func(t *testing.T) { ReadQueryErrorTest(t, ds) })
	t.Run(""TestReadAllTuples"", func(t *testing.T) { ReadAllTuplesTest(t, ds) })
	t.Run(""TestReadAllTuplesInvalidContinuationToken"", func(t *testing.T) { ReadAllTuplesInvalidContinuationTokenTest(t, ds) })
	t.Run(""TestReadAuthorizationModelsWithoutPaging"",
		func(t *testing.T) { TestReadAuthorizationModelsWithoutPaging(t, ds) },
	)
	t.Run(""TestReadAuthorizationModelsWithPaging"",
		func(t *testing.T) { TestReadAuthorizationModelsWithPaging(t, ds) },
	)
	t.Run(""TestReadAuthorizationModelsInvalidContinuationToken"",
		func(t *testing.T) { TestReadAuthorizationModelsInvalidContinuationToken(t, ds) },
	)
	t.Run(""TestReadChanges"", func(t *testing.T) { TestReadChanges(t, ds) })
	t.Run(""TestReadChangesReturnsSameContTokenWhenNoChanges"",
		func(t *testing.T) { TestReadChangesReturnsSameContTokenWhenNoChanges(t, ds) },
	)
	t.Run(""TestListObjectsRespectsMaxResults"", func(t *testing.T) { TestListObjectsRespectsMaxResults(t, ds) })
}
func RunCommandTests(t *testing.T, ds storage.OpenFGADatastore) {
	t.Run(""TestWriteCommand"", func(t *testing.T) { TestWriteCommand(t, ds) })
	t.Run(""TestWriteAuthorizationModel"", func(t *testing.T) { WriteAuthorizationModelTest(t, ds) })
	t.Run(""TestWriteAssertions"", func(t *testing.T) { TestWriteAssertions(t, ds) })
	t.Run(""TestCreateStore"", func(t *testing.T) { TestCreateStore(t, ds) })
	t.Run(""TestDeleteStore"", func(t *testing.T) { TestDeleteStore(t, ds) })
	t.Run(""TestConnectedObjects"", func(t *testing.T) { ConnectedObjectsTest(t, ds) })
}
func RunAllBenchmarks(b *testing.B, ds storage.OpenFGADatastore) {
	RunListObjectsBenchmarks(b, ds)
}
func RunListObjectsBenchmarks(b *testing.B, ds storage.OpenFGADatastore) {
	b.Run(""BenchmarkListObjectsWithReverseExpand"", func(b *testing.B) { BenchmarkListObjectsWithReverseExpand(b, ds) })
	b.Run(""BenchmarkListObjectsWithConcurrentChecks"", func(b *testing.B) { BenchmarkListObjectsWithConcurrentChecks(b, ds) })
}
",CWE-835,74.0,1
"package storage
import (
	""context""
	""database/sql""
	""fmt""
	""io""
	""log""
	""strings""
	""testing""
	""time""
	""github.com/cenkalti/backoff/v4""
	""github.com/docker/docker/api/types""
	""github.com/docker/docker/api/types/container""
	""github.com/docker/docker/client""
	""github.com/docker/go-connections/nat""
	""github.com/go-sql-driver/mysql""
	""github.com/oklog/ulid/v2""
	""github.com/pressly/goose/v3""
	""github.com/stretchr/testify/require""
	""github.com/openfga/openfga/assets""
)
const (
	mySQLImage = ""mysql:8""
)
type mySQLTestContainer struct {
	addr     string
	version  int64
	username string
	password string
}
// NewMySQLTestContainer returns an implementation of the DatastoreTestContainer interface
// for MySQL.
func NewMySQLTestContainer() *mySQLTestContainer {
	return &mySQLTestContainer{}
}
func (m *mySQLTestContainer) GetDatabaseSchemaVersion() int64 {
	return m.version
}
// RunMySQLTestContainer runs a MySQL container, connects to it, and returns a
// bootstrapped implementation of the DatastoreTestContainer interface wired up for the
// MySQL datastore engine.
func (m *mySQLTestContainer) RunMySQLTestContainer(t testing.TB) (DatastoreTestContainer, func()) {
	dockerClient, err := client.NewClientWithOpts(
		client.FromEnv,
		client.WithAPIVersionNegotiation(),
	)
	require.NoError(t, err)
	allImages, err := dockerClient.ImageList(context.Background(), types.ImageListOptions{
		All: true,
	})
	require.NoError(t, err)
	foundMysqlImage := false
	for _, image := range allImages {
		for _, tag := range image.RepoTags {
			if strings.Contains(tag, mySQLImage) {
				foundMysqlImage = true
				break
			}
		}
	}
	if !foundMysqlImage {
		t.Logf(""Pulling image %s"", mySQLImage)
		reader, err := dockerClient.ImagePull(context.Background(), mySQLImage, types.ImagePullOptions{})
		require.NoError(t, err)
		_, err = io.Copy(io.Discard, reader) // consume the image pull output to make sure it's done
		require.NoError(t, err)
	}
	containerCfg := container.Config{
		Env: []string{
			""MYSQL_DATABASE=defaultdb"",
			""MYSQL_ROOT_PASSWORD=secret"",
		},
		ExposedPorts: nat.PortSet{
			nat.Port(""3306/tcp""): {},
		},
		Image: mySQLImage,
	}
	hostCfg := container.HostConfig{
		AutoRemove:      true,
		PublishAllPorts: true,
		Tmpfs:           map[string]string{""/var/lib/mysql"": """"},
	}
	name := fmt.Sprintf(""mysql-%s"", ulid.Make().String())
	cont, err := dockerClient.ContainerCreate(context.Background(), &containerCfg, &hostCfg, nil, nil, name)
	require.NoError(t, err, ""failed to create mysql docker container"")
	stopContainer := func() {
		t.Logf(""stopping container %s"", name)
		timeoutSec := 5
		err := dockerClient.ContainerStop(context.Background(), cont.ID, container.StopOptions{Timeout: &timeoutSec})
		if err != nil && !client.IsErrNotFound(err) {
			t.Logf(""failed to stop mysql container: %v"", err)
		}
		dockerClient.Close()
		t.Logf(""stopped container %s"", name)
	}
	err = dockerClient.ContainerStart(context.Background(), cont.ID, types.ContainerStartOptions{})
	if err != nil {
		stopContainer()
		t.Fatalf(""failed to start mysql container: %v"", err)
	}
	containerJSON, err := dockerClient.ContainerInspect(context.Background(), cont.ID)
	require.NoError(t, err)
	p, ok := containerJSON.NetworkSettings.Ports[""3306/tcp""]
	if !ok || len(p) == 0 {
		t.Fatalf(""failed to get host port mapping from mysql container"")
	}
	mySQLTestContainer := &mySQLTestContainer{
		addr:     fmt.Sprintf(""localhost:%s"", p[0].HostPort),
		username: ""root"",
		password: ""secret"",
	}
	uri := fmt.Sprintf(""%s:%s@tcp(%s)/defaultdb?parseTime=true"", mySQLTestContainer.username, mySQLTestContainer.password, mySQLTestContainer.addr)
	err = mysql.SetLogger(log.New(io.Discard, """", 0))
	require.NoError(t, err)
	goose.SetLogger(goose.NopLogger())
	var db *sql.DB
	backoffPolicy := backoff.NewExponentialBackOff()
	backoffPolicy.MaxElapsedTime = 2 * time.Minute
	err = backoff.Retry(
		func() error {
			db, err = goose.OpenDBWithDriver(""mysql"", uri)
			if err != nil {
				return err
			}
			return db.Ping()
		},
		backoffPolicy,
	)
	if err != nil {
		stopContainer()
		t.Fatalf(""failed to connect to mysql container: %v"", err)
	}
	goose.SetBaseFS(assets.EmbedMigrations)
	err = goose.Up(db, assets.MySQLMigrationDir)
	require.NoError(t, err)
	version, err := goose.GetDBVersion(db)
	require.NoError(t, err)
	mySQLTestContainer.version = version
	err = db.Close()
	require.NoError(t, err)
	return mySQLTestContainer, stopContainer
}
// GetConnectionURI returns the mysql connection uri for the running mysql test container.
func (m *mySQLTestContainer) GetConnectionURI(includeCredentials bool) string {
	creds := """"
	if includeCredentials {
		creds = fmt.Sprintf(""%s:%s@"", m.username, m.password)
	}
	return fmt.Sprintf(
		""%stcp(%s)/%s?parseTime=true"",
		creds,
		m.addr,
		""defaultdb"",
	)
}
func (m *mySQLTestContainer) GetUsername() string {
	return m.username
}
func (m *mySQLTestContainer) GetPassword() string {
	return m.password
}
",CWE-401,198.0,1
"package storage
import (
	""context""
	""fmt""
	""io""
	""strings""
	""testing""
	""time""
	""github.com/cenkalti/backoff/v4""
	""github.com/docker/docker/api/types""
	""github.com/docker/docker/api/types/container""
	""github.com/docker/docker/client""
	""github.com/docker/go-connections/nat""
	_ ""github.com/jackc/pgx/v5/stdlib""
	""github.com/oklog/ulid/v2""
	""github.com/pressly/goose/v3""
	""github.com/stretchr/testify/require""
	""github.com/openfga/openfga/assets""
)
const (
	postgresImage = ""postgres:14""
)
type postgresTestContainer struct {
	addr     string
	version  int64
	username string
	password string
}
// NewPostgresTestContainer returns an implementation of the DatastoreTestContainer interface
// for Postgres.
func NewPostgresTestContainer() *postgresTestContainer {
	return &postgresTestContainer{}
}
func (p *postgresTestContainer) GetDatabaseSchemaVersion() int64 {
	return p.version
}
// RunPostgresTestContainer runs a Postgres container, connects to it, and returns a
// bootstrapped implementation of the DatastoreTestContainer interface wired up for the
// Postgres datastore engine.
func (p *postgresTestContainer) RunPostgresTestContainer(t testing.TB) (DatastoreTestContainer, func()) {
	dockerClient, err := client.NewClientWithOpts(
		client.FromEnv,
		client.WithAPIVersionNegotiation(),
	)
	require.NoError(t, err)
	allImages, err := dockerClient.ImageList(context.Background(), types.ImageListOptions{
		All: true,
	})
	require.NoError(t, err)
	foundPostgresImage := false
	for _, image := range allImages {
		for _, tag := range image.RepoTags {
			if strings.Contains(tag, postgresImage) {
				foundPostgresImage = true
				break
			}
		}
	}
	if !foundPostgresImage {
		t.Logf(""Pulling image %s"", postgresImage)
		reader, err := dockerClient.ImagePull(context.Background(), postgresImage, types.ImagePullOptions{})
		require.NoError(t, err)
		_, err = io.Copy(io.Discard, reader) // consume the image pull output to make sure it's done
		require.NoError(t, err)
	}
	containerCfg := container.Config{
		Env: []string{
			""POSTGRES_DB=defaultdb"",
			""POSTGRES_PASSWORD=secret"",
		},
		ExposedPorts: nat.PortSet{
			nat.Port(""5432/tcp""): {},
		},
		Image: postgresImage,
	}
	hostCfg := container.HostConfig{
		AutoRemove:      true,
		PublishAllPorts: true,
		Tmpfs:           map[string]string{""/var/lib/postgresql/data"": """"},
	}
	name := fmt.Sprintf(""postgres-%s"", ulid.Make().String())
	cont, err := dockerClient.ContainerCreate(context.Background(), &containerCfg, &hostCfg, nil, nil, name)
	require.NoError(t, err, ""failed to create postgres docker container"")
	stopContainer := func() {
		t.Logf(""stopping container %s"", name)
		timeoutSec := 5
		err := dockerClient.ContainerStop(context.Background(), cont.ID, container.StopOptions{Timeout: &timeoutSec})
		if err != nil && !client.IsErrNotFound(err) {
			t.Logf(""failed to stop postgres container: %v"", err)
		}
		dockerClient.Close()
		t.Logf(""stopped container %s"", name)
	}
	err = dockerClient.ContainerStart(context.Background(), cont.ID, types.ContainerStartOptions{})
	if err != nil {
		stopContainer()
		t.Fatalf(""failed to start postgres container: %v"", err)
	}
	containerJSON, err := dockerClient.ContainerInspect(context.Background(), cont.ID)
	require.NoError(t, err)
	m, ok := containerJSON.NetworkSettings.Ports[""5432/tcp""]
	if !ok || len(m) == 0 {
		t.Fatalf(""failed to get host port mapping from postgres container"")
	}
	pgTestContainer := &postgresTestContainer{
		addr:     fmt.Sprintf(""localhost:%s"", m[0].HostPort),
		username: ""postgres"",
		password: ""secret"",
	}
	uri := fmt.Sprintf(""postgres://%s:%s@%s/defaultdb?sslmode=disable"", pgTestContainer.username, pgTestContainer.password, pgTestContainer.addr)
	goose.SetLogger(goose.NopLogger())
	db, err := goose.OpenDBWithDriver(""pgx"", uri)
	require.NoError(t, err)
	backoffPolicy := backoff.NewExponentialBackOff()
	backoffPolicy.MaxElapsedTime = 30 * time.Second
	err = backoff.Retry(
		func() error {
			return db.Ping()
		},
		backoffPolicy,
	)
	if err != nil {
		stopContainer()
		t.Fatalf(""failed to connect to postgres container: %v"", err)
	}
	goose.SetBaseFS(assets.EmbedMigrations)
	err = goose.Up(db, assets.PostgresMigrationDir)
	require.NoError(t, err)
	version, err := goose.GetDBVersion(db)
	require.NoError(t, err)
	pgTestContainer.version = version
	err = db.Close()
	require.NoError(t, err)
	return pgTestContainer, stopContainer
}
// GetConnectionURI returns the postgres connection uri for the running postgres test container.
func (p *postgresTestContainer) GetConnectionURI(includeCredentials bool) string {
	creds := """"
	if includeCredentials {
		creds = fmt.Sprintf(""%s:%s@"", p.username, p.password)
	}
	return fmt.Sprintf(
		""postgres://%s%s/%s?sslmode=disable"",
		creds,
		p.addr,
		""defaultdb"",
	)
}
func (p *postgresTestContainer) GetUsername() string {
	return p.username
}
func (p *postgresTestContainer) GetPassword() string {
	return p.password
}
",CWE-401,191.0,1
"package listobjects
import (
	""testing""
	openfgav1 ""github.com/openfga/api/proto/openfga/v1""
	""github.com/stretchr/testify/require""
	""google.golang.org/grpc""
	""google.golang.org/grpc/credentials/insecure""
	""github.com/openfga/openfga/cmd/run""
	""github.com/openfga/openfga/tests""
)
func TestListObjectsMemory(t *testing.T) {
	testRunAll(t, ""memory"")
}
func TestListObjectsPostgres(t *testing.T) {
	testRunAll(t, ""postgres"")
}
func TestListObjectsMySQL(t *testing.T) {
	testRunAll(t, ""mysql"")
}
func testRunAll(t *testing.T, engine string) {
	// uncomment in https://github.com/openfga/openfga/pull/1315
	// defer goleak.VerifyNone(t)
	cfg := run.MustDefaultConfigWithRandomPorts()
	cfg.Log.Level = ""error""
	cfg.Datastore.Engine = engine
	cancel := tests.StartServer(t, cfg)
	defer cancel()
	conn, err := grpc.Dial(cfg.GRPC.Addr,
		grpc.WithBlock(),
		grpc.WithTransportCredentials(insecure.NewCredentials()),
	)
	require.NoError(t, err)
	defer conn.Close()
	RunAllTests(t, openfgav1.NewOpenFGAServiceClient(conn))
}
",CWE-401,45.0,1
"//go:build go1.17
// +build go1.17
package saml
import (
	""encoding/base64""
	""encoding/xml""
	""net/http""
	""net/url""
	""strings""
	""testing""
	""time""
	dsig ""github.com/russellhaering/goxmldsig""
	""gotest.tools/assert""
	is ""gotest.tools/assert/cmp""
	""gotest.tools/golden""
)
func TestSPRejectsMalformedResponse(t *testing.T) {
	test := NewServiceProviderTest(t)
	// An actual response from google
	TimeNow = func() time.Time {
		rv, _ := time.Parse(""Mon Jan 2 15:04:05 UTC 2006"", ""Tue Jan 5 16:55:39 UTC 2016"")
		return rv
	}
	Clock = dsig.NewFakeClockAt(TimeNow())
	SamlResponse := golden.Get(t, ""TestSPRejectsMalformedResponse_response"")
	test.IDPMetadata = golden.Get(t, ""TestSPRejectsMalformedResponse_IDPMetadata"")
	s := ServiceProvider{
		Key:         test.Key,
		Certificate: test.Certificate,
		MetadataURL: mustParseURL(""https://29ee6d2e.ngrok.io/saml/metadata""),
		AcsURL:      mustParseURL(""https://29ee6d2e.ngrok.io/saml/acs""),
		IDPMetadata: &EntityDescriptor{},
	}
	err := xml.Unmarshal(test.IDPMetadata, &s.IDPMetadata)
	assert.Check(t, err)
	// this is a valid response
	{
		req := http.Request{PostForm: url.Values{}}
		req.PostForm.Set(""SAMLResponse"", string(SamlResponse))
		assertion, err := s.ParseResponse(&req, []string{""id-fd419a5ab0472645427f8e07d87a3a5dd0b2e9a6""})
		assert.Check(t, err)
		assert.Check(t, is.Equal(""ross@octolabs.io"", assertion.Subject.NameID.Value))
	}
	// this is a valid response but with a comment injected
	{
		x, _ := base64.StdEncoding.DecodeString(string(SamlResponse))
		y := strings.Replace(string(x), ""<saml2p:Response"", ""<saml2p:Response ::foo=\""bar\"""", 1)
		SamlResponse = []byte(base64.StdEncoding.EncodeToString([]byte(y)))
		req := http.Request{PostForm: url.Values{}}
		req.PostForm.Set(""SAMLResponse"", string(SamlResponse))
		assertion, err := s.ParseResponse(&req, []string{""id-fd419a5ab0472645427f8e07d87a3a5dd0b2e9a6""})
		assert.Check(t, is.Error(err.(*InvalidResponseError).PrivateErr,
			""cannot validate signature on Response: Signature could not be verified""))
		assert.Check(t, is.Nil(assertion))
	}
}
func TestSPInvalidResponses(t *testing.T) {
	test := NewServiceProviderTest(t)
	s := ServiceProvider{
		Key:         test.Key,
		Certificate: test.Certificate,
		MetadataURL: mustParseURL(""https://15661444.ngrok.io/saml2/metadata""),
		AcsURL:      mustParseURL(""https://15661444.ngrok.io/saml2/acs""),
		IDPMetadata: &EntityDescriptor{},
	}
	err := xml.Unmarshal(test.IDPMetadata, &s.IDPMetadata)
	assert.Check(t, err)
	req := http.Request{PostForm: url.Values{}}
	req.PostForm.Set(""SAMLResponse"", ""???"")
	_, err = s.ParseResponse(&req, []string{""id-9e61753d64e928af5a7a341a97f420c9""})
	assert.Check(t, is.Error(err.(*InvalidResponseError).PrivateErr,
		""cannot parse base64: illegal base64 data at input byte 0""))
	req.PostForm.Set(""SAMLResponse"", base64.StdEncoding.EncodeToString([]byte(""<hello>World!</hello>"")))
	_, err = s.ParseResponse(&req, []string{""id-9e61753d64e928af5a7a341a97f420c9""})
	assert.Check(t, is.Error(err.(*InvalidResponseError).PrivateErr,
		""cannot unmarshal response: expected element type <Response> but have <hello>""))
	req.PostForm.Set(""SAMLResponse"", base64.StdEncoding.EncodeToString(test.SamlResponse))
	_, err = s.ParseResponse(&req, []string{""wrongRequestID""})
	assert.Check(t, is.Error(err.(*InvalidResponseError).PrivateErr,
		""`InResponseTo` does not match any of the possible request IDs (expected [wrongRequestID])""))
	TimeNow = func() time.Time {
		rv, _ := time.Parse(""Mon Jan 2 15:04:05 MST 2006"", ""Mon Nov 30 20:57:09 UTC 2016"")
		return rv
	}
	Clock = dsig.NewFakeClockAt(TimeNow())
	req.PostForm.Set(""SAMLResponse"", base64.StdEncoding.EncodeToString(test.SamlResponse))
	_, err = s.ParseResponse(&req, []string{""id-9e61753d64e928af5a7a341a97f420c9""})
	assert.Check(t, is.Error(err.(*InvalidResponseError).PrivateErr,
		""response IssueInstant expired at 2015-12-01 01:57:51.375 +0000 UTC""))
	TimeNow = func() time.Time {
		rv, _ := time.Parse(""Mon Jan 2 15:04:05 MST 2006"", ""Mon Dec 1 01:57:09 UTC 2015"")
		return rv
	}
	Clock = dsig.NewFakeClockAt(TimeNow())
	s.IDPMetadata.EntityID = ""http://snakeoil.com""
	req.PostForm.Set(""SAMLResponse"", base64.StdEncoding.EncodeToString(test.SamlResponse))
	_, err = s.ParseResponse(&req, []string{""id-9e61753d64e928af5a7a341a97f420c9""})
	assert.Check(t, is.Error(err.(*InvalidResponseError).PrivateErr,
		""response Issuer does not match the IDP metadata (expected \""http://snakeoil.com\"")""))
	s.IDPMetadata.EntityID = ""https://idp.testshib.org/idp/shibboleth""
	oldSpStatusSuccess := StatusSuccess
	StatusSuccess = ""not:the:success:value""
	req.PostForm.Set(""SAMLResponse"", base64.StdEncoding.EncodeToString(test.SamlResponse))
	_, err = s.ParseResponse(&req, []string{""id-9e61753d64e928af5a7a341a97f420c9""})
	assert.Check(t, is.Error(err.(*InvalidResponseError).PrivateErr,
		""urn:oasis:names:tc:SAML:2.0:status:Success""))
	StatusSuccess = oldSpStatusSuccess
	s.IDPMetadata.IDPSSODescriptors[0].KeyDescriptors[0].KeyInfo.X509Data.X509Certificates[0].Data = ""invalid""
	req.PostForm.Set(""SAMLResponse"", base64.StdEncoding.EncodeToString(test.SamlResponse))
	_, err = s.ParseResponse(&req, []string{""id-9e61753d64e928af5a7a341a97f420c9""})
	assert.Check(t, is.Error(err.(*InvalidResponseError).PrivateErr,
		""cannot validate signature on Response: cannot parse certificate: illegal base64 data at input byte 4""))
	s.IDPMetadata.IDPSSODescriptors[0].KeyDescriptors[0].KeyInfo.X509Data.X509Certificates[0].Data = ""aW52YWxpZA==""
	req.PostForm.Set(""SAMLResponse"", base64.StdEncoding.EncodeToString(test.SamlResponse))
	_, err = s.ParseResponse(&req, []string{""id-9e61753d64e928af5a7a341a97f420c9""})
	assert.Check(t, is.Error(err.(*InvalidResponseError).PrivateErr,
		""cannot validate signature on Response: x509: malformed certificate""))
}
",CWE-287,137.0,1
"package saml
import (
	""encoding/xml""
	""testing""
	""time""
	""gotest.tools/assert""
	is ""gotest.tools/assert/cmp""
	""gotest.tools/golden""
)
func TestCanParseMetadata(t *testing.T) {
	buf := golden.Get(t, ""TestCanParseMetadata_metadata.xml"")
	metadata := EntityDescriptor{}
	err := xml.Unmarshal(buf, &metadata)
	assert.Check(t, err)
	var False = false
	var True = true
	expected := EntityDescriptor{
		EntityID:      ""https://dev.aa.kndr.org/users/auth/saml/metadata"",
		ID:            ""_af805d1c-c2e3-444e-9cf5-efc664eeace6"",
		ValidUntil:    time.Date(2001, time.February, 3, 4, 5, 6, 789000000, time.UTC),
		CacheDuration: time.Hour,
		SPSSODescriptors: []SPSSODescriptor{
			{
				XMLName: xml.Name{Space: ""urn:oasis:names:tc:SAML:2.0:metadata"", Local: ""SPSSODescriptor""},
				SSODescriptor: SSODescriptor{
					RoleDescriptor: RoleDescriptor{
						ProtocolSupportEnumeration: ""urn:oasis:names:tc:SAML:2.0:protocol"",
					},
				},
				AuthnRequestsSigned:  &False,
				WantAssertionsSigned: &False,
				AssertionConsumerServices: []IndexedEndpoint{
					{
						Binding:   ""urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST"",
						Location:  ""https://dev.aa.kndr.org/users/auth/saml/callback"",
						Index:     0,
						IsDefault: &True,
					},
				},
				AttributeConsumingServices: []AttributeConsumingService{
					{
						Index:        1,
						IsDefault:    &True,
						ServiceNames: []LocalizedName{{Lang: ""en"", Value: ""Required attributes""}},
						RequestedAttributes: []RequestedAttribute{
							{
								Attribute: Attribute{
									FriendlyName: ""Email address"",
									Name:         ""email"",
									NameFormat:   ""urn:oasis:names:tc:SAML:2.0:attrname-format:basic"",
								},
							},
							{
								Attribute: Attribute{
									FriendlyName: ""Full name"",
									Name:         ""name"",
									NameFormat:   ""urn:oasis:names:tc:SAML:2.0:attrname-format:basic"",
								},
							},
							{
								Attribute: Attribute{
									FriendlyName: ""Given name"",
									Name:         ""first_name"",
									NameFormat:   ""urn:oasis:names:tc:SAML:2.0:attrname-format:basic"",
								},
							},
							{
								Attribute: Attribute{
									FriendlyName: ""Family name"",
									Name:         ""last_name"",
									NameFormat:   ""urn:oasis:names:tc:SAML:2.0:attrname-format:basic"",
								},
							},
						},
					},
				},
			},
		},
	}
	assert.Check(t, is.DeepEqual(expected, metadata))
}
func TestCanProduceSPMetadata(t *testing.T) {
	validUntil, _ := time.Parse(""2006-01-02T15:04:05.000000"", ""2013-03-10T00:32:19.104000"")
	AuthnRequestsSigned := true
	WantAssertionsSigned := true
	metadata := EntityDescriptor{
		EntityID:      ""http://localhost:5000/e087a985171710fb9fb30f30f41384f9/saml2/metadata/"",
		ValidUntil:    validUntil,
		CacheDuration: time.Hour,
		SPSSODescriptors: []SPSSODescriptor{
			{
				AuthnRequestsSigned:  &AuthnRequestsSigned,
				WantAssertionsSigned: &WantAssertionsSigned,
				SSODescriptor: SSODescriptor{
					RoleDescriptor: RoleDescriptor{
						ProtocolSupportEnumeration: ""urn:oasis:names:tc:SAML:2.0:protocol"",
						KeyDescriptors: []KeyDescriptor{
							{
								Use: ""encryption"",
								KeyInfo: KeyInfo{
									X509Data: X509Data{
										X509Certificates: []X509Certificate{
											{
												Data: `MIIB7zCCAVgCCQDFzbKIp7b3MTANBgkqhkiG9w0BAQUFADA8MQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCR0ExDDAKBgNVBAoMA2ZvbzESMBAGA1UEAwwJbG9jYWxob3N0MB4XDTEzMTAwMjAwMDg1MVoX
DTE0MTAwMjAwMDg1MVowPDELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAkdBMQwwCgYDVQQKDANmb28x
EjAQBgNVBAMMCWxvY2FsaG9zdDCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA1PMHYmhZj308
kWLhZVT4vOulqx/9ibm5B86fPWwUKKQ2i12MYtz07tzukPymisTDhQaqyJ8Kqb/6JjhmeMnEOdTv
SPmHO8m1ZVveJU6NoKRn/mP/BD7FW52WhbrUXLSeHVSKfWkNk6S4hk9MV9TswTvyRIKvRsw0X/gf
nqkroJcCAwEAATANBgkqhkiG9w0BAQUFAAOBgQCMMlIO+GNcGekevKgkakpMdAqJfs24maGb90Dv
TLbRZRD7Xvn1MnVBBS9hzlXiFLYOInXACMW5gcoRFfeTQLSouMM8o57h0uKjfTmuoWHLQLi6hnF+
cvCsEFiJZ4AbF+DgmO6TarJ8O05t8zvnOwJlNCASPZRH/JmF8tX0hoHuAQ==`,
											},
										},
									},
								},
							},
							{
								Use: ""signing"",
								KeyInfo: KeyInfo{
									X509Data: X509Data{
										X509Certificates: []X509Certificate{
											{
												Data: `MIIB7zCCAVgCCQDFzbKIp7b3MTANBgkqhkiG9w0BAQUFADA8MQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCR0ExDDAKBgNVBAoMA2ZvbzESMBAGA1UEAwwJbG9jYWxob3N0MB4XDTEzMTAwMjAwMDg1MVoX
DTE0MTAwMjAwMDg1MVowPDELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAkdBMQwwCgYDVQQKDANmb28x
EjAQBgNVBAMMCWxvY2FsaG9zdDCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA1PMHYmhZj308
kWLhZVT4vOulqx/9ibm5B86fPWwUKKQ2i12MYtz07tzukPymisTDhQaqyJ8Kqb/6JjhmeMnEOdTv
SPmHO8m1ZVveJU6NoKRn/mP/BD7FW52WhbrUXLSeHVSKfWkNk6S4hk9MV9TswTvyRIKvRsw0X/gf
nqkroJcCAwEAATANBgkqhkiG9w0BAQUFAAOBgQCMMlIO+GNcGekevKgkakpMdAqJfs24maGb90Dv
TLbRZRD7Xvn1MnVBBS9hzlXiFLYOInXACMW5gcoRFfeTQLSouMM8o57h0uKjfTmuoWHLQLi6hnF+
cvCsEFiJZ4AbF+DgmO6TarJ8O05t8zvnOwJlNCASPZRH/JmF8tX0hoHuAQ==`,
											},
										},
									},
								},
							},
						},
					},
					SingleLogoutServices: []Endpoint{{
						Binding:  ""urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect"",
						Location: ""http://localhost:5000/e087a985171710fb9fb30f30f41384f9/saml2/ls/"",
					}},
				},
				AssertionConsumerServices: []IndexedEndpoint{{
					Binding:  ""urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST"",
					Location: ""http://localhost:5000/e087a985171710fb9fb30f30f41384f9/saml2/ls/"",
					Index:    1,
				}},
			},
		},
	}
	buf, err := xml.MarshalIndent(metadata, """", ""  "")
	assert.Check(t, err)
	golden.Assert(t, string(buf), ""TestCanProduceSPMetadata_expected"")
}
",CWE-79,168.0,1
"// Copyright 2020 The Prometheus Authors
// This code is partly borrowed from Caddy:
//    Copyright 2015 Matthew Holt and The Caddy Authors
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package web
import (
	""encoding/hex""
	""fmt""
	""net/http""
	""sync""
	""github.com/go-kit/log""
	""golang.org/x/crypto/bcrypt""
)
// extraHTTPHeaders is a map of HTTP headers that can be added to HTTP
// responses.
// This is private on purpose to ensure consistency in the Prometheus ecosystem.
var extraHTTPHeaders = map[string][]string{
	""Strict-Transport-Security"": nil,
	""X-Content-Type-Options"":    {""nosniff""},
	""X-Frame-Options"":           {""deny"", ""sameorigin""},
	""X-XSS-Protection"":          nil,
	""Content-Security-Policy"":   nil,
}
func validateUsers(configPath string) error {
	c, err := getConfig(configPath)
	if err != nil {
		return err
	}
	for _, p := range c.Users {
		_, err = bcrypt.Cost([]byte(p))
		if err != nil {
			return err
		}
	}
	return nil
}
// validateHeaderConfig checks that the provided header configuration is correct.
// It does not check the validity of all the values, only the ones which are
// well-defined enumerations.
func validateHeaderConfig(headers map[string]string) error {
HeadersLoop:
	for k, v := range headers {
		values, ok := extraHTTPHeaders[k]
		if !ok {
			return fmt.Errorf(""HTTP header %q can not be configured"", k)
		}
		for _, allowedValue := range values {
			if v == allowedValue {
				continue HeadersLoop
			}
		}
		if len(values) > 0 {
			return fmt.Errorf(""invalid value for %s. Expected one of: %q, but got: %q"", k, values, v)
		}
	}
	return nil
}
type webHandler struct {
	tlsConfigPath string
	handler       http.Handler
	logger        log.Logger
	cache         *cache
	// bcryptMtx is there to ensure that bcrypt.CompareHashAndPassword is run
	// only once in parallel as this is CPU intensive.
	bcryptMtx sync.Mutex
}
func (u *webHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	c, err := getConfig(u.tlsConfigPath)
	if err != nil {
		u.logger.Log(""msg"", ""Unable to parse configuration"", ""err"", err)
		http.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
		return
	}
	// Configure http headers.
	for k, v := range c.HTTPConfig.Header {
		w.Header().Set(k, v)
	}
	if len(c.Users) == 0 {
		u.handler.ServeHTTP(w, r)
		return
	}
	user, pass, auth := r.BasicAuth()
	if auth {
		hashedPassword, validUser := c.Users[user]
		if !validUser {
			// The user is not found. Use a fixed password hash to
			// prevent user enumeration by timing requests.
			// This is a bcrypt-hashed version of ""fakepassword"".
			hashedPassword = ""$2y$10$QOauhQNbBCuQDKes6eFzPeMqBSjb7Mr5DUmpZ/VcEd00UAV/LDeSi""
		}
		cacheKey := hex.EncodeToString(append(append([]byte(user), []byte(hashedPassword)...), []byte(pass)...))
		authOk, ok := u.cache.get(cacheKey)
		if !ok {
			// This user, hashedPassword, password is not cached.
			u.bcryptMtx.Lock()
			err := bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(pass))
			u.bcryptMtx.Unlock()
			authOk = err == nil
			u.cache.set(cacheKey, authOk)
		}
		if authOk && validUser {
			u.handler.ServeHTTP(w, r)
			return
		}
	}
	w.Header().Set(""WWW-Authenticate"", ""Basic"")
	http.Error(w, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)
}
",CWE-287,138.0,1
"// Copyright 2020 The Prometheus Authors
// This code is partly borrowed from Caddy:
//    Copyright 2015 Matthew Holt and The Caddy Authors
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package web
import (
	""encoding/hex""
	""fmt""
	""net/http""
	""sync""
	""github.com/go-kit/log""
	""golang.org/x/crypto/bcrypt""
)
// extraHTTPHeaders is a map of HTTP headers that can be added to HTTP
// responses.
// This is private on purpose to ensure consistency in the Prometheus ecosystem.
var extraHTTPHeaders = map[string][]string{
	""Strict-Transport-Security"": nil,
	""X-Content-Type-Options"":    {""nosniff""},
	""X-Frame-Options"":           {""deny"", ""sameorigin""},
	""X-XSS-Protection"":          nil,
	""Content-Security-Policy"":   nil,
}
func validateUsers(configPath string) error {
	c, err := getConfig(configPath)
	if err != nil {
		return err
	}
	for _, p := range c.Users {
		_, err = bcrypt.Cost([]byte(p))
		if err != nil {
			return err
		}
	}
	return nil
}
// validateHeaderConfig checks that the provided header configuration is correct.
// It does not check the validity of all the values, only the ones which are
// well-defined enumerations.
func validateHeaderConfig(headers map[string]string) error {
HeadersLoop:
	for k, v := range headers {
		values, ok := extraHTTPHeaders[k]
		if !ok {
			return fmt.Errorf(""HTTP header %q can not be configured"", k)
		}
		for _, allowedValue := range values {
			if v == allowedValue {
				continue HeadersLoop
			}
		}
		if len(values) > 0 {
			return fmt.Errorf(""invalid value for %s. Expected one of: %q, but got: %q"", k, values, v)
		}
	}
	return nil
}
type webHandler struct {
	tlsConfigPath string
	handler       http.Handler
	logger        log.Logger
	cache         *cache
	// bcryptMtx is there to ensure that bcrypt.CompareHashAndPassword is run
	// only once in parallel as this is CPU intensive.
	bcryptMtx sync.Mutex
}
func (u *webHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	c, err := getConfig(u.tlsConfigPath)
	if err != nil {
		u.logger.Log(""msg"", ""Unable to parse configuration"", ""err"", err)
		http.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
		return
	}
	// Configure http headers.
	for k, v := range c.HTTPConfig.Header {
		w.Header().Set(k, v)
	}
	if len(c.Users) == 0 {
		u.handler.ServeHTTP(w, r)
		return
	}
	user, pass, auth := r.BasicAuth()
	if auth {
		hashedPassword, validUser := c.Users[user]
		if !validUser {
			// The user is not found. Use a fixed password hash to
			// prevent user enumeration by timing requests.
			// This is a bcrypt-hashed version of ""fakepassword"".
			hashedPassword = ""$2y$10$QOauhQNbBCuQDKes6eFzPeMqBSjb7Mr5DUmpZ/VcEd00UAV/LDeSi""
		}
		cacheKey := hex.EncodeToString(append(append([]byte(user), []byte(hashedPassword)...), []byte(pass)...))
		authOk, ok := u.cache.get(cacheKey)
		if !ok {
			// This user, hashedPassword, password is not cached.
			u.bcryptMtx.Lock()
			err := bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(pass))
			u.bcryptMtx.Unlock()
			authOk = err == nil
			u.cache.set(cacheKey, authOk)
		}
		if authOk && validUser {
			u.handler.ServeHTTP(w, r)
			return
		}
	}
	w.Header().Set(""WWW-Authenticate"", ""Basic"")
	http.Error(w, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)
}
",CWE-303,138.0,1
"package server
import (
	""context""
	""github.com/traefik/traefik/v2/pkg/config/runtime""
	""github.com/traefik/traefik/v2/pkg/config/static""
	""github.com/traefik/traefik/v2/pkg/log""
	""github.com/traefik/traefik/v2/pkg/metrics""
	""github.com/traefik/traefik/v2/pkg/server/middleware""
	tcpmiddleware ""github.com/traefik/traefik/v2/pkg/server/middleware/tcp""
	""github.com/traefik/traefik/v2/pkg/server/router""
	tcprouter ""github.com/traefik/traefik/v2/pkg/server/router/tcp""
	udprouter ""github.com/traefik/traefik/v2/pkg/server/router/udp""
	""github.com/traefik/traefik/v2/pkg/server/service""
	""github.com/traefik/traefik/v2/pkg/server/service/tcp""
	""github.com/traefik/traefik/v2/pkg/server/service/udp""
	""github.com/traefik/traefik/v2/pkg/tls""
	udptypes ""github.com/traefik/traefik/v2/pkg/udp""
)
// RouterFactory the factory of TCP/UDP routers.
type RouterFactory struct {
	entryPointsTCP []string
	entryPointsUDP []string
	managerFactory  *service.ManagerFactory
	metricsRegistry metrics.Registry
	pluginBuilder middleware.PluginsBuilder
	chainBuilder *middleware.ChainBuilder
	tlsManager   *tls.Manager
}
// NewRouterFactory creates a new RouterFactory.
func NewRouterFactory(staticConfiguration static.Configuration, managerFactory *service.ManagerFactory, tlsManager *tls.Manager,
	chainBuilder *middleware.ChainBuilder, pluginBuilder middleware.PluginsBuilder, metricsRegistry metrics.Registry,
) *RouterFactory {
	var entryPointsTCP, entryPointsUDP []string
	for name, cfg := range staticConfiguration.EntryPoints {
		protocol, err := cfg.GetProtocol()
		if err != nil {
			// Should never happen because Traefik should not start if protocol is invalid.
			log.WithoutContext().Errorf(""Invalid protocol: %v"", err)
		}
		if protocol == ""udp"" {
			entryPointsUDP = append(entryPointsUDP, name)
		} else {
			entryPointsTCP = append(entryPointsTCP, name)
		}
	}
	return &RouterFactory{
		entryPointsTCP:  entryPointsTCP,
		entryPointsUDP:  entryPointsUDP,
		managerFactory:  managerFactory,
		metricsRegistry: metricsRegistry,
		tlsManager:      tlsManager,
		chainBuilder:    chainBuilder,
		pluginBuilder:   pluginBuilder,
	}
}
// CreateRouters creates new TCPRouters and UDPRouters.
func (f *RouterFactory) CreateRouters(rtConf *runtime.Configuration) (map[string]*tcprouter.Router, map[string]udptypes.Handler) {
	ctx := context.Background()
	// HTTP
	serviceManager := f.managerFactory.Build(rtConf)
	middlewaresBuilder := middleware.NewBuilder(rtConf.Middlewares, serviceManager, f.pluginBuilder)
	routerManager := router.NewManager(rtConf, serviceManager, middlewaresBuilder, f.chainBuilder, f.metricsRegistry)
	handlersNonTLS := routerManager.BuildHandlers(ctx, f.entryPointsTCP, false)
	handlersTLS := routerManager.BuildHandlers(ctx, f.entryPointsTCP, true)
	serviceManager.LaunchHealthCheck()
	// TCP
	svcTCPManager := tcp.NewManager(rtConf)
	middlewaresTCPBuilder := tcpmiddleware.NewBuilder(rtConf.TCPMiddlewares)
	rtTCPManager := tcprouter.NewManager(rtConf, svcTCPManager, middlewaresTCPBuilder, handlersNonTLS, handlersTLS, f.tlsManager)
	routersTCP := rtTCPManager.BuildHandlers(ctx, f.entryPointsTCP)
	// UDP
	svcUDPManager := udp.NewManager(rtConf)
	rtUDPManager := udprouter.NewManager(rtConf, svcUDPManager)
	routersUDP := rtUDPManager.BuildHandlers(ctx, f.entryPointsUDP)
	rtConf.PopulateUsedBy()
	return routersTCP, routersUDP
}
",CWE-295,99.0,1
"// Copyright 2020-2021 Clastix Labs
// SPDX-License-Identifier: Apache-2.0
package tenant
import (
	""context""
	""fmt""
	""strings""
	""golang.org/x/sync/errgroup""
	corev1 ""k8s.io/api/core/v1""
	""k8s.io/apimachinery/pkg/fields""
	""k8s.io/apimachinery/pkg/types""
	""k8s.io/client-go/util/retry""
	""sigs.k8s.io/controller-runtime/pkg/client""
	""sigs.k8s.io/controller-runtime/pkg/controller/controllerutil""
	capsulev1beta1 ""github.com/clastix/capsule/api/v1beta1""
)
// Ensuring all annotations are applied to each Namespace handled by the Tenant.
func (r *Manager) syncNamespaces(ctx context.Context, tenant *capsulev1beta1.Tenant) (err error) {
	group := new(errgroup.Group)
	for _, item := range tenant.Status.Namespaces {
		namespace := item
		group.Go(func() error {
			return r.syncNamespaceMetadata(ctx, namespace, tenant)
		})
	}
	if err = group.Wait(); err != nil {
		r.Log.Error(err, ""Cannot sync Namespaces"")
		err = fmt.Errorf(""cannot sync Namespaces: %w"", err)
	}
	return
}
// nolint:gocognit
func (r *Manager) syncNamespaceMetadata(ctx context.Context, namespace string, tnt *capsulev1beta1.Tenant) (err error) {
	var res controllerutil.OperationResult
	err = retry.RetryOnConflict(retry.DefaultBackoff, func() (conflictErr error) {
		ns := &corev1.Namespace{}
		if conflictErr = r.Client.Get(ctx, types.NamespacedName{Name: namespace}, ns); err != nil {
			return
		}
		capsuleLabel, _ := capsulev1beta1.GetTypeLabel(&capsulev1beta1.Tenant{})
		res, conflictErr = controllerutil.CreateOrUpdate(ctx, r.Client, ns, func() error {
			annotations := make(map[string]string)
			labels := map[string]string{
				""name"":       namespace,
				capsuleLabel: tnt.GetName(),
			}
			if tnt.Spec.NamespaceOptions != nil && tnt.Spec.NamespaceOptions.AdditionalMetadata != nil {
				for k, v := range tnt.Spec.NamespaceOptions.AdditionalMetadata.Annotations {
					annotations[k] = v
				}
			}
			if tnt.Spec.NamespaceOptions != nil && tnt.Spec.NamespaceOptions.AdditionalMetadata != nil {
				for k, v := range tnt.Spec.NamespaceOptions.AdditionalMetadata.Labels {
					labels[k] = v
				}
			}
			if tnt.Spec.NodeSelector != nil {
				var selector []string
				for k, v := range tnt.Spec.NodeSelector {
					selector = append(selector, fmt.Sprintf(""%s=%s"", k, v))
				}
				annotations[""scheduler.alpha.kubernetes.io/node-selector""] = strings.Join(selector, "","")
			}
			if tnt.Spec.IngressOptions.AllowedClasses != nil {
				if len(tnt.Spec.IngressOptions.AllowedClasses.Exact) > 0 {
					annotations[capsulev1beta1.AvailableIngressClassesAnnotation] = strings.Join(tnt.Spec.IngressOptions.AllowedClasses.Exact, "","")
				}
				if len(tnt.Spec.IngressOptions.AllowedClasses.Regex) > 0 {
					annotations[capsulev1beta1.AvailableIngressClassesRegexpAnnotation] = tnt.Spec.IngressOptions.AllowedClasses.Regex
				}
			}
			if tnt.Spec.StorageClasses != nil {
				if len(tnt.Spec.StorageClasses.Exact) > 0 {
					annotations[capsulev1beta1.AvailableStorageClassesAnnotation] = strings.Join(tnt.Spec.StorageClasses.Exact, "","")
				}
				if len(tnt.Spec.StorageClasses.Regex) > 0 {
					annotations[capsulev1beta1.AvailableStorageClassesRegexpAnnotation] = tnt.Spec.StorageClasses.Regex
				}
			}
			if tnt.Spec.ContainerRegistries != nil {
				if len(tnt.Spec.ContainerRegistries.Exact) > 0 {
					annotations[capsulev1beta1.AllowedRegistriesAnnotation] = strings.Join(tnt.Spec.ContainerRegistries.Exact, "","")
				}
				if len(tnt.Spec.ContainerRegistries.Regex) > 0 {
					annotations[capsulev1beta1.AllowedRegistriesRegexpAnnotation] = tnt.Spec.ContainerRegistries.Regex
				}
			}
			if value, ok := tnt.Annotations[capsulev1beta1.ForbiddenNamespaceLabelsAnnotation]; ok {
				annotations[capsulev1beta1.ForbiddenNamespaceLabelsAnnotation] = value
			}
			if value, ok := tnt.Annotations[capsulev1beta1.ForbiddenNamespaceLabelsRegexpAnnotation]; ok {
				annotations[capsulev1beta1.ForbiddenNamespaceLabelsRegexpAnnotation] = value
			}
			if value, ok := tnt.Annotations[capsulev1beta1.ForbiddenNamespaceAnnotationsAnnotation]; ok {
				annotations[capsulev1beta1.ForbiddenNamespaceAnnotationsAnnotation] = value
			}
			if value, ok := tnt.Annotations[capsulev1beta1.ForbiddenNamespaceAnnotationsRegexpAnnotation]; ok {
				annotations[capsulev1beta1.ForbiddenNamespaceAnnotationsRegexpAnnotation] = value
			}
			if ns.Annotations == nil {
				ns.SetAnnotations(annotations)
			} else {
				for k, v := range annotations {
					ns.Annotations[k] = v
				}
			}
			if ns.Labels == nil {
				ns.SetLabels(labels)
			} else {
				for k, v := range labels {
					ns.Labels[k] = v
				}
			}
			return nil
		})
		return
	})
	r.emitEvent(tnt, namespace, res, ""Ensuring Namespace metadata"", err)
	return err
}
func (r *Manager) ensureNamespaceCount(ctx context.Context, tenant *capsulev1beta1.Tenant) error {
	return retry.RetryOnConflict(retry.DefaultBackoff, func() error {
		tenant.Status.Size = uint(len(tenant.Status.Namespaces))
		found := &capsulev1beta1.Tenant{}
		if err := r.Client.Get(ctx, types.NamespacedName{Name: tenant.GetName()}, found); err != nil {
			return err
		}
		found.Status.Size = tenant.Status.Size
		return r.Client.Status().Update(ctx, found, &client.UpdateOptions{})
	})
}
func (r *Manager) collectNamespaces(ctx context.Context, tenant *capsulev1beta1.Tenant) error {
	return retry.RetryOnConflict(retry.DefaultBackoff, func() (err error) {
		list := &corev1.NamespaceList{}
		err = r.Client.List(ctx, list, client.MatchingFieldsSelector{
			Selector: fields.OneTermEqualSelector("".metadata.ownerReferences[*].capsule"", tenant.GetName()),
		})
		if err != nil {
			return
		}
		_, err = controllerutil.CreateOrUpdate(ctx, r.Client, tenant.DeepCopy(), func() error {
			tenant.AssignNamespaces(list.Items)
			return r.Client.Status().Update(ctx, tenant, &client.UpdateOptions{})
		})
		return
	})
}
",CWE-863,187.0,1
"// Copyright 2020-2021 Clastix Labs
// SPDX-License-Identifier: Apache-2.0
package namespace
import (
	""context""
	corev1 ""k8s.io/api/core/v1""
	""k8s.io/apimachinery/pkg/fields""
	""k8s.io/apimachinery/pkg/types""
	""k8s.io/client-go/tools/record""
	""sigs.k8s.io/controller-runtime/pkg/client""
	""sigs.k8s.io/controller-runtime/pkg/webhook/admission""
	capsulev1beta1 ""github.com/clastix/capsule/api/v1beta1""
	""github.com/clastix/capsule/pkg/configuration""
	capsulewebhook ""github.com/clastix/capsule/pkg/webhook""
	""github.com/clastix/capsule/pkg/webhook/utils""
)
type freezedHandler struct {
	configuration configuration.Configuration
}
func FreezeHandler(configuration configuration.Configuration) capsulewebhook.Handler {
	return &freezedHandler{configuration: configuration}
}
func (r *freezedHandler) OnCreate(client client.Client, decoder *admission.Decoder, recorder record.EventRecorder) capsulewebhook.Func {
	return func(ctx context.Context, req admission.Request) *admission.Response {
		ns := &corev1.Namespace{}
		if err := decoder.Decode(req, ns); err != nil {
			return utils.ErroredResponse(err)
		}
		for _, objectRef := range ns.ObjectMeta.OwnerReferences {
			// retrieving the selected Tenant
			tnt := &capsulev1beta1.Tenant{}
			if err := client.Get(ctx, types.NamespacedName{Name: objectRef.Name}, tnt); err != nil {
				return utils.ErroredResponse(err)
			}
			if tnt.IsCordoned() {
				recorder.Eventf(tnt, corev1.EventTypeWarning, ""TenantFreezed"", ""Namespace %s cannot be attached, the current Tenant is freezed"", ns.GetName())
				response := admission.Denied(""the selected Tenant is freezed"")
				return &response
			}
		}
		// creating NS that is not bounded to any Tenant
		return nil
	}
}
func (r *freezedHandler) OnDelete(c client.Client, _ *admission.Decoder, recorder record.EventRecorder) capsulewebhook.Func {
	return func(ctx context.Context, req admission.Request) *admission.Response {
		tntList := &capsulev1beta1.TenantList{}
		if err := c.List(ctx, tntList, client.MatchingFieldsSelector{
			Selector: fields.OneTermEqualSelector("".status.namespaces"", req.Name),
		}); err != nil {
			return utils.ErroredResponse(err)
		}
		if len(tntList.Items) == 0 {
			return nil
		}
		tnt := tntList.Items[0]
		if tnt.IsCordoned() && utils.IsCapsuleUser(req, r.configuration.UserGroups()) {
			recorder.Eventf(&tnt, corev1.EventTypeWarning, ""TenantFreezed"", ""Namespace %s cannot be deleted, the current Tenant is freezed"", req.Name)
			response := admission.Denied(""the selected Tenant is freezed"")
			return &response
		}
		return nil
	}
}
func (r *freezedHandler) OnUpdate(c client.Client, decoder *admission.Decoder, recorder record.EventRecorder) capsulewebhook.Func {
	return func(ctx context.Context, req admission.Request) *admission.Response {
		ns := &corev1.Namespace{}
		if err := decoder.Decode(req, ns); err != nil {
			return utils.ErroredResponse(err)
		}
		tntList := &capsulev1beta1.TenantList{}
		if err := c.List(ctx, tntList, client.MatchingFieldsSelector{
			Selector: fields.OneTermEqualSelector("".status.namespaces"", ns.Name),
		}); err != nil {
			return utils.ErroredResponse(err)
		}
		if len(tntList.Items) == 0 {
			return nil
		}
		tnt := tntList.Items[0]
		if tnt.IsCordoned() && utils.IsCapsuleUser(req, r.configuration.UserGroups()) {
			recorder.Eventf(&tnt, corev1.EventTypeWarning, ""TenantFreezed"", ""Namespace %s cannot be updated, the current Tenant is freezed"", ns.GetName())
			response := admission.Denied(""the selected Tenant is freezed"")
			return &response
		}
		return nil
	}
}
",CWE-863,115.0,1
"// Copyright 2020-2021 Clastix Labs
// SPDX-License-Identifier: Apache-2.0
package namespace
import (
	""context""
	""fmt""
	""net/http""
	corev1 ""k8s.io/api/core/v1""
	""k8s.io/apimachinery/pkg/types""
	""k8s.io/client-go/tools/record""
	""sigs.k8s.io/controller-runtime/pkg/client""
	""sigs.k8s.io/controller-runtime/pkg/webhook/admission""
	capsulev1beta1 ""github.com/clastix/capsule/api/v1beta1""
	capsulewebhook ""github.com/clastix/capsule/pkg/webhook""
	""github.com/clastix/capsule/pkg/webhook/utils""
)
type patchHandler struct{}
func PatchHandler() capsulewebhook.Handler {
	return &patchHandler{}
}
func (r *patchHandler) OnCreate(client.Client, *admission.Decoder, record.EventRecorder) capsulewebhook.Func {
	return func(ctx context.Context, req admission.Request) *admission.Response {
		return nil
	}
}
func (r *patchHandler) OnDelete(client.Client, *admission.Decoder, record.EventRecorder) capsulewebhook.Func {
	return func(ctx context.Context, req admission.Request) *admission.Response {
		return nil
	}
}
func (r *patchHandler) OnUpdate(c client.Client, decoder *admission.Decoder, recorder record.EventRecorder) capsulewebhook.Func {
	return func(ctx context.Context, req admission.Request) *admission.Response {
		// Decode Namespace
		ns := &corev1.Namespace{}
		if err := decoder.DecodeRaw(req.OldObject, ns); err != nil {
			return utils.ErroredResponse(err)
		}
		// Get Tenant Label
		ln, err := capsulev1beta1.GetTypeLabel(&capsulev1beta1.Tenant{})
		if err != nil {
			response := admission.Errored(http.StatusBadRequest, err)
			return &response
		}
		// Extract Tenant from namespace
		e := fmt.Sprintf(""namespace/%s can not be patched"", ns.Name)
		if label, ok := ns.ObjectMeta.Labels[ln]; ok {
			// retrieving the selected Tenant
			tnt := &capsulev1beta1.Tenant{}
			if err = c.Get(ctx, types.NamespacedName{Name: label}, tnt); err != nil {
				response := admission.Errored(http.StatusBadRequest, err)
				return &response
			}
			if !utils.IsTenantOwner(tnt.Spec.Owners, req.UserInfo) {
				recorder.Eventf(tnt, corev1.EventTypeWarning, ""NamespacePatch"", e)
				response := admission.Denied(e)
				return &response
			}
		} else {
			recorder.Eventf(ns, corev1.EventTypeWarning, ""NamespacePatch"", e)
			response := admission.Denied(e)
			return &response
		}
		return nil
	}
}
",CWE-863,83.0,1
"// Copyright 2020-2021 Clastix Labs
// SPDX-License-Identifier: Apache-2.0
package namespace
import (
	""context""
	""fmt""
	corev1 ""k8s.io/api/core/v1""
	""k8s.io/apimachinery/pkg/types""
	""k8s.io/client-go/tools/record""
	""sigs.k8s.io/controller-runtime/pkg/client""
	""sigs.k8s.io/controller-runtime/pkg/webhook/admission""
	capsulev1beta1 ""github.com/clastix/capsule/api/v1beta1""
	capsulewebhook ""github.com/clastix/capsule/pkg/webhook""
	""github.com/clastix/capsule/pkg/webhook/utils""
)
type userMetadataHandler struct{}
func UserMetadataHandler() capsulewebhook.Handler {
	return &userMetadataHandler{}
}
func (r *userMetadataHandler) validateUserMetadata(tnt *capsulev1beta1.Tenant, recorder record.EventRecorder, labels map[string]string, annotations map[string]string) *admission.Response {
	if tnt.ForbiddenUserNamespaceLabels() != nil {
		forbiddenLabels := tnt.ForbiddenUserNamespaceLabels()
		for label := range labels {
			var forbidden, matched bool
			forbidden = forbiddenLabels.ExactMatch(label)
			matched = forbiddenLabels.RegexMatch(label)
			if forbidden || matched {
				recorder.Eventf(tnt, corev1.EventTypeWarning, ""ForbiddenNamespaceLabel"", fmt.Sprintf(""Label %s is forbidden for a namespaces of the current Tenant "", label))
				response := admission.Denied(NewNamespaceLabelForbiddenError(label, forbiddenLabels).Error())
				return &response
			}
		}
	}
	if tnt.ForbiddenUserNamespaceAnnotations() != nil {
		forbiddenAnnotations := tnt.ForbiddenUserNamespaceLabels()
		for annotation := range annotations {
			var forbidden, matched bool
			forbidden = forbiddenAnnotations.ExactMatch(annotation)
			matched = forbiddenAnnotations.RegexMatch(annotation)
			if forbidden || matched {
				recorder.Eventf(tnt, corev1.EventTypeWarning, ""ForbiddenNamespaceAnnotation"", fmt.Sprintf(""Annotation %s is forbidden for a namespaces of the current Tenant "", annotation))
				response := admission.Denied(NewNamespaceAnnotationForbiddenError(annotation, forbiddenAnnotations).Error())
				return &response
			}
		}
	}
	return nil
}
func (r *userMetadataHandler) OnCreate(client client.Client, decoder *admission.Decoder, recorder record.EventRecorder) capsulewebhook.Func {
	return func(ctx context.Context, req admission.Request) *admission.Response {
		ns := &corev1.Namespace{}
		if err := decoder.Decode(req, ns); err != nil {
			return utils.ErroredResponse(err)
		}
		tnt := &capsulev1beta1.Tenant{}
		for _, objectRef := range ns.ObjectMeta.OwnerReferences {
			// retrieving the selected Tenant
			if err := client.Get(ctx, types.NamespacedName{Name: objectRef.Name}, tnt); err != nil {
				return utils.ErroredResponse(err)
			}
		}
		labels := ns.GetLabels()
		annotations := ns.GetAnnotations()
		return r.validateUserMetadata(tnt, recorder, labels, annotations)
	}
}
func (r *userMetadataHandler) OnDelete(client client.Client, decoder *admission.Decoder, recorder record.EventRecorder) capsulewebhook.Func {
	return func(ctx context.Context, req admission.Request) *admission.Response {
		return nil
	}
}
func (r *userMetadataHandler) OnUpdate(client client.Client, decoder *admission.Decoder, recorder record.EventRecorder) capsulewebhook.Func {
	return func(ctx context.Context, req admission.Request) *admission.Response {
		oldNs := &corev1.Namespace{}
		if err := decoder.DecodeRaw(req.OldObject, oldNs); err != nil {
			return utils.ErroredResponse(err)
		}
		newNs := &corev1.Namespace{}
		if err := decoder.Decode(req, newNs); err != nil {
			return utils.ErroredResponse(err)
		}
		tnt := &capsulev1beta1.Tenant{}
		for _, objectRef := range newNs.ObjectMeta.OwnerReferences {
			// retrieving the selected Tenant
			if err := client.Get(ctx, types.NamespacedName{Name: objectRef.Name}, tnt); err != nil {
				return utils.ErroredResponse(err)
			}
		}
		var labels, annotations map[string]string
		for key, value := range newNs.GetLabels() {
			if _, ok := oldNs.GetLabels()[key]; ok {
				if labels == nil {
					labels = make(map[string]string)
				}
				labels[key] = value
			}
		}
		for key, value := range newNs.GetAnnotations() {
			if _, ok := oldNs.GetAnnotations()[key]; ok {
				if annotations == nil {
					annotations = make(map[string]string)
				}
				annotations[key] = value
			}
		}
		return r.validateUserMetadata(tnt, recorder, labels, annotations)
	}
}
",CWE-863,140.0,1
"// Copyright 2020-2021 Clastix Labs
// SPDX-License-Identifier: Apache-2.0
package tenant
import (
	""context""
	""fmt""
	""strings""
	corev1 ""k8s.io/api/core/v1""
	""k8s.io/apimachinery/pkg/fields""
	""k8s.io/client-go/tools/record""
	""sigs.k8s.io/controller-runtime/pkg/client""
	""sigs.k8s.io/controller-runtime/pkg/webhook/admission""
	capsulev1beta1 ""github.com/clastix/capsule/api/v1beta1""
	""github.com/clastix/capsule/pkg/configuration""
	capsulewebhook ""github.com/clastix/capsule/pkg/webhook""
	""github.com/clastix/capsule/pkg/webhook/utils""
)
type cordoningHandler struct {
	configuration configuration.Configuration
}
func CordoningHandler(configuration configuration.Configuration) capsulewebhook.Handler {
	return &cordoningHandler{
		configuration: configuration,
	}
}
func (h *cordoningHandler) cordonHandler(ctx context.Context, clt client.Client, req admission.Request, recorder record.EventRecorder) *admission.Response {
	tntList := &capsulev1beta1.TenantList{}
	if err := clt.List(ctx, tntList, client.MatchingFieldsSelector{
		Selector: fields.OneTermEqualSelector("".status.namespaces"", req.Namespace),
	}); err != nil {
		return utils.ErroredResponse(err)
	}
	// resource is not inside a Tenant namespace
	if len(tntList.Items) == 0 {
		return nil
	}
	tnt := tntList.Items[0]
	if tnt.IsCordoned() && utils.IsCapsuleUser(req, h.configuration.UserGroups()) {
		recorder.Eventf(&tnt, corev1.EventTypeWarning, ""TenantFreezed"", ""%s %s/%s cannot be %sd, current Tenant is freezed"", req.Kind.String(), req.Namespace, req.Name, strings.ToLower(string(req.Operation)))
		response := admission.Denied(fmt.Sprintf(""tenant %s is freezed: please, reach out to the system administrator"", tnt.GetName()))
		return &response
	}
	return nil
}
func (h *cordoningHandler) OnCreate(client client.Client, _ *admission.Decoder, recorder record.EventRecorder) capsulewebhook.Func {
	return func(ctx context.Context, req admission.Request) *admission.Response {
		return h.cordonHandler(ctx, client, req, recorder)
	}
}
func (h *cordoningHandler) OnDelete(client client.Client, _ *admission.Decoder, recorder record.EventRecorder) capsulewebhook.Func {
	return func(ctx context.Context, req admission.Request) *admission.Response {
		return h.cordonHandler(ctx, client, req, recorder)
	}
}
func (h *cordoningHandler) OnUpdate(client client.Client, _ *admission.Decoder, recorder record.EventRecorder) capsulewebhook.Func {
	return func(ctx context.Context, req admission.Request) *admission.Response {
		return h.cordonHandler(ctx, client, req, recorder)
	}
}
",CWE-863,75.0,1
"// Copyright 2020-2021 Clastix Labs
// SPDX-License-Identifier: Apache-2.0
package utils
import (
	""context""
	""k8s.io/client-go/tools/record""
	""sigs.k8s.io/controller-runtime/pkg/client""
	""sigs.k8s.io/controller-runtime/pkg/webhook/admission""
	""github.com/clastix/capsule/pkg/configuration""
	""github.com/clastix/capsule/pkg/webhook""
)
func InCapsuleGroups(configuration configuration.Configuration, handlers ...webhook.Handler) webhook.Handler {
	return &handler{
		configuration: configuration,
		handlers:      handlers,
	}
}
type handler struct {
	configuration configuration.Configuration
	handlers      []webhook.Handler
}
func (h *handler) OnCreate(client client.Client, decoder *admission.Decoder, recorder record.EventRecorder) webhook.Func {
	return func(ctx context.Context, req admission.Request) *admission.Response {
		if !IsCapsuleUser(req, h.configuration.UserGroups()) {
			return nil
		}
		for _, hndl := range h.handlers {
			if response := hndl.OnCreate(client, decoder, recorder)(ctx, req); response != nil {
				return response
			}
		}
		return nil
	}
}
func (h *handler) OnDelete(client client.Client, decoder *admission.Decoder, recorder record.EventRecorder) webhook.Func {
	return func(ctx context.Context, req admission.Request) *admission.Response {
		if !IsCapsuleUser(req, h.configuration.UserGroups()) {
			return nil
		}
		for _, hndl := range h.handlers {
			if response := hndl.OnDelete(client, decoder, recorder)(ctx, req); response != nil {
				return response
			}
		}
		return nil
	}
}
func (h *handler) OnUpdate(client client.Client, decoder *admission.Decoder, recorder record.EventRecorder) webhook.Func {
	return func(ctx context.Context, req admission.Request) *admission.Response {
		if !IsCapsuleUser(req, h.configuration.UserGroups()) {
			return nil
		}
		for _, hndl := range h.handlers {
			if response := hndl.OnUpdate(client, decoder, recorder)(ctx, req); response != nil {
				return response
			}
		}
		return nil
	}
}
",CWE-863,76.0,1
"package utils
import (
	""sigs.k8s.io/controller-runtime/pkg/webhook/admission""
	""github.com/clastix/capsule/pkg/utils""
)
func IsCapsuleUser(req admission.Request, userGroups []string) bool {
	groupList := utils.NewUserGroupList(req.UserInfo.Groups)
	// if the user is a ServiceAccount belonging to the kube-system namespace, definitely, it's not a Capsule user
	// and we can skip the check in case of Capsule user group assigned to system:authenticated
	// (ref: https://github.com/clastix/capsule/issues/234)
	if groupList.Find(""system:serviceaccounts:kube-system"") {
		return false
	}
	for _, group := range userGroups {
		if groupList.Find(group) {
			return true
		}
	}
	return false
}
",CWE-863,26.0,1
"// +build ocr
package docconv
import (
	""fmt""
	""io""
	""io/ioutil""
	""log""
	""os""
	""os/exec""
	""path/filepath""
	""strings""
	""sync""
)
var (
	exts = []string{"".jpg"", "".tif"", "".tiff"", "".png"", "".pbm""}
)
func compareExt(ext string, exts []string) bool {
	for _, e := range exts {
		if ext == e {
			return true
		}
	}
	return false
}
func cleanupTemp(tmpDir string) {
	err := os.RemoveAll(tmpDir)
	if err != nil {
		log.Println(err)
	}
}
func ConvertPDFImages(path string) (BodyResult, error) {
	bodyResult := BodyResult{}
	tmp, err := ioutil.TempDir(os.TempDir(), ""tmp-imgs-"")
	if err != nil {
		bodyResult.err = err
		return bodyResult, err
	}
	tmpDir := fmt.Sprintf(""%s/"", tmp)
	defer cleanupTemp(tmpDir)
	_, err = exec.Command(""pdfimages"", ""-j"", path, tmpDir).Output()
	if err != nil {
		return bodyResult, err
	}
	filePaths := []string{}
	walkFunc := func(path string, info os.FileInfo, err error) error {
		path, err = filepath.Abs(path)
		if err != nil {
			return err
		}
		if compareExt(filepath.Ext(path), exts) {
			filePaths = append(filePaths, path)
		}
		return nil
	}
	filepath.Walk(tmpDir, walkFunc)
	fileLength := len(filePaths)
	if fileLength < 1 {
		return bodyResult, nil
	}
	var wg sync.WaitGroup
	data := make(chan string, fileLength)
	wg.Add(fileLength)
	for _, p := range filePaths {
		go func(pathFile string) {
			defer wg.Done()
			f, err := os.Open(pathFile)
			if err != nil {
				return
			}
			defer f.Close()
			out, _, err := ConvertImage(f)
			if err != nil {
				return
			}
			data <- out
		}(p)
	}
	wg.Wait()
	close(data)
	for str := range data {
		bodyResult.body += str + "" ""
	}
	return bodyResult, nil
}
// PdfHasImage verify if `path` (PDF) has images
func PDFHasImage(path string) bool {
	cmd := ""pdffonts -l 5 %s | tail -n +3 | cut -d' ' -f1 | sort | uniq""
	out, err := exec.Command(""bash"", ""-c"", fmt.Sprintf(cmd, path)).Output()
	if err != nil {
		log.Println(err)
		return false
	}
	if string(out) == """" {
		return true
	}
	return false
}
func ConvertPDF(r io.Reader) (string, map[string]string, error) {
	f, err := NewLocalFile(r)
	if err != nil {
		return """", nil, fmt.Errorf(""error creating local file: %v"", err)
	}
	defer f.Done()
	bodyResult, metaResult, textConvertErr := ConvertPDFText(f.Name())
	if textConvertErr != nil {
		return """", nil, textConvertErr
	}
	if bodyResult.err != nil {
		return """", nil, bodyResult.err
	}
	if metaResult.err != nil {
		return """", nil, metaResult.err
	}
	if !PDFHasImage(f.Name()) {
		return bodyResult.body, metaResult.meta, nil
	}
	imageConvertResult, imageConvertErr := ConvertPDFImages(f.Name())
	if imageConvertErr != nil {
		log.Println(imageConvertErr)
		return bodyResult.body, metaResult.meta, nil
	}
	if imageConvertResult.err != nil {
		log.Println(imageConvertResult.err)
		return bodyResult.body, metaResult.meta, nil
	}
	fullBody := strings.Join([]string{bodyResult.body, imageConvertResult.body}, "" "")
	return fullBody, metaResult.meta, nil
}
",CWE-78,162.0,1
"package docconv
import (
	""archive/zip""
	""bytes""
	""encoding/xml""
	""fmt""
	""io""
	""io/ioutil""
	""os""
	""time""
)
type typeOverride struct {
	XMLName     xml.Name `xml:""Override""`
	ContentType string   `xml:""ContentType,attr""`
	PartName    string   `xml:""PartName,attr""`
}
type contentTypeDefinition struct {
	XMLName   xml.Name       `xml:""Types""`
	Overrides []typeOverride `xml:""Override""`
}
// ConvertDocx converts an MS Word docx file to text.
func ConvertDocx(r io.Reader) (string, map[string]string, error) {
	var size int64
	// Common case: if the reader is a file (or trivial wrapper), avoid
	// loading it all into memory.
	var ra io.ReaderAt
	if f, ok := r.(interface {
		io.ReaderAt
		Stat() (os.FileInfo, error)
	}); ok {
		si, err := f.Stat()
		if err != nil {
			return """", nil, err
		}
		size = si.Size()
		ra = f
	} else {
		b, err := ioutil.ReadAll(r)
		if err != nil {
			return """", nil, nil
		}
		size = int64(len(b))
		ra = bytes.NewReader(b)
	}
	zr, err := zip.NewReader(ra, size)
	if err != nil {
		return """", nil, fmt.Errorf(""error unzipping data: %v"", err)
	}
	zipFiles := mapZipFiles(zr.File)
	contentTypeDefinition, err := getContentTypeDefinition(zipFiles[""[Content_Types].xml""])
	if err != nil {
		return """", nil, err
	}
	meta := make(map[string]string)
	var textHeader, textBody, textFooter string
	for _, override := range contentTypeDefinition.Overrides {
		f := zipFiles[override.PartName]
		switch {
		case override.ContentType == ""application/vnd.openxmlformats-package.core-properties+xml"":
			rc, err := f.Open()
			if err != nil {
				return """", nil, fmt.Errorf(""error opening '%v' from archive: %v"", f.Name, err)
			}
			defer rc.Close()
			meta, err = XMLToMap(rc)
			if err != nil {
				return """", nil, fmt.Errorf(""error parsing '%v': %v"", f.Name, err)
			}
			if tmp, ok := meta[""modified""]; ok {
				if t, err := time.Parse(time.RFC3339, tmp); err == nil {
					meta[""ModifiedDate""] = fmt.Sprintf(""%d"", t.Unix())
				}
			}
			if tmp, ok := meta[""created""]; ok {
				if t, err := time.Parse(time.RFC3339, tmp); err == nil {
					meta[""CreatedDate""] = fmt.Sprintf(""%d"", t.Unix())
				}
			}
		case override.ContentType == ""application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml"":
			body, err := parseDocxText(f)
			if err != nil {
				return """", nil, err
			}
			textBody += body + ""\n""
		case override.ContentType == ""application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml"":
			footer, err := parseDocxText(f)
			if err != nil {
				return """", nil, err
			}
			textFooter += footer + ""\n""
		case override.ContentType == ""application/vnd.openxmlformats-officedocument.wordprocessingml.header+xml"":
			header, err := parseDocxText(f)
			if err != nil {
				return """", nil, err
			}
			textHeader += header + ""\n""
		}
	}
	return textHeader + ""\n"" + textBody + ""\n"" + textFooter, meta, nil
}
func getContentTypeDefinition(zf *zip.File) (*contentTypeDefinition, error) {
	f, err := zf.Open()
	if err != nil {
		return nil, err
	}
	defer f.Close()
	x := &contentTypeDefinition{}
	if err := xml.NewDecoder(f).Decode(x); err != nil {
		return nil, err
	}
	return x, nil
}
func mapZipFiles(files []*zip.File) map[string]*zip.File {
	filesMap := make(map[string]*zip.File, 2*len(files))
	for _, f := range files {
		filesMap[f.Name] = f
		filesMap[""/""+f.Name] = f
	}
	return filesMap
}
func parseDocxText(f *zip.File) (string, error) {
	r, err := f.Open()
	if err != nil {
		return """", fmt.Errorf(""error opening '%v' from archive: %v"", f.Name, err)
	}
	defer r.Close()
	text, err := DocxXMLToText(r)
	if err != nil {
		return """", fmt.Errorf(""error parsing '%v': %v"", f.Name, err)
	}
	return text, nil
}
// DocxXMLToText converts Docx XML into plain text.
func DocxXMLToText(r io.Reader) (string, error) {
	return XMLToText(r, []string{""br"", ""p"", ""tab""}, []string{""instrText"", ""script""}, true)
}
",CWE-789,156.0,1
"package docconv
import (
	""archive/zip""
	""bytes""
	""fmt""
	""io""
	""io/ioutil""
	""time""
)
// ConvertODT converts a ODT file to text
func ConvertODT(r io.Reader) (string, map[string]string, error) {
	meta := make(map[string]string)
	var textBody string
	b, err := ioutil.ReadAll(r)
	if err != nil {
		return """", nil, err
	}
	zr, err := zip.NewReader(bytes.NewReader(b), int64(len(b)))
	if err != nil {
		return """", nil, fmt.Errorf(""error unzipping data: %v"", err)
	}
	for _, f := range zr.File {
		switch f.Name {
		case ""meta.xml"":
			rc, err := f.Open()
			if err != nil {
				return """", nil, fmt.Errorf(""error extracting '%v' from archive: %v"", f.Name, err)
			}
			defer rc.Close()
			info, err := XMLToMap(rc)
			if err != nil {
				return """", nil, fmt.Errorf(""error parsing '%v': %v"", f.Name, err)
			}
			if tmp, ok := info[""creator""]; ok {
				meta[""Author""] = tmp
			}
			if tmp, ok := info[""date""]; ok {
				if t, err := time.Parse(""2006-01-02T15:04:05"", tmp); err == nil {
					meta[""ModifiedDate""] = fmt.Sprintf(""%d"", t.Unix())
				}
			}
			if tmp, ok := info[""creation-date""]; ok {
				if t, err := time.Parse(""2006-01-02T15:04:05"", tmp); err == nil {
					meta[""CreatedDate""] = fmt.Sprintf(""%d"", t.Unix())
				}
			}
		case ""content.xml"":
			rc, err := f.Open()
			if err != nil {
				return """", nil, fmt.Errorf(""error extracting '%v' from archive: %v"", f.Name, err)
			}
			defer rc.Close()
			textBody, err = XMLToText(rc, []string{""br"", ""p"", ""tab""}, []string{}, true)
			if err != nil {
				return """", nil, fmt.Errorf(""error parsing '%v': %v"", f.Name, err)
			}
		}
	}
	return textBody, meta, nil
}
",CWE-789,70.0,1
"package docconv
import (
	""archive/zip""
	""bufio""
	""bytes""
	""encoding/binary""
	""fmt""
	""io""
	""io/ioutil""
	""strings""
	""google.golang.org/protobuf/proto""
	TSP ""code.sajari.com/docconv/iWork""
	""code.sajari.com/docconv/snappy""
)
// ConvertPages converts a Pages file to text.
func ConvertPages(r io.Reader) (string, map[string]string, error) {
	meta := make(map[string]string)
	var textBody string
	b, err := ioutil.ReadAll(r)
	if err != nil {
		return """", nil, fmt.Errorf(""error reading data: %v"", err)
	}
	zr, err := zip.NewReader(bytes.NewReader(b), int64(len(b)))
	if err != nil {
		return """", nil, fmt.Errorf(""error unzipping data: %v"", err)
	}
	for _, f := range zr.File {
		if strings.HasSuffix(f.Name, ""Preview.pdf"") {
			// There is a preview PDF version we can use
			if rc, err := f.Open(); err == nil {
				return ConvertPDF(rc)
			}
		}
		if f.Name == ""index.xml"" {
			// There's an XML version we can use
			if rc, err := f.Open(); err == nil {
				return ConvertXML(rc)
			}
		}
		if f.Name == ""Index/Document.iwa"" {
			rc, _ := f.Open()
			defer rc.Close()
			bReader := bufio.NewReader(snappy.NewReader(io.MultiReader(strings.NewReader(""\xff\x06\x00\x00sNaPpY""), rc)))
			// Ignore error.
			// NOTE: This error was unchecked. Need to revisit this to see if it
			// should be acted on.
			archiveLength, _ := binary.ReadVarint(bReader)
			// Ignore error.
			// NOTE: This error was unchecked. Need to revisit this to see if it
			// should be acted on.
			archiveInfoData, _ := ioutil.ReadAll(io.LimitReader(bReader, archiveLength))
			archiveInfo := &TSP.ArchiveInfo{}
			err = proto.Unmarshal(archiveInfoData, archiveInfo)
			fmt.Println(""archiveInfo:"", archiveInfo, err)
		}
	}
	return textBody, meta, nil
}
",CWE-789,70.0,1
"package docconv
import (
	""bytes""
	""encoding/xml""
	""fmt""
	""io""
)
// ConvertXML converts an XML file to text.
func ConvertXML(r io.Reader) (string, map[string]string, error) {
	meta := make(map[string]string)
	cleanXML, err := Tidy(r, true)
	if err != nil {
		return """", nil, fmt.Errorf(""tidy error: %v"", err)
	}
	result, err := XMLToText(bytes.NewReader(cleanXML), []string{}, []string{}, true)
	if err != nil {
		return """", nil, fmt.Errorf(""error from XMLToText: %v"", err)
	}
	return result, meta, nil
}
// XMLToText converts XML to plain text given how to treat elements.
func XMLToText(r io.Reader, breaks []string, skip []string, strict bool) (string, error) {
	var result string
	dec := xml.NewDecoder(r)
	dec.Strict = strict
	for {
		t, err := dec.Token()
		if err != nil {
			if err == io.EOF {
				break
			}
			return """", err
		}
		switch v := t.(type) {
		case xml.CharData:
			result += string(v)
		case xml.StartElement:
			for _, breakElement := range breaks {
				if v.Name.Local == breakElement {
					result += ""\n""
				}
			}
			for _, skipElement := range skip {
				if v.Name.Local == skipElement {
					depth := 1
					for {
						t, err := dec.Token()
						if err != nil {
							// An io.EOF here is actually an error.
							return """", err
						}
						switch t.(type) {
						case xml.StartElement:
							depth++
						case xml.EndElement:
							depth--
						}
						if depth == 0 {
							break
						}
					}
				}
			}
		}
	}
	return result, nil
}
// XMLToMap converts XML to a nested string map.
func XMLToMap(r io.Reader) (map[string]string, error) {
	m := make(map[string]string)
	dec := xml.NewDecoder(r)
	var tagName string
	for {
		t, err := dec.Token()
		if err != nil {
			if err == io.EOF {
				break
			}
			return nil, err
		}
		switch v := t.(type) {
		case xml.StartElement:
			tagName = string(v.Name.Local)
		case xml.CharData:
			m[tagName] = string(v)
		}
	}
	return m, nil
}
",CWE-789,99.0,1
"SSH_KEY_1 = (
    ""ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDCUQeasspT/etEJR2WUoR+h2sMOQYbJgr0QE+J8p97gEhmz107KWZ+3""
    ""mbOwyIFzfWBcJZCEg9wy5Paj+YxbGONqbpXAhPdVQ2TLgxr41bNXvbcRAxZC+Q12UZywR4Klb2kungKz4qkcmSZzouaKK""
    ""12UxzGB3xQ0N+3osKFj3xA1+B6HqrVreU19XdVoAJh0xLZwhw17/NDM+dAcEdMZ9V89KyjwjraXtOVfFhQF0EDF0ame8d""
    ""6UkayGrAiXC2He0P2Cja+J371P27AlNLHFJij8WGxvcGGSeAxMLoVSDOOllLCYH5UieV8mNpX1kNe2LeA58ciZb0AXHai""
    ""pSmCHgh/ some-comment""
)
SSH_KEY_2 = (
    ""ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDF1DyXlqc40AVUgt/IO0GFcTniaoFt5qCUAeNVlvalMnsrRULIXkb0g""
    ""1ds9P9/UI2jWr70ZYG7XieQX1F7NpzaDeUyPGCrLV1/ev1ZtUImCrDFfMznEjkcqB33mRe1rCFGKNVOYUviPE1yBdbfZB""
    ""GUuJBX2GOXQQj9fU4Hiq3rAgOhz89717mt+qZxZllZ4mdyVEaMBWCwqAvl7Z5ecDjB+llFpBORTmsT8OZoGbZnJTIB1d9""
    ""j0tSbegP17emE+g9fTrk4/ePmSIAKcSV3xj6h98AGesNibyu9eKVrroEptxX4crl0o95Me6B1/DCL632xrTO0a5mSmlF4""
    ""cxCgjLj9 to/ key2""
)
SSH_KEY_BAD = ""ssh-rsa AAAblahblahkey some-comment""
SSH_KEY_RSA_1024 = (
    ""ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAAAgQDhKgSsCJR9UyQa/Gsheb5F56hg23CVnCLpmpyC2JMqVEptG9CL83Oft""
    ""pOPvEb/785Act4En1VFvwMwTj25VurbG3XI984csiNdWPlM1ke4lHK2PQepSYyZVYn+hhXhzSILNDixhBYeDVv4GOfJM1""
    ""HBO2AEtupOMHOqtnQLjV1UnQ== rsa-1024""
)
SSH_KEY_DSA = (
    ""ssh-dss AAAAB3NzaC1kc3MAAACBAKdCbYh9GgDPFppJmyRcpWhFn3Xc5vcljGE20df84KYQeBVCQg3zTLkwynHyrpEwT""
    ""HmIc0bgH14muGwPOdt8CEtj9EvcPHHCEaZ/4IdT02awY+Opszq7LI/YXzfu3cbgOoB22zj+chhryCiMIisEBHQv00F54z""
    ""01yOi3mOX7BIZBAAAAFQDgX/4IaAAtnbQ3DeDbWSJVxdKtIQAAAIEAoUsqfKyrzmDLgLhLpJpVs5BPdziHxlJM1+cQuIa""
    ""VsTHe7tyu61hpColor2ybyhafKhJ3ZH9bsl8DASwkGQXyjOTL/T6IzVhlcCfeDtirwAwQNINz8xwplLIbCOLAAOdVrKE9""
    ""xHMO5RPXO8i58CFF7c5fm3vg87nLH+uh1AwFyysAAACABCca7QX1ZJIoIt37HxCwV3+ktcoVhoZhuzHNRe9l4CSKSeSdn""
    ""WrdaC8G7tvKPTrImYIPqSZz3ohLDioflMUN3yIHnO1VsDn0hwTa7x9c/RiGAkiwKagF1icGfzgEiMt7PTfJT/nMeFoahu""
    ""JEk8kasRtdm0VcM4JyOLiqej/8VRo= dsa-1024""
)
SSH_KEY_ECDSA_P256 = (
    ""ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBD7FwYV01qXgP2TManNEq""
    ""nOD/JXCp7WChDk7c3GiwHSlZVn3xvmtphQjzE6Ag4GDh/bFOaKIcGc66691GsOE6Vo= ecdsa-p256""
)
SSH_KEY_ED25519 = (
    ""ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIJXKRoCgQqJ0iyC51HOIJzPqjwZcvf3DF9IAwFQWwqop comment""
)
",CWE-74,43.0,1
"package collection
import (
	""context""
	""github.com/answerdev/answer/internal/base/constant""
	""github.com/answerdev/answer/internal/base/data""
	""github.com/answerdev/answer/internal/base/pager""
	""github.com/answerdev/answer/internal/base/reason""
	""github.com/answerdev/answer/internal/entity""
	collectioncommon ""github.com/answerdev/answer/internal/service/collection_common""
	""github.com/answerdev/answer/internal/service/unique""
	""github.com/segmentfault/pacman/errors""
)
// collectionRepo collection repository
type collectionRepo struct {
	data         *data.Data
	uniqueIDRepo unique.UniqueIDRepo
}
// NewCollectionRepo new repository
func NewCollectionRepo(data *data.Data, uniqueIDRepo unique.UniqueIDRepo) collectioncommon.CollectionRepo {
	return &collectionRepo{
		data:         data,
		uniqueIDRepo: uniqueIDRepo,
	}
}
// AddCollection add collection
func (cr *collectionRepo) AddCollection(ctx context.Context, collection *entity.Collection) (err error) {
	id, err := cr.uniqueIDRepo.GenUniqueIDStr(ctx, collection.TableName())
	if err == nil {
		collection.ID = id
		_, err = cr.data.DB.Insert(collection)
		if err != nil {
			return errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
		}
	}
	return nil
}
// RemoveCollection delete collection
func (cr *collectionRepo) RemoveCollection(ctx context.Context, id string) (err error) {
	_, err = cr.data.DB.Where(""id =?"", id).Delete(&entity.Collection{})
	if err != nil {
		return errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return nil
}
// UpdateCollection update collection
func (cr *collectionRepo) UpdateCollection(ctx context.Context, collection *entity.Collection, cols []string) (err error) {
	_, err = cr.data.DB.ID(collection.ID).Cols(cols...).Update(collection)
	return errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
}
// GetCollection get collection one
func (cr *collectionRepo) GetCollection(ctx context.Context, id int) (collection *entity.Collection, exist bool, err error) {
	collection = &entity.Collection{}
	exist, err = cr.data.DB.ID(id).Get(collection)
	if err != nil {
		return nil, false, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return
}
// GetCollectionList get collection list all
func (cr *collectionRepo) GetCollectionList(ctx context.Context, collection *entity.Collection) (collectionList []*entity.Collection, err error) {
	collectionList = make([]*entity.Collection, 0)
	err = cr.data.DB.Find(collectionList, collection)
	err = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	return
}
// GetOneByObjectIDAndUser get one by object TagID and user
func (cr *collectionRepo) GetOneByObjectIDAndUser(ctx context.Context, userID string, objectID string) (collection *entity.Collection, exist bool, err error) {
	collection = &entity.Collection{}
	exist, err = cr.data.DB.Where(""user_id = ? and object_id = ?"", userID, objectID).Get(collection)
	if err != nil {
		return nil, false, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return
}
// SearchByObjectIDsAndUser search by object IDs and user
func (cr *collectionRepo) SearchByObjectIDsAndUser(ctx context.Context, userID string, objectIDs []string) ([]*entity.Collection, error) {
	collectionList := make([]*entity.Collection, 0)
	err := cr.data.DB.Where(""user_id = ?"", userID).In(""object_id"", objectIDs).Find(&collectionList)
	if err != nil {
		return collectionList, err
	}
	return collectionList, nil
}
// CountByObjectID count by object TagID
func (cr *collectionRepo) CountByObjectID(ctx context.Context, objectID string) (total int64, err error) {
	collection := &entity.Collection{}
	total, err = cr.data.DB.Where(""object_id = ?"", objectID).Count(collection)
	if err != nil {
		return 0, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return
}
// GetCollectionPage get collection page
func (cr *collectionRepo) GetCollectionPage(ctx context.Context, page, pageSize int, collection *entity.Collection) (collectionList []*entity.Collection, total int64, err error) {
	collectionList = make([]*entity.Collection, 0)
	session := cr.data.DB.NewSession()
	if collection.UserID != """" && collection.UserID != ""0"" {
		session = session.Where(""user_id = ?"", collection.UserID)
	}
	if collection.UserCollectionGroupID != """" && collection.UserCollectionGroupID != ""0"" {
		session = session.Where(""user_collection_group_id = ?"", collection.UserCollectionGroupID)
	}
	session = session.OrderBy(""update_time desc"")
	total, err = pager.Help(page, pageSize, collectionList, collection, session)
	err = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	return
}
// SearchObjectCollected check object is collected or not
func (cr *collectionRepo) SearchObjectCollected(ctx context.Context, userID string, objectIds []string) (map[string]bool, error) {
	collectedMap := make(map[string]bool)
	list, err := cr.SearchByObjectIDsAndUser(ctx, userID, objectIds)
	if err != nil {
		err = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
		return collectedMap, err
	}
	for _, item := range list {
		collectedMap[item.ObjectID] = true
	}
	return collectedMap, err
}
// SearchList
func (cr *collectionRepo) SearchList(ctx context.Context, search *entity.CollectionSearch) ([]*entity.Collection, int64, error) {
	var count int64
	var err error
	rows := make([]*entity.Collection, 0)
	if search.Page > 0 {
		search.Page = search.Page - 1
	} else {
		search.Page = 0
	}
	if search.PageSize == 0 {
		search.PageSize = constant.DefaultPageSize
	}
	offset := search.Page * search.PageSize
	session := cr.data.DB.Where("""")
	if len(search.UserID) > 0 {
		session = session.And(""user_id = ?"", search.UserID)
	} else {
		return rows, count, nil
	}
	session = session.Limit(search.PageSize, offset)
	count, err = session.OrderBy(""updated_at desc"").FindAndCount(&rows)
	if err != nil {
		return rows, count, err
	}
	return rows, count, nil
}
",CWE-362,166.0,1
"package middleware
import (
	""fmt""
	""net/url""
	""os""
	""path/filepath""
	""strings""
	""github.com/answerdev/answer/internal/service/service_config""
	""github.com/answerdev/answer/internal/service/uploader""
	""github.com/answerdev/answer/pkg/converter""
	""github.com/gin-gonic/gin""
	""github.com/segmentfault/pacman/log""
)
type AvatarMiddleware struct {
	serviceConfig   *service_config.ServiceConfig
	uploaderService *uploader.UploaderService
}
// NewAvatarMiddleware new auth user middleware
func NewAvatarMiddleware(serviceConfig *service_config.ServiceConfig,
	uploaderService *uploader.UploaderService,
) *AvatarMiddleware {
	return &AvatarMiddleware{
		serviceConfig:   serviceConfig,
		uploaderService: uploaderService,
	}
}
func (am *AvatarMiddleware) AvatarThumb() gin.HandlerFunc {
	return func(ctx *gin.Context) {
		u := ctx.Request.RequestURI
		if strings.Contains(u, ""/uploads/avatar/"") {
			sizeStr := ctx.Query(""s"")
			size := converter.StringToInt(sizeStr)
			uUrl, err := url.Parse(u)
			if err != nil {
				ctx.Next()
				return
			}
			_, urlfileName := filepath.Split(uUrl.Path)
			uploadPath := am.serviceConfig.UploadPath
			filePath := fmt.Sprintf(""%s/avatar/%s"", uploadPath, urlfileName)
			var avatarfile []byte
			if size == 0 {
				avatarfile, err = os.ReadFile(filePath)
			} else {
				avatarfile, err = am.uploaderService.AvatarThumbFile(ctx, uploadPath, urlfileName, size)
			}
			if err != nil {
				ctx.Next()
				return
			}
			_, err = ctx.Writer.WriteString(string(avatarfile))
			if err != nil {
				log.Error(err)
			}
			ctx.Abort()
			return
		}
		ctx.Next()
	}
}
",CWE-79,67.0,1
"package converter
import (
	""bytes""
	""github.com/asaskevich/govalidator""
	""github.com/microcosm-cc/bluemonday""
	""github.com/segmentfault/pacman/log""
	""github.com/yuin/goldmark""
	""github.com/yuin/goldmark/ast""
	""github.com/yuin/goldmark/extension""
	""github.com/yuin/goldmark/parser""
	""github.com/yuin/goldmark/renderer""
	""github.com/yuin/goldmark/renderer/html""
	goldmarkHTML ""github.com/yuin/goldmark/renderer/html""
	""github.com/yuin/goldmark/util""
)
// Markdown2HTML convert markdown to html
func Markdown2HTML(source string) string {
	mdConverter := goldmark.New(
		goldmark.WithExtensions(&DangerousHTMLFilterExtension{}, extension.GFM),
		goldmark.WithParserOptions(
			parser.WithAutoHeadingID(),
		),
		goldmark.WithRendererOptions(
			goldmarkHTML.WithHardWraps(),
		),
	)
	var buf bytes.Buffer
	if err := mdConverter.Convert([]byte(source), &buf); err != nil {
		log.Error(err)
		return source
	}
	return buf.String()
}
type DangerousHTMLFilterExtension struct {
}
func (e *DangerousHTMLFilterExtension) Extend(m goldmark.Markdown) {
	m.Renderer().AddOptions(renderer.WithNodeRenderers(
		util.Prioritized(&DangerousHTMLRenderer{
			Config: goldmarkHTML.NewConfig(),
			Filter: bluemonday.UGCPolicy(),
		}, 1),
	))
}
type DangerousHTMLRenderer struct {
	goldmarkHTML.Config
	Filter *bluemonday.Policy
}
// RegisterFuncs implements renderer.NodeRenderer.RegisterFuncs.
func (r *DangerousHTMLRenderer) RegisterFuncs(reg renderer.NodeRendererFuncRegisterer) {
	reg.Register(ast.KindHTMLBlock, r.renderHTMLBlock)
	reg.Register(ast.KindRawHTML, r.renderRawHTML)
	reg.Register(ast.KindLink, r.renderLink)
	reg.Register(ast.KindAutoLink, r.renderAutoLink)
}
func (r *DangerousHTMLRenderer) renderRawHTML(w util.BufWriter, source []byte, node ast.Node, entering bool) (ast.WalkStatus, error) {
	if !entering {
		return ast.WalkSkipChildren, nil
	}
	n := node.(*ast.RawHTML)
	l := n.Segments.Len()
	for i := 0; i < l; i++ {
		segment := n.Segments.At(i)
		_, _ = w.Write(r.Filter.SanitizeBytes(segment.Value(source)))
	}
	return ast.WalkSkipChildren, nil
}
func (r *DangerousHTMLRenderer) renderHTMLBlock(w util.BufWriter, source []byte, node ast.Node, entering bool) (ast.WalkStatus, error) {
	n := node.(*ast.HTMLBlock)
	if entering {
		l := n.Lines().Len()
		for i := 0; i < l; i++ {
			line := n.Lines().At(i)
			r.Writer.SecureWrite(w, r.Filter.SanitizeBytes(line.Value(source)))
		}
	} else {
		if n.HasClosure() {
			closure := n.ClosureLine
			r.Writer.SecureWrite(w, closure.Value(source))
		}
	}
	return ast.WalkContinue, nil
}
func (r *DangerousHTMLRenderer) renderLink(w util.BufWriter, source []byte, node ast.Node, entering bool) (ast.WalkStatus, error) {
	n := node.(*ast.Link)
	if entering && r.renderLinkIsUrl(string(n.Destination)) {
		_, _ = w.WriteString(""<a href=\"""")
		if r.Unsafe || !html.IsDangerousURL(n.Destination) {
			_, _ = w.Write(util.EscapeHTML(util.URLEscape(n.Destination, true)))
		}
		_ = w.WriteByte('""')
		if n.Title != nil {
			_, _ = w.WriteString(` title=""`)
			r.Writer.Write(w, n.Title)
			_ = w.WriteByte('""')
		}
		if n.Attributes() != nil {
			html.RenderAttributes(w, n, html.LinkAttributeFilter)
		}
		_ = w.WriteByte('>')
	} else {
		_, _ = w.WriteString(""</a>"")
	}
	return ast.WalkContinue, nil
}
func (r *DangerousHTMLRenderer) renderAutoLink(w util.BufWriter, source []byte, node ast.Node, entering bool) (ast.WalkStatus, error) {
	n := node.(*ast.AutoLink)
	if !entering || !r.renderLinkIsUrl(string(n.URL(source))) {
		return ast.WalkContinue, nil
	}
	_, _ = w.WriteString(`<a href=""`)
	url := n.URL(source)
	label := n.Label(source)
	if n.AutoLinkType == ast.AutoLinkEmail && !bytes.HasPrefix(bytes.ToLower(url), []byte(""mailto:"")) {
		_, _ = w.WriteString(""mailto:"")
	}
	_, _ = w.Write(util.EscapeHTML(util.URLEscape(url, false)))
	if n.Attributes() != nil {
		_ = w.WriteByte('""')
		html.RenderAttributes(w, n, html.LinkAttributeFilter)
		_ = w.WriteByte('>')
	} else {
		_, _ = w.WriteString(`"">`)
	}
	_, _ = w.Write(util.EscapeHTML(label))
	_, _ = w.WriteString(`</a>`)
	return ast.WalkContinue, nil
}
func (r *DangerousHTMLRenderer) renderLinkIsUrl(verifyUrl string) bool {
	return govalidator.IsURL(verifyUrl)
}
",CWE-79,146.0,1
"package install
import (
	""fmt""
	""net/url""
	""strings""
	""github.com/answerdev/answer/internal/base/reason""
	""github.com/answerdev/answer/internal/base/validator""
	""github.com/answerdev/answer/pkg/checker""
	""github.com/segmentfault/pacman/errors""
	""xorm.io/xorm/schemas""
)
// CheckConfigFileResp check config file if exist or not response
type CheckConfigFileResp struct {
	ConfigFileExist     bool `json:""config_file_exist""`
	DBConnectionSuccess bool `json:""db_connection_success""`
	DbTableExist        bool `json:""db_table_exist""`
}
// CheckDatabaseReq check database
type CheckDatabaseReq struct {
	DbType     string `validate:""required,oneof=postgres sqlite3 mysql"" json:""db_type""`
	DbUsername string `json:""db_username""`
	DbPassword string `json:""db_password""`
	DbHost     string `json:""db_host""`
	DbName     string `json:""db_name""`
	DbFile     string `json:""db_file""`
}
// GetConnection get connection string
func (r *CheckDatabaseReq) GetConnection() string {
	if r.DbType == string(schemas.SQLITE) {
		return r.DbFile
	}
	if r.DbType == string(schemas.MYSQL) {
		return fmt.Sprintf(""%s:%s@tcp(%s)/%s"",
			r.DbUsername, r.DbPassword, r.DbHost, r.DbName)
	}
	if r.DbType == string(schemas.POSTGRES) {
		host, port := parsePgSQLHostPort(r.DbHost)
		return fmt.Sprintf(""host=%s port=%s user=%s password=%s dbname=%s sslmode=disable"",
			host, port, r.DbUsername, r.DbPassword, r.DbName)
	}
	return """"
}
func parsePgSQLHostPort(dbHost string) (host string, port string) {
	if strings.Contains(dbHost, "":"") {
		idx := strings.LastIndex(dbHost, "":"")
		host, port = dbHost[:idx], dbHost[idx+1:]
	} else if len(dbHost) > 0 {
		host = dbHost
	}
	if host == """" {
		host = ""127.0.0.1""
	}
	if port == """" {
		port = ""5432""
	}
	return host, port
}
// CheckDatabaseResp check database response
type CheckDatabaseResp struct {
	ConnectionSuccess bool `json:""connection_success""`
}
// InitEnvironmentResp init environment response
type InitEnvironmentResp struct {
	Success            bool   `json:""success""`
	CreateConfigFailed bool   `json:""create_config_failed""`
	DefaultConfig      string `json:""default_config""`
	ErrType            string `json:""err_type""`
}
// InitBaseInfoReq init base info request
type InitBaseInfoReq struct {
	Language      string `validate:""required,gt=0,lte=30"" json:""lang""`
	SiteName      string `validate:""required,gt=0,lte=30"" json:""site_name""`
	SiteURL       string `validate:""required,gt=0,lte=512,url"" json:""site_url""`
	ContactEmail  string `validate:""required,email,gt=0,lte=500"" json:""contact_email""`
	AdminName     string `validate:""required,gt=3,lte=30"" json:""name""`
	AdminPassword string `validate:""required,gte=8,lte=32"" json:""password""`
	AdminEmail    string `validate:""required,email,gt=0,lte=500"" json:""email""`
}
func (r *InitBaseInfoReq) Check() (errFields []*validator.FormErrorField, err error) {
	if checker.IsInvalidUsername(r.AdminName) {
		errField := &validator.FormErrorField{
			ErrorField: ""name"",
			ErrorMsg:   reason.UsernameInvalid,
		}
		errFields = append(errFields, errField)
		return errFields, errors.BadRequest(reason.UsernameInvalid)
	}
	return
}
func (r *InitBaseInfoReq) FormatSiteUrl() {
	parsedUrl, err := url.Parse(r.SiteURL)
	if err != nil {
		return
	}
	r.SiteURL = fmt.Sprintf(""%s://%s"", parsedUrl.Scheme, parsedUrl.Host)
}
",CWE-79,108.0,1
"package captcha
import (
	""context""
	""fmt""
	""time""
	""github.com/answerdev/answer/internal/base/data""
	""github.com/answerdev/answer/internal/base/reason""
	""github.com/answerdev/answer/internal/service/action""
	""github.com/segmentfault/pacman/errors""
	""github.com/segmentfault/pacman/log""
)
// captchaRepo captcha repository
type captchaRepo struct {
	data *data.Data
}
// NewCaptchaRepo new repository
func NewCaptchaRepo(data *data.Data) action.CaptchaRepo {
	return &captchaRepo{
		data: data,
	}
}
func (cr *captchaRepo) SetActionType(ctx context.Context, ip, actionType string, amount int) (err error) {
	cacheKey := fmt.Sprintf(""ActionRecord:%s@"", ip)
	err = cr.data.Cache.SetInt64(ctx, cacheKey, int64(amount), 6*time.Minute)
	if err != nil {
		err = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return
}
func (cr *captchaRepo) GetActionType(ctx context.Context, ip, actionType string) (amount int, err error) {
	cacheKey := fmt.Sprintf(""ActionRecord:%s@"", ip)
	res, err := cr.data.Cache.GetInt64(ctx, cacheKey)
	if err != nil {
		err = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return int(res), nil
}
func (cr *captchaRepo) DelActionType(ctx context.Context, ip, actionType string) (err error) {
	cacheKey := fmt.Sprintf(""ActionRecord:%s@"", ip)
	err = cr.data.Cache.Del(ctx, cacheKey)
	if err != nil {
		err = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return
}
// SetCaptcha set captcha to cache
func (cr *captchaRepo) SetCaptcha(ctx context.Context, key, captcha string) (err error) {
	err = cr.data.Cache.SetString(ctx, key, captcha, 6*time.Minute)
	if err != nil {
		err = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return
}
// GetCaptcha get captcha from cache
func (cr *captchaRepo) GetCaptcha(ctx context.Context, key string) (captcha string, err error) {
	captcha, err = cr.data.Cache.GetString(ctx, key)
	if err != nil {
		log.Debug(err)
	}
	return captcha, nil
}
",CWE-294,71.0,1
"package captcha
import (
	""context""
	""fmt""
	""time""
	""github.com/answerdev/answer/internal/base/data""
	""github.com/answerdev/answer/internal/base/reason""
	""github.com/answerdev/answer/internal/service/action""
	""github.com/segmentfault/pacman/errors""
	""github.com/segmentfault/pacman/log""
)
// captchaRepo captcha repository
type captchaRepo struct {
	data *data.Data
}
// NewCaptchaRepo new repository
func NewCaptchaRepo(data *data.Data) action.CaptchaRepo {
	return &captchaRepo{
		data: data,
	}
}
func (cr *captchaRepo) SetActionType(ctx context.Context, ip, actionType string, amount int) (err error) {
	cacheKey := fmt.Sprintf(""ActionRecord:%s@"", ip)
	err = cr.data.Cache.SetInt64(ctx, cacheKey, int64(amount), 6*time.Minute)
	if err != nil {
		err = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return
}
func (cr *captchaRepo) GetActionType(ctx context.Context, ip, actionType string) (amount int, err error) {
	cacheKey := fmt.Sprintf(""ActionRecord:%s@"", ip)
	res, err := cr.data.Cache.GetInt64(ctx, cacheKey)
	if err != nil {
		err = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return int(res), nil
}
func (cr *captchaRepo) DelActionType(ctx context.Context, ip, actionType string) (err error) {
	cacheKey := fmt.Sprintf(""ActionRecord:%s@"", ip)
	err = cr.data.Cache.Del(ctx, cacheKey)
	if err != nil {
		err = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return
}
// SetCaptcha set captcha to cache
func (cr *captchaRepo) SetCaptcha(ctx context.Context, key, captcha string) (err error) {
	err = cr.data.Cache.SetString(ctx, key, captcha, 6*time.Minute)
	if err != nil {
		err = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return
}
// GetCaptcha get captcha from cache
func (cr *captchaRepo) GetCaptcha(ctx context.Context, key string) (captcha string, err error) {
	captcha, err = cr.data.Cache.GetString(ctx, key)
	if err != nil {
		log.Debug(err)
	}
	return captcha, nil
}
",CWE-203,71.0,1
"package captcha
import (
	""context""
	""fmt""
	""time""
	""github.com/answerdev/answer/internal/base/data""
	""github.com/answerdev/answer/internal/base/reason""
	""github.com/answerdev/answer/internal/service/action""
	""github.com/segmentfault/pacman/errors""
	""github.com/segmentfault/pacman/log""
)
// captchaRepo captcha repository
type captchaRepo struct {
	data *data.Data
}
// NewCaptchaRepo new repository
func NewCaptchaRepo(data *data.Data) action.CaptchaRepo {
	return &captchaRepo{
		data: data,
	}
}
func (cr *captchaRepo) SetActionType(ctx context.Context, ip, actionType string, amount int) (err error) {
	cacheKey := fmt.Sprintf(""ActionRecord:%s@"", ip)
	err = cr.data.Cache.SetInt64(ctx, cacheKey, int64(amount), 6*time.Minute)
	if err != nil {
		err = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return
}
func (cr *captchaRepo) GetActionType(ctx context.Context, ip, actionType string) (amount int, err error) {
	cacheKey := fmt.Sprintf(""ActionRecord:%s@"", ip)
	res, err := cr.data.Cache.GetInt64(ctx, cacheKey)
	if err != nil {
		err = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return int(res), nil
}
func (cr *captchaRepo) DelActionType(ctx context.Context, ip, actionType string) (err error) {
	cacheKey := fmt.Sprintf(""ActionRecord:%s@"", ip)
	err = cr.data.Cache.Del(ctx, cacheKey)
	if err != nil {
		err = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return
}
// SetCaptcha set captcha to cache
func (cr *captchaRepo) SetCaptcha(ctx context.Context, key, captcha string) (err error) {
	err = cr.data.Cache.SetString(ctx, key, captcha, 6*time.Minute)
	if err != nil {
		err = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return
}
// GetCaptcha get captcha from cache
func (cr *captchaRepo) GetCaptcha(ctx context.Context, key string) (captcha string, err error) {
	captcha, err = cr.data.Cache.GetString(ctx, key)
	if err != nil {
		log.Debug(err)
	}
	return captcha, nil
}
",CWE-307,71.0,1
"package captcha
import (
	""context""
	""fmt""
	""time""
	""github.com/answerdev/answer/internal/base/data""
	""github.com/answerdev/answer/internal/base/reason""
	""github.com/answerdev/answer/internal/service/action""
	""github.com/segmentfault/pacman/errors""
	""github.com/segmentfault/pacman/log""
)
// captchaRepo captcha repository
type captchaRepo struct {
	data *data.Data
}
// NewCaptchaRepo new repository
func NewCaptchaRepo(data *data.Data) action.CaptchaRepo {
	return &captchaRepo{
		data: data,
	}
}
func (cr *captchaRepo) SetActionType(ctx context.Context, ip, actionType string, amount int) (err error) {
	cacheKey := fmt.Sprintf(""ActionRecord:%s@"", ip)
	err = cr.data.Cache.SetInt64(ctx, cacheKey, int64(amount), 6*time.Minute)
	if err != nil {
		err = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return
}
func (cr *captchaRepo) GetActionType(ctx context.Context, ip, actionType string) (amount int, err error) {
	cacheKey := fmt.Sprintf(""ActionRecord:%s@"", ip)
	res, err := cr.data.Cache.GetInt64(ctx, cacheKey)
	if err != nil {
		err = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return int(res), nil
}
func (cr *captchaRepo) DelActionType(ctx context.Context, ip, actionType string) (err error) {
	cacheKey := fmt.Sprintf(""ActionRecord:%s@"", ip)
	err = cr.data.Cache.Del(ctx, cacheKey)
	if err != nil {
		err = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return
}
// SetCaptcha set captcha to cache
func (cr *captchaRepo) SetCaptcha(ctx context.Context, key, captcha string) (err error) {
	err = cr.data.Cache.SetString(ctx, key, captcha, 6*time.Minute)
	if err != nil {
		err = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return
}
// GetCaptcha get captcha from cache
func (cr *captchaRepo) GetCaptcha(ctx context.Context, key string) (captcha string, err error) {
	captcha, err = cr.data.Cache.GetString(ctx, key)
	if err != nil {
		log.Debug(err)
	}
	return captcha, nil
}
",CWE-263,71.0,1
"package action
import (
	""context""
	""image/color""
	""strings""
	""github.com/answerdev/answer/internal/base/reason""
	""github.com/answerdev/answer/internal/schema""
	""github.com/mojocn/base64Captcha""
	""github.com/segmentfault/pacman/errors""
	""github.com/segmentfault/pacman/log""
)
// CaptchaRepo captcha repository
type CaptchaRepo interface {
	SetCaptcha(ctx context.Context, key, captcha string) (err error)
	GetCaptcha(ctx context.Context, key string) (captcha string, err error)
	SetActionType(ctx context.Context, ip, actionType string, amount int) (err error)
	GetActionType(ctx context.Context, ip, actionType string) (amount int, err error)
	DelActionType(ctx context.Context, ip, actionType string) (err error)
}
// CaptchaService kit service
type CaptchaService struct {
	captchaRepo CaptchaRepo
}
// NewCaptchaService captcha service
func NewCaptchaService(captchaRepo CaptchaRepo) *CaptchaService {
	return &CaptchaService{
		captchaRepo: captchaRepo,
	}
}
// ActionRecord action record
func (cs *CaptchaService) ActionRecord(ctx context.Context, req *schema.ActionRecordReq) (resp *schema.ActionRecordResp, err error) {
	resp = &schema.ActionRecordResp{}
	num, err := cs.captchaRepo.GetActionType(ctx, req.IP, req.Action)
	if err != nil {
		num = 0
	}
	// TODO config num to config file
	if num >= 3 {
		resp.CaptchaID, resp.CaptchaImg, err = cs.GenerateCaptcha(ctx)
		resp.Verify = true
	}
	return
}
func (cs *CaptchaService) UserRegisterCaptcha(ctx context.Context) (resp *schema.ActionRecordResp, err error) {
	resp = &schema.ActionRecordResp{}
	resp.CaptchaID, resp.CaptchaImg, err = cs.GenerateCaptcha(ctx)
	resp.Verify = true
	return
}
func (cs *CaptchaService) UserRegisterVerifyCaptcha(
	ctx context.Context, id string, VerifyValue string,
) bool {
	if id == """" || VerifyValue == """" {
		return false
	}
	pass, err := cs.VerifyCaptcha(ctx, id, VerifyValue)
	if err != nil {
		return false
	}
	return pass
}
// ActionRecordVerifyCaptcha
// Verify that you need to enter a CAPTCHA, and that the CAPTCHA is correct
func (cs *CaptchaService) ActionRecordVerifyCaptcha(
	ctx context.Context, actionType string, ip string, id string, VerifyValue string,
) bool {
	num, cahceErr := cs.captchaRepo.GetActionType(ctx, ip, actionType)
	if cahceErr != nil {
		return true
	}
	if num >= 3 {
		if id == """" || VerifyValue == """" {
			return false
		}
		pass, err := cs.VerifyCaptcha(ctx, id, VerifyValue)
		if err != nil {
			return false
		}
		return pass
	}
	return true
}
func (cs *CaptchaService) ActionRecordAdd(ctx context.Context, actionType string, ip string) (int, error) {
	var err error
	num, cahceErr := cs.captchaRepo.GetActionType(ctx, ip, actionType)
	if cahceErr != nil {
		log.Error(err)
	}
	num++
	err = cs.captchaRepo.SetActionType(ctx, ip, actionType, num)
	if err != nil {
		return 0, err
	}
	return num, nil
}
func (cs *CaptchaService) ActionRecordDel(ctx context.Context, actionType string, ip string) {
	err := cs.captchaRepo.DelActionType(ctx, ip, actionType)
	if err != nil {
		log.Error(err)
	}
}
// GenerateCaptcha generate captcha
func (cs *CaptchaService) GenerateCaptcha(ctx context.Context) (key, captchaBase64 string, err error) {
	driverString := base64Captcha.DriverString{
		Height:          40,
		Width:           100,
		NoiseCount:      0,
		ShowLineOptions: 2 | 4,
		Length:          4,
		Source:          ""1234567890qwertyuioplkjhgfdsazxcvbnm"",
		BgColor:         &color.RGBA{R: 3, G: 102, B: 214, A: 125},
		Fonts:           []string{""wqy-microhei.ttc""},
	}
	driver := driverString.ConvertFonts()
	id, content, answer := driver.GenerateIdQuestionAnswer()
	item, err := driver.DrawCaptcha(content)
	if err != nil {
		return """", """", errors.InternalServer(reason.UnknownError).WithError(err).WithStack()
	}
	err = cs.captchaRepo.SetCaptcha(ctx, id, answer)
	if err != nil {
		return """", """", err
	}
	captchaBase64 = item.EncodeB64string()
	return id, captchaBase64, nil
}
// VerifyCaptcha generate captcha
func (cs *CaptchaService) VerifyCaptcha(ctx context.Context, key, captcha string) (isCorrect bool, err error) {
	realCaptcha, err := cs.captchaRepo.GetCaptcha(ctx, key)
	if err != nil {
		return false, nil
	}
	return strings.TrimSpace(captcha) == realCaptcha, nil
}
",CWE-294,150.0,1
"package action
import (
	""context""
	""image/color""
	""strings""
	""github.com/answerdev/answer/internal/base/reason""
	""github.com/answerdev/answer/internal/schema""
	""github.com/mojocn/base64Captcha""
	""github.com/segmentfault/pacman/errors""
	""github.com/segmentfault/pacman/log""
)
// CaptchaRepo captcha repository
type CaptchaRepo interface {
	SetCaptcha(ctx context.Context, key, captcha string) (err error)
	GetCaptcha(ctx context.Context, key string) (captcha string, err error)
	SetActionType(ctx context.Context, ip, actionType string, amount int) (err error)
	GetActionType(ctx context.Context, ip, actionType string) (amount int, err error)
	DelActionType(ctx context.Context, ip, actionType string) (err error)
}
// CaptchaService kit service
type CaptchaService struct {
	captchaRepo CaptchaRepo
}
// NewCaptchaService captcha service
func NewCaptchaService(captchaRepo CaptchaRepo) *CaptchaService {
	return &CaptchaService{
		captchaRepo: captchaRepo,
	}
}
// ActionRecord action record
func (cs *CaptchaService) ActionRecord(ctx context.Context, req *schema.ActionRecordReq) (resp *schema.ActionRecordResp, err error) {
	resp = &schema.ActionRecordResp{}
	num, err := cs.captchaRepo.GetActionType(ctx, req.IP, req.Action)
	if err != nil {
		num = 0
	}
	// TODO config num to config file
	if num >= 3 {
		resp.CaptchaID, resp.CaptchaImg, err = cs.GenerateCaptcha(ctx)
		resp.Verify = true
	}
	return
}
func (cs *CaptchaService) UserRegisterCaptcha(ctx context.Context) (resp *schema.ActionRecordResp, err error) {
	resp = &schema.ActionRecordResp{}
	resp.CaptchaID, resp.CaptchaImg, err = cs.GenerateCaptcha(ctx)
	resp.Verify = true
	return
}
func (cs *CaptchaService) UserRegisterVerifyCaptcha(
	ctx context.Context, id string, VerifyValue string,
) bool {
	if id == """" || VerifyValue == """" {
		return false
	}
	pass, err := cs.VerifyCaptcha(ctx, id, VerifyValue)
	if err != nil {
		return false
	}
	return pass
}
// ActionRecordVerifyCaptcha
// Verify that you need to enter a CAPTCHA, and that the CAPTCHA is correct
func (cs *CaptchaService) ActionRecordVerifyCaptcha(
	ctx context.Context, actionType string, ip string, id string, VerifyValue string,
) bool {
	num, cahceErr := cs.captchaRepo.GetActionType(ctx, ip, actionType)
	if cahceErr != nil {
		return true
	}
	if num >= 3 {
		if id == """" || VerifyValue == """" {
			return false
		}
		pass, err := cs.VerifyCaptcha(ctx, id, VerifyValue)
		if err != nil {
			return false
		}
		return pass
	}
	return true
}
func (cs *CaptchaService) ActionRecordAdd(ctx context.Context, actionType string, ip string) (int, error) {
	var err error
	num, cahceErr := cs.captchaRepo.GetActionType(ctx, ip, actionType)
	if cahceErr != nil {
		log.Error(err)
	}
	num++
	err = cs.captchaRepo.SetActionType(ctx, ip, actionType, num)
	if err != nil {
		return 0, err
	}
	return num, nil
}
func (cs *CaptchaService) ActionRecordDel(ctx context.Context, actionType string, ip string) {
	err := cs.captchaRepo.DelActionType(ctx, ip, actionType)
	if err != nil {
		log.Error(err)
	}
}
// GenerateCaptcha generate captcha
func (cs *CaptchaService) GenerateCaptcha(ctx context.Context) (key, captchaBase64 string, err error) {
	driverString := base64Captcha.DriverString{
		Height:          40,
		Width:           100,
		NoiseCount:      0,
		ShowLineOptions: 2 | 4,
		Length:          4,
		Source:          ""1234567890qwertyuioplkjhgfdsazxcvbnm"",
		BgColor:         &color.RGBA{R: 3, G: 102, B: 214, A: 125},
		Fonts:           []string{""wqy-microhei.ttc""},
	}
	driver := driverString.ConvertFonts()
	id, content, answer := driver.GenerateIdQuestionAnswer()
	item, err := driver.DrawCaptcha(content)
	if err != nil {
		return """", """", errors.InternalServer(reason.UnknownError).WithError(err).WithStack()
	}
	err = cs.captchaRepo.SetCaptcha(ctx, id, answer)
	if err != nil {
		return """", """", err
	}
	captchaBase64 = item.EncodeB64string()
	return id, captchaBase64, nil
}
// VerifyCaptcha generate captcha
func (cs *CaptchaService) VerifyCaptcha(ctx context.Context, key, captcha string) (isCorrect bool, err error) {
	realCaptcha, err := cs.captchaRepo.GetCaptcha(ctx, key)
	if err != nil {
		return false, nil
	}
	return strings.TrimSpace(captcha) == realCaptcha, nil
}
",CWE-203,150.0,1
"package action
import (
	""context""
	""image/color""
	""strings""
	""github.com/answerdev/answer/internal/base/reason""
	""github.com/answerdev/answer/internal/schema""
	""github.com/mojocn/base64Captcha""
	""github.com/segmentfault/pacman/errors""
	""github.com/segmentfault/pacman/log""
)
// CaptchaRepo captcha repository
type CaptchaRepo interface {
	SetCaptcha(ctx context.Context, key, captcha string) (err error)
	GetCaptcha(ctx context.Context, key string) (captcha string, err error)
	SetActionType(ctx context.Context, ip, actionType string, amount int) (err error)
	GetActionType(ctx context.Context, ip, actionType string) (amount int, err error)
	DelActionType(ctx context.Context, ip, actionType string) (err error)
}
// CaptchaService kit service
type CaptchaService struct {
	captchaRepo CaptchaRepo
}
// NewCaptchaService captcha service
func NewCaptchaService(captchaRepo CaptchaRepo) *CaptchaService {
	return &CaptchaService{
		captchaRepo: captchaRepo,
	}
}
// ActionRecord action record
func (cs *CaptchaService) ActionRecord(ctx context.Context, req *schema.ActionRecordReq) (resp *schema.ActionRecordResp, err error) {
	resp = &schema.ActionRecordResp{}
	num, err := cs.captchaRepo.GetActionType(ctx, req.IP, req.Action)
	if err != nil {
		num = 0
	}
	// TODO config num to config file
	if num >= 3 {
		resp.CaptchaID, resp.CaptchaImg, err = cs.GenerateCaptcha(ctx)
		resp.Verify = true
	}
	return
}
func (cs *CaptchaService) UserRegisterCaptcha(ctx context.Context) (resp *schema.ActionRecordResp, err error) {
	resp = &schema.ActionRecordResp{}
	resp.CaptchaID, resp.CaptchaImg, err = cs.GenerateCaptcha(ctx)
	resp.Verify = true
	return
}
func (cs *CaptchaService) UserRegisterVerifyCaptcha(
	ctx context.Context, id string, VerifyValue string,
) bool {
	if id == """" || VerifyValue == """" {
		return false
	}
	pass, err := cs.VerifyCaptcha(ctx, id, VerifyValue)
	if err != nil {
		return false
	}
	return pass
}
// ActionRecordVerifyCaptcha
// Verify that you need to enter a CAPTCHA, and that the CAPTCHA is correct
func (cs *CaptchaService) ActionRecordVerifyCaptcha(
	ctx context.Context, actionType string, ip string, id string, VerifyValue string,
) bool {
	num, cahceErr := cs.captchaRepo.GetActionType(ctx, ip, actionType)
	if cahceErr != nil {
		return true
	}
	if num >= 3 {
		if id == """" || VerifyValue == """" {
			return false
		}
		pass, err := cs.VerifyCaptcha(ctx, id, VerifyValue)
		if err != nil {
			return false
		}
		return pass
	}
	return true
}
func (cs *CaptchaService) ActionRecordAdd(ctx context.Context, actionType string, ip string) (int, error) {
	var err error
	num, cahceErr := cs.captchaRepo.GetActionType(ctx, ip, actionType)
	if cahceErr != nil {
		log.Error(err)
	}
	num++
	err = cs.captchaRepo.SetActionType(ctx, ip, actionType, num)
	if err != nil {
		return 0, err
	}
	return num, nil
}
func (cs *CaptchaService) ActionRecordDel(ctx context.Context, actionType string, ip string) {
	err := cs.captchaRepo.DelActionType(ctx, ip, actionType)
	if err != nil {
		log.Error(err)
	}
}
// GenerateCaptcha generate captcha
func (cs *CaptchaService) GenerateCaptcha(ctx context.Context) (key, captchaBase64 string, err error) {
	driverString := base64Captcha.DriverString{
		Height:          40,
		Width:           100,
		NoiseCount:      0,
		ShowLineOptions: 2 | 4,
		Length:          4,
		Source:          ""1234567890qwertyuioplkjhgfdsazxcvbnm"",
		BgColor:         &color.RGBA{R: 3, G: 102, B: 214, A: 125},
		Fonts:           []string{""wqy-microhei.ttc""},
	}
	driver := driverString.ConvertFonts()
	id, content, answer := driver.GenerateIdQuestionAnswer()
	item, err := driver.DrawCaptcha(content)
	if err != nil {
		return """", """", errors.InternalServer(reason.UnknownError).WithError(err).WithStack()
	}
	err = cs.captchaRepo.SetCaptcha(ctx, id, answer)
	if err != nil {
		return """", """", err
	}
	captchaBase64 = item.EncodeB64string()
	return id, captchaBase64, nil
}
// VerifyCaptcha generate captcha
func (cs *CaptchaService) VerifyCaptcha(ctx context.Context, key, captcha string) (isCorrect bool, err error) {
	realCaptcha, err := cs.captchaRepo.GetCaptcha(ctx, key)
	if err != nil {
		return false, nil
	}
	return strings.TrimSpace(captcha) == realCaptcha, nil
}
",CWE-307,150.0,1
"package action
import (
	""context""
	""image/color""
	""strings""
	""github.com/answerdev/answer/internal/base/reason""
	""github.com/answerdev/answer/internal/schema""
	""github.com/mojocn/base64Captcha""
	""github.com/segmentfault/pacman/errors""
	""github.com/segmentfault/pacman/log""
)
// CaptchaRepo captcha repository
type CaptchaRepo interface {
	SetCaptcha(ctx context.Context, key, captcha string) (err error)
	GetCaptcha(ctx context.Context, key string) (captcha string, err error)
	SetActionType(ctx context.Context, ip, actionType string, amount int) (err error)
	GetActionType(ctx context.Context, ip, actionType string) (amount int, err error)
	DelActionType(ctx context.Context, ip, actionType string) (err error)
}
// CaptchaService kit service
type CaptchaService struct {
	captchaRepo CaptchaRepo
}
// NewCaptchaService captcha service
func NewCaptchaService(captchaRepo CaptchaRepo) *CaptchaService {
	return &CaptchaService{
		captchaRepo: captchaRepo,
	}
}
// ActionRecord action record
func (cs *CaptchaService) ActionRecord(ctx context.Context, req *schema.ActionRecordReq) (resp *schema.ActionRecordResp, err error) {
	resp = &schema.ActionRecordResp{}
	num, err := cs.captchaRepo.GetActionType(ctx, req.IP, req.Action)
	if err != nil {
		num = 0
	}
	// TODO config num to config file
	if num >= 3 {
		resp.CaptchaID, resp.CaptchaImg, err = cs.GenerateCaptcha(ctx)
		resp.Verify = true
	}
	return
}
func (cs *CaptchaService) UserRegisterCaptcha(ctx context.Context) (resp *schema.ActionRecordResp, err error) {
	resp = &schema.ActionRecordResp{}
	resp.CaptchaID, resp.CaptchaImg, err = cs.GenerateCaptcha(ctx)
	resp.Verify = true
	return
}
func (cs *CaptchaService) UserRegisterVerifyCaptcha(
	ctx context.Context, id string, VerifyValue string,
) bool {
	if id == """" || VerifyValue == """" {
		return false
	}
	pass, err := cs.VerifyCaptcha(ctx, id, VerifyValue)
	if err != nil {
		return false
	}
	return pass
}
// ActionRecordVerifyCaptcha
// Verify that you need to enter a CAPTCHA, and that the CAPTCHA is correct
func (cs *CaptchaService) ActionRecordVerifyCaptcha(
	ctx context.Context, actionType string, ip string, id string, VerifyValue string,
) bool {
	num, cahceErr := cs.captchaRepo.GetActionType(ctx, ip, actionType)
	if cahceErr != nil {
		return true
	}
	if num >= 3 {
		if id == """" || VerifyValue == """" {
			return false
		}
		pass, err := cs.VerifyCaptcha(ctx, id, VerifyValue)
		if err != nil {
			return false
		}
		return pass
	}
	return true
}
func (cs *CaptchaService) ActionRecordAdd(ctx context.Context, actionType string, ip string) (int, error) {
	var err error
	num, cahceErr := cs.captchaRepo.GetActionType(ctx, ip, actionType)
	if cahceErr != nil {
		log.Error(err)
	}
	num++
	err = cs.captchaRepo.SetActionType(ctx, ip, actionType, num)
	if err != nil {
		return 0, err
	}
	return num, nil
}
func (cs *CaptchaService) ActionRecordDel(ctx context.Context, actionType string, ip string) {
	err := cs.captchaRepo.DelActionType(ctx, ip, actionType)
	if err != nil {
		log.Error(err)
	}
}
// GenerateCaptcha generate captcha
func (cs *CaptchaService) GenerateCaptcha(ctx context.Context) (key, captchaBase64 string, err error) {
	driverString := base64Captcha.DriverString{
		Height:          40,
		Width:           100,
		NoiseCount:      0,
		ShowLineOptions: 2 | 4,
		Length:          4,
		Source:          ""1234567890qwertyuioplkjhgfdsazxcvbnm"",
		BgColor:         &color.RGBA{R: 3, G: 102, B: 214, A: 125},
		Fonts:           []string{""wqy-microhei.ttc""},
	}
	driver := driverString.ConvertFonts()
	id, content, answer := driver.GenerateIdQuestionAnswer()
	item, err := driver.DrawCaptcha(content)
	if err != nil {
		return """", """", errors.InternalServer(reason.UnknownError).WithError(err).WithStack()
	}
	err = cs.captchaRepo.SetCaptcha(ctx, id, answer)
	if err != nil {
		return """", """", err
	}
	captchaBase64 = item.EncodeB64string()
	return id, captchaBase64, nil
}
// VerifyCaptcha generate captcha
func (cs *CaptchaService) VerifyCaptcha(ctx context.Context, key, captcha string) (isCorrect bool, err error) {
	realCaptcha, err := cs.captchaRepo.GetCaptcha(ctx, key)
	if err != nil {
		return false, nil
	}
	return strings.TrimSpace(captcha) == realCaptcha, nil
}
",CWE-263,150.0,1
"package converter
import (
	""bytes""
	""github.com/asaskevich/govalidator""
	""github.com/microcosm-cc/bluemonday""
	""github.com/segmentfault/pacman/log""
	""github.com/yuin/goldmark""
	""github.com/yuin/goldmark/ast""
	""github.com/yuin/goldmark/extension""
	""github.com/yuin/goldmark/parser""
	""github.com/yuin/goldmark/renderer""
	""github.com/yuin/goldmark/renderer/html""
	goldmarkHTML ""github.com/yuin/goldmark/renderer/html""
	""github.com/yuin/goldmark/util""
)
// Markdown2HTML convert markdown to html
func Markdown2HTML(source string) string {
	mdConverter := goldmark.New(
		goldmark.WithExtensions(&DangerousHTMLFilterExtension{}, extension.GFM),
		goldmark.WithParserOptions(
			parser.WithAutoHeadingID(),
		),
		goldmark.WithRendererOptions(
			goldmarkHTML.WithHardWraps(),
		),
	)
	var buf bytes.Buffer
	if err := mdConverter.Convert([]byte(source), &buf); err != nil {
		log.Error(err)
		return source
	}
	return buf.String()
}
// Markdown2BasicHTML convert markdown to html ,Only basic syntax can be used
func Markdown2BasicHTML(source string) string {
	content := Markdown2HTML(source)
	filter := bluemonday.NewPolicy()
	filter.AllowElements(""p"", ""b"", ""br"")
	filter.AllowAttrs(""src"").OnElements(""img"")
	filter.AddSpaceWhenStrippingTag(true)
	content = filter.Sanitize(content)
	return content
}
type DangerousHTMLFilterExtension struct {
}
func (e *DangerousHTMLFilterExtension) Extend(m goldmark.Markdown) {
	m.Renderer().AddOptions(renderer.WithNodeRenderers(
		util.Prioritized(&DangerousHTMLRenderer{
			Config: goldmarkHTML.NewConfig(),
			Filter: bluemonday.UGCPolicy(),
		}, 1),
	))
}
type DangerousHTMLRenderer struct {
	goldmarkHTML.Config
	Filter *bluemonday.Policy
}
// RegisterFuncs implements renderer.NodeRenderer.RegisterFuncs.
func (r *DangerousHTMLRenderer) RegisterFuncs(reg renderer.NodeRendererFuncRegisterer) {
	reg.Register(ast.KindHTMLBlock, r.renderHTMLBlock)
	reg.Register(ast.KindRawHTML, r.renderRawHTML)
	reg.Register(ast.KindLink, r.renderLink)
	reg.Register(ast.KindAutoLink, r.renderAutoLink)
}
func (r *DangerousHTMLRenderer) renderRawHTML(w util.BufWriter, source []byte, node ast.Node, entering bool) (ast.WalkStatus, error) {
	if !entering {
		return ast.WalkSkipChildren, nil
	}
	n := node.(*ast.RawHTML)
	l := n.Segments.Len()
	for i := 0; i < l; i++ {
		segment := n.Segments.At(i)
		_, _ = w.Write(r.Filter.SanitizeBytes(segment.Value(source)))
	}
	return ast.WalkSkipChildren, nil
}
func (r *DangerousHTMLRenderer) renderHTMLBlock(w util.BufWriter, source []byte, node ast.Node, entering bool) (ast.WalkStatus, error) {
	n := node.(*ast.HTMLBlock)
	if entering {
		l := n.Lines().Len()
		for i := 0; i < l; i++ {
			line := n.Lines().At(i)
			r.Writer.SecureWrite(w, r.Filter.SanitizeBytes(line.Value(source)))
		}
	} else {
		if n.HasClosure() {
			closure := n.ClosureLine
			r.Writer.SecureWrite(w, closure.Value(source))
		}
	}
	return ast.WalkContinue, nil
}
func (r *DangerousHTMLRenderer) renderLink(w util.BufWriter, source []byte, node ast.Node, entering bool) (ast.WalkStatus, error) {
	n := node.(*ast.Link)
	if entering && r.renderLinkIsUrl(string(n.Destination)) {
		_, _ = w.WriteString(""<a href=\"""")
		if r.Unsafe || !html.IsDangerousURL(n.Destination) {
			_, _ = w.Write(util.EscapeHTML(util.URLEscape(n.Destination, true)))
		}
		_ = w.WriteByte('""')
		if n.Title != nil {
			_, _ = w.WriteString(` title=""`)
			r.Writer.Write(w, n.Title)
			_ = w.WriteByte('""')
		}
		if n.Attributes() != nil {
			html.RenderAttributes(w, n, html.LinkAttributeFilter)
		}
		_ = w.WriteByte('>')
	} else {
		_, _ = w.WriteString(""</a>"")
	}
	return ast.WalkContinue, nil
}
func (r *DangerousHTMLRenderer) renderAutoLink(w util.BufWriter, source []byte, node ast.Node, entering bool) (ast.WalkStatus, error) {
	n := node.(*ast.AutoLink)
	if !entering || !r.renderLinkIsUrl(string(n.URL(source))) {
		return ast.WalkContinue, nil
	}
	_, _ = w.WriteString(`<a href=""`)
	url := n.URL(source)
	label := n.Label(source)
	if n.AutoLinkType == ast.AutoLinkEmail && !bytes.HasPrefix(bytes.ToLower(url), []byte(""mailto:"")) {
		_, _ = w.WriteString(""mailto:"")
	}
	_, _ = w.Write(util.EscapeHTML(util.URLEscape(url, false)))
	if n.Attributes() != nil {
		_ = w.WriteByte('""')
		html.RenderAttributes(w, n, html.LinkAttributeFilter)
		_ = w.WriteByte('>')
	} else {
		_, _ = w.WriteString(`"">`)
	}
	_, _ = w.Write(util.EscapeHTML(label))
	_, _ = w.WriteString(`</a>`)
	return ast.WalkContinue, nil
}
func (r *DangerousHTMLRenderer) renderLinkIsUrl(verifyUrl string) bool {
	return govalidator.IsURL(verifyUrl)
}
",CWE-79,157.0,1
"module github.com/answerdev/answer
go 1.18
require (
	github.com/Chain-Zhang/pinyin v0.1.3
	github.com/anargu/gin-brotli v0.0.0-20220116052358-12bf532d5267
	github.com/asaskevich/govalidator v0.0.0-20210307081110-f21760c49a8d
	github.com/bwmarrin/snowflake v0.3.0
	github.com/davecgh/go-spew v1.1.1
	github.com/disintegration/imaging v1.6.2
	github.com/gin-gonic/gin v1.8.1
	github.com/go-playground/locales v0.14.0
	github.com/go-playground/universal-translator v0.18.0
	github.com/go-playground/validator/v10 v10.11.1
	github.com/go-sql-driver/mysql v1.6.0
	github.com/goccy/go-json v0.9.11
	github.com/golang/mock v1.6.0
	github.com/google/uuid v1.3.0
	github.com/google/wire v0.5.0
	github.com/gosimple/slug v1.13.1
	github.com/grokify/html-strip-tags-go v0.0.1
	github.com/jinzhu/copier v0.3.5
	github.com/jinzhu/now v1.1.5
	github.com/lib/pq v1.10.7
	github.com/microcosm-cc/bluemonday v1.0.21
	github.com/mojocn/base64Captcha v1.3.5
	github.com/ory/dockertest/v3 v3.9.1
	github.com/robfig/cron/v3 v3.0.1
	github.com/segmentfault/pacman v1.0.3
	github.com/segmentfault/pacman/contrib/cache/memory v0.0.0-20221219081300-f734f4a16aa0
	github.com/segmentfault/pacman/contrib/conf/viper v0.0.0-20221018072427-a15dd1434e05
	github.com/segmentfault/pacman/contrib/i18n v0.0.0-20221219081300-f734f4a16aa0
	github.com/segmentfault/pacman/contrib/log/zap v0.0.0-20221018072427-a15dd1434e05
	github.com/segmentfault/pacman/contrib/server/http v0.0.0-20221018072427-a15dd1434e05
	github.com/spf13/cobra v1.6.1
	github.com/stretchr/testify v1.8.1
	github.com/swaggo/files v1.0.0
	github.com/swaggo/gin-swagger v1.5.3
	github.com/swaggo/swag v1.8.10
	github.com/tidwall/gjson v1.14.4
	github.com/yuin/goldmark v1.4.13
	golang.org/x/crypto v0.1.0
	golang.org/x/net v0.2.0
	gopkg.in/gomail.v2 v2.0.0-20160411212932-81ebce5c23df
	gopkg.in/yaml.v3 v3.0.1
	modernc.org/sqlite v1.14.2
	xorm.io/builder v0.3.12
	xorm.io/core v0.7.3
	xorm.io/xorm v1.3.2
)
require (
	github.com/Azure/go-ansiterm v0.0.0-20170929234023-d6e3b3328b78 // indirect
	github.com/KyleBanks/depth v1.2.1 // indirect
	github.com/LinkinStars/go-i18n/v2 v2.2.2 // indirect
	github.com/Microsoft/go-winio v0.5.2 // indirect
	github.com/Nvveen/Gotty v0.0.0-20120604004816-cd527374f1e5 // indirect
	github.com/andybalholm/brotli v1.0.4 // indirect
	github.com/aymerick/douceur v0.2.0 // indirect
	github.com/cenkalti/backoff/v4 v4.1.3 // indirect
	github.com/containerd/continuity v0.3.0 // indirect
	github.com/docker/cli v20.10.14+incompatible // indirect
	github.com/docker/docker v20.10.7+incompatible // indirect
	github.com/docker/go-connections v0.4.0 // indirect
	github.com/docker/go-units v0.4.0 // indirect
	github.com/fsnotify/fsnotify v1.6.0 // indirect
	github.com/gin-contrib/sse v0.1.0 // indirect
	github.com/go-openapi/jsonpointer v0.19.5 // indirect
	github.com/go-openapi/jsonreference v0.20.0 // indirect
	github.com/go-openapi/spec v0.20.7 // indirect
	github.com/go-openapi/swag v0.22.3 // indirect
	github.com/gogo/protobuf v1.3.2 // indirect
	github.com/golang/freetype v0.0.0-20170609003504-e2365dfdc4a0 // indirect
	github.com/golang/snappy v0.0.4 // indirect
	github.com/google/shlex v0.0.0-20191202100458-e7afc7fbc510 // indirect
	github.com/gorilla/css v1.0.0 // indirect
	github.com/gosimple/unidecode v1.0.1 // indirect
	github.com/hashicorp/hcl v1.0.0 // indirect
	github.com/imdario/mergo v0.3.12 // indirect
	github.com/inconshreveable/mousetrap v1.0.1 // indirect
	github.com/josharian/intern v1.0.0 // indirect
	github.com/json-iterator/go v1.1.12 // indirect
	github.com/kballard/go-shellquote v0.0.0-20180428030007-95032a82bc51 // indirect
	github.com/leodido/go-urn v1.2.1 // indirect
	github.com/lestrrat-go/file-rotatelogs v2.4.0+incompatible // indirect
	github.com/lestrrat-go/strftime v1.0.6 // indirect
	github.com/magiconair/properties v1.8.6 // indirect
	github.com/mailru/easyjson v0.7.7 // indirect
	github.com/mattn/go-isatty v0.0.16 // indirect
	github.com/mattn/go-sqlite3 v1.14.16 // indirect
	github.com/mitchellh/mapstructure v1.5.0 // indirect
	github.com/moby/term v0.0.0-20201216013528-df9cb8a40635 // indirect
	github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect
	github.com/modern-go/reflect2 v1.0.2 // indirect
	github.com/opencontainers/go-digest v1.0.0 // indirect
	github.com/opencontainers/image-spec v1.0.2 // indirect
	github.com/opencontainers/runc v1.1.2 // indirect
	github.com/patrickmn/go-cache v2.1.0+incompatible // indirect
	github.com/pelletier/go-toml v1.9.5 // indirect
	github.com/pelletier/go-toml/v2 v2.0.5 // indirect
	github.com/pkg/errors v0.9.1 // indirect
	github.com/pmezard/go-difflib v1.0.0 // indirect
	github.com/remyoudompheng/bigfft v0.0.0-20200410134404-eec4a21b6bb0 // indirect
	github.com/sirupsen/logrus v1.8.1 // indirect
	github.com/spf13/afero v1.9.2 // indirect
	github.com/spf13/cast v1.5.0 // indirect
	github.com/spf13/jwalterweatherman v1.1.0 // indirect
	github.com/spf13/pflag v1.0.5 // indirect
	github.com/spf13/viper v1.13.0 // indirect
	github.com/subosito/gotenv v1.4.1 // indirect
	github.com/syndtr/goleveldb v1.0.0 // indirect
	github.com/tidwall/match v1.1.1 // indirect
	github.com/tidwall/pretty v1.2.0 // indirect
	github.com/ugorji/go/codec v1.2.7 // indirect
	github.com/xeipuuv/gojsonpointer v0.0.0-20180127040702-4e3ac2762d5f // indirect
	github.com/xeipuuv/gojsonreference v0.0.0-20180127040603-bd5ef7bd5415 // indirect
	github.com/xeipuuv/gojsonschema v1.2.0 // indirect
	go.uber.org/atomic v1.10.0 // indirect
	go.uber.org/multierr v1.8.0 // indirect
	go.uber.org/zap v1.23.0 // indirect
	golang.org/x/image v0.1.0 // indirect
	golang.org/x/mod v0.6.0 // indirect
	golang.org/x/sys v0.2.0 // indirect
	golang.org/x/text v0.5.0 // indirect
	golang.org/x/tools v0.2.0 // indirect
	google.golang.org/protobuf v1.28.1 // indirect
	gopkg.in/alexcesaro/quotedprintable.v3 v3.0.0-20150716171945-2caba252f4dc // indirect
	gopkg.in/ini.v1 v1.67.0 // indirect
	gopkg.in/yaml.v2 v2.4.0 // indirect
	lukechampine.com/uint128 v1.1.1 // indirect
	modernc.org/cc/v3 v3.35.18 // indirect
	modernc.org/ccgo/v3 v3.12.82 // indirect
	modernc.org/libc v1.11.87 // indirect
	modernc.org/mathutil v1.4.1 // indirect
	modernc.org/memory v1.0.5 // indirect
	modernc.org/opt v0.1.1 // indirect
	modernc.org/strutil v1.1.1 // indirect
	modernc.org/token v1.0.0 // indirect
	sigs.k8s.io/yaml v1.3.0 // indirect
)
",CWE-1230,142.0,1
"module github.com/answerdev/answer
go 1.18
require (
	github.com/Chain-Zhang/pinyin v0.1.3
	github.com/anargu/gin-brotli v0.0.0-20220116052358-12bf532d5267
	github.com/asaskevich/govalidator v0.0.0-20210307081110-f21760c49a8d
	github.com/bwmarrin/snowflake v0.3.0
	github.com/davecgh/go-spew v1.1.1
	github.com/disintegration/imaging v1.6.2
	github.com/gin-gonic/gin v1.8.1
	github.com/go-playground/locales v0.14.0
	github.com/go-playground/universal-translator v0.18.0
	github.com/go-playground/validator/v10 v10.11.1
	github.com/go-sql-driver/mysql v1.6.0
	github.com/goccy/go-json v0.9.11
	github.com/golang/mock v1.6.0
	github.com/google/uuid v1.3.0
	github.com/google/wire v0.5.0
	github.com/gosimple/slug v1.13.1
	github.com/grokify/html-strip-tags-go v0.0.1
	github.com/jinzhu/copier v0.3.5
	github.com/jinzhu/now v1.1.5
	github.com/lib/pq v1.10.7
	github.com/microcosm-cc/bluemonday v1.0.21
	github.com/mojocn/base64Captcha v1.3.5
	github.com/ory/dockertest/v3 v3.9.1
	github.com/robfig/cron/v3 v3.0.1
	github.com/segmentfault/pacman v1.0.3
	github.com/segmentfault/pacman/contrib/cache/memory v0.0.0-20221219081300-f734f4a16aa0
	github.com/segmentfault/pacman/contrib/conf/viper v0.0.0-20221018072427-a15dd1434e05
	github.com/segmentfault/pacman/contrib/i18n v0.0.0-20221219081300-f734f4a16aa0
	github.com/segmentfault/pacman/contrib/log/zap v0.0.0-20221018072427-a15dd1434e05
	github.com/segmentfault/pacman/contrib/server/http v0.0.0-20221018072427-a15dd1434e05
	github.com/spf13/cobra v1.6.1
	github.com/stretchr/testify v1.8.1
	github.com/swaggo/files v1.0.0
	github.com/swaggo/gin-swagger v1.5.3
	github.com/swaggo/swag v1.8.10
	github.com/tidwall/gjson v1.14.4
	github.com/yuin/goldmark v1.4.13
	golang.org/x/crypto v0.1.0
	golang.org/x/net v0.2.0
	gopkg.in/gomail.v2 v2.0.0-20160411212932-81ebce5c23df
	gopkg.in/yaml.v3 v3.0.1
	modernc.org/sqlite v1.14.2
	xorm.io/builder v0.3.12
	xorm.io/core v0.7.3
	xorm.io/xorm v1.3.2
)
require (
	github.com/Azure/go-ansiterm v0.0.0-20170929234023-d6e3b3328b78 // indirect
	github.com/KyleBanks/depth v1.2.1 // indirect
	github.com/LinkinStars/go-i18n/v2 v2.2.2 // indirect
	github.com/Microsoft/go-winio v0.5.2 // indirect
	github.com/Nvveen/Gotty v0.0.0-20120604004816-cd527374f1e5 // indirect
	github.com/andybalholm/brotli v1.0.4 // indirect
	github.com/aymerick/douceur v0.2.0 // indirect
	github.com/cenkalti/backoff/v4 v4.1.3 // indirect
	github.com/containerd/continuity v0.3.0 // indirect
	github.com/docker/cli v20.10.14+incompatible // indirect
	github.com/docker/docker v20.10.7+incompatible // indirect
	github.com/docker/go-connections v0.4.0 // indirect
	github.com/docker/go-units v0.4.0 // indirect
	github.com/fsnotify/fsnotify v1.6.0 // indirect
	github.com/gin-contrib/sse v0.1.0 // indirect
	github.com/go-openapi/jsonpointer v0.19.5 // indirect
	github.com/go-openapi/jsonreference v0.20.0 // indirect
	github.com/go-openapi/spec v0.20.7 // indirect
	github.com/go-openapi/swag v0.22.3 // indirect
	github.com/gogo/protobuf v1.3.2 // indirect
	github.com/golang/freetype v0.0.0-20170609003504-e2365dfdc4a0 // indirect
	github.com/golang/snappy v0.0.4 // indirect
	github.com/google/shlex v0.0.0-20191202100458-e7afc7fbc510 // indirect
	github.com/gorilla/css v1.0.0 // indirect
	github.com/gosimple/unidecode v1.0.1 // indirect
	github.com/hashicorp/hcl v1.0.0 // indirect
	github.com/imdario/mergo v0.3.12 // indirect
	github.com/inconshreveable/mousetrap v1.0.1 // indirect
	github.com/josharian/intern v1.0.0 // indirect
	github.com/json-iterator/go v1.1.12 // indirect
	github.com/kballard/go-shellquote v0.0.0-20180428030007-95032a82bc51 // indirect
	github.com/leodido/go-urn v1.2.1 // indirect
	github.com/lestrrat-go/file-rotatelogs v2.4.0+incompatible // indirect
	github.com/lestrrat-go/strftime v1.0.6 // indirect
	github.com/magiconair/properties v1.8.6 // indirect
	github.com/mailru/easyjson v0.7.7 // indirect
	github.com/mattn/go-isatty v0.0.16 // indirect
	github.com/mattn/go-sqlite3 v1.14.16 // indirect
	github.com/mitchellh/mapstructure v1.5.0 // indirect
	github.com/moby/term v0.0.0-20201216013528-df9cb8a40635 // indirect
	github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect
	github.com/modern-go/reflect2 v1.0.2 // indirect
	github.com/opencontainers/go-digest v1.0.0 // indirect
	github.com/opencontainers/image-spec v1.0.2 // indirect
	github.com/opencontainers/runc v1.1.2 // indirect
	github.com/patrickmn/go-cache v2.1.0+incompatible // indirect
	github.com/pelletier/go-toml v1.9.5 // indirect
	github.com/pelletier/go-toml/v2 v2.0.5 // indirect
	github.com/pkg/errors v0.9.1 // indirect
	github.com/pmezard/go-difflib v1.0.0 // indirect
	github.com/remyoudompheng/bigfft v0.0.0-20200410134404-eec4a21b6bb0 // indirect
	github.com/sirupsen/logrus v1.8.1 // indirect
	github.com/spf13/afero v1.9.2 // indirect
	github.com/spf13/cast v1.5.0 // indirect
	github.com/spf13/jwalterweatherman v1.1.0 // indirect
	github.com/spf13/pflag v1.0.5 // indirect
	github.com/spf13/viper v1.13.0 // indirect
	github.com/subosito/gotenv v1.4.1 // indirect
	github.com/syndtr/goleveldb v1.0.0 // indirect
	github.com/tidwall/match v1.1.1 // indirect
	github.com/tidwall/pretty v1.2.0 // indirect
	github.com/ugorji/go/codec v1.2.7 // indirect
	github.com/xeipuuv/gojsonpointer v0.0.0-20180127040702-4e3ac2762d5f // indirect
	github.com/xeipuuv/gojsonreference v0.0.0-20180127040603-bd5ef7bd5415 // indirect
	github.com/xeipuuv/gojsonschema v1.2.0 // indirect
	go.uber.org/atomic v1.10.0 // indirect
	go.uber.org/multierr v1.8.0 // indirect
	go.uber.org/zap v1.23.0 // indirect
	golang.org/x/image v0.1.0 // indirect
	golang.org/x/mod v0.6.0 // indirect
	golang.org/x/sys v0.2.0 // indirect
	golang.org/x/text v0.5.0 // indirect
	golang.org/x/tools v0.2.0 // indirect
	google.golang.org/protobuf v1.28.1 // indirect
	gopkg.in/alexcesaro/quotedprintable.v3 v3.0.0-20150716171945-2caba252f4dc // indirect
	gopkg.in/ini.v1 v1.67.0 // indirect
	gopkg.in/yaml.v2 v2.4.0 // indirect
	lukechampine.com/uint128 v1.1.1 // indirect
	modernc.org/cc/v3 v3.35.18 // indirect
	modernc.org/ccgo/v3 v3.12.82 // indirect
	modernc.org/libc v1.11.87 // indirect
	modernc.org/mathutil v1.4.1 // indirect
	modernc.org/memory v1.0.5 // indirect
	modernc.org/opt v0.1.1 // indirect
	modernc.org/strutil v1.1.1 // indirect
	modernc.org/token v1.0.0 // indirect
	sigs.k8s.io/yaml v1.3.0 // indirect
)
",CWE-201,142.0,1
"package migrations
import (
	""context""
	""fmt""
	""github.com/answerdev/answer/internal/base/data""
	""github.com/answerdev/answer/internal/entity""
	""xorm.io/xorm""
)
const minDBVersion = 0 // answer 1.0.0
// Migration describes on migration from lower version to high version
type Migration interface {
	Description() string
	Migrate(*xorm.Engine) error
	ShouldCleanCache() bool
}
type migration struct {
	description      string
	migrate          func(*xorm.Engine) error
	shouldCleanCache bool
}
// Description returns the migration's description
func (m *migration) Description() string {
	return m.description
}
// Migrate executes the migration
func (m *migration) Migrate(x *xorm.Engine) error {
	return m.migrate(x)
}
// ShouldCleanCache should clean the cache
func (m *migration) ShouldCleanCache() bool {
	return m.shouldCleanCache
}
// NewMigration creates a new migration
func NewMigration(desc string, fn func(*xorm.Engine) error, shouldCleanCache bool) Migration {
	return &migration{description: desc, migrate: fn, shouldCleanCache: shouldCleanCache}
}
// Use noopMigration when there is a migration that has been no-oped
var noopMigration = func(_ *xorm.Engine) error { return nil }
var migrations = []Migration{
	// 0->1
	NewMigration(""this is first version, no operation"", noopMigration, false),
	NewMigration(""add user language"", addUserLanguage, false),
	NewMigration(""add recommend and reserved tag fields"", addTagRecommendedAndReserved, false),
	NewMigration(""add activity timeline"", addActivityTimeline, false),
	NewMigration(""add user role"", addRoleFeatures, false),
	NewMigration(""add theme and private mode"", addThemeAndPrivateMode, true),
	NewMigration(""add new answer notification"", addNewAnswerNotification, true),
	NewMigration(""add user pin hide features"", addRolePinAndHideFeatures, true),
}
// GetCurrentDBVersion returns the current db version
func GetCurrentDBVersion(engine *xorm.Engine) (int64, error) {
	if err := engine.Sync(new(entity.Version)); err != nil {
		return -1, fmt.Errorf(""sync version failed: %v"", err)
	}
	currentVersion := &entity.Version{ID: 1}
	has, err := engine.Get(currentVersion)
	if err != nil {
		return -1, fmt.Errorf(""get first version failed: %v"", err)
	}
	if !has {
		_, err := engine.InsertOne(&entity.Version{ID: 1, VersionNumber: 0})
		if err != nil {
			return -1, fmt.Errorf(""insert first version failed: %v"", err)
		}
		return 0, nil
	}
	return currentVersion.VersionNumber, nil
}
// ExpectedVersion returns the expected db version
func ExpectedVersion() int64 {
	return int64(minDBVersion + len(migrations))
}
// Migrate database to current version
func Migrate(dbConf *data.Database, cacheConf *data.CacheConf) error {
	cache, cacheCleanup, err := data.NewCache(cacheConf)
	if err != nil {
		fmt.Println(""new check failed:"", err.Error())
	}
	engine, err := data.NewDB(false, dbConf)
	if err != nil {
		fmt.Println(""new database failed: "", err.Error())
		return err
	}
	currentDBVersion, err := GetCurrentDBVersion(engine)
	if err != nil {
		return err
	}
	expectedVersion := ExpectedVersion()
	for currentDBVersion < expectedVersion {
		fmt.Printf(""[migrate] current db version is %d, try to migrate version %d, latest version is %d\n"",
			currentDBVersion, currentDBVersion+1, expectedVersion)
		migrationFunc := migrations[currentDBVersion]
		fmt.Printf(""[migrate] try to migrate db version %d, description: %s\n"", currentDBVersion+1, migrationFunc.Description())
		if err := migrationFunc.Migrate(engine); err != nil {
			fmt.Printf(""[migrate] migrate to db version %d failed: %s\n"", currentDBVersion+1, err.Error())
			return err
		}
		if migrationFunc.ShouldCleanCache() {
			if err := cache.Flush(context.Background()); err != nil {
				fmt.Printf(""[migrate] flush cache failed: %s\n"", err.Error())
			}
		}
		fmt.Printf(""[migrate] migrate to db version %d success\n"", currentDBVersion+1)
		if _, err := engine.Update(&entity.Version{ID: 1, VersionNumber: currentDBVersion + 1}); err != nil {
			fmt.Printf(""[migrate] migrate to db version %d, update failed: %s"", currentDBVersion+1, err.Error())
			return err
		}
		currentDBVersion++
	}
	if cache != nil {
		cacheCleanup()
	}
	return nil
}
",CWE-862,132.0,1
"package auth
import (
	""context""
	""encoding/json""
	""github.com/answerdev/answer/internal/base/constant""
	""github.com/answerdev/answer/internal/base/data""
	""github.com/answerdev/answer/internal/base/reason""
	""github.com/answerdev/answer/internal/entity""
	""github.com/answerdev/answer/internal/service/auth""
	""github.com/segmentfault/pacman/errors""
	""github.com/segmentfault/pacman/log""
)
// authRepo auth repository
type authRepo struct {
	data *data.Data
}
// GetUserCacheInfo get user cache info
func (ar *authRepo) GetUserCacheInfo(ctx context.Context, accessToken string) (userInfo *entity.UserCacheInfo, err error) {
	userInfoCache, err := ar.data.Cache.GetString(ctx, constant.UserTokenCacheKey+accessToken)
	if err != nil {
		return nil, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	userInfo = &entity.UserCacheInfo{}
	err = json.Unmarshal([]byte(userInfoCache), userInfo)
	if err != nil {
		return nil, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return userInfo, nil
}
// SetUserCacheInfo set user cache info
func (ar *authRepo) SetUserCacheInfo(ctx context.Context, accessToken string, userInfo *entity.UserCacheInfo) (err error) {
	userInfoCache, err := json.Marshal(userInfo)
	if err != nil {
		return err
	}
	err = ar.data.Cache.SetString(ctx, constant.UserTokenCacheKey+accessToken,
		string(userInfoCache), constant.UserTokenCacheTime)
	if err != nil {
		return errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	if err := ar.AddUserTokenMapping(ctx, userInfo.UserID, accessToken); err != nil {
		log.Error(err)
	}
	return nil
}
// RemoveUserCacheInfo remove user cache info
func (ar *authRepo) RemoveUserCacheInfo(ctx context.Context, accessToken string) (err error) {
	err = ar.data.Cache.Del(ctx, constant.UserTokenCacheKey+accessToken)
	if err != nil {
		return errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return nil
}
// SetUserStatus set user status
func (ar *authRepo) SetUserStatus(ctx context.Context, userID string, userInfo *entity.UserCacheInfo) (err error) {
	userInfoCache, err := json.Marshal(userInfo)
	if err != nil {
		return err
	}
	err = ar.data.Cache.SetString(ctx, constant.UserStatusChangedCacheKey+userID,
		string(userInfoCache), constant.UserStatusChangedCacheTime)
	if err != nil {
		return errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return nil
}
// GetUserStatus get user status
func (ar *authRepo) GetUserStatus(ctx context.Context, userID string) (userInfo *entity.UserCacheInfo, err error) {
	userInfoCache, err := ar.data.Cache.GetString(ctx, constant.UserStatusChangedCacheKey+userID)
	if err != nil {
		return nil, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	userInfo = &entity.UserCacheInfo{}
	err = json.Unmarshal([]byte(userInfoCache), userInfo)
	if err != nil {
		return nil, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return userInfo, nil
}
// RemoveUserStatus remove user status
func (ar *authRepo) RemoveUserStatus(ctx context.Context, userID string) (err error) {
	err = ar.data.Cache.Del(ctx, constant.UserStatusChangedCacheKey+userID)
	if err != nil {
		return errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return nil
}
// GetAdminUserCacheInfo get admin user cache info
func (ar *authRepo) GetAdminUserCacheInfo(ctx context.Context, accessToken string) (userInfo *entity.UserCacheInfo, err error) {
	userInfoCache, err := ar.data.Cache.GetString(ctx, constant.AdminTokenCacheKey+accessToken)
	if err != nil {
		err = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
		return
	}
	userInfo = &entity.UserCacheInfo{}
	err = json.Unmarshal([]byte(userInfoCache), userInfo)
	if err != nil {
		return nil, err
	}
	return userInfo, nil
}
// SetAdminUserCacheInfo set admin user cache info
func (ar *authRepo) SetAdminUserCacheInfo(ctx context.Context, accessToken string, userInfo *entity.UserCacheInfo) (err error) {
	userInfoCache, err := json.Marshal(userInfo)
	if err != nil {
		return err
	}
	err = ar.data.Cache.SetString(ctx, constant.AdminTokenCacheKey+accessToken, string(userInfoCache),
		constant.AdminTokenCacheTime)
	if err != nil {
		return errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return nil
}
// RemoveAdminUserCacheInfo remove admin user cache info
func (ar *authRepo) RemoveAdminUserCacheInfo(ctx context.Context, accessToken string) (err error) {
	err = ar.data.Cache.Del(ctx, constant.AdminTokenCacheKey+accessToken)
	if err != nil {
		return errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return nil
}
// AddUserTokenMapping add user token mapping
func (ar *authRepo) AddUserTokenMapping(ctx context.Context, userID, accessToken string) (err error) {
	key := constant.UserTokenMappingCacheKey + userID
	resp, _ := ar.data.Cache.GetString(ctx, key)
	mapping := make(map[string]bool, 0)
	if len(resp) > 0 {
		_ = json.Unmarshal([]byte(resp), &mapping)
	}
	mapping[accessToken] = true
	content, _ := json.Marshal(mapping)
	return ar.data.Cache.SetString(ctx, key, string(content), constant.UserTokenCacheTime)
}
// RemoveUserTokens Log out all users under this user id
func (ar *authRepo) RemoveUserTokens(ctx context.Context, userID string) {
	key := constant.UserTokenMappingCacheKey + userID
	resp, _ := ar.data.Cache.GetString(ctx, key)
	mapping := make(map[string]bool, 0)
	if len(resp) > 0 {
		_ = json.Unmarshal([]byte(resp), &mapping)
		log.Debugf(""find %d user tokens by user id %s"", len(mapping), userID)
	}
	for token := range mapping {
		if err := ar.RemoveUserCacheInfo(ctx, token); err != nil {
			log.Error(err)
		} else {
			log.Debugf(""del user %s token success"")
		}
	}
	if err := ar.RemoveUserStatus(ctx, userID); err != nil {
		log.Error(err)
	}
	if err := ar.data.Cache.Del(ctx, key); err != nil {
		log.Error(err)
	}
}
// NewAuthRepo new repository
func NewAuthRepo(data *data.Data) auth.AuthRepo {
	return &authRepo{
		data: data,
	}
}
",CWE-613,181.0,1
"package auth
import (
	""context""
	""github.com/answerdev/answer/internal/entity""
	""github.com/answerdev/answer/pkg/token""
	""github.com/segmentfault/pacman/log""
)
// AuthRepo auth repository
type AuthRepo interface {
	GetUserCacheInfo(ctx context.Context, accessToken string) (userInfo *entity.UserCacheInfo, err error)
	SetUserCacheInfo(ctx context.Context, accessToken string, userInfo *entity.UserCacheInfo) error
	RemoveUserCacheInfo(ctx context.Context, accessToken string) (err error)
	SetUserStatus(ctx context.Context, userID string, userInfo *entity.UserCacheInfo) (err error)
	GetUserStatus(ctx context.Context, userID string) (userInfo *entity.UserCacheInfo, err error)
	RemoveUserStatus(ctx context.Context, userID string) (err error)
	GetAdminUserCacheInfo(ctx context.Context, accessToken string) (userInfo *entity.UserCacheInfo, err error)
	SetAdminUserCacheInfo(ctx context.Context, accessToken string, userInfo *entity.UserCacheInfo) error
	RemoveAdminUserCacheInfo(ctx context.Context, accessToken string) (err error)
	AddUserTokenMapping(ctx context.Context, userID, accessToken string) (err error)
	RemoveUserTokens(ctx context.Context, userID string)
}
// AuthService kit service
type AuthService struct {
	authRepo AuthRepo
}
// NewAuthService email service
func NewAuthService(authRepo AuthRepo) *AuthService {
	return &AuthService{
		authRepo: authRepo,
	}
}
func (as *AuthService) GetUserCacheInfo(ctx context.Context, accessToken string) (userInfo *entity.UserCacheInfo, err error) {
	userCacheInfo, err := as.authRepo.GetUserCacheInfo(ctx, accessToken)
	if err != nil {
		return nil, err
	}
	cacheInfo, _ := as.authRepo.GetUserStatus(ctx, userCacheInfo.UserID)
	if cacheInfo != nil {
		log.Debugf(""user status updated: %+v"", cacheInfo)
		userCacheInfo.UserStatus = cacheInfo.UserStatus
		userCacheInfo.EmailStatus = cacheInfo.EmailStatus
		userCacheInfo.RoleID = cacheInfo.RoleID
		// update current user cache info
		err := as.authRepo.SetUserCacheInfo(ctx, accessToken, userCacheInfo)
		if err != nil {
			return nil, err
		}
	}
	return userCacheInfo, nil
}
func (as *AuthService) SetUserCacheInfo(ctx context.Context, userInfo *entity.UserCacheInfo) (accessToken string, err error) {
	accessToken = token.GenerateToken()
	err = as.authRepo.SetUserCacheInfo(ctx, accessToken, userInfo)
	return accessToken, err
}
func (as *AuthService) SetUserStatus(ctx context.Context, userInfo *entity.UserCacheInfo) (err error) {
	return as.authRepo.SetUserStatus(ctx, userInfo.UserID, userInfo)
}
func (as *AuthService) UpdateUserCacheInfo(ctx context.Context, token string, userInfo *entity.UserCacheInfo) (err error) {
	err = as.authRepo.SetUserCacheInfo(ctx, token, userInfo)
	if err != nil {
		return err
	}
	if err := as.authRepo.RemoveUserStatus(ctx, userInfo.UserID); err != nil {
		log.Error(err)
	}
	return
}
func (as *AuthService) RemoveUserCacheInfo(ctx context.Context, accessToken string) (err error) {
	return as.authRepo.RemoveUserCacheInfo(ctx, accessToken)
}
// AddUserTokenMapping add user token mapping
func (as *AuthService) AddUserTokenMapping(ctx context.Context, userID, accessToken string) (err error) {
	return as.authRepo.AddUserTokenMapping(ctx, userID, accessToken)
}
// RemoveUserTokens Log out all users under this user id
func (as *AuthService) RemoveUserTokens(ctx context.Context, userID string) {
	as.authRepo.RemoveUserTokens(ctx, userID)
}
//Admin
func (as *AuthService) GetAdminUserCacheInfo(ctx context.Context, accessToken string) (userInfo *entity.UserCacheInfo, err error) {
	return as.authRepo.GetAdminUserCacheInfo(ctx, accessToken)
}
func (as *AuthService) SetAdminUserCacheInfo(ctx context.Context, accessToken string, userInfo *entity.UserCacheInfo) (err error) {
	err = as.authRepo.SetAdminUserCacheInfo(ctx, accessToken, userInfo)
	return err
}
func (as *AuthService) RemoveAdminUserCacheInfo(ctx context.Context, accessToken string) (err error) {
	return as.authRepo.RemoveAdminUserCacheInfo(ctx, accessToken)
}
",CWE-613,107.0,1
"package migrations
import (
	""encoding/json""
	""fmt""
	""github.com/answerdev/answer/internal/base/constant""
	""github.com/answerdev/answer/internal/entity""
	""github.com/answerdev/answer/internal/schema""
	""github.com/tidwall/gjson""
	""xorm.io/xorm""
)
func addLoginLimitations(x *xorm.Engine) error {
	loginSiteInfo := &entity.SiteInfo{
		Type: constant.SiteTypeLogin,
	}
	exist, err := x.Get(loginSiteInfo)
	if err != nil {
		return fmt.Errorf(""get config failed: %w"", err)
	}
	if exist {
		content := &schema.SiteLoginReq{}
		_ = json.Unmarshal([]byte(loginSiteInfo.Content), content)
		content.AllowEmailRegistrations = true
		content.AllowEmailDomains = make([]string, 0)
		_, err = x.ID(loginSiteInfo.ID).Cols(""content"").Update(loginSiteInfo)
		if err != nil {
			return fmt.Errorf(""update site info failed: %w"", err)
		}
	}
	interfaceSiteInfo := &entity.SiteInfo{
		Type: constant.SiteTypeInterface,
	}
	exist, err = x.Get(interfaceSiteInfo)
	if err != nil {
		return fmt.Errorf(""get config failed: %w"", err)
	}
	siteUsers := &schema.SiteUsersReq{
		AllowUpdateDisplayName: true,
		AllowUpdateUsername:    true,
		AllowUpdateAvatar:      true,
		AllowUpdateBio:         true,
		AllowUpdateWebsite:     true,
		AllowUpdateLocation:    true,
	}
	if exist {
		siteUsers.DefaultAvatar = gjson.Get(interfaceSiteInfo.Content, ""default_avatar"").String()
	}
	data, _ := json.Marshal(siteUsers)
	exist, err = x.Get(&entity.SiteInfo{Type: constant.SiteTypeUsers})
	if err != nil {
		return fmt.Errorf(""get config failed: %w"", err)
	}
	if !exist {
		usersSiteInfo := &entity.SiteInfo{
			Type:    constant.SiteTypeUsers,
			Content: string(data),
			Status:  1,
		}
		_, err = x.InsertOne(usersSiteInfo)
		if err != nil {
			return fmt.Errorf(""insert site info failed: %w"", err)
		}
	}
	return nil
}
",CWE-521,70.0,1
"package checker
import (
	""fmt""
	""regexp""
)
const (
	levelD = iota
	LevelC
	LevelB
	LevelA
	LevelS
)
// CheckPassword
// minLength: Specifies the minimum length of a password
// maxLength：Specifies the maximum length of a password
// minLevel：Specifies the minimum strength level required for passwords
// pwd：Text passwords
func CheckPassword(minLength, maxLength, minLevel int, pwd string) error {
	// First check whether the password length is within the range
	if len(pwd) < minLength {
		return fmt.Errorf(""BAD PASSWORD: The password is shorter than %d characters"", minLength)
	}
	if len(pwd) > maxLength {
		return fmt.Errorf(""BAD PASSWORD: The password is logner than %d characters"", maxLength)
	}
	// The password strength level is initialized to D.
	// The regular is used to verify the password strength.
	// If the matching is successful, the password strength increases by 1
	level := levelD
	patternList := []string{`[0-9]+`, `[a-z]+`, `[A-Z]+`, `[~!@
	for _, pattern := range patternList {
		match, _ := regexp.MatchString(pattern, pwd)
		if match {
			level++
		}
	}
	// If the final password strength falls below the required minimum strength, return with an error
	if level < minLevel {
		return fmt.Errorf(""the password does not satisfy the current policy requirements"")
	}
	return nil
}
",CWE-521,48.0,1
"package controller
import (
	""github.com/answerdev/answer/internal/base/handler""
	""github.com/answerdev/answer/internal/base/middleware""
	""github.com/answerdev/answer/internal/base/reason""
	""github.com/answerdev/answer/internal/base/translator""
	""github.com/answerdev/answer/internal/schema""
	""github.com/answerdev/answer/internal/service""
	""github.com/answerdev/answer/internal/service/rank""
	""github.com/answerdev/answer/pkg/uid""
	""github.com/gin-gonic/gin""
	""github.com/jinzhu/copier""
	""github.com/segmentfault/pacman/errors""
)
// VoteController activity controller
type VoteController struct {
	VoteService *service.VoteService
	rankService *rank.RankService
}
// NewVoteController new controller
func NewVoteController(voteService *service.VoteService, rankService *rank.RankService) *VoteController {
	return &VoteController{VoteService: voteService, rankService: rankService}
}
// VoteUp godoc
// @Summary vote up
// @Description add vote
// @Tags Activity
// @Accept json
// @Produce json
// @Security ApiKeyAuth
// @Param data body schema.VoteReq true ""vote""
// @Success 200 {object} handler.RespBody{data=schema.VoteResp}
// @Router /answer/api/v1/vote/up [post]
func (vc *VoteController) VoteUp(ctx *gin.Context) {
	req := &schema.VoteReq{}
	if handler.BindAndCheck(ctx, req) {
		return
	}
	req.ObjectID = uid.DeShortID(req.ObjectID)
	req.UserID = middleware.GetLoginUserIDFromContext(ctx)
	can, needRank, err := vc.rankService.CheckVotePermission(ctx, req.UserID, req.ObjectID, true)
	if err != nil {
		handler.HandleResponse(ctx, err, nil)
		return
	}
	if !can {
		lang := handler.GetLang(ctx)
		msg := translator.TrWithData(lang, reason.NoEnoughRankToOperate, &schema.PermissionTrTplData{Rank: needRank})
		handler.HandleResponse(ctx, errors.Forbidden(reason.NoEnoughRankToOperate).WithMsg(msg), nil)
		return
	}
	dto := &schema.VoteDTO{}
	_ = copier.Copy(dto, req)
	resp, err := vc.VoteService.VoteUp(ctx, dto)
	if err != nil {
		handler.HandleResponse(ctx, err, schema.ErrTypeToast)
	} else {
		handler.HandleResponse(ctx, err, resp)
	}
}
// VoteDown godoc
// @Summary vote down
// @Description add vote
// @Tags Activity
// @Accept json
// @Produce json
// @Security ApiKeyAuth
// @Param data body schema.VoteReq true ""vote""
// @Success 200 {object} handler.RespBody{data=schema.VoteResp}
// @Router /answer/api/v1/vote/down [post]
func (vc *VoteController) VoteDown(ctx *gin.Context) {
	req := &schema.VoteReq{}
	if handler.BindAndCheck(ctx, req) {
		return
	}
	req.ObjectID = uid.DeShortID(req.ObjectID)
	req.UserID = middleware.GetLoginUserIDFromContext(ctx)
	can, needRank, err := vc.rankService.CheckVotePermission(ctx, req.UserID, req.ObjectID, false)
	if err != nil {
		handler.HandleResponse(ctx, err, nil)
		return
	}
	if !can {
		lang := handler.GetLang(ctx)
		msg := translator.TrWithData(lang, reason.NoEnoughRankToOperate, &schema.PermissionTrTplData{Rank: needRank})
		handler.HandleResponse(ctx, errors.Forbidden(reason.NoEnoughRankToOperate).WithMsg(msg), nil)
		return
	}
	dto := &schema.VoteDTO{}
	_ = copier.Copy(dto, req)
	resp, err := vc.VoteService.VoteDown(ctx, dto)
	if err != nil {
		handler.HandleResponse(ctx, err, schema.ErrTypeToast)
	} else {
		handler.HandleResponse(ctx, err, resp)
	}
}
// UserVotes user votes
// @Summary get user personal votes
// @Description get user personal votes
// @Tags Activity
// @Accept json
// @Produce json
// @Security ApiKeyAuth
// @Param page query int false ""page size""
// @Param page_size query int false ""page size""
// @Success 200 {object} handler.RespBody{data=pager.PageModel{list=[]schema.GetVoteWithPageResp}}
// @Router /answer/api/v1/personal/vote/page [get]
func (vc *VoteController) UserVotes(ctx *gin.Context) {
	req := schema.GetVoteWithPageReq{}
	if handler.BindAndCheck(ctx, &req) {
		return
	}
	req.UserID = middleware.GetLoginUserIDFromContext(ctx)
	resp, err := vc.VoteService.ListUserVotes(ctx, req)
	handler.HandleResponse(ctx, err, resp)
}
",CWE-366,128.0,1
"package activity
import (
	""context""
	""time""
	""github.com/answerdev/answer/internal/service/activity_common""
	""github.com/answerdev/answer/internal/service/follow""
	""github.com/answerdev/answer/pkg/obj""
	""github.com/segmentfault/pacman/log""
	""xorm.io/builder""
	""github.com/answerdev/answer/internal/base/data""
	""github.com/answerdev/answer/internal/base/reason""
	""github.com/answerdev/answer/internal/entity""
	""github.com/answerdev/answer/internal/service/unique""
	""github.com/segmentfault/pacman/errors""
	""xorm.io/xorm""
)
// FollowRepo activity repository
type FollowRepo struct {
	data         *data.Data
	uniqueIDRepo unique.UniqueIDRepo
	activityRepo activity_common.ActivityRepo
}
// NewFollowRepo new repository
func NewFollowRepo(
	data *data.Data,
	uniqueIDRepo unique.UniqueIDRepo,
	activityRepo activity_common.ActivityRepo,
) follow.FollowRepo {
	return &FollowRepo{
		data:         data,
		uniqueIDRepo: uniqueIDRepo,
		activityRepo: activityRepo,
	}
}
func (ar *FollowRepo) Follow(ctx context.Context, objectID, userID string) error {
	objectTypeStr, err := obj.GetObjectTypeStrByObjectID(objectID)
	if err != nil {
		return errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	activityType, err := ar.activityRepo.GetActivityTypeByObjKey(ctx, objectTypeStr, ""follow"")
	if err != nil {
		return err
	}
	_, err = ar.data.DB.Transaction(func(session *xorm.Session) (result any, err error) {
		session = session.Context(ctx)
		var (
			existsActivity entity.Activity
			has            bool
		)
		result = nil
		has, err = session.Where(builder.Eq{""activity_type"": activityType}).
			And(builder.Eq{""user_id"": userID}).
			And(builder.Eq{""object_id"": objectID}).
			Get(&existsActivity)
		if err != nil {
			return
		}
		if has && existsActivity.Cancelled == entity.ActivityAvailable {
			return
		}
		if has {
			_, err = session.Where(builder.Eq{""id"": existsActivity.ID}).
				Cols(`cancelled`).
				Update(&entity.Activity{
					Cancelled: entity.ActivityAvailable,
				})
		} else {
			// update existing activity with new user id and u object id
			_, err = session.Insert(&entity.Activity{
				UserID:           userID,
				ObjectID:         objectID,
				OriginalObjectID: objectID,
				ActivityType:     activityType,
				Cancelled:        entity.ActivityAvailable,
				Rank:             0,
				HasRank:          0,
			})
		}
		if err != nil {
			log.Error(err)
			return
		}
		// start update followers when everything is fine
		err = ar.updateFollows(ctx, session, objectID, 1)
		if err != nil {
			log.Error(err)
		}
		return
	})
	return err
}
func (ar *FollowRepo) FollowCancel(ctx context.Context, objectID, userID string) error {
	objectTypeStr, err := obj.GetObjectTypeStrByObjectID(objectID)
	if err != nil {
		return errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	activityType, err := ar.activityRepo.GetActivityTypeByObjKey(ctx, objectTypeStr, ""follow"")
	if err != nil {
		return err
	}
	_, err = ar.data.DB.Transaction(func(session *xorm.Session) (result any, err error) {
		session = session.Context(ctx)
		var (
			existsActivity entity.Activity
			has            bool
		)
		result = nil
		has, err = session.Where(builder.Eq{""activity_type"": activityType}).
			And(builder.Eq{""user_id"": userID}).
			And(builder.Eq{""object_id"": objectID}).
			Get(&existsActivity)
		if err != nil || !has {
			return
		}
		if has && existsActivity.Cancelled == entity.ActivityCancelled {
			return
		}
		if _, err = session.Where(""id = ?"", existsActivity.ID).
			Cols(""cancelled"").
			Update(&entity.Activity{
				Cancelled:   entity.ActivityCancelled,
				CancelledAt: time.Now(),
			}); err != nil {
			return
		}
		err = ar.updateFollows(ctx, session, objectID, -1)
		return
	})
	return err
}
func (ar *FollowRepo) updateFollows(ctx context.Context, session *xorm.Session, objectID string, follows int) error {
	objectType, err := obj.GetObjectTypeStrByObjectID(objectID)
	if err != nil {
		return err
	}
	switch objectType {
	case ""question"":
		_, err = session.Where(""id = ?"", objectID).Incr(""follow_count"", follows).Update(&entity.Question{})
	case ""user"":
		_, err = session.Where(""id = ?"", objectID).Incr(""follow_count"", follows).Update(&entity.User{})
	case ""tag"":
		_, err = session.Where(""id = ?"", objectID).Incr(""follow_count"", follows).Update(&entity.Tag{})
	default:
		err = errors.InternalServer(reason.DisallowFollow).WithMsg(""this object can't be followed"")
	}
	return err
}
",CWE-366,169.0,1
"package activity
import (
	""context""
	""github.com/answerdev/answer/internal/base/data""
	""github.com/answerdev/answer/internal/base/reason""
	""github.com/answerdev/answer/internal/entity""
	""github.com/answerdev/answer/internal/service/activity""
	""github.com/answerdev/answer/internal/service/activity_common""
	""github.com/answerdev/answer/internal/service/config""
	""github.com/answerdev/answer/internal/service/rank""
	""github.com/segmentfault/pacman/errors""
	""xorm.io/xorm""
)
// UserActiveActivityRepo answer accepted
type UserActiveActivityRepo struct {
	data          *data.Data
	activityRepo  activity_common.ActivityRepo
	userRankRepo  rank.UserRankRepo
	configService *config.ConfigService
}
const (
	UserActivated = ""user.activated""
)
// NewUserActiveActivityRepo new repository
func NewUserActiveActivityRepo(
	data *data.Data,
	activityRepo activity_common.ActivityRepo,
	userRankRepo rank.UserRankRepo,
	configService *config.ConfigService,
) activity.UserActiveActivityRepo {
	return &UserActiveActivityRepo{
		data:          data,
		activityRepo:  activityRepo,
		userRankRepo:  userRankRepo,
		configService: configService,
	}
}
// UserActive accept other answer
func (ar *UserActiveActivityRepo) UserActive(ctx context.Context, userID string) (err error) {
	cfg, err := ar.configService.GetConfigByKey(ctx, UserActivated)
	if err != nil {
		return err
	}
	activityType := cfg.ID
	deltaRank := cfg.GetIntValue()
	addActivity := &entity.Activity{
		UserID:           userID,
		ObjectID:         ""0"",
		OriginalObjectID: ""0"",
		ActivityType:     activityType,
		Rank:             deltaRank,
		HasRank:          1,
	}
	_, err = ar.data.DB.Transaction(func(session *xorm.Session) (result any, err error) {
		session = session.Context(ctx)
		_, exists, err := ar.activityRepo.GetActivity(ctx, session, ""0"", addActivity.UserID, activityType)
		if err != nil {
			return nil, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
		}
		if exists {
			return nil, nil
		}
		_, err = ar.userRankRepo.TriggerUserRank(ctx, session, addActivity.UserID, addActivity.Rank, activityType)
		if err != nil {
			return nil, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
		}
		_, err = session.Insert(addActivity)
		if err != nil {
			return nil, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
		}
		return nil, nil
	})
	return err
}
",CWE-366,84.0,1
"package activity_common
import (
	""context""
	""fmt""
	""time""
	""github.com/answerdev/answer/internal/entity""
	""github.com/answerdev/answer/internal/service/activity_common""
	""github.com/answerdev/answer/internal/service/activity_type""
	""github.com/answerdev/answer/pkg/obj""
	""xorm.io/builder""
	""xorm.io/xorm""
	""github.com/answerdev/answer/internal/base/data""
	""github.com/answerdev/answer/internal/base/reason""
	""github.com/answerdev/answer/internal/service/config""
	""github.com/answerdev/answer/internal/service/unique""
	""github.com/segmentfault/pacman/errors""
)
// ActivityRepo activity repository
type ActivityRepo struct {
	data          *data.Data
	uniqueIDRepo  unique.UniqueIDRepo
	configService *config.ConfigService
}
// NewActivityRepo new repository
func NewActivityRepo(
	data *data.Data,
	uniqueIDRepo unique.UniqueIDRepo,
	configService *config.ConfigService,
) activity_common.ActivityRepo {
	return &ActivityRepo{
		data:          data,
		uniqueIDRepo:  uniqueIDRepo,
		configService: configService,
	}
}
func (ar *ActivityRepo) GetActivityTypeByObjID(ctx context.Context, objectID string, action string) (
	activityType, rank, hasRank int, err error) {
	objectKey, err := obj.GetObjectTypeStrByObjectID(objectID)
	if err != nil {
		return
	}
	confKey := fmt.Sprintf(""%s.%s"", objectKey, action)
	cfg, err := ar.configService.GetConfigByKey(ctx, confKey)
	if err != nil {
		return
	}
	activityType, rank = cfg.ID, cfg.GetIntValue()
	hasRank = 0
	if rank != 0 {
		hasRank = 1
	}
	return
}
func (ar *ActivityRepo) GetActivityTypeByObjKey(ctx context.Context, objectKey, action string) (activityType int, err error) {
	configKey := fmt.Sprintf(""%s.%s"", objectKey, action)
	cfg, err := ar.configService.GetConfigByKey(ctx, configKey)
	if err != nil {
		return 0, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return cfg.ID, nil
}
func (ar *ActivityRepo) GetActivityTypeByConfigKey(ctx context.Context, configKey string) (activityType int, err error) {
	cfg, err := ar.configService.GetConfigByKey(ctx, configKey)
	if err != nil {
		return 0, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return cfg.ID, nil
}
func (ar *ActivityRepo) GetActivity(ctx context.Context, session *xorm.Session,
	objectID, userID string, activityType int,
) (existsActivity *entity.Activity, exist bool, err error) {
	existsActivity = &entity.Activity{}
	exist, err = session.
		Where(builder.Eq{""object_id"": objectID}).
		And(builder.Eq{""user_id"": userID}).
		And(builder.Eq{""activity_type"": activityType}).
		Get(existsActivity)
	return
}
func (ar *ActivityRepo) GetUserIDObjectIDActivitySum(ctx context.Context, userID, objectID string) (int, error) {
	sum := &entity.ActivityRankSum{}
	_, err := ar.data.DB.Context(ctx).Table(entity.Activity{}.TableName()).
		Select(""sum(`rank`) as `rank`"").
		Where(""user_id =?"", userID).
		And(""object_id = ?"", objectID).
		And(""cancelled =0"").
		Get(sum)
	if err != nil {
		err = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
		return 0, err
	}
	return sum.Rank, nil
}
// AddActivity add activity
func (ar *ActivityRepo) AddActivity(ctx context.Context, activity *entity.Activity) (err error) {
	_, err = ar.data.DB.Context(ctx).Insert(activity)
	if err != nil {
		err = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return
}
// GetUsersWhoHasGainedTheMostReputation get users who has gained the most reputation over a period of time
func (ar *ActivityRepo) GetUsersWhoHasGainedTheMostReputation(
	ctx context.Context, startTime, endTime time.Time, limit int) (rankStat []*entity.ActivityUserRankStat, err error) {
	rankStat = make([]*entity.ActivityUserRankStat, 0)
	session := ar.data.DB.Context(ctx).Select(""user_id, SUM(`rank`) AS rank_amount"").Table(""activity"")
	session.Where(""has_rank = 1 AND cancelled = 0"")
	session.Where(""created_at >= ?"", startTime)
	session.Where(""created_at <= ?"", endTime)
	session.GroupBy(""user_id"")
	session.Desc(""rank_amount"")
	session.Limit(limit)
	err = session.Find(&rankStat)
	if err != nil {
		err = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return
}
// GetUsersWhoHasVoteMost get users who has vote most
func (ar *ActivityRepo) GetUsersWhoHasVoteMost(
	ctx context.Context, startTime, endTime time.Time, limit int) (voteStat []*entity.ActivityUserVoteStat, err error) {
	voteStat = make([]*entity.ActivityUserVoteStat, 0)
	actIDs := make([]int, 0)
	for _, act := range activity_type.ActivityTypeList {
		cfg, err := ar.configService.GetConfigByKey(ctx, act)
		if err == nil {
			actIDs = append(actIDs, cfg.ID)
		}
	}
	session := ar.data.DB.Context(ctx).Select(""user_id, COUNT(*) AS vote_count"").Table(""activity"")
	session.Where(""cancelled = 0"")
	session.In(""activity_type"", actIDs)
	session.Where(""created_at >= ?"", startTime)
	session.Where(""created_at <= ?"", endTime)
	session.GroupBy(""user_id"")
	session.Desc(""vote_count"")
	session.Limit(limit)
	err = session.Find(&voteStat)
	if err != nil {
		err = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return
}
",CWE-366,160.0,1
"package activity_common
import (
	""context""
	""github.com/answerdev/answer/internal/base/data""
	""github.com/answerdev/answer/internal/base/reason""
	""github.com/answerdev/answer/internal/entity""
	""github.com/answerdev/answer/internal/service/activity_common""
	""github.com/answerdev/answer/internal/service/unique""
	""github.com/answerdev/answer/pkg/obj""
	""github.com/segmentfault/pacman/errors""
	""github.com/segmentfault/pacman/log""
)
// FollowRepo follow repository
type FollowRepo struct {
	data         *data.Data
	uniqueIDRepo unique.UniqueIDRepo
	activityRepo activity_common.ActivityRepo
}
// NewFollowRepo new repository
func NewFollowRepo(
	data *data.Data,
	uniqueIDRepo unique.UniqueIDRepo,
	activityRepo activity_common.ActivityRepo,
) activity_common.FollowRepo {
	return &FollowRepo{
		data:         data,
		uniqueIDRepo: uniqueIDRepo,
		activityRepo: activityRepo,
	}
}
// GetFollowAmount get object id's follows
func (ar *FollowRepo) GetFollowAmount(ctx context.Context, objectID string) (follows int, err error) {
	objectType, err := obj.GetObjectTypeStrByObjectID(objectID)
	if err != nil {
		return 0, err
	}
	switch objectType {
	case ""question"":
		model := &entity.Question{}
		_, err = ar.data.DB.Context(ctx).Where(""id = ?"", objectID).Cols(""`follow_count`"").Get(model)
		if err == nil {
			follows = int(model.FollowCount)
		}
	case ""user"":
		model := &entity.User{}
		_, err = ar.data.DB.Context(ctx).Where(""id = ?"", objectID).Cols(""`follow_count`"").Get(model)
		if err == nil {
			follows = int(model.FollowCount)
		}
	case ""tag"":
		model := &entity.Tag{}
		_, err = ar.data.DB.Context(ctx).Where(""id = ?"", objectID).Cols(""`follow_count`"").Get(model)
		if err == nil {
			follows = int(model.FollowCount)
		}
	default:
		err = errors.InternalServer(reason.DisallowFollow).WithMsg(""this object can't be followed"")
	}
	if err != nil {
		return 0, err
	}
	return follows, nil
}
// GetFollowUserIDs get follow userID by objectID
func (ar *FollowRepo) GetFollowUserIDs(ctx context.Context, objectID string) (userIDs []string, err error) {
	objectTypeStr, err := obj.GetObjectTypeStrByObjectID(objectID)
	if err != nil {
		return nil, err
	}
	activityType, err := ar.activityRepo.GetActivityTypeByObjKey(ctx, objectTypeStr, ""follow"")
	if err != nil {
		log.Errorf(""can't get activity type by object key: %s"", objectTypeStr)
		return nil, err
	}
	userIDs = make([]string, 0)
	session := ar.data.DB.Context(ctx).Select(""user_id"")
	session.Table(entity.Activity{}.TableName())
	session.Where(""object_id = ?"", objectID)
	session.Where(""activity_type = ?"", activityType)
	session.Where(""cancelled = 0"")
	err = session.Find(&userIDs)
	if err != nil {
		return nil, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return userIDs, nil
}
// GetFollowIDs get all follow id list
func (ar *FollowRepo) GetFollowIDs(ctx context.Context, userID, objectKey string) (followIDs []string, err error) {
	followIDs = make([]string, 0)
	activityType, err := ar.activityRepo.GetActivityTypeByObjKey(ctx, objectKey, ""follow"")
	if err != nil {
		return nil, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	session := ar.data.DB.Context(ctx).Select(""object_id"")
	session.Table(entity.Activity{}.TableName())
	session.Where(""user_id = ? AND activity_type = ?"", userID, activityType)
	session.Where(""cancelled = 0"")
	err = session.Find(&followIDs)
	if err != nil {
		return nil, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return followIDs, nil
}
// IsFollowed check user if follow object or not
func (ar *FollowRepo) IsFollowed(ctx context.Context, userID, objectID string) (followed bool, err error) {
	objectKey, err := obj.GetObjectTypeStrByObjectID(objectID)
	if err != nil {
		return false, err
	}
	activityType, err := ar.activityRepo.GetActivityTypeByObjKey(ctx, objectKey, ""follow"")
	if err != nil {
		return false, err
	}
	at := &entity.Activity{}
	has, err := ar.data.DB.Context(ctx).Where(""user_id = ? AND object_id = ? AND activity_type = ?"", userID, objectID, activityType).Get(at)
	if err != nil {
		return false, err
	}
	if !has {
		return false, nil
	}
	if at.Cancelled == entity.ActivityCancelled {
		return false, nil
	} else {
		return true, nil
	}
}
",CWE-366,140.0,1
"package repo
import (
	""github.com/answerdev/answer/internal/base/data""
	""github.com/answerdev/answer/internal/repo/activity""
	""github.com/answerdev/answer/internal/repo/activity_common""
	""github.com/answerdev/answer/internal/repo/answer""
	""github.com/answerdev/answer/internal/repo/auth""
	""github.com/answerdev/answer/internal/repo/captcha""
	""github.com/answerdev/answer/internal/repo/collection""
	""github.com/answerdev/answer/internal/repo/comment""
	""github.com/answerdev/answer/internal/repo/config""
	""github.com/answerdev/answer/internal/repo/export""
	""github.com/answerdev/answer/internal/repo/meta""
	""github.com/answerdev/answer/internal/repo/notification""
	""github.com/answerdev/answer/internal/repo/plugin_config""
	""github.com/answerdev/answer/internal/repo/question""
	""github.com/answerdev/answer/internal/repo/rank""
	""github.com/answerdev/answer/internal/repo/reason""
	""github.com/answerdev/answer/internal/repo/report""
	""github.com/answerdev/answer/internal/repo/revision""
	""github.com/answerdev/answer/internal/repo/role""
	""github.com/answerdev/answer/internal/repo/search_common""
	""github.com/answerdev/answer/internal/repo/site_info""
	""github.com/answerdev/answer/internal/repo/tag""
	""github.com/answerdev/answer/internal/repo/tag_common""
	""github.com/answerdev/answer/internal/repo/unique""
	""github.com/answerdev/answer/internal/repo/user""
	""github.com/answerdev/answer/internal/repo/user_external_login""
	""github.com/google/wire""
)
// ProviderSetRepo is data providers.
var ProviderSetRepo = wire.NewSet(
	data.NewData,
	data.NewDB,
	data.NewCache,
	comment.NewCommentRepo,
	comment.NewCommentCommonRepo,
	captcha.NewCaptchaRepo,
	unique.NewUniqueIDRepo,
	report.NewReportRepo,
	activity_common.NewFollowRepo,
	activity_common.NewVoteRepo,
	config.NewConfigRepo,
	user.NewUserRepo,
	user.NewUserAdminRepo,
	rank.NewUserRankRepo,
	question.NewQuestionRepo,
	answer.NewAnswerRepo,
	activity_common.NewActivityRepo,
	activity.NewVoteRepo,
	activity.NewFollowRepo,
	activity.NewAnswerActivityRepo,
	activity.NewQuestionActivityRepo,
	activity.NewUserActiveActivityRepo,
	activity.NewActivityRepo,
	tag.NewTagRepo,
	tag_common.NewTagCommonRepo,
	tag.NewTagRelRepo,
	collection.NewCollectionRepo,
	collection.NewCollectionGroupRepo,
	auth.NewAuthRepo,
	revision.NewRevisionRepo,
	search_common.NewSearchRepo,
	meta.NewMetaRepo,
	export.NewEmailRepo,
	reason.NewReasonRepo,
	site_info.NewSiteInfo,
	notification.NewNotificationRepo,
	role.NewRoleRepo,
	role.NewUserRoleRelRepo,
	role.NewRolePowerRelRepo,
	role.NewPowerRepo,
	user_external_login.NewUserExternalLoginRepo,
	plugin_config.NewPluginConfigRepo,
)
",CWE-366,78.0,1
"package rank
import (
	""context""
	""github.com/answerdev/answer/internal/base/data""
	""github.com/answerdev/answer/internal/base/pager""
	""github.com/answerdev/answer/internal/base/reason""
	""github.com/answerdev/answer/internal/entity""
	""github.com/answerdev/answer/internal/service/config""
	""github.com/answerdev/answer/internal/service/rank""
	""github.com/answerdev/answer/plugin""
	""github.com/jinzhu/now""
	""github.com/segmentfault/pacman/errors""
	""github.com/segmentfault/pacman/log""
	""xorm.io/builder""
	""xorm.io/xorm""
)
// UserRankRepo user rank repository
type UserRankRepo struct {
	data          *data.Data
	configService *config.ConfigService
}
// NewUserRankRepo new repository
func NewUserRankRepo(data *data.Data, configService *config.ConfigService) rank.UserRankRepo {
	return &UserRankRepo{
		data:          data,
		configService: configService,
	}
}
// TriggerUserRank trigger user rank change
// session is need provider, it means this action must be success or failure
// if outer action is failed then this action is need rollback
func (ur *UserRankRepo) TriggerUserRank(ctx context.Context,
	session *xorm.Session, userID string, deltaRank int, activityType int,
) (isReachStandard bool, err error) {
	// IMPORTANT: If user center enabled the rank agent, then we should not change user rank.
	if plugin.RankAgentEnabled() {
		return false, nil
	}
	if deltaRank == 0 {
		return false, nil
	}
	if deltaRank < 0 {
		// if user rank is lower than 1 after this action, then user rank will be set to 1 only.
		var isReachMin bool
		isReachMin, err = ur.checkUserMinRank(ctx, session, userID, deltaRank)
		if err != nil {
			return false, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
		}
		if isReachMin {
			_, err = session.Where(builder.Eq{""id"": userID}).Update(&entity.User{Rank: 1})
			if err != nil {
				return false, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
			}
			return true, nil
		}
	} else {
		isReachStandard, err = ur.checkUserTodayRank(ctx, session, userID, activityType)
		if err != nil {
			return false, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
		}
		if isReachStandard {
			return isReachStandard, nil
		}
	}
	_, err = session.Where(builder.Eq{""id"": userID}).Incr(""`rank`"", deltaRank).Update(&entity.User{})
	if err != nil {
		return false, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return false, nil
}
func (ur *UserRankRepo) checkUserMinRank(ctx context.Context, session *xorm.Session, userID string, deltaRank int) (
	isReachStandard bool, err error,
) {
	bean := &entity.User{ID: userID}
	_, err = session.Select(""`rank`"").Get(bean)
	if err != nil {
		return false, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	if bean.Rank+deltaRank < 1 {
		log.Infof(""user %s is rank %d out of range before rank operation"", userID, deltaRank)
		return true, nil
	}
	return
}
func (ur *UserRankRepo) checkUserTodayRank(ctx context.Context,
	session *xorm.Session, userID string, activityType int,
) (isReachStandard bool, err error) {
	// exclude daily rank
	exclude, _ := ur.configService.GetArrayStringValue(ctx, ""daily_rank_limit.exclude"")
	for _, item := range exclude {
		cfg, err := ur.configService.GetConfigByKey(ctx, item)
		if err != nil {
			return false, err
		}
		if activityType == cfg.ID {
			return false, nil
		}
	}
	// get user
	start, end := now.BeginningOfDay(), now.EndOfDay()
	session.Where(builder.Eq{""user_id"": userID})
	session.Where(builder.Eq{""cancelled"": 0})
	session.Where(builder.Between{
		Col:     ""updated_at"",
		LessVal: start,
		MoreVal: end,
	})
	earned, err := session.Sum(&entity.Activity{}, ""`rank`"")
	if err != nil {
		return false, err
	}
	// max rank
	maxDailyRank, err := ur.configService.GetIntValue(ctx, ""daily_rank_limit"")
	if err != nil {
		return false, err
	}
	if int(earned) < maxDailyRank {
		return false, nil
	}
	log.Infof(""user %s today has rank %d is reach stand %d"", userID, earned, maxDailyRank)
	return true, nil
}
func (ur *UserRankRepo) UserRankPage(ctx context.Context, userID string, page, pageSize int) (
	rankPage []*entity.Activity, total int64, err error,
) {
	rankPage = make([]*entity.Activity, 0)
	session := ur.data.DB.Context(ctx).Where(builder.Eq{""has_rank"": 1}.And(builder.Eq{""cancelled"": 0})).And(builder.Gt{""`rank`"": 0})
	session.Desc(""created_at"")
	cond := &entity.Activity{UserID: userID}
	total, err = pager.Help(page, pageSize, &rankPage, cond, session)
	if err != nil {
		err = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return
}
",CWE-366,150.0,1
"package schema
type VoteReq struct {
	ObjectID string `validate:""required"" form:""object_id"" json:""object_id""`  //	 id
	IsCancel bool   `validate:""omitempty"" form:""is_cancel"" json:""is_cancel""` // is cancel
	UserID   string `json:""-""`
}
type VoteDTO struct {
	// object TagID
	ObjectID string
	// is cancel
	IsCancel bool
	// user TagID
	UserID string
}
type VoteResp struct {
	UpVotes    int    `json:""up_votes""`
	DownVotes  int    `json:""down_votes""`
	Votes      int    `json:""votes""`
	VoteStatus string `json:""vote_status""`
}
type GetVoteWithPageReq struct {
	// page
	Page int `validate:""omitempty,min=1"" form:""page""`
	// page size
	PageSize int `validate:""omitempty,min=1"" form:""page_size""`
	// user id
	UserID string `json:""-""`
}
type VoteQuestion struct {
	// object ID
	ID string `json:""id""`
	// title
	Title string `json:""title""`
}
type VoteAnswer struct {
	// object ID
	ID string `json:""id""`
	// question ID
	QuestionID string `json:""question_id""`
	// title
	Title string `json:""title""`
}
type GetVoteWithPageResp struct {
	// create time
	CreatedAt int64 `json:""created_at""`
	// object id
	ObjectID string `json:""object_id""`
	// question id
	QuestionID string `json:""question_id""`
	// answer id
	AnswerID string `json:""answer_id""`
	// object type
	ObjectType string `json:""object_type"" enums:""question,answer,tag,comment""`
	// title
	Title string `json:""title""`
	// url title
	UrlTitle string `json:""url_title""`
	// content
	Content string `json:""content""`
	// vote type
	VoteType string `json:""vote_type""`
}
",CWE-366,70.0,1
"package activity
import (
	""context""
	""time""
	""github.com/segmentfault/pacman/log""
)
// AnswerActivityRepo answer activity
type AnswerActivityRepo interface {
	AcceptAnswer(ctx context.Context,
		answerObjID, questionObjID, questionUserID, answerUserID string, isSelf bool) (err error)
	CancelAcceptAnswer(ctx context.Context,
		answerObjID, questionObjID, questionUserID, answerUserID string) (err error)
	DeleteAnswer(ctx context.Context, answerID string) (err error)
}
// QuestionActivityRepo answer activity
type QuestionActivityRepo interface {
	DeleteQuestion(ctx context.Context, questionID string) (err error)
}
// AnswerActivityService user service
type AnswerActivityService struct {
	answerActivityRepo   AnswerActivityRepo
	questionActivityRepo QuestionActivityRepo
}
// NewAnswerActivityService new comment service
func NewAnswerActivityService(
	answerActivityRepo AnswerActivityRepo, questionActivityRepo QuestionActivityRepo) *AnswerActivityService {
	return &AnswerActivityService{
		answerActivityRepo:   answerActivityRepo,
		questionActivityRepo: questionActivityRepo,
	}
}
// AcceptAnswer accept answer change activity
func (as *AnswerActivityService) AcceptAnswer(ctx context.Context,
	answerObjID, questionObjID, questionUserID, answerUserID string, isSelf bool) (err error) {
	return as.answerActivityRepo.AcceptAnswer(ctx, answerObjID, questionObjID, questionUserID, answerUserID, isSelf)
}
// CancelAcceptAnswer cancel accept answer change activity
func (as *AnswerActivityService) CancelAcceptAnswer(ctx context.Context,
	answerObjID, questionObjID, questionUserID, answerUserID string) (err error) {
	return as.answerActivityRepo.CancelAcceptAnswer(ctx, answerObjID, questionObjID, questionUserID, answerUserID)
}
// DeleteAnswer delete answer change activity
func (as *AnswerActivityService) DeleteAnswer(ctx context.Context, answerID string, createdAt time.Time,
	voteCount int) (err error) {
	if voteCount >= 3 {
		log.Infof(""There is no need to roll back the reputation by answering likes above the target value. %s %d"", answerID, voteCount)
		return nil
	}
	if createdAt.Before(time.Now().AddDate(0, 0, -60)) {
		log.Infof(""There is no need to roll back the reputation by answer's existence time meets the target. %s %s"", answerID, createdAt.String())
		return nil
	}
	return as.answerActivityRepo.DeleteAnswer(ctx, answerID)
}
// DeleteQuestion delete question change activity
func (as *AnswerActivityService) DeleteQuestion(ctx context.Context, questionID string, createdAt time.Time,
	voteCount int) (err error) {
	if voteCount >= 3 {
		log.Infof(""There is no need to roll back the reputation by answering likes above the target value. %s %d"", questionID, voteCount)
		return nil
	}
	if createdAt.Before(time.Now().AddDate(0, 0, -60)) {
		log.Infof(""There is no need to roll back the reputation by answer's existence time meets the target. %s %s"", questionID, createdAt.String())
		return nil
	}
	return as.questionActivityRepo.DeleteQuestion(ctx, questionID)
}
",CWE-366,78.0,1
"package activity_common
import (
	""context""
	""time""
	""github.com/answerdev/answer/internal/entity""
	""github.com/answerdev/answer/internal/schema""
	""github.com/answerdev/answer/internal/service/activity_queue""
	""github.com/answerdev/answer/pkg/converter""
	""github.com/answerdev/answer/pkg/uid""
	""github.com/segmentfault/pacman/log""
	""xorm.io/xorm""
)
type ActivityRepo interface {
	GetActivityTypeByObjID(ctx context.Context, objectId string, action string) (activityType, rank int, hasRank int, err error)
	GetActivityTypeByObjKey(ctx context.Context, objectKey, action string) (activityType int, err error)
	GetActivity(ctx context.Context, session *xorm.Session, objectID, userID string, activityType int) (
		existsActivity *entity.Activity, exist bool, err error)
	GetUserIDObjectIDActivitySum(ctx context.Context, userID, objectID string) (int, error)
	GetActivityTypeByConfigKey(ctx context.Context, configKey string) (activityType int, err error)
	AddActivity(ctx context.Context, activity *entity.Activity) (err error)
	GetUsersWhoHasGainedTheMostReputation(
		ctx context.Context, startTime, endTime time.Time, limit int) (rankStat []*entity.ActivityUserRankStat, err error)
	GetUsersWhoHasVoteMost(
		ctx context.Context, startTime, endTime time.Time, limit int) (voteStat []*entity.ActivityUserVoteStat, err error)
}
type ActivityCommon struct {
	activityRepo         ActivityRepo
	activityQueueService activity_queue.ActivityQueueService
}
// NewActivityCommon new activity common
func NewActivityCommon(
	activityRepo ActivityRepo,
	activityQueueService activity_queue.ActivityQueueService,
) *ActivityCommon {
	activity := &ActivityCommon{
		activityRepo:         activityRepo,
		activityQueueService: activityQueueService,
	}
	activity.activityQueueService.RegisterHandler(activity.HandleActivity)
	return activity
}
// HandleActivity handle activity message
func (ac *ActivityCommon) HandleActivity(ctx context.Context, msg *schema.ActivityMsg) error {
	activityType, err := ac.activityRepo.GetActivityTypeByConfigKey(ctx, string(msg.ActivityTypeKey))
	if err != nil {
		log.Errorf(""error getting activity type %s, activity type is %d"", err, activityType)
		return err
	}
	act := &entity.Activity{
		UserID:           msg.UserID,
		TriggerUserID:    msg.TriggerUserID,
		ObjectID:         uid.DeShortID(msg.ObjectID),
		OriginalObjectID: uid.DeShortID(msg.OriginalObjectID),
		ActivityType:     activityType,
		Cancelled:        entity.ActivityAvailable,
	}
	if len(msg.RevisionID) > 0 {
		act.RevisionID = converter.StringToInt64(msg.RevisionID)
	}
	if err := ac.activityRepo.AddActivity(ctx, act); err != nil {
		return err
	}
	return nil
}
",CWE-366,72.0,1
"package config
import (
	""encoding/json""
	""fmt""
	""github.com/KubeOperator/kubepi/internal/model/v1/config""
	""github.com/KubeOperator/kubepi/pkg/file""
	""github.com/coreos/etcd/pkg/fileutil""
	""github.com/spf13/viper""
)
const configNotFoundSkipErr = ""config file not found in %s, skip""
const configReadErr = ""can not read config file %s ,%s""
const configMergeErr = ""can not merge config file, %s""
var configFilePaths = []string{
	""/etc/kubepi"",
}
func ReadConfig(c *config.Config, path ...string)  error {
	v := viper.New()
	v.SetConfigName(""app"")
	v.SetConfigType(""yaml"")
	for i := range path {
		configFilePaths = append(configFilePaths, path[i])
	}
	for i := range configFilePaths {
		realDir := file.ReplaceHomeDir(configFilePaths[i])
		if exists := fileutil.Exist(realDir); !exists {
			fmt.Println(fmt.Sprintf(configNotFoundSkipErr, realDir))
			continue
		}
		v.AddConfigPath(realDir)
		if err := v.ReadInConfig(); err != nil {
			fmt.Println(fmt.Sprintf(configReadErr, realDir, err.Error()))
			continue
		}
		if err := v.MergeInConfig(); err != nil {
			fmt.Println(fmt.Sprintf(configMergeErr, configFilePaths))
		}
	}
	var configMap map[string]interface{}
	if err := v.Unmarshal(&configMap); err != nil {
		return  err
	}
	str, err := json.Marshal(&configMap)
	if err != nil {
		return  err
	}
	if err := json.Unmarshal(str, &c); err != nil {
		return  nil
	}
	return  nil
}
",CWE-798,60.0,1
"package config
import v1 ""github.com/KubeOperator/kubepi/internal/model/v1""
type Config struct {
	v1.BaseModel
	v1.Metadata
	Spec Spec `json:""spec""`
}
type Spec struct {
	Server  ServerConfig  `json:""server""`
	DB      DBConfig      `json:""db""`
	Session SessionConfig `json:""session""`
	Logger  LoggerConfig  `json:""logger""`
	AppId   string        `json:""appId""`
}
type ServerConfig struct {
	Bind BindConfig `json:""bind""`
	SSL  SSLConfig  `json:""ssl""`
}
type BindConfig struct {
	Host string `json:""host""`
	Port int    `json:""port""`
}
type SSLConfig struct {
	Enable         bool   `json:""enable""`
	Certificate    string `json:""certificate""`
	CertificateKey string `json:""certificateKey""`
}
type LoggerConfig struct {
	Level string
}
type DBConfig struct {
	Path string `json:""path""`
}
type SessionConfig struct {
	Expires int `json:""expires""`
}
",CWE-798,45.0,1
"package v1
import (
	""encoding/json""
	""net/http""
	""github.com/KubeOperator/KubeOperator/pkg/controller""
	""github.com/KubeOperator/KubeOperator/pkg/errorf""
	""github.com/KubeOperator/KubeOperator/pkg/middleware""
	""github.com/jinzhu/gorm""
	""github.com/kataras/iris/v12""
	""github.com/kataras/iris/v12/context""
	""github.com/kataras/iris/v12/mvc""
	""github.com/pkg/errors""
)
var AuthScope iris.Party
var WhiteScope iris.Party
func V1(parent iris.Party) {
	v1 := parent.Party(""/v1"")
	authParty := v1.Party(""/auth"")
	mvc.New(authParty.Party(""/session"")).HandleError(ErrorHandler).Handle(controller.NewSessionController())
	mvc.New(v1.Party(""/user"")).HandleError(ErrorHandler).Handle(controller.NewForgotPasswordController())
	AuthScope = v1.Party(""/"")
	AuthScope.Use(middleware.JWTMiddleware().Serve)
	AuthScope.Use(middleware.UserMiddleware)
	AuthScope.Use(middleware.RBACMiddleware())
	AuthScope.Use(middleware.PagerMiddleware)
	AuthScope.Use(middleware.ForceMiddleware)
	mvc.New(AuthScope.Party(""/clusters"")).HandleError(ErrorHandler).Handle(controller.NewClusterController())
	mvc.New(AuthScope.Party(""/credentials"")).HandleError(ErrorHandler).Handle(controller.NewCredentialController())
	mvc.New(AuthScope.Party(""/hosts"")).HandleError(ErrorHandler).Handle(controller.NewHostController())
	mvc.New(AuthScope.Party(""/users"")).HandleError(ErrorHandler).Handle(controller.NewUserController())
	mvc.New(AuthScope.Party(""/dashboard"")).HandleError(ErrorHandler).Handle(controller.NewKubePiController())
	mvc.New(AuthScope.Party(""/regions"")).HandleError(ErrorHandler).Handle(controller.NewRegionController())
	mvc.New(AuthScope.Party(""/zones"")).HandleError(ErrorHandler).Handle(controller.NewZoneController())
	mvc.New(AuthScope.Party(""/plans"")).HandleError(ErrorHandler).Handle(controller.NewPlanController())
	mvc.New(AuthScope.Party(""/settings"")).HandleError(ErrorHandler).Handle(controller.NewSystemSettingController())
	mvc.New(AuthScope.Party(""/ntp"")).HandleError(ErrorHandler).Handle(controller.NewNtpServerController())
	mvc.New(AuthScope.Party(""/logs"")).HandleError(ErrorHandler).Handle(controller.NewSystemLogController())
	mvc.New(AuthScope.Party(""/projects"")).HandleError(ErrorHandler).Handle(controller.NewProjectController())
	mvc.New(AuthScope.Party(""/clusters/provisioner"")).HandleError(ErrorHandler).Handle(controller.NewProvisionerController())
	mvc.New(AuthScope.Party(""/kubernetes"")).HandleError(ErrorHandler).Handle(controller.NewKubernetesController())
	mvc.New(AuthScope.Party(""/clusters/tool"")).HandleError(ErrorHandler).Handle(controller.NewClusterToolController())
	mvc.New(AuthScope.Party(""/backupaccounts"")).HandleError(ErrorHandler).Handle(controller.NewBackupAccountController())
	mvc.New(AuthScope.Party(""/clusters/backup"")).HandleError(ErrorHandler).Handle(controller.NewClusterBackupStrategyController())
	mvc.New(AuthScope.Party(""/clusters/monitor"")).HandleError(ErrorHandler).Handle(controller.NewMonitorController())
	mvc.New(AuthScope.Party(""/tasks"")).Handle(ErrorHandler).Handle(controller.NewTaskLogController())
	mvc.New(AuthScope.Party(""/components"")).Handle(ErrorHandler).Handle(controller.NewComponentController())
	mvc.New(AuthScope.Party(""/license"")).Handle(ErrorHandler).Handle(controller.NewLicenseController())
	mvc.New(AuthScope.Party(""/clusters/backup/files"")).HandleError(ErrorHandler).Handle(controller.NewClusterBackupFileController())
	mvc.New(AuthScope.Party(""/clusters/velero/{cluster}/{operate}"")).HandleError(ErrorHandler).Handle(controller.NewClusterVeleroBackupController())
	mvc.New(AuthScope.Party(""/manifests"")).HandleError(ErrorHandler).Handle(controller.NewManifestController())
	mvc.New(AuthScope.Party(""/vmconfigs"")).HandleError(ErrorHandler).Handle(controller.NewVmConfigController())
	mvc.New(AuthScope.Party(""/ippools"")).HandleError(ErrorHandler).Handle(controller.NewIpPoolController())
	mvc.New(AuthScope.Party(""/ippools/{name}/ips"")).HandleError(ErrorHandler).Handle(controller.NewIpController())
	mvc.New(AuthScope.Party(""/projects/{project}/resources"")).HandleError(ErrorHandler).Handle(controller.NewProjectResourceController())
	mvc.New(AuthScope.Party(""/projects/{project}/members"")).HandleError(ErrorHandler).Handle(controller.NewProjectMemberController())
	mvc.New(AuthScope.Party(""/projects/{project}/clusters/{cluster}/members"")).HandleError(ErrorHandler).Handle(controller.NewClusterMemberController())
	mvc.New(AuthScope.Party(""/projects/{project}/clusters/{cluster}/resources"")).HandleError(ErrorHandler).Handle(controller.NewClusterResourceController())
	mvc.New(AuthScope.Party(""/templates"")).HandleError(ErrorHandler).Handle(controller.NewTemplateConfigController())
	mvc.New(AuthScope.Party(""/clusters/grade"")).HandleError(ErrorHandler).Handle(controller.NewGradeController())
	mvc.New(AuthScope.Party(""/ldap"")).HandleError(ErrorHandler).Handle(controller.NewLdapController())
	mvc.New(AuthScope.Party(""/msg/accounts"")).HandleError(ErrorHandler).Handle(controller.NewMessageAccountController())
	mvc.New(AuthScope.Party(""/msg/subscribes"")).HandleError(ErrorHandler).Handle(controller.NewMessageSubscribeController())
	mvc.New(AuthScope.Party(""/user/messages"")).HandleError(ErrorHandler).Handle(controller.NewUserMsgController())
	mvc.New(AuthScope.Party(""/user/settings"")).HandleError(ErrorHandler).Handle(controller.NewUserSettingController())
	WhiteScope = v1.Party(""/"")
	WhiteScope.Get(""/clusters/kubeconfig/{name}"", downloadKubeconfig)
	WhiteScope.Get(""/captcha"", generateCaptcha)
	mvc.New(WhiteScope.Party(""/theme"")).HandleError(ErrorHandler).Handle(controller.NewThemeController())
}
func ErrorHandler(ctx context.Context, err error) {
	if err != nil {
		warp := struct {
			Msg string `json:""msg""`
		}{err.Error()}
		var result string
		switch errType := err.(type) {
		case gorm.Errors:
			errorSet := make(map[string]string)
			for _, er := range errType {
				tr := ctx.Tr(er.Error())
				if tr != """" {
					errorMsg := tr
					errorSet[er.Error()] = errorMsg
				}
			}
			for _, set := range errorSet {
				result = result + set + "" ""
			}
		case error:
			switch errRoot := errors.Cause(err).(type) {
			case errorf.CErrFs:
				errs := errRoot.Get()
				for _, er := range errs {
					args := er.Args.([]interface{})
					tr := ctx.Tr(er.Msg, args...)
					if tr != """" {
						result = result + tr + ""\n ""
					}
				}
			default:
				tr := ctx.Tr(errors.Cause(err).Error())
				if tr != """" {
					result = tr
				} else {
					result = err.Error()
				}
			}
		}
		warp.Msg = result
		bf, _ := json.Marshal(&warp)
		ctx.StatusCode(http.StatusBadRequest)
		_, _ = ctx.WriteString(string(bf))
		ctx.StopExecution()
		return
	}
}
",CWE-863,123.0,1
"package command
import (
	""time""
	""github.com/zitadel/zitadel/internal/eventstore""
	""github.com/zitadel/zitadel/internal/crypto""
	""github.com/zitadel/zitadel/internal/domain""
	""github.com/zitadel/zitadel/internal/repository/user""
)
type HumanPasswordWriteModel struct {
	eventstore.WriteModel
	EncodedHash          string
	SecretChangeRequired bool
	Code                     *crypto.CryptoValue
	CodeCreationDate         time.Time
	CodeExpiry               time.Duration
	PasswordCheckFailedCount uint64
	UserState domain.UserState
}
func NewHumanPasswordWriteModel(userID, resourceOwner string) *HumanPasswordWriteModel {
	return &HumanPasswordWriteModel{
		WriteModel: eventstore.WriteModel{
			AggregateID:   userID,
			ResourceOwner: resourceOwner,
		},
	}
}
func (wm *HumanPasswordWriteModel) Reduce() error {
	for _, event := range wm.Events {
		switch e := event.(type) {
		case *user.HumanAddedEvent:
			wm.EncodedHash = user.SecretOrEncodedHash(e.Secret, e.EncodedHash)
			wm.SecretChangeRequired = e.ChangeRequired
			wm.UserState = domain.UserStateActive
		case *user.HumanRegisteredEvent:
			wm.EncodedHash = user.SecretOrEncodedHash(e.Secret, e.EncodedHash)
			wm.SecretChangeRequired = e.ChangeRequired
			wm.UserState = domain.UserStateActive
		case *user.HumanInitialCodeAddedEvent:
			wm.UserState = domain.UserStateInitial
		case *user.HumanInitializedCheckSucceededEvent:
			wm.UserState = domain.UserStateActive
		case *user.HumanPasswordChangedEvent:
			wm.EncodedHash = user.SecretOrEncodedHash(e.Secret, e.EncodedHash)
			wm.SecretChangeRequired = e.ChangeRequired
			wm.Code = nil
			wm.PasswordCheckFailedCount = 0
		case *user.HumanPasswordCodeAddedEvent:
			wm.Code = e.Code
			wm.CodeCreationDate = e.CreationDate()
			wm.CodeExpiry = e.Expiry
		case *user.HumanEmailVerifiedEvent:
			if wm.UserState == domain.UserStateInitial {
				wm.UserState = domain.UserStateActive
			}
		case *user.HumanPasswordCheckFailedEvent:
			wm.PasswordCheckFailedCount += 1
		case *user.HumanPasswordCheckSucceededEvent:
			wm.PasswordCheckFailedCount = 0
		case *user.UserUnlockedEvent:
			wm.PasswordCheckFailedCount = 0
		case *user.UserRemovedEvent:
			wm.UserState = domain.UserStateDeleted
		case *user.HumanPasswordHashUpdatedEvent:
			wm.EncodedHash = e.EncodedHash
		}
	}
	return wm.WriteModel.Reduce()
}
func (wm *HumanPasswordWriteModel) Query() *eventstore.SearchQueryBuilder {
	query := eventstore.NewSearchQueryBuilder(eventstore.ColumnsEvent).
		AddQuery().
		AggregateTypes(user.AggregateType).
		AggregateIDs(wm.AggregateID).
		EventTypes(user.HumanAddedType,
			user.HumanRegisteredType,
			user.HumanInitialCodeAddedType,
			user.HumanInitializedCheckSucceededType,
			user.HumanPasswordChangedType,
			user.HumanPasswordCodeAddedType,
			user.HumanEmailVerifiedType,
			user.HumanPasswordCheckFailedType,
			user.HumanPasswordCheckSucceededType,
			user.HumanPasswordHashUpdatedType,
			user.UserRemovedType,
			user.UserUnlockedType,
			user.UserV1AddedType,
			user.UserV1RegisteredType,
			user.UserV1InitialCodeAddedType,
			user.UserV1InitializedCheckSucceededType,
			user.UserV1PasswordChangedType,
			user.UserV1PasswordCodeAddedType,
			user.UserV1EmailVerifiedType,
			user.UserV1PasswordCheckFailedType,
			user.UserV1PasswordCheckSucceededType,
		).
		Builder()
	if wm.ResourceOwner != """" {
		query.ResourceOwner(wm.ResourceOwner)
	}
	return query
}
",CWE-362,113.0,1
"package query
import (
	""context""
	""time""
	""github.com/zitadel/zitadel/internal/crypto""
	""github.com/zitadel/zitadel/internal/domain""
	""github.com/zitadel/zitadel/internal/errors""
	""github.com/zitadel/zitadel/internal/eventstore""
	""github.com/zitadel/zitadel/internal/repository/user""
	""github.com/zitadel/zitadel/internal/telemetry/tracing""
)
type HumanPasswordReadModel struct {
	*eventstore.ReadModel
	EncodedHash          string
	SecretChangeRequired bool
	Code                     *crypto.CryptoValue
	CodeCreationDate         time.Time
	CodeExpiry               time.Duration
	PasswordCheckFailedCount uint64
	UserState domain.UserState
}
func (q *Queries) GetHumanPassword(ctx context.Context, orgID, userID string) (encodedHash string, err error) {
	ctx, span := tracing.NewSpan(ctx)
	defer func() { span.EndWithError(err) }()
	if userID == """" {
		return """", errors.ThrowInvalidArgument(nil, ""QUERY-4Mfsf"", ""Errors.User.UserIDMissing"")
	}
	existingPassword, err := q.passwordReadModel(ctx, userID, orgID)
	if err != nil {
		return """", errors.ThrowInternal(nil, ""QUERY-p1k1n2i"", ""Errors.User.NotFound"")
	}
	if existingPassword.UserState == domain.UserStateUnspecified || existingPassword.UserState == domain.UserStateDeleted {
		return """", errors.ThrowPreconditionFailed(nil, ""QUERY-3n77z"", ""Errors.User.NotFound"")
	}
	return existingPassword.EncodedHash, nil
}
func (q *Queries) passwordReadModel(ctx context.Context, userID, resourceOwner string) (readModel *HumanPasswordReadModel, err error) {
	ctx, span := tracing.NewSpan(ctx)
	defer func() { span.EndWithError(err) }()
	readModel = NewHumanPasswordReadModel(userID, resourceOwner)
	err = q.eventstore.FilterToQueryReducer(ctx, readModel)
	if err != nil {
		return nil, err
	}
	return readModel, nil
}
func NewHumanPasswordReadModel(userID, resourceOwner string) *HumanPasswordReadModel {
	return &HumanPasswordReadModel{
		ReadModel: &eventstore.ReadModel{
			AggregateID:   userID,
			ResourceOwner: resourceOwner,
		},
	}
}
func (rm *HumanPasswordReadModel) AppendEvents(events ...eventstore.Event) {
	rm.ReadModel.AppendEvents(events...)
}
func (wm *HumanPasswordReadModel) Reduce() error {
	for _, event := range wm.Events {
		switch e := event.(type) {
		case *user.HumanAddedEvent:
			wm.EncodedHash = user.SecretOrEncodedHash(e.Secret, e.EncodedHash)
			wm.SecretChangeRequired = e.ChangeRequired
			wm.UserState = domain.UserStateActive
		case *user.HumanRegisteredEvent:
			wm.EncodedHash = user.SecretOrEncodedHash(e.Secret, e.EncodedHash)
			wm.SecretChangeRequired = e.ChangeRequired
			wm.UserState = domain.UserStateActive
		case *user.HumanInitialCodeAddedEvent:
			wm.UserState = domain.UserStateInitial
		case *user.HumanInitializedCheckSucceededEvent:
			wm.UserState = domain.UserStateActive
		case *user.HumanPasswordChangedEvent:
			wm.EncodedHash = user.SecretOrEncodedHash(e.Secret, e.EncodedHash)
			wm.SecretChangeRequired = e.ChangeRequired
			wm.Code = nil
			wm.PasswordCheckFailedCount = 0
		case *user.HumanPasswordCodeAddedEvent:
			wm.Code = e.Code
			wm.CodeCreationDate = e.CreationDate()
			wm.CodeExpiry = e.Expiry
		case *user.HumanEmailVerifiedEvent:
			if wm.UserState == domain.UserStateInitial {
				wm.UserState = domain.UserStateActive
			}
		case *user.HumanPasswordCheckFailedEvent:
			wm.PasswordCheckFailedCount += 1
		case *user.HumanPasswordCheckSucceededEvent:
			wm.PasswordCheckFailedCount = 0
		case *user.UserUnlockedEvent:
			wm.PasswordCheckFailedCount = 0
		case *user.UserRemovedEvent:
			wm.UserState = domain.UserStateDeleted
		case *user.HumanPasswordHashUpdatedEvent:
			wm.EncodedHash = e.EncodedHash
		}
	}
	return wm.ReadModel.Reduce()
}
func (wm *HumanPasswordReadModel) Query() *eventstore.SearchQueryBuilder {
	query := eventstore.NewSearchQueryBuilder(eventstore.ColumnsEvent).
		AwaitOpenTransactions().
		AllowTimeTravel().
		AddQuery().
		AggregateTypes(user.AggregateType).
		AggregateIDs(wm.AggregateID).
		EventTypes(user.HumanAddedType,
			user.HumanRegisteredType,
			user.HumanInitialCodeAddedType,
			user.HumanInitializedCheckSucceededType,
			user.HumanPasswordChangedType,
			user.HumanPasswordCodeAddedType,
			user.HumanEmailVerifiedType,
			user.HumanPasswordCheckFailedType,
			user.HumanPasswordCheckSucceededType,
			user.HumanPasswordHashUpdatedType,
			user.UserRemovedType,
			user.UserUnlockedType,
			user.UserV1AddedType,
			user.UserV1RegisteredType,
			user.UserV1InitialCodeAddedType,
			user.UserV1InitializedCheckSucceededType,
			user.UserV1PasswordChangedType,
			user.UserV1PasswordCodeAddedType,
			user.UserV1EmailVerifiedType,
			user.UserV1PasswordCheckFailedType,
			user.UserV1PasswordCheckSucceededType,
		).
		Builder()
	if wm.ResourceOwner != """" {
		query.ResourceOwner(wm.ResourceOwner)
	}
	return query
}
",CWE-362,150.0,1
"package bitfield
// NOTE: Don't bother replacing the divisions/modulo with shifts/ands, go is smart.
import (
	""math/bits""
)
// NewBitfield creates a new fixed-sized Bitfield (allocated up-front).
//
// Panics if size is not a multiple of 8.
func NewBitfield(size int) Bitfield {
	if size%8 != 0 {
		panic(""Bitfield size must be a multiple of 8"")
	}
	return make([]byte, size/8)
}
// FromBytes constructs a new bitfield from a serialized bitfield.
func FromBytes(size int, bits []byte) Bitfield {
	bf := NewBitfield(size)
	start := len(bf) - len(bits)
	if start < 0 {
		panic(""bitfield too small"")
	}
	copy(bf[start:], bits)
	return bf
}
func (bf Bitfield) offset(i int) (uint, uint8) {
	return uint(len(bf)) - (uint(i) / 8) - 1, uint8(i) % 8
}
// Bitfield is, well, a bitfield.
type Bitfield []byte
// Bytes returns the Bitfield as a byte string.
//
// This function *does not* copy.
func (bf Bitfield) Bytes() []byte {
	for i, b := range bf {
		if b != 0 {
			return bf[i:]
		}
	}
	return nil
}
// Bit returns the ith bit.
//
// Panics if the bit is out of bounds.
func (bf Bitfield) Bit(i int) bool {
	idx, off := bf.offset(i)
	return (bf[idx]>>off)&0x1 != 0
}
// SetBit sets the ith bit.
//
// Panics if the bit is out of bounds.
func (bf Bitfield) SetBit(i int) {
	idx, off := bf.offset(i)
	bf[idx] |= 1 << off
}
// UnsetBit unsets the ith bit.
//
// Panics if the bit is out of bounds.
func (bf Bitfield) UnsetBit(i int) {
	idx, off := bf.offset(i)
	bf[idx] &= 0xFF ^ (1 << off)
}
// SetBytes sets the bits to the given byte array.
//
// Panics if 'b' is larger than the bitfield.
func (bf Bitfield) SetBytes(b []byte) {
	start := len(bf) - len(b)
	if start < 0 {
		panic(""bitfield too small"")
	}
	for i := range bf[:start] {
		bf[i] = 0
	}
	copy(bf[start:], b)
}
// Ones returns the number of bits set.
func (bf Bitfield) Ones() int {
	cnt := 0
	for _, b := range bf {
		cnt += bits.OnesCount8(b)
	}
	return cnt
}
// OnesBefore returns the number of bits set *before* this bit.
func (bf Bitfield) OnesBefore(i int) int {
	idx, off := bf.offset(i)
	cnt := bits.OnesCount8(bf[idx] << (8 - off))
	for _, b := range bf[idx+1:] {
		cnt += bits.OnesCount8(b)
	}
	return cnt
}
// OnesAfter returns the number of bits set *after* this bit.
func (bf Bitfield) OnesAfter(i int) int {
	idx, off := bf.offset(i)
	cnt := bits.OnesCount8(bf[idx] >> off)
	for _, b := range bf[:idx] {
		cnt += bits.OnesCount8(b)
	}
	return cnt
}
",CWE-1284,115.0,1
"package hamt
// adapted from https://github.com/ipfs/go-unixfs/blob/master/hamt/util.go
import (
	""fmt""
	""math/bits""
	bitfield ""github.com/ipfs/go-bitfield""
	""github.com/ipfs/go-unixfsnode/data""
	dagpb ""github.com/ipld/go-codec-dagpb""
	""github.com/spaolacci/murmur3""
)
// hashBits is a helper that allows the reading of the 'next n bits' as an integer.
type hashBits struct {
	b        []byte
	consumed int
}
func mkmask(n int) byte {
	return (1 << uint(n)) - 1
}
// Next returns the next 'i' bits of the hashBits value as an integer, or an
// error if there aren't enough bits.
func (hb *hashBits) Next(i int) (int, error) {
	if hb.consumed+i > len(hb.b)*8 {
		return 0, ErrHAMTTooDeep
	}
	return hb.next(i), nil
}
func (hb *hashBits) next(i int) int {
	curbi := hb.consumed / 8
	leftb := 8 - (hb.consumed % 8)
	curb := hb.b[curbi]
	if i == leftb {
		out := int(mkmask(i) & curb)
		hb.consumed += i
		return out
	}
	if i < leftb {
		a := curb & mkmask(leftb) // mask out the high bits we don't want
		b := a & ^mkmask(leftb-i) // mask out the low bits we don't want
		c := b >> uint(leftb-i)   // shift whats left down
		hb.consumed += i
		return int(c)
	}
	out := int(mkmask(leftb) & curb)
	out <<= uint(i - leftb)
	hb.consumed += leftb
	out += hb.next(i - leftb)
	return out
}
func validateHAMTData(nd data.UnixFSData) error {
	if nd.FieldDataType().Int() != data.Data_HAMTShard {
		return data.ErrWrongNodeType{Expected: data.Data_HAMTShard, Actual: nd.FieldDataType().Int()}
	}
	if !nd.FieldHashType().Exists() || uint64(nd.FieldHashType().Must().Int()) != HashMurmur3 {
		return ErrInvalidHashType
	}
	if !nd.FieldData().Exists() {
		return ErrNoDataField
	}
	if !nd.FieldFanout().Exists() {
		return ErrNoFanoutField
	}
	if err := checkLogTwo(int(nd.FieldFanout().Must().Int())); err != nil {
		return err
	}
	return nil
}
func log2Size(nd data.UnixFSData) int {
	return bits.TrailingZeros(uint(nd.FieldFanout().Must().Int()))
}
func maxPadLength(nd data.UnixFSData) int {
	return len(fmt.Sprintf(""%X"", nd.FieldFanout().Must().Int()-1))
}
func bitField(nd data.UnixFSData) bitfield.Bitfield {
	bf := bitfield.NewBitfield(int(nd.FieldFanout().Must().Int()))
	bf.SetBytes(nd.FieldData().Must().Bytes())
	return bf
}
func checkLogTwo(v int) error {
	if v <= 0 {
		return ErrHAMTSizeInvalid
	}
	lg2 := bits.TrailingZeros(uint(v))
	if 1<<uint(lg2) != v {
		return ErrHAMTSizeInvalid
	}
	return nil
}
func hash(val []byte) []byte {
	h := murmur3.New64()
	h.Write(val)
	return h.Sum(nil)
}
func isValueLink(pbLink dagpb.PBLink, maxPadLen int) (bool, error) {
	if !pbLink.FieldName().Exists() {
		return false, ErrMissingLinkName
	}
	name := pbLink.FieldName().Must().String()
	if len(name) < maxPadLen {
		return false, ErrInvalidLinkName{name}
	}
	if len(name) == maxPadLen {
		return false, nil
	}
	return true, nil
}
func MatchKey(pbLink dagpb.PBLink, key string, maxPadLen int) bool {
	return pbLink.FieldName().Must().String()[maxPadLen:] == key
}
",CWE-400,131.0,1
"module github.com/ipfs/go-unixfsnode
go 1.18
require (
	github.com/ipfs/go-bitfield v1.0.0
	github.com/ipfs/go-cid v0.2.0
	github.com/ipfs/go-ipfs-chunker v0.0.1
	github.com/ipfs/go-ipfs-util v0.0.2
	github.com/ipfs/go-ipld-format v0.2.0
	github.com/ipfs/go-merkledag v0.5.1
	github.com/ipfs/go-unixfs v0.3.1
	github.com/ipld/go-car/v2 v2.1.1
	github.com/ipld/go-codec-dagpb v1.4.1
	github.com/ipld/go-ipld-prime v0.16.0
	github.com/multiformats/go-multicodec v0.4.1
	github.com/multiformats/go-multihash v0.1.0
	github.com/spaolacci/murmur3 v1.1.0
	github.com/stretchr/testify v1.7.0
	google.golang.org/protobuf v1.28.0
)
require (
	github.com/davecgh/go-spew v1.1.1 // indirect
	github.com/gogo/protobuf v1.3.2 // indirect
	github.com/google/uuid v1.2.0 // indirect
	github.com/hashicorp/golang-lru v0.5.4 // indirect
	github.com/ipfs/bbloom v0.0.4 // indirect
	github.com/ipfs/go-block-format v0.0.3 // indirect
	github.com/ipfs/go-blockservice v0.2.1 // indirect
	github.com/ipfs/go-datastore v0.5.0 // indirect
	github.com/ipfs/go-ipfs-blockstore v1.1.2 // indirect
	github.com/ipfs/go-ipfs-ds-help v1.1.0 // indirect
	github.com/ipfs/go-ipfs-exchange-interface v0.1.0 // indirect
	github.com/ipfs/go-ipfs-exchange-offline v0.1.1 // indirect
	github.com/ipfs/go-ipld-cbor v0.0.5 // indirect
	github.com/ipfs/go-ipld-legacy v0.1.0 // indirect
	github.com/ipfs/go-log v1.0.5 // indirect
	github.com/ipfs/go-log/v2 v2.3.0 // indirect
	github.com/ipfs/go-metrics-interface v0.0.1 // indirect
	github.com/ipfs/go-verifcid v0.0.1 // indirect
	github.com/jbenet/goprocess v0.1.4 // indirect
	github.com/klauspost/cpuid/v2 v2.0.12 // indirect
	github.com/libp2p/go-buffer-pool v0.0.2 // indirect
	github.com/mattn/go-isatty v0.0.13 // indirect
	github.com/minio/blake2b-simd v0.0.0-20160723061019-3f5f724cb5b1 // indirect
	github.com/minio/sha256-simd v1.0.0 // indirect
	github.com/mr-tron/base58 v1.2.0 // indirect
	github.com/multiformats/go-base32 v0.0.4 // indirect
	github.com/multiformats/go-base36 v0.1.0 // indirect
	github.com/multiformats/go-multibase v0.0.3 // indirect
	github.com/multiformats/go-varint v0.0.6 // indirect
	github.com/opentracing/opentracing-go v1.2.0 // indirect
	github.com/petar/GoLLRB v0.0.0-20210522233825-ae3b015fd3e9 // indirect
	github.com/pmezard/go-difflib v1.0.0 // indirect
	github.com/polydawn/refmt v0.0.0-20201211092308-30ac6d18308e // indirect
	github.com/whyrusleeping/cbor v0.0.0-20171005072247-63513f603b11 // indirect
	github.com/whyrusleeping/cbor-gen v0.0.0-20200123233031-1cdf64d27158 // indirect
	github.com/whyrusleeping/chunker v0.0.0-20181014151217-fe64bd25879f // indirect
	go.uber.org/atomic v1.7.0 // indirect
	go.uber.org/multierr v1.7.0 // indirect
	go.uber.org/zap v1.16.0 // indirect
	golang.org/x/crypto v0.0.0-20220427172511-eb4f295cb31f // indirect
	golang.org/x/exp v0.0.0-20210615023648-acb5c1269671 // indirect
	golang.org/x/sync v0.0.0-20210220032951-036812b2e83c // indirect
	golang.org/x/sys v0.0.0-20220429233432-b5fbb4746d32 // indirect
	golang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1 // indirect
	gopkg.in/yaml.v3 v3.0.0-20210107192922-496545a6307b // indirect
	lukechampine.com/blake3 v1.1.7 // indirect
)
",CWE-400,71.0,1
"package hamt
// adapted from https://github.com/ipfs/go-unixfs/blob/master/hamt/util.go
import (
	""fmt""
	""math/bits""
	bitfield ""github.com/ipfs/go-bitfield""
	""github.com/ipfs/go-unixfsnode/data""
	dagpb ""github.com/ipld/go-codec-dagpb""
	""github.com/spaolacci/murmur3""
)
// hashBits is a helper that allows the reading of the 'next n bits' as an integer.
type hashBits struct {
	b        []byte
	consumed int
}
func mkmask(n int) byte {
	return (1 << uint(n)) - 1
}
// Next returns the next 'i' bits of the hashBits value as an integer, or an
// error if there aren't enough bits.
func (hb *hashBits) Next(i int) (int, error) {
	if hb.consumed+i > len(hb.b)*8 {
		return 0, ErrHAMTTooDeep
	}
	return hb.next(i), nil
}
func (hb *hashBits) next(i int) int {
	curbi := hb.consumed / 8
	leftb := 8 - (hb.consumed % 8)
	curb := hb.b[curbi]
	if i == leftb {
		out := int(mkmask(i) & curb)
		hb.consumed += i
		return out
	}
	if i < leftb {
		a := curb & mkmask(leftb) // mask out the high bits we don't want
		b := a & ^mkmask(leftb-i) // mask out the low bits we don't want
		c := b >> uint(leftb-i)   // shift whats left down
		hb.consumed += i
		return int(c)
	}
	out := int(mkmask(leftb) & curb)
	out <<= uint(i - leftb)
	hb.consumed += leftb
	out += hb.next(i - leftb)
	return out
}
func validateHAMTData(nd data.UnixFSData) error {
	if nd.FieldDataType().Int() != data.Data_HAMTShard {
		return data.ErrWrongNodeType{Expected: data.Data_HAMTShard, Actual: nd.FieldDataType().Int()}
	}
	if !nd.FieldHashType().Exists() || uint64(nd.FieldHashType().Must().Int()) != HashMurmur3 {
		return ErrInvalidHashType
	}
	if !nd.FieldData().Exists() {
		return ErrNoDataField
	}
	if !nd.FieldFanout().Exists() {
		return ErrNoFanoutField
	}
	if err := checkLogTwo(int(nd.FieldFanout().Must().Int())); err != nil {
		return err
	}
	return nil
}
func log2Size(nd data.UnixFSData) int {
	return bits.TrailingZeros(uint(nd.FieldFanout().Must().Int()))
}
func maxPadLength(nd data.UnixFSData) int {
	return len(fmt.Sprintf(""%X"", nd.FieldFanout().Must().Int()-1))
}
const maximumHamtWidth = 1 << 10
func bitField(nd data.UnixFSData) (bitfield.Bitfield, error) {
	fanout := int(nd.FieldFanout().Must().Int())
	if fanout > maximumHamtWidth {
		return nil, fmt.Errorf(""hamt witdh (%d) exceed maximum allowed (%d)"", fanout, maximumHamtWidth)
	}
	bf := bitfield.NewBitfield(fanout)
	bf.SetBytes(nd.FieldData().Must().Bytes())
	return bf, nil
}
func checkLogTwo(v int) error {
	if v <= 0 {
		return ErrHAMTSizeInvalid
	}
	lg2 := bits.TrailingZeros(uint(v))
	if 1<<uint(lg2) != v {
		return ErrHAMTSizeInvalid
	}
	return nil
}
func hash(val []byte) []byte {
	h := murmur3.New64()
	h.Write(val)
	return h.Sum(nil)
}
func isValueLink(pbLink dagpb.PBLink, maxPadLen int) (bool, error) {
	if !pbLink.FieldName().Exists() {
		return false, ErrMissingLinkName
	}
	name := pbLink.FieldName().Must().String()
	if len(name) < maxPadLen {
		return false, ErrInvalidLinkName{name}
	}
	if len(name) == maxPadLen {
		return false, nil
	}
	return true, nil
}
func MatchKey(pbLink dagpb.PBLink, key string, maxPadLen int) bool {
	return pbLink.FieldName().Must().String()[maxPadLen:] == key
}
",CWE-400,137.0,1
"// Copyright 2022 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//go:build !purego && (amd64 || arm64)
package nistec
import ""errors""
// Montgomery multiplication modulo org(G). Sets res = in1 * in2 * R⁻¹.
//
//go:noescape
func p256OrdMul(res, in1, in2 *p256OrdElement)
// Montgomery square modulo org(G), repeated n times (n >= 1).
//
//go:noescape
func p256OrdSqr(res, in *p256OrdElement, n int)
func p256OrdInverse(k []byte) ([]byte, error) {
	if len(k) != 32 {
		return nil, errors.New(""invalid scalar length"")
	}
	x := new(p256OrdElement)
	p256OrdBigToLittle(x, (*[32]byte)(k))
	// Inversion is implemented as exponentiation by n - 2, per Fermat's little theorem.
	//
	// The sequence of 38 multiplications and 254 squarings is derived from
	// https://briansmith.org/ecc-inversion-addition-chains-01
	_1 := new(p256OrdElement)
	_11 := new(p256OrdElement)
	_101 := new(p256OrdElement)
	_111 := new(p256OrdElement)
	_1111 := new(p256OrdElement)
	_10101 := new(p256OrdElement)
	_101111 := new(p256OrdElement)
	t := new(p256OrdElement)
	// This code operates in the Montgomery domain where R = 2²⁵⁶ mod n and n is
	// the order of the scalar field. Elements in the Montgomery domain take the
	// form a×R and p256OrdMul calculates (a × b × R⁻¹) mod n. RR is R in the
	// domain, or R×R mod n, thus p256OrdMul(x, RR) gives x×R, i.e. converts x
	// into the Montgomery domain.
	RR := &p256OrdElement{0x83244c95be79eea2, 0x4699799c49bd6fa6,
		0x2845b2392b6bec59, 0x66e12d94f3d95620}
	p256OrdMul(_1, x, RR)      // _1
	p256OrdSqr(x, _1, 1)       // _10
	p256OrdMul(_11, x, _1)     // _11
	p256OrdMul(_101, x, _11)   // _101
	p256OrdMul(_111, x, _101)  // _111
	p256OrdSqr(x, _101, 1)     // _1010
	p256OrdMul(_1111, _101, x) // _1111
	p256OrdSqr(t, x, 1)          // _10100
	p256OrdMul(_10101, t, _1)    // _10101
	p256OrdSqr(x, _10101, 1)     // _101010
	p256OrdMul(_101111, _101, x) // _101111
	p256OrdMul(x, _10101, x)     // _111111 = x6
	p256OrdSqr(t, x, 2)          // _11111100
	p256OrdMul(t, t, _11)        // _11111111 = x8
	p256OrdSqr(x, t, 8)          // _ff00
	p256OrdMul(x, x, t)          // _ffff = x16
	p256OrdSqr(t, x, 16)         // _ffff0000
	p256OrdMul(t, t, x)          // _ffffffff = x32
	p256OrdSqr(x, t, 64)
	p256OrdMul(x, x, t)
	p256OrdSqr(x, x, 32)
	p256OrdMul(x, x, t)
	sqrs := []int{
		6, 5, 4, 5, 5,
		4, 3, 3, 5, 9,
		6, 2, 5, 6, 5,
		4, 5, 5, 3, 10,
		2, 5, 5, 3, 7, 6}
	muls := []*p256OrdElement{
		_101111, _111, _11, _1111, _10101,
		_101, _101, _101, _111, _101111,
		_1111, _1, _1, _1111, _111,
		_111, _111, _101, _11, _101111,
		_11, _11, _11, _1, _10101, _1111}
	for i, s := range sqrs {
		p256OrdSqr(x, x, s)
		p256OrdMul(x, x, muls[i])
	}
	// Montgomery multiplication by R⁻¹, or 1 outside the domain as R⁻¹×R = 1,
	// converts a Montgomery value out of the domain.
	one := &p256OrdElement{1}
	p256OrdMul(x, x, one)
	var xOut [32]byte
	p256OrdLittleToBig(&xOut, x)
	return xOut[:], nil
}
",CWE-682,102.0,1
"package paranoidhttp
import (
	""context""
	""errors""
	""fmt""
	""net""
	""net/http""
	""regexp""
	""time""
)
// Config stores the rules for allowing IP/hosts
type config struct {
	ForbiddenIPNets []*net.IPNet
	PermittedIPNets []*net.IPNet
	ForbiddenHosts  []*regexp.Regexp
}
// DefaultClient is the default Client whose setting is the same as http.DefaultClient.
var (
	defaultConfig config
	DefaultClient *http.Client
)
func mustParseCIDR(addr string) *net.IPNet {
	_, ipnet, err := net.ParseCIDR(addr)
	if err != nil {
		panic(`net: ParseCIDR(""` + addr + `""): ` + err.Error())
	}
	return ipnet
}
func init() {
	defaultConfig = config{
		ForbiddenIPNets: []*net.IPNet{
			mustParseCIDR(""10.0.0.0/8""),     // private class A
			mustParseCIDR(""172.16.0.0/12""),  // private class B
			mustParseCIDR(""192.168.0.0/16""), // private class C
			mustParseCIDR(""192.0.2.0/24""),   // test net 1
			mustParseCIDR(""192.88.99.0/24""), // 6to4 relay
		},
		ForbiddenHosts: []*regexp.Regexp{
			regexp.MustCompile(`(?i)^localhost$`),
			regexp.MustCompile(`(?i)\s+`),
		},
	}
	DefaultClient, _, _ = NewClient()
}
// isHostForbidden checks whether a hostname is forbidden by the Config
func (c *config) isHostForbidden(host string) bool {
	for _, forbiddenHost := range c.ForbiddenHosts {
		if forbiddenHost.MatchString(host) {
			return true
		}
	}
	return false
}
// isIPForbidden checks whether an IP address is forbidden by the Config
func (c *config) isIPForbidden(ip net.IP) bool {
	for _, permittedIPNet := range c.PermittedIPNets {
		if permittedIPNet.Contains(ip) {
			return false
		}
	}
	if ip.Equal(net.IPv4bcast) || !ip.IsGlobalUnicast() {
		return true
	}
	for _, forbiddenIPNet := range c.ForbiddenIPNets {
		if forbiddenIPNet.Contains(ip) {
			return true
		}
	}
	return false
}
// BasicConfig contains the most common hosts and IPs to be blocked
func basicConfig() *config {
	c := defaultConfig // copy to return clone
	return &c
}
// Option type of paranoidhttp
type Option func(*config)
// ForbiddenIPNets sets forbidden IPNets
func ForbiddenIPNets(ips ...*net.IPNet) Option {
	return func(c *config) {
		c.ForbiddenIPNets = ips
	}
}
// PermittedIPNets sets permitted IPNets
// It takes priority over other forbidden rules.
func PermittedIPNets(ips ...*net.IPNet) Option {
	return func(c *config) {
		c.PermittedIPNets = ips
	}
}
// ForbiddenHosts set forbidden host rules by regexp
func ForbiddenHosts(hostRegs ...*regexp.Regexp) Option {
	return func(c *config) {
		c.ForbiddenHosts = hostRegs
	}
}
func safeAddr(ctx context.Context, resolver *net.Resolver, hostport string, opts ...Option) (string, error) {
	c := basicConfig()
	for _, opt := range opts {
		opt(c)
	}
	host, port, err := net.SplitHostPort(hostport)
	if err != nil {
		return """", err
	}
	ip := net.ParseIP(host)
	if ip != nil {
		if ip.To4() != nil && c.isIPForbidden(ip) {
			return """", fmt.Errorf(""bad ip is detected: %v"", ip)
		}
		return net.JoinHostPort(ip.String(), port), nil
	}
	if c.isHostForbidden(host) {
		return """", fmt.Errorf(""bad host is detected: %v"", host)
	}
	r := resolver
	if r == nil {
		r = net.DefaultResolver
	}
	addrs, err := r.LookupIPAddr(ctx, host)
	if err != nil || len(addrs) <= 0 {
		return """", err
	}
	safeAddrs := make([]net.IPAddr, 0, len(addrs))
	for _, addr := range addrs {
		// only support IPv4 address
		if addr.IP.To4() == nil {
			continue
		}
		if c.isIPForbidden(addr.IP) {
			return """", fmt.Errorf(""bad ip is detected: %v"", addr.IP)
		}
		safeAddrs = append(safeAddrs, addr)
	}
	if len(safeAddrs) == 0 {
		return """", fmt.Errorf(""fail to lookup ip addr: %v"", host)
	}
	return net.JoinHostPort(safeAddrs[0].IP.String(), port), nil
}
// NewDialer returns a dialer function which only accepts IPv4 connections.
//
// This is used to create a new paranoid http.Client,
// because I'm not sure about a paranoid behavior for IPv6 connections :(
func NewDialer(dialer *net.Dialer, opts ...Option) func(ctx context.Context, network, addr string) (net.Conn, error) {
	return func(ctx context.Context, network, hostport string) (net.Conn, error) {
		switch network {
		case ""tcp"", ""tcp4"":
			addr, err := safeAddr(ctx, dialer.Resolver, hostport, opts...)
			if err != nil {
				return nil, err
			}
			return dialer.DialContext(ctx, ""tcp4"", addr)
		default:
			return nil, errors.New(""does not support any networks except tcp4"")
		}
	}
}
// NewClient returns a new http.Client configured to be paranoid for attackers.
//
// This also returns http.Tranport and net.Dialer so that you can customize those behavior.
func NewClient(opts ...Option) (*http.Client, *http.Transport, *net.Dialer) {
	dialer := &net.Dialer{
		Timeout:   30 * time.Second,
		KeepAlive: 30 * time.Second,
	}
	transport := &http.Transport{
		Proxy:               http.ProxyFromEnvironment,
		DialContext:         NewDialer(dialer, opts...),
		TLSHandshakeTimeout: 10 * time.Second,
	}
	return &http.Client{
		Timeout:   30 * time.Second,
		Transport: transport,
	}, transport, dialer
}
",CWE-918,196.0,1
"package paranoidhttp
import (
	""net""
	""testing""
)
func TestRequest(t *testing.T) {
	resp, err := DefaultClient.Get(""http://www.example.org"")
	if err != nil && resp.StatusCode == 200 {
		t.Error(""The request with an ordinal url should be successful"")
	}
	resp, err = DefaultClient.Get(""http://localhost"")
	if err == nil {
		t.Errorf(""The request for localhost should be fail"")
	}
	if _, err := DefaultClient.Get(""http://192.168.0.1""); err == nil {
		t.Errorf(""The request for localhost should be fail"")
	}
}
func TestIsHostForbidden(t *testing.T) {
	badHosts := []string{
		""localhost"",
		""host has space"",
	}
	for _, h := range badHosts {
		if !basicConfig().isHostForbidden(h) {
			t.Errorf(""%s should be forbidden"", h)
		}
	}
	notBadHosts := []string{
		""www.hatena.ne.jp"",
		""www.google.com"",
		""xn--t8jx73hngb.jp"",
	}
	for _, h := range notBadHosts {
		if basicConfig().isHostForbidden(h) {
			t.Errorf(""%s should not be forbidden"", h)
		}
	}
}
func TestIsIpForbidden(t *testing.T) {
	badIPs := []string{
		""0.0.0.0"",                      // Unspecified
		""127.0.0.0"", ""127.255.255.255"", // Loopback
		""10.0.0.0"", ""10.255.255.255"", // Private A
		""172.16.0.0"", ""172.31.255.255"", // Private B
		""192.168.0.0"", ""192.168.255.255"", // Private C
		""192.0.2.0"", ""192.0.2.255"", // Test-Net
		""192.88.99.0"", ""192.88.99.255"", // 6to4 relay
		""224.0.0.0"", ""239.255.255.255"", // Multicast
		""169.254.0.0"", ""169.254.255.255"", // Link local
	}
	for _, ip := range badIPs {
		if !basicConfig().isIPForbidden(net.ParseIP(ip)) {
			t.Errorf(""%s should be forbidden"", ip)
		}
	}
	notBadIPs := []string{
		""0.0.0.1"", ""8.8.8.8"",
		""126.255.255.255"", ""128.0.0.0"",
		""9.255.255.255"", ""11.0.0.0"",
		""172.15.255.255"", ""172.32.0.0"",
		""192.167.255.255"", ""192.169.0.0"",
		""192.88.98.255"", ""192.88.100.0"",
		""223.255.255.255"", ""240.0.0.0"",
		""169.253.255.255"", ""169.255.0.0"",
	}
	for _, ip := range notBadIPs {
		if basicConfig().isIPForbidden(net.ParseIP(ip)) {
			t.Errorf(""%s should not be forbidden"", ip)
		}
	}
	c := basicConfig()
	ip := ""172.18.0.1""
	if !c.isIPForbidden(net.ParseIP(ip)) {
		t.Errorf(""%s should be forbidden"", ip)
	}
	c.PermittedIPNets = append(c.PermittedIPNets, mustParseCIDR(""172.18.0.1/32""))
	if c.isIPForbidden(net.ParseIP(ip)) {
		t.Errorf(""%s should not be forbidden"", ip)
	}
}
",CWE-918,96.0,1
"package config
import ""github.com/spf13/viper""
type attest struct {
	Key      string `yaml:""key"" json:""key"" mapstructure:""key""`
	Password string `yaml:""password"" json:""password"" mapstructure:""password""`
}
func (cfg attest) loadDefaultValues(v *viper.Viper) {
	v.SetDefault(""attest.key"", """")
	v.SetDefault(""attest.password"", """")
}
",CWE-532,14.0,1
"package defaults
import (
	""time""
)
const (
	// these requests take at _least_ two minutes at the moment.
	ProvideTimeout  = time.Minute * 3
	ProvSearchDelay = time.Second
	// Number of concurrent workers in decision engine that process requests to the blockstore
	BitswapEngineBlockstoreWorkerCount = 128
	// the total number of simultaneous threads sending outgoing messages
	BitswapTaskWorkerCount = 8
	// how many worker threads to start for decision engine task worker
	BitswapEngineTaskWorkerCount = 8
	// the total amount of bytes that a peer should have outstanding, it is utilized by the decision engine
	BitswapMaxOutstandingBytesPerPeer = 1 << 20
	// the number of bytes we attempt to make each outgoing bitswap message
	BitswapEngineTargetMessageSize = 16 * 1024
	// HasBlockBufferSize is the buffer size of the channel for new blocks
	// that need to be provided. They should get pulled over by the
	// provideCollector even before they are actually provided.
	// TODO: Does this need to be this large givent that?
	HasBlockBufferSize = 256
)
",CWE-770,28.0,1
"package bitswap
import (
	""time""
	delay ""github.com/ipfs/go-ipfs-delay""
	""github.com/ipfs/go-libipfs/bitswap/client""
	""github.com/ipfs/go-libipfs/bitswap/server""
	""github.com/ipfs/go-libipfs/bitswap/tracer""
)
type option func(*Bitswap)
// Option is interface{} of server.Option or client.Option or func(*Bitswap)
// wrapped in a struct to gain strong type checking.
type Option struct {
	v interface{}
}
func EngineBlockstoreWorkerCount(count int) Option {
	return Option{server.EngineBlockstoreWorkerCount(count)}
}
func EngineTaskWorkerCount(count int) Option {
	return Option{server.EngineTaskWorkerCount(count)}
}
func MaxOutstandingBytesPerPeer(count int) Option {
	return Option{server.MaxOutstandingBytesPerPeer(count)}
}
func TaskWorkerCount(count int) Option {
	return Option{server.TaskWorkerCount(count)}
}
func ProvideEnabled(enabled bool) Option {
	return Option{server.ProvideEnabled(enabled)}
}
func SetSendDontHaves(send bool) Option {
	return Option{server.SetSendDontHaves(send)}
}
func WithPeerBlockRequestFilter(pbrf server.PeerBlockRequestFilter) Option {
	return Option{server.WithPeerBlockRequestFilter(pbrf)}
}
func WithScoreLedger(scoreLedger server.ScoreLedger) Option {
	return Option{server.WithScoreLedger(scoreLedger)}
}
func WithTargetMessageSize(tms int) Option {
	return Option{server.WithTargetMessageSize(tms)}
}
func WithTaskComparator(comparator server.TaskComparator) Option {
	return Option{server.WithTaskComparator(comparator)}
}
func ProviderSearchDelay(newProvSearchDelay time.Duration) Option {
	return Option{client.ProviderSearchDelay(newProvSearchDelay)}
}
func RebroadcastDelay(newRebroadcastDelay delay.D) Option {
	return Option{client.RebroadcastDelay(newRebroadcastDelay)}
}
func SetSimulateDontHavesOnTimeout(send bool) Option {
	return Option{client.SetSimulateDontHavesOnTimeout(send)}
}
func WithTracer(tap tracer.Tracer) Option {
	// Only trace the server, both receive the same messages anyway
	return Option{
		option(func(bs *Bitswap) {
			bs.tracer = tap
		}),
	}
}
",CWE-770,80.0,1
"package decision
import (
	""github.com/ipfs/go-cid""
	""github.com/libp2p/go-libp2p/core/peer""
)
type peerLedger struct {
	cids map[cid.Cid]map[peer.ID]struct{}
}
func newPeerLedger() *peerLedger {
	return &peerLedger{cids: make(map[cid.Cid]map[peer.ID]struct{})}
}
func (l *peerLedger) Wants(p peer.ID, k cid.Cid) {
	m, ok := l.cids[k]
	if !ok {
		m = make(map[peer.ID]struct{})
		l.cids[k] = m
	}
	m[p] = struct{}{}
}
func (l *peerLedger) CancelWant(p peer.ID, k cid.Cid) {
	m, ok := l.cids[k]
	if !ok {
		return
	}
	delete(m, p)
	if len(m) == 0 {
		delete(l.cids, k)
	}
}
func (l *peerLedger) Peers(k cid.Cid) []peer.ID {
	m, ok := l.cids[k]
	if !ok {
		return nil
	}
	peers := make([]peer.ID, 0, len(m))
	for p := range m {
		peers = append(peers, p)
	}
	return peers
}
",CWE-770,47.0,1
"module github.com/ipfs/go-libipfs
go 1.19
require (
	github.com/benbjohnson/clock v1.3.0
	github.com/cespare/xxhash v1.1.0
	github.com/crackcomm/go-gitignore v0.0.0-20170627025303-887ab5e44cc3
	github.com/cskr/pubsub v1.0.2
	github.com/dustin/go-humanize v1.0.0
	github.com/gabriel-vasile/mimetype v1.4.1
	github.com/gogo/protobuf v1.3.2
	github.com/google/uuid v1.3.0
	github.com/gorilla/mux v1.8.0
	github.com/ipfs/go-blockservice v0.5.0
	github.com/ipfs/go-cid v0.3.2
	github.com/ipfs/go-datastore v0.6.0
	github.com/ipfs/go-detect-race v0.0.1
	github.com/ipfs/go-fetcher v1.6.1
	github.com/ipfs/go-ipfs-blockstore v1.2.0
	github.com/ipfs/go-ipfs-blocksutil v0.0.1
	github.com/ipfs/go-ipfs-delay v0.0.1
	github.com/ipfs/go-ipfs-exchange-interface v0.2.0
	github.com/ipfs/go-ipfs-exchange-offline v0.3.0
	github.com/ipfs/go-ipfs-redirects-file v0.1.1
	github.com/ipfs/go-ipfs-routing v0.3.0
	github.com/ipfs/go-ipfs-util v0.0.2
	github.com/ipfs/go-ipld-format v0.4.0
	github.com/ipfs/go-ipns v0.3.0
	github.com/ipfs/go-log v1.0.5
	github.com/ipfs/go-log/v2 v2.5.1
	github.com/ipfs/go-merkledag v0.9.0
	github.com/ipfs/go-metrics-interface v0.0.1
	github.com/ipfs/go-namesys v0.7.0
	github.com/ipfs/go-path v0.3.0
	github.com/ipfs/go-peertaskqueue v0.8.0
	github.com/ipfs/go-unixfs v0.3.1
	github.com/ipfs/go-unixfsnode v1.5.1
	github.com/ipfs/interface-go-ipfs-core v0.10.0
	github.com/ipld/go-car v0.5.0
	github.com/ipld/go-car/v2 v2.5.1
	github.com/ipld/go-codec-dagpb v1.5.0
	github.com/ipld/go-ipld-prime v0.19.0
	github.com/jbenet/goprocess v0.1.4
	github.com/libp2p/go-buffer-pool v0.1.0
	github.com/libp2p/go-libp2p v0.25.1
	github.com/libp2p/go-libp2p-record v0.2.0
	github.com/libp2p/go-libp2p-testing v0.12.0
	github.com/libp2p/go-msgio v0.3.0
	github.com/miekg/dns v1.1.50
	github.com/multiformats/go-multiaddr v0.8.0
	github.com/multiformats/go-multibase v0.1.1
	github.com/multiformats/go-multicodec v0.7.0
	github.com/multiformats/go-multihash v0.2.1
	github.com/multiformats/go-multistream v0.4.1
	github.com/prometheus/client_golang v1.14.0
	github.com/samber/lo v1.36.0
	github.com/stretchr/testify v1.8.1
	go.opencensus.io v0.24.0
	go.opentelemetry.io/otel v1.7.0
	go.opentelemetry.io/otel/trace v1.7.0
	go.uber.org/multierr v1.9.0
	go.uber.org/zap v1.24.0
	golang.org/x/sys v0.4.0
)
require (
	github.com/alecthomas/units v0.0.0-20210927113745-59d0afb8317a // indirect
	github.com/beorn7/perks v1.0.1 // indirect
	github.com/cespare/xxhash/v2 v2.2.0 // indirect
	github.com/davecgh/go-spew v1.1.1 // indirect
	github.com/decred/dcrd/dcrec/secp256k1/v4 v4.1.0 // indirect
	github.com/go-logr/logr v1.2.3 // indirect
	github.com/go-logr/stdr v1.2.2 // indirect
	github.com/golang/protobuf v1.5.2 // indirect
	github.com/google/gopacket v1.1.19 // indirect
	github.com/hashicorp/errwrap v1.1.0 // indirect
	github.com/hashicorp/go-multierror v1.1.1 // indirect
	github.com/hashicorp/golang-lru v0.5.4 // indirect
	github.com/huin/goupnp v1.0.3 // indirect
	github.com/ipfs/bbloom v0.0.4 // indirect
	github.com/ipfs/go-bitfield v1.0.0 // indirect
	github.com/ipfs/go-block-format v0.1.1 // indirect
	github.com/ipfs/go-ipfs-ds-help v1.1.0 // indirect
	github.com/ipfs/go-ipfs-files v0.3.0 // indirect
	github.com/ipfs/go-ipfs-pq v0.0.2 // indirect
	github.com/ipfs/go-ipld-cbor v0.0.6 // indirect
	github.com/ipfs/go-ipld-legacy v0.1.1 // indirect
	github.com/ipfs/go-verifcid v0.0.2 // indirect
	github.com/jackpal/go-nat-pmp v1.0.2 // indirect
	github.com/klauspost/cpuid/v2 v2.2.3 // indirect
	github.com/koron/go-ssdp v0.0.3 // indirect
	github.com/libp2p/go-cidranger v1.1.0 // indirect
	github.com/libp2p/go-libp2p-asn-util v0.2.0 // indirect
	github.com/libp2p/go-libp2p-kad-dht v0.21.0 // indirect
	github.com/libp2p/go-libp2p-kbucket v0.5.0 // indirect
	github.com/libp2p/go-nat v0.1.0 // indirect
	github.com/libp2p/go-netroute v0.2.1 // indirect
	github.com/mattn/go-isatty v0.0.17 // indirect
	github.com/matttproud/golang_protobuf_extensions v1.0.4 // indirect
	github.com/minio/sha256-simd v1.0.0 // indirect
	github.com/mr-tron/base58 v1.2.0 // indirect
	github.com/multiformats/go-base32 v0.1.0 // indirect
	github.com/multiformats/go-base36 v0.2.0 // indirect
	github.com/multiformats/go-multiaddr-dns v0.3.1 // indirect
	github.com/multiformats/go-multiaddr-fmt v0.1.0 // indirect
	github.com/multiformats/go-varint v0.0.7 // indirect
	github.com/opentracing/opentracing-go v1.2.0 // indirect
	github.com/petar/GoLLRB v0.0.0-20210522233825-ae3b015fd3e9 // indirect
	github.com/pkg/errors v0.9.1 // indirect
	github.com/pmezard/go-difflib v1.0.0 // indirect
	github.com/polydawn/refmt v0.89.0 // indirect
	github.com/prometheus/client_model v0.3.0 // indirect
	github.com/prometheus/common v0.37.0 // indirect
	github.com/prometheus/procfs v0.8.0 // indirect
	github.com/spaolacci/murmur3 v1.1.0 // indirect
	github.com/stretchr/objx v0.5.0 // indirect
	github.com/ucarion/urlpath v0.0.0-20200424170820-7ccc79b76bbb // indirect
	github.com/whyrusleeping/base32 v0.0.0-20170828182744-c30ac30633cc // indirect
	github.com/whyrusleeping/cbor v0.0.0-20171005072247-63513f603b11 // indirect
	github.com/whyrusleeping/cbor-gen v0.0.0-20230126041949-52956bd4c9aa // indirect
	github.com/whyrusleeping/go-keyspace v0.0.0-20160322163242-5b898ac5add1 // indirect
	go.uber.org/atomic v1.10.0 // indirect
	golang.org/x/crypto v0.5.0 // indirect
	golang.org/x/exp v0.0.0-20230129154200-a960b3787bd2 // indirect
	golang.org/x/mod v0.7.0 // indirect
	golang.org/x/net v0.5.0 // indirect
	golang.org/x/sync v0.1.0 // indirect
	golang.org/x/tools v0.3.0 // indirect
	golang.org/x/xerrors v0.0.0-20220907171357-04be3eba64a2 // indirect
	google.golang.org/protobuf v1.28.1 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
	lukechampine.com/blake3 v1.1.7 // indirect
)
",CWE-770,135.0,1
"package defaults
import (
	""time""
)
const (
	// these requests take at _least_ two minutes at the moment.
	ProvideTimeout  = time.Minute * 3
	ProvSearchDelay = time.Second
	// Number of concurrent workers in decision engine that process requests to the blockstore
	BitswapEngineBlockstoreWorkerCount = 128
	// the total number of simultaneous threads sending outgoing messages
	BitswapTaskWorkerCount = 8
	// how many worker threads to start for decision engine task worker
	BitswapEngineTaskWorkerCount = 8
	// the total amount of bytes that a peer should have outstanding, it is utilized by the decision engine
	BitswapMaxOutstandingBytesPerPeer = 1 << 20
	// the number of bytes we attempt to make each outgoing bitswap message
	BitswapEngineTargetMessageSize = 16 * 1024
	// HasBlockBufferSize is the buffer size of the channel for new blocks
	// that need to be provided. They should get pulled over by the
	// provideCollector even before they are actually provided.
	// TODO: Does this need to be this large givent that?
	HasBlockBufferSize = 256
	// Maximum size of the wantlist we are willing to keep in memory.
	MaxQueuedWantlistEntiresPerPeer = 1024
)
",CWE-770,31.0,1
"package bitswap
import (
	""time""
	delay ""github.com/ipfs/go-ipfs-delay""
	""github.com/ipfs/go-libipfs/bitswap/client""
	""github.com/ipfs/go-libipfs/bitswap/server""
	""github.com/ipfs/go-libipfs/bitswap/tracer""
)
type option func(*Bitswap)
// Option is interface{} of server.Option or client.Option or func(*Bitswap)
// wrapped in a struct to gain strong type checking.
type Option struct {
	v interface{}
}
func EngineBlockstoreWorkerCount(count int) Option {
	return Option{server.EngineBlockstoreWorkerCount(count)}
}
func EngineTaskWorkerCount(count int) Option {
	return Option{server.EngineTaskWorkerCount(count)}
}
func MaxOutstandingBytesPerPeer(count int) Option {
	return Option{server.MaxOutstandingBytesPerPeer(count)}
}
func MaxQueuedWantlistEntriesPerPeer(count uint) Option {
	return Option{server.MaxQueuedWantlistEntriesPerPeer(count)}
}
func TaskWorkerCount(count int) Option {
	return Option{server.TaskWorkerCount(count)}
}
func ProvideEnabled(enabled bool) Option {
	return Option{server.ProvideEnabled(enabled)}
}
func SetSendDontHaves(send bool) Option {
	return Option{server.SetSendDontHaves(send)}
}
func WithPeerBlockRequestFilter(pbrf server.PeerBlockRequestFilter) Option {
	return Option{server.WithPeerBlockRequestFilter(pbrf)}
}
func WithScoreLedger(scoreLedger server.ScoreLedger) Option {
	return Option{server.WithScoreLedger(scoreLedger)}
}
func WithTargetMessageSize(tms int) Option {
	return Option{server.WithTargetMessageSize(tms)}
}
func WithTaskComparator(comparator server.TaskComparator) Option {
	return Option{server.WithTaskComparator(comparator)}
}
func ProviderSearchDelay(newProvSearchDelay time.Duration) Option {
	return Option{client.ProviderSearchDelay(newProvSearchDelay)}
}
func RebroadcastDelay(newRebroadcastDelay delay.D) Option {
	return Option{client.RebroadcastDelay(newRebroadcastDelay)}
}
func SetSimulateDontHavesOnTimeout(send bool) Option {
	return Option{client.SetSimulateDontHavesOnTimeout(send)}
}
func WithTracer(tap tracer.Tracer) Option {
	// Only trace the server, both receive the same messages anyway
	return Option{
		option(func(bs *Bitswap) {
			bs.tracer = tap
		}),
	}
}
",CWE-770,84.0,1
"package teler
import (
	""fmt""
	""strings""
	""net/http""
	""github.com/kitabisa/teler-waf/request""
	""github.com/kitabisa/teler-waf/threat""
	""gitlab.com/golang-commonmark/mdurl""
)
// inThreatIndex checks if the given substring is in specific threat datasets
func (t *Teler) inThreatIndex(kind threat.Threat, substr string) bool {
	if i := strings.Index(t.threat.data[kind], substr); i >= 0 {
		return true
	}
	return false
}
// inWhitelist checks if the given substring is in whitelist patterns
func (t *Teler) inWhitelist(r *http.Request) bool {
	uri := toURLDecode(r.URL.RequestURI())
	headers := headersToRawString(r.Header)
	clientIP := getClientIP(r)
	// Check the request URI, headers, and client IP address against the whitelist
	for _, pattern := range t.whitelistRegexes {
		if pattern.MatchString(uri) || pattern.MatchString(headers) || pattern.MatchString(clientIP) {
			return true
		}
	}
	return false
}
// headersToRawString converts a map of http.Header to
// multiline string, example:
// from,
//
//	Header = map[string][]string{
//		""Accept-Encoding"": {""gzip, deflate""},
//		""Accept-Language"": {""en-us""},
//		""Foo"": {""Bar"", ""two""},
//	}
//
// to
//
//	Host: example.com
//	accept-encoding: gzip, deflate
//	Accept-Language: en-us
//	fOO: Bar
//	foo: two
func headersToRawString(headers http.Header) string {
	var h strings.Builder
	// Iterate over the request headers and append each key-value pair to the builder
	for key, values := range headers {
		for _, value := range values {
			h.WriteString(
				fmt.Sprintf(""%s: %s\n"", toURLDecode(key), toURLDecode(value)),
			)
		}
	}
	// Returns the accumulated string of builder
	return h.String()
}
// toURLDecode decode URL-decoded characters string using mdurl package
func toURLDecode(s string) string {
	return mdurl.Decode(s)
}
// isValidMethod check if the given request.Method is valid
func isValidMethod(method request.Method) bool {
	switch method {
	case request.GET, request.HEAD, request.POST, request.PUT, request.PATCH:
	case request.DELETE, request.CONNECT, request.OPTIONS, request.TRACE, request.ALL:
	case """":
		return true
	}
	return false
}
// normalizeRawStringReader trim double-quotes of HTTP raw string,
// replace double-escape of CR and LF, and double it in the end, and
// returning as pointer of strings.Reader
func normalizeRawStringReader(raw string) *strings.Reader {
	var builder strings.Builder
	raw = strings.Trim(raw, `""`)
	raw = strings.ReplaceAll(raw, ""\\n"", ""\n"")
	raw = strings.ReplaceAll(raw, ""\\r"", ""\r"")
	builder.WriteString(raw)
	builder.WriteString(""\r\n\r\n"")
	return strings.NewReader(builder.String())
}
// getClientIP to get client IP address from request
func getClientIP(r *http.Request) string {
	// Get the client's IP address from the X-Real-Ip header field
	clientIP := r.Header.Get(""X-Real-Ip"")
	// If the X-Real-Ip header field is not present, try the X-Forwarded-For header field
	if clientIP == """" {
		clientIP = r.Header.Get(""X-Forwarded-For"")
	}
	// If the X-Forwarded-For header field is not present, use the RemoteAddr field
	if clientIP == """" {
		clientIP = r.RemoteAddr
	}
	// Returning client IP address
	return clientIP
}
",CWE-79,122.0,1
"package middleware
import (
	""errors""
	jwt ""github.com/appleboy/gin-jwt/v2""
	""github.com/gin-gonic/gin""
	""github.com/px-org/PanIndex/module""
	log ""github.com/sirupsen/logrus""
	""net/http""
	""net/url""
	""strings""
	""time""
)
const (
	LoginTimeOut = 24 * 365
	identityKey  = ""id""
)
func JWTMiddlewar() (*jwt.GinJWTMiddleware, error) {
	authMiddleware, err := jwt.New(&jwt.GinJWTMiddleware{
		Realm:       ""PanIndex Zone"",
		Key:         []byte(""PanIndex""),
		Timeout:     (time.Duration(LoginTimeOut)) * time.Hour,
		MaxRefresh:  (time.Duration(LoginTimeOut)) * time.Hour,
		IdentityKey: identityKey,
		PayloadFunc: func(data interface{}) jwt.MapClaims {
			if v, ok := data.(*User); ok {
				return jwt.MapClaims{
					identityKey: v.UserName,
				}
			}
			return jwt.MapClaims{}
		},
		IdentityHandler: func(c *gin.Context) interface{} {
			claims := jwt.ExtractClaims(c)
			return &User{
				UserName: claims[identityKey].(string),
			}
		},
		Authenticator: func(c *gin.Context) (interface{}, error) {
			var loginVals Login
			if err := c.ShouldBind(&loginVals); err != nil {
				return """", jwt.ErrMissingLoginValues
			}
			password := loginVals.Password
			user := loginVals.User
			if user == module.GloablConfig.AdminUser &&
				password == module.GloablConfig.AdminPassword {
				return &User{
					UserName: module.GloablConfig.AdminUser,
				}, nil
			}
			return nil, errors.New(""密码错误！请重试"")
		},
		Authorizator: func(data interface{}, c *gin.Context) bool {
			if v, ok := data.(*User); ok && v.UserName == module.GloablConfig.AdminUser {
				return true
			}
			return false
		},
		LoginResponse: func(c *gin.Context, code int, token string, expire time.Time) {
			//c.Redirect(http.StatusFound, module.GloablConfig.AdminPath+""/common"")
			referer := c.Request.Header.Get(""Referer"")
			u, _ := url.Parse(referer)
			if strings.HasPrefix(u.Path, module.GloablConfig.AdminPath) {
				c.Redirect(http.StatusFound, module.GloablConfig.AdminPath+""/common"")
			} else {
				c.Redirect(http.StatusFound, c.Request.Header.Get(""Referer""))
			}
		},
		LogoutResponse: func(c *gin.Context, code int) {
			ThemeCheck(c)
			theme := c.GetString(""theme"")
			c.HTML(http.StatusOK, ""templates/pan/admin/login.html"", gin.H{
				""error"":        true,
				""msg"":          ""退出成功"",
				""redirect_url"": ""login"",
				""config"":       module.GloablConfig,
				""theme"":        theme,
			})
		},
		Unauthorized: func(c *gin.Context, code int, message string) {
			path := c.Request.RequestURI
			if strings.HasPrefix(path, ""/api"") {
				//api return json
				c.JSON(code, gin.H{
					""status"": code,
					""msg"":    message,
				})
			} else {
				//return to login
				data := gin.H{
					""error"":        true,
					""msg"":          message,
					""redirect_url"": ""login"",
					""config"":       module.GloablConfig,
					""theme"":        module.GloablConfig.Theme,
				}
				if message == ""cookie token is empty"" {
					data[""error""] = false
					data[""msg""] = """"
				}
				c.HTML(http.StatusOK, ""templates/pan/admin/login.html"", data)
			}
		},
		SendCookie:     true,
		SecureCookie:   false,   //non HTTPS dev environments
		CookieHTTPOnly: true,    // JS can't modify
		CookieName:     ""token"", // default jwt
		TokenLookup:    ""header: Authorization, cookie: token"",
		CookieSameSite: http.SameSiteDefaultMode, //SameSiteDefaultMode, SameSiteLaxMode, SameSiteStrictMode, SameSiteNoneMode
		TokenHeadName:  ""Bearer"",
		// TimeFunc provides the current time. You can override it to use another time value. This is useful for testing or if your server uses a different time zone than your tokens.
		TimeFunc: time.Now,
	})
	errInit := authMiddleware.MiddlewareInit()
	if errInit != nil {
		log.Fatal(""authMiddleware.MiddlewareInit() Error:"" + errInit.Error())
	}
	if err != nil {
		log.Fatal(""JWT Error:"" + err.Error())
	}
	return authMiddleware, err
}
type Login struct {
	User     string `form:""user"" json:""user"" binding:""required""`
	Password string `form:""password"" json:""password"" binding:""required""`
}
type User struct {
	UserName string
}
",CWE-798,136.0,1
"package zip
import (
	""archive/zip""
	""io""
	""os""
	""path""
	""path/filepath""
)
// Unzip decompresses a zip file to specified directory.
// Note that the destination directory don't need to specify the trailing path separator.
func Unzip(zipPath, dstDir string) error {
	// Open zip file.
	reader, err := zip.OpenReader(zipPath)
	if err != nil {
		return err
	}
	defer reader.Close()
	for _, file := range reader.File {
		if err := unzipFile(file, dstDir); err != nil {
			return err
		}
	}
	return nil
}
func unzipFile(file *zip.File, dstDir string) error {
	// create the directory of file
	filePath := path.Join(dstDir, file.Name)
	if file.FileInfo().IsDir() {
		if err := os.MkdirAll(filePath, os.ModePerm); err != nil {
			return err
		}
		return nil
	}
	if err := os.MkdirAll(filepath.Dir(filePath), os.ModePerm); err != nil {
		return err
	}
	// open the file
	r, err := file.Open()
	if err != nil {
		return err
	}
	defer r.Close()
	// create the file
	w, err := os.Create(filePath)
	if err != nil {
		return err
	}
	defer w.Close()
	// save the decompressed file content
	_, err = io.Copy(w, r)
	return err
}
",CWE-22,59.0,1
"package api
import (
	log ""github.com/Sirupsen/logrus""
	""github.com/ansible-semaphore/semaphore/api/helpers""
	""github.com/ansible-semaphore/semaphore/db""
	""github.com/ansible-semaphore/semaphore/util""
	""github.com/gorilla/context""
	""net/http""
	""strings""
	""time""
)
func authenticationHandler(w http.ResponseWriter, r *http.Request) {
	var userID int
	authHeader := strings.ToLower(r.Header.Get(""authorization""))
	if len(authHeader) > 0 && strings.Contains(authHeader, ""bearer"") {
		token, err := helpers.Store(r).GetAPIToken(strings.Replace(authHeader, ""bearer "", """", 1))
		if err != nil {
			if err != db.ErrNotFound {
				log.Error(err)
			}
			w.WriteHeader(http.StatusUnauthorized)
			return
		}
		userID = token.UserID
	} else {
		// fetch session from cookie
		cookie, err := r.Cookie(""semaphore"")
		if err != nil {
			w.WriteHeader(http.StatusUnauthorized)
			return
		}
		value := make(map[string]interface{})
		if err = util.Cookie.Decode(""semaphore"", cookie.Value, &value); err != nil {
			w.WriteHeader(http.StatusUnauthorized)
			return
		}
		user, ok := value[""user""]
		sessionVal, okSession := value[""session""]
		if !ok || !okSession {
			w.WriteHeader(http.StatusUnauthorized)
			return
		}
		userID = user.(int)
		sessionID := sessionVal.(int)
		// fetch session
		session, err := helpers.Store(r).GetSession(userID, sessionID)
		if err != nil {
			w.WriteHeader(http.StatusUnauthorized)
			return
		}
		if time.Since(session.LastActive).Hours() > 7*24 {
			// more than week old unused session
			// destroy.
			if err := helpers.Store(r).ExpireSession(userID, sessionID); err != nil {
				// it is internal error, it doesn't concern the user
				log.Error(err)
			}
			w.WriteHeader(http.StatusUnauthorized)
			return
		}
		if err := helpers.Store(r).TouchSession(userID, sessionID); err != nil {
			log.Error(err)
			w.WriteHeader(http.StatusUnauthorized)
			return
		}
	}
	user, err := helpers.Store(r).GetUser(userID)
	if err != nil {
		if err != db.ErrNotFound {
			// internal error
			log.Error(err)
		}
		w.WriteHeader(http.StatusUnauthorized)
		return
	}
	if util.Config.DemoMode {
		if !user.Admin && r.Method != ""GET"" &&
			!strings.HasSuffix(r.URL.Path, ""/tasks"") &&
			!strings.HasSuffix(r.URL.Path, ""/stop"") {
			w.WriteHeader(http.StatusUnauthorized)
			return
		}
	}
	context.Set(r, ""user"", &user)
}
// nolint: gocyclo
func authentication(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		authenticationHandler(w, r)
		next.ServeHTTP(w, r)
	})
}
// nolint: gocyclo
func authenticationWithStore(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		store := helpers.Store(r)
		db.StoreSession(store, r.URL.String(), func() {
			authenticationHandler(w, r)
		})
		next.ServeHTTP(w, r)
	})
}
",CWE-287,125.0,1
"//
// Copyright 2021 The Sigstore Authors.
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package app
import (
	""fmt""
	""net/http""
	""net/http/pprof""
	""os""
	""time""
	homedir ""github.com/mitchellh/go-homedir""
	""github.com/sigstore/rekor/pkg/log""
	""github.com/spf13/cobra""
	""github.com/spf13/viper""
)
var (
	cfgFile     string
	logType     string
	enablePprof bool
	// these map to the operationId as defined in openapi.yaml file
	operationIds = []string{
		""searchIndex"",
		""getLogInfo"",
		""getPublicKey"",
		""getLogProof"",
		""createLogEntry"",
		""getLogEntryByIndex"",
		""getLogEntryByUUID"",
		""searchLogQuery"",
	}
)
// rootCmd represents the base command when called without any subcommands
var rootCmd = &cobra.Command{
	Use:   ""rekor-server"",
	Short: ""Rekor signature transparency log server"",
	Long: `Rekor fulfills the signature transparency role of sigstore's software
	signing infrastructure. It can also be run on its own and is designed to be
	extensible to work with different manifest schemas and PKI tooling`,
	// Uncomment the following line if your bare application
	// has an action associated with it:
	//	Run: func(cmd *cobra.Command, args []string) { },
}
// Execute adds all child commands to the root command and sets flags appropriately.
// This is called by main.main(). It only needs to happen once to the rootCmd.
func Execute() {
	if err := rootCmd.Execute(); err != nil {
		log.Logger.Error(err)
		os.Exit(1)
	}
}
func init() {
	cobra.OnInitialize(initConfig)
	rootCmd.PersistentFlags().StringVar(&cfgFile, ""config"", """", ""config file (default is $HOME/.rekor-server.yaml)"")
	rootCmd.PersistentFlags().StringVar(&logType, ""log_type"", ""dev"", ""logger type to use (dev/prod)"")
	rootCmd.PersistentFlags().BoolVar(&enablePprof, ""enable_pprof"", false, ""enable pprof for profiling on port 6060"")
	rootCmd.PersistentFlags().Bool(""enable_killswitch"", false, ""enable killswitch for TESTING ONLY on port 2345"")
	_ = rootCmd.PersistentFlags().MarkHidden(""enable_killswitch"")
	rootCmd.PersistentFlags().String(""trillian_log_server.address"", ""127.0.0.1"", ""Trillian log server address"")
	rootCmd.PersistentFlags().Uint16(""trillian_log_server.port"", 8090, ""Trillian log server port"")
	rootCmd.PersistentFlags().Uint(""trillian_log_server.tlog_id"", 0, ""Trillian tree id"")
	rootCmd.PersistentFlags().String(""trillian_log_server.sharding_config"", """", ""path to config file for inactive shards, in JSON or YAML"")
	hostname, err := os.Hostname()
	if err != nil {
		hostname = ""localhost""
	}
	rootCmd.PersistentFlags().String(""rekor_server.hostname"", hostname, ""public hostname of instance"")
	rootCmd.PersistentFlags().String(""rekor_server.address"", ""127.0.0.1"", ""Address to bind to"")
	rootCmd.PersistentFlags().String(""rekor_server.signer"", ""memory"",
		`Rekor signer to use. Valid options are: [gcpkms, memory, filename containing PEM encoded private key].
Memory and file-based signers should only be used for testing.`)
	rootCmd.PersistentFlags().String(""rekor_server.signer-passwd"", """", ""Password to decrypt signer private key"")
	rootCmd.PersistentFlags().Uint16(""port"", 3000, ""Port to bind to"")
	rootCmd.PersistentFlags().Bool(""enable_retrieve_api"", true, ""enables Redis-based index API endpoint"")
	_ = rootCmd.PersistentFlags().MarkDeprecated(""enable_retrieve_api"", ""this flag is deprecated in favor of enabled_api_endpoints (searchIndex)"")
	rootCmd.PersistentFlags().String(""redis_server.address"", ""127.0.0.1"", ""Redis server address"")
	rootCmd.PersistentFlags().Uint16(""redis_server.port"", 6379, ""Redis server port"")
	rootCmd.PersistentFlags().Bool(""enable_attestation_storage"", false, ""enables rich attestation storage"")
	rootCmd.PersistentFlags().String(""attestation_storage_bucket"", """", ""url for attestation storage bucket"")
	rootCmd.PersistentFlags().Int(""max_attestation_size"", 100*1024, ""max size for attestation storage, in bytes"")
	rootCmd.PersistentFlags().StringSlice(""enabled_api_endpoints"", operationIds, ""list of API endpoints to enable using operationId from openapi.yaml"")
	rootCmd.PersistentFlags().Uint64(""max_request_body_size"", 0, ""maximum size for HTTP request body, in bytes; set to 0 for unlimited"")
	if err := viper.BindPFlags(rootCmd.PersistentFlags()); err != nil {
		log.Logger.Fatal(err)
	}
	rootCmd.Flags().BoolP(""toggle"", ""t"", false, ""Help message for toggle"")
	log.Logger.Debugf(""pprof enabled %v"", enablePprof)
	// Enable pprof
	if enablePprof {
		go func() {
			mux := http.NewServeMux()
			mux.HandleFunc(""/debug/pprof/"", pprof.Index)
			mux.HandleFunc(""/debug/pprof/{action}"", pprof.Index)
			mux.HandleFunc(""/debug/pprof/symbol"", pprof.Symbol)
			srv := &http.Server{
				Addr:         "":6060"",
				ReadTimeout:  10 * time.Second,
				WriteTimeout: 10 * time.Second,
				Handler:      mux,
			}
			if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
				log.Logger.Fatalf(""Error when starting or running http server: %v"", err)
			}
		}()
	}
}
// initConfig reads in config file and ENV variables if set.
func initConfig() {
	if cfgFile != """" {
		// Use config file from the flag.
		viper.SetConfigFile(cfgFile)
	} else {
		// Find home directory.
		home, err := homedir.Dir()
		if err != nil {
			fmt.Println(err)
			os.Exit(1)
		}
		viper.AddConfigPath(home)
		viper.AddConfigPath(""."")
		viper.SetConfigName(""rekor-server"")
		viper.SetConfigType(""yaml"")
	}
	viper.AutomaticEnv() // read in environment variables that match
	// If a config file is found, read it in.
	if err := viper.ReadInConfig(); err == nil {
		log.Logger.Infof(""Using config file: %s"", viper.ConfigFileUsed())
	}
}
",CWE-770,166.0,1
"//
// Copyright 2021 The Sigstore Authors.
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package alpine
import (
	""os""
	""testing""
	""github.com/sigstore/rekor/pkg/pki/x509""
)
func TestAlpinePackage(t *testing.T) {
	inputArchive, err := os.Open(""tests/test_alpine.apk"")
	if err != nil {
		t.Fatalf(""could not open archive %v"", err)
	}
	p := Package{}
	err = p.Unmarshal(inputArchive)
	if err != nil {
		t.Fatalf(""unmarshal error: %v"", err)
	}
	pubKey, err := os.Open(""tests/test_alpine.pub"")
	if err != nil {
		t.Fatalf(""could not open archive %v"", err)
	}
	pub, err := x509.NewPublicKey(pubKey)
	if err != nil {
		t.Fatalf(""failed to parse public key: %v"", err)
	}
	if err = p.VerifySignature(pub.CryptoPubKey()); err != nil {
		t.Fatalf(""signature verification failed: %v"", err)
	}
}
",CWE-770,51.0,1
"//
// Copyright 2021 The Sigstore Authors.
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package jar
import (
	""bytes""
	""context""
	""os""
	""reflect""
	""testing""
	""github.com/go-openapi/runtime""
	""github.com/go-openapi/strfmt""
	""github.com/go-openapi/swag""
	""github.com/sigstore/rekor/pkg/generated/models""
	""github.com/sigstore/rekor/pkg/types""
	""go.uber.org/goleak""
)
func TestMain(m *testing.M) {
	goleak.VerifyTestMain(m)
}
func TestNewEntryReturnType(t *testing.T) {
	entry := NewEntry()
	if reflect.TypeOf(entry) != reflect.ValueOf(&V001Entry{}).Type() {
		t.Errorf(""invalid type returned from NewEntry: %T"", entry)
	}
}
func TestCrossFieldValidation(t *testing.T) {
	type TestCase struct {
		caseDesc                  string
		entry                     V001Entry
		expectUnmarshalSuccess    bool
		expectCanonicalizeSuccess bool
		expectedVerifierSuccess   bool
	}
	jarBytes, _ := os.ReadFile(""tests/test.jar"")
	// extracted from jar
	certificate := `-----BEGIN CERTIFICATE-----
MIIB+DCCAX6gAwIBAgITNVkDZoCiofPDsy7dfm6geLbuhzAKBggqhkjOPQQDAzAq
MRUwEwYDVQQKEwxzaWdzdG9yZS5kZXYxETAPBgNVBAMTCHNpZ3N0b3JlMB4XDTIx
MDMwNzAzMjAyOVoXDTMxMDIyMzAzMjAyOVowKjEVMBMGA1UEChMMc2lnc3RvcmUu
ZGV2MREwDwYDVQQDEwhzaWdzdG9yZTB2MBAGByqGSM49AgEGBSuBBAAiA2IABLSy
A7Ii5k+pNO8ZEWY0ylemWDowOkNa3kL+GZE5Z5GWehL9/A9bRNA3RbrsZ5i0Jcas
taRL7Sp5fp/jD5dxqc/UdTVnlvS16an+2Yfswe/QuLolRUCrcOE2+2iA5+tzd6Nm
MGQwDgYDVR0PAQH/BAQDAgEGMBIGA1UdEwEB/wQIMAYBAf8CAQEwHQYDVR0OBBYE
FMjFHQBBmiQpMlEk6w2uSu1KBtPsMB8GA1UdIwQYMBaAFMjFHQBBmiQpMlEk6w2u
Su1KBtPsMAoGCCqGSM49BAMDA2gAMGUCMH8liWJfMui6vXXBhjDgY4MwslmN/TJx
Ve/83WrFomwmNf056y1X48F9c4m3a3ozXAIxAKjRay5/aj/jsKKGIkmQatjI8uup
Hr/+CxFvaJWmpYqNkLDGRU+9orzh5hI2RrcuaQ==
-----END CERTIFICATE-----
`
	testCases := []TestCase{
		{
			caseDesc:                ""empty obj"",
			entry:                   V001Entry{},
			expectUnmarshalSuccess:  false,
			expectedVerifierSuccess: false,
		},
		{
			caseDesc: ""empty archive"",
			entry: V001Entry{
				JARModel: models.JarV001Schema{
					Archive: &models.JarV001SchemaArchive{},
				},
			},
			expectUnmarshalSuccess:  false,
			expectedVerifierSuccess: false,
		},
		{
			caseDesc: ""archive with inline content"",
			entry: V001Entry{
				JARModel: models.JarV001Schema{
					Archive: &models.JarV001SchemaArchive{
						Content: strfmt.Base64(jarBytes),
					},
				},
			},
			expectUnmarshalSuccess:    true,
			expectCanonicalizeSuccess: true,
			expectedVerifierSuccess:   true,
		},
	}
	for _, tc := range testCases {
		v := &V001Entry{}
		r := models.Jar{
			APIVersion: swag.String(tc.entry.APIVersion()),
			Spec:       tc.entry.JARModel,
		}
		if err := v.Unmarshal(&r); (err == nil) != tc.expectUnmarshalSuccess {
			t.Errorf(""unexpected result in '%v': %v"", tc.caseDesc, err)
		}
		// No need to continue here if unmarshal failed
		if !tc.expectUnmarshalSuccess {
			continue
		}
		b, err := v.Canonicalize(context.TODO())
		if (err == nil) != tc.expectCanonicalizeSuccess {
			t.Errorf(""unexpected result from Canonicalize for '%v': %v"", tc.caseDesc, err)
		} else if err != nil {
			if _, ok := err.(types.ValidationError); !ok {
				t.Errorf(""canonicalize returned an unexpected error that isn't of type types.ValidationError: %v"", err)
			}
		}
		if b != nil {
			pe, err := models.UnmarshalProposedEntry(bytes.NewReader(b), runtime.JSONConsumer())
			if err != nil {
				t.Errorf(""unexpected err from Unmarshalling canonicalized entry for '%v': %v"", tc.caseDesc, err)
			}
			if _, err := types.UnmarshalEntry(pe); err != nil {
				t.Errorf(""unexpected err from type-specific unmarshalling for '%v': %v"", tc.caseDesc, err)
			}
		}
		verifier, err := v.Verifier()
		if tc.expectedVerifierSuccess {
			if err != nil {
				t.Errorf(""%v: unexpected error, got %v"", tc.caseDesc, err)
			} else {
				pub, _ := verifier.CanonicalValue()
				if !reflect.DeepEqual(pub, []byte(certificate)) {
					t.Errorf(""verifier and public keys do not match: %v, %v"", string(pub), certificate)
				}
			}
		} else {
			if err == nil {
				s, _ := verifier.CanonicalValue()
				t.Errorf(""%v: expected error for %v, got %v"", tc.caseDesc, string(s), err)
			}
		}
	}
}
",CWE-770,153.0,1
"package router
import (
	""context""
	""database/sql""
	""encoding/json""
	""fmt""
	""time""
	""github.com/rudderlabs/rudder-server/utils/misc""
)
var failedEventsManager FailedEventsManagerI
type FailedEventRowT struct {
	DestinationID string          `json:""destination_id""`
	RecordID      json.RawMessage `json:""record_id""`
}
var (
	failedKeysTablePrefix  = ""failed_keys""
	failedKeysExpire       time.Duration
	failedKeysCleanUpSleep time.Duration
	failedKeysEnabled      bool
)
type FailedEventsManagerI interface {
	SaveFailedRecordIDs(map[string][]*FailedEventRowT, *sql.Tx)
	DropFailedRecordIDs(jobRunID string)
	FetchFailedRecordIDs(jobRunID string) []*FailedEventRowT
	GetDBHandle() *sql.DB
}
type FailedEventsManagerT struct {
	dbHandle *sql.DB
}
func GetFailedEventsManager() FailedEventsManagerI {
	if failedEventsManager == nil {
		fem := new(FailedEventsManagerT)
		dbHandle, err := sql.Open(""postgres"", misc.GetConnectionString())
		if err != nil {
			panic(err)
		}
		fem.dbHandle = dbHandle
		failedEventsManager = fem
	}
	return failedEventsManager
}
func (*FailedEventsManagerT) SaveFailedRecordIDs(taskRunIDFailedEventsMap map[string][]*FailedEventRowT, txn *sql.Tx) {
	if !failedKeysEnabled {
		return
	}
	for taskRunID, failedEvents := range taskRunIDFailedEventsMap {
		table := fmt.Sprintf(`%s_%s`, failedKeysTablePrefix, taskRunID)
		sqlStatement := fmt.Sprintf(`CREATE TABLE IF NOT EXISTS %s (
		destination_id TEXT NOT NULL,
		record_id JSONB NOT NULL,
		created_at TIMESTAMP NOT NULL);`, table)
		_, err := txn.Exec(sqlStatement)
		if err != nil {
			_ = txn.Rollback()
			panic(err)
		}
		insertQuery := fmt.Sprintf(`INSERT INTO %s VALUES($1, $2, $3);`, table)
		stmt, err := txn.Prepare(insertQuery)
		if err != nil {
			_ = txn.Rollback()
			panic(err)
		}
		createdAt := time.Now()
		for _, failedEvent := range failedEvents {
			if len(failedEvent.RecordID) == 0 || !json.Valid(failedEvent.RecordID) {
				pkgLogger.Infof(""skipped adding invalid recordId: %s, to failed keys table: %s"", failedEvent.RecordID, table)
				continue
			}
			_, err = stmt.Exec(failedEvent.DestinationID, failedEvent.RecordID, createdAt)
			if err != nil {
				panic(err)
			}
		}
		stmt.Close()
	}
}
func (fem *FailedEventsManagerT) DropFailedRecordIDs(taskRunID string) {
	if !failedKeysEnabled {
		return
	}
	// Drop table
	table := fmt.Sprintf(`%s_%s`, failedKeysTablePrefix, taskRunID)
	sqlStatement := fmt.Sprintf(`DROP TABLE IF EXISTS %s`, table)
	_, err := fem.dbHandle.Exec(sqlStatement)
	if err != nil {
		pkgLogger.Errorf(""Failed to drop table %s with error: %v"", taskRunID, err)
	}
}
func (fem *FailedEventsManagerT) FetchFailedRecordIDs(taskRunID string) []*FailedEventRowT {
	if !failedKeysEnabled {
		return []*FailedEventRowT{}
	}
	failedEvents := make([]*FailedEventRowT, 0)
	var rows *sql.Rows
	var err error
	table := fmt.Sprintf(`%s_%s`, failedKeysTablePrefix, taskRunID)
	sqlStatement := fmt.Sprintf(`SELECT %[1]s.destination_id, %[1]s.record_id
                                             FROM %[1]s `, table)
	rows, err = fem.dbHandle.Query(sqlStatement)
	if err != nil {
		pkgLogger.Errorf(""Failed to fetch from table %s with error: %v"", taskRunID, err)
		return failedEvents
	}
	defer rows.Close()
	for rows.Next() {
		var failedEvent FailedEventRowT
		err := rows.Scan(&failedEvent.DestinationID, &failedEvent.RecordID)
		if err != nil {
			panic(err)
		}
		failedEvents = append(failedEvents, &failedEvent)
	}
	return failedEvents
}
func CleanFailedRecordsTableProcess(ctx context.Context) {
	if !failedKeysEnabled {
		return
	}
	for {
		select {
		case <-ctx.Done():
			return
		case <-time.After(failedKeysCleanUpSleep):
			dbHandle, err := sql.Open(""postgres"", misc.GetConnectionString())
			if err != nil {
				panic(err)
			}
			failedKeysLike := failedKeysTablePrefix + ""%""
			failedKeysTableQuery := fmt.Sprintf(`SELECT table_name
													FROM information_schema.tables
													WHERE table_schema='public' AND table_type='BASE TABLE' AND table_name ilike '%s'`, failedKeysLike)
			rows, err := dbHandle.Query(failedKeysTableQuery)
			if err != nil {
				panic(err)
			}
			for rows.Next() {
				var table string
				err = rows.Scan(&table)
				if err != nil {
					pkgLogger.Errorf(""Failed to scan failed keys table %s with error: %v"", table, err)
					return
				}
				latestCreatedAtQuery := fmt.Sprintf(`SELECT created_at from %s order by created_at desc limit 1`, table)
				row := dbHandle.QueryRow(latestCreatedAtQuery)
				var latestCreatedAt time.Time
				err = row.Scan(&latestCreatedAt)
				if err != nil && err != sql.ErrNoRows {
					pkgLogger.Errorf(""Failed to fetch records from failed keys table %s with error: %v"", table, err)
					continue
				}
				currentTime := time.Now()
				diff := currentTime.Sub(latestCreatedAt)
				if diff > failedKeysExpire {
					dropQuery := fmt.Sprintf(`DROP TABLE IF EXISTS %s`, table)
					rows, err = dbHandle.Query(dropQuery)
					if err != nil {
						pkgLogger.Errorf(""Failed to drop table %s with error: %v"", table, err)
					}
				}
			}
			dbHandle.Close()
		}
	}
}
func (fem *FailedEventsManagerT) GetDBHandle() *sql.DB {
	return fem.dbHandle
}
",CWE-89,190.0,1
"package router
import (
	""context""
	""database/sql""
	""encoding/json""
	""fmt""
	""strings""
	""time""
	""github.com/rudderlabs/rudder-server/utils/misc""
)
var failedEventsManager FailedEventsManagerI
type FailedEventRowT struct {
	DestinationID string          `json:""destination_id""`
	RecordID      json.RawMessage `json:""record_id""`
}
var (
	failedKeysTablePrefix  = ""failed_keys""
	failedKeysExpire       time.Duration
	failedKeysCleanUpSleep time.Duration
	failedKeysEnabled      bool
)
type FailedEventsManagerI interface {
	SaveFailedRecordIDs(map[string][]*FailedEventRowT, *sql.Tx)
	DropFailedRecordIDs(jobRunID string)
	FetchFailedRecordIDs(jobRunID string) []*FailedEventRowT
	GetDBHandle() *sql.DB
}
type FailedEventsManagerT struct {
	dbHandle *sql.DB
}
func GetFailedEventsManager() FailedEventsManagerI {
	if failedEventsManager == nil {
		fem := new(FailedEventsManagerT)
		dbHandle, err := sql.Open(""postgres"", misc.GetConnectionString())
		if err != nil {
			panic(err)
		}
		fem.dbHandle = dbHandle
		failedEventsManager = fem
	}
	return failedEventsManager
}
func (*FailedEventsManagerT) SaveFailedRecordIDs(taskRunIDFailedEventsMap map[string][]*FailedEventRowT, txn *sql.Tx) {
	if !failedKeysEnabled {
		return
	}
	for taskRunID, failedEvents := range taskRunIDFailedEventsMap {
		table := `""` + strings.ReplaceAll(fmt.Sprintf(`%s_%s`, failedKeysTablePrefix, taskRunID), `""`, `""""`) + `""`
		sqlStatement := fmt.Sprintf(`CREATE TABLE IF NOT EXISTS %s (
		destination_id TEXT NOT NULL,
		record_id JSONB NOT NULL,
		created_at TIMESTAMP NOT NULL);`, table)
		_, err := txn.Exec(sqlStatement)
		if err != nil {
			_ = txn.Rollback()
			panic(err)
		}
		insertQuery := fmt.Sprintf(`INSERT INTO %s VALUES($1, $2, $3);`, table)
		stmt, err := txn.Prepare(insertQuery)
		if err != nil {
			_ = txn.Rollback()
			panic(err)
		}
		createdAt := time.Now()
		for _, failedEvent := range failedEvents {
			if len(failedEvent.RecordID) == 0 || !json.Valid(failedEvent.RecordID) {
				pkgLogger.Infof(""skipped adding invalid recordId: %s, to failed keys table: %s"", failedEvent.RecordID, table)
				continue
			}
			_, err = stmt.Exec(failedEvent.DestinationID, failedEvent.RecordID, createdAt)
			if err != nil {
				panic(err)
			}
		}
		stmt.Close()
	}
}
func (fem *FailedEventsManagerT) DropFailedRecordIDs(taskRunID string) {
	if !failedKeysEnabled {
		return
	}
	// Drop table
	table := fmt.Sprintf(`%s_%s`, failedKeysTablePrefix, taskRunID)
	sqlStatement := fmt.Sprintf(`DROP TABLE IF EXISTS %s`, table)
	_, err := fem.dbHandle.Exec(sqlStatement)
	if err != nil {
		pkgLogger.Errorf(""Failed to drop table %s with error: %v"", taskRunID, err)
	}
}
func (fem *FailedEventsManagerT) FetchFailedRecordIDs(taskRunID string) []*FailedEventRowT {
	if !failedKeysEnabled {
		return []*FailedEventRowT{}
	}
	failedEvents := make([]*FailedEventRowT, 0)
	var rows *sql.Rows
	var err error
	table := `""` + strings.ReplaceAll(fmt.Sprintf(`%s_%s`, failedKeysTablePrefix, taskRunID), `""`, `""""`) + `""`
	sqlStatement := fmt.Sprintf(`SELECT %[1]s.destination_id, %[1]s.record_id
                                             FROM %[1]s `, table)
	rows, err = fem.dbHandle.Query(sqlStatement)
	if err != nil {
		pkgLogger.Errorf(""Failed to fetch from table %s with error: %v"", taskRunID, err)
		return failedEvents
	}
	defer rows.Close()
	for rows.Next() {
		var failedEvent FailedEventRowT
		err := rows.Scan(&failedEvent.DestinationID, &failedEvent.RecordID)
		if err != nil {
			panic(err)
		}
		failedEvents = append(failedEvents, &failedEvent)
	}
	return failedEvents
}
func CleanFailedRecordsTableProcess(ctx context.Context) {
	if !failedKeysEnabled {
		return
	}
	for {
		select {
		case <-ctx.Done():
			return
		case <-time.After(failedKeysCleanUpSleep):
			dbHandle, err := sql.Open(""postgres"", misc.GetConnectionString())
			if err != nil {
				panic(err)
			}
			failedKeysLike := failedKeysTablePrefix + ""%""
			failedKeysTableQuery := fmt.Sprintf(`SELECT table_name
													FROM information_schema.tables
													WHERE table_schema='public' AND table_type='BASE TABLE' AND table_name ilike '%s'`, failedKeysLike)
			rows, err := dbHandle.Query(failedKeysTableQuery)
			if err != nil {
				panic(err)
			}
			for rows.Next() {
				var table string
				err = rows.Scan(&table)
				if err != nil {
					pkgLogger.Errorf(""Failed to scan failed keys table %s with error: %v"", table, err)
					return
				}
				latestCreatedAtQuery := fmt.Sprintf(`SELECT created_at from %s order by created_at desc limit 1`, table)
				row := dbHandle.QueryRow(latestCreatedAtQuery)
				var latestCreatedAt time.Time
				err = row.Scan(&latestCreatedAt)
				if err != nil && err != sql.ErrNoRows {
					pkgLogger.Errorf(""Failed to fetch records from failed keys table %s with error: %v"", table, err)
					continue
				}
				currentTime := time.Now()
				diff := currentTime.Sub(latestCreatedAt)
				if diff > failedKeysExpire {
					dropQuery := fmt.Sprintf(`DROP TABLE IF EXISTS %s`, table)
					rows, err = dbHandle.Query(dropQuery)
					if err != nil {
						pkgLogger.Errorf(""Failed to drop table %s with error: %v"", table, err)
					}
				}
			}
			dbHandle.Close()
		}
	}
}
func (fem *FailedEventsManagerT) GetDBHandle() *sql.DB {
	return fem.dbHandle
}
",CWE-89,191.0,1
"/*
Copyright 2021 The Fluid Authors.
Licensed under the Apache License, Version 2.0 (the ""License"");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an ""AS IS"" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package app
import (
	""context""
	""errors""
	""flag""
	""fmt""
	""net/http""
	""net/http/pprof""
	""os""
	""time""
	""github.com/fluid-cloudnative/fluid""
	datav1alpha1 ""github.com/fluid-cloudnative/fluid/api/v1alpha1""
	""github.com/fluid-cloudnative/fluid/pkg/csi""
	""github.com/fluid-cloudnative/fluid/pkg/csi/config""
	utilfeature ""github.com/fluid-cloudnative/fluid/pkg/utils/feature""
	""github.com/golang/glog""
	""github.com/spf13/cobra""
	""k8s.io/apimachinery/pkg/runtime""
	clientgoscheme ""k8s.io/client-go/kubernetes/scheme""
	ctrl ""sigs.k8s.io/controller-runtime""
)
var (
	endpoint    string
	nodeID      string
	metricsAddr string
	pprofAddr   string
	pruneFs     []string
	prunePath   string
)
var scheme = runtime.NewScheme()
var startCmd = &cobra.Command{
	Use:   ""start"",
	Short: ""start fluid driver on node"",
	Run: func(cmd *cobra.Command, args []string) {
		handle()
	},
}
func init() {
	// Register k8s-native resources and Fluid CRDs
	_ = clientgoscheme.AddToScheme(scheme)
	_ = datav1alpha1.AddToScheme(scheme)
	if err := flag.Set(""logtostderr"", ""true""); err != nil {
		fmt.Printf(""Failed to flag.set due to %v"", err)
		os.Exit(1)
	}
	startCmd.Flags().StringVarP(&nodeID, ""nodeid"", """", """", ""node id"")
	if err := startCmd.MarkFlagRequired(""nodeid""); err != nil {
		ErrorAndExit(err)
	}
	startCmd.Flags().StringVarP(&endpoint, ""endpoint"", """", """", ""CSI endpoint"")
	if err := startCmd.MarkFlagRequired(""endpoint""); err != nil {
		ErrorAndExit(err)
	}
	startCmd.Flags().StringSliceVarP(&pruneFs, ""prune-fs"", """", []string{""fuse.alluxio-fuse"", ""fuse.jindofs-fuse"", ""fuse.juicefs"", ""fuse.goosefs-fuse"", ""ossfs""}, ""Prune fs to add in /etc/updatedb.conf, separated by comma"")
	startCmd.Flags().StringVarP(&prunePath, ""prune-path"", """", ""/runtime-mnt"", ""Prune path to add in /etc/updatedb.conf"")
	startCmd.Flags().StringVarP(&metricsAddr, ""metrics-addr"", """", "":8080"", ""The address the metrics endpoint binds to."")
	startCmd.Flags().StringVarP(&pprofAddr, ""pprof-addr"", """", """", ""The address for pprof to use while exporting profiling results"")
	utilfeature.DefaultMutableFeatureGate.AddFlag(startCmd.Flags())
	startCmd.Flags().AddGoFlagSet(flag.CommandLine)
}
func ErrorAndExit(err error) {
	fmt.Fprintf(os.Stderr, ""%s"", err.Error())
	os.Exit(1)
}
func handle() {
	// startReaper()
	fluid.LogVersion()
	if pprofAddr != """" {
		newPprofServer(pprofAddr)
	}
	mgr, err := ctrl.NewManager(ctrl.GetConfigOrDie(), ctrl.Options{
		Scheme:             scheme,
		MetricsBindAddress: metricsAddr,
		Port:               9443,
	})
	if err != nil {
		panic(fmt.Sprintf(""csi: unable to create controller manager due to error %v"", err))
	}
	config := config.Config{
		NodeId:    nodeID,
		Endpoint:  endpoint,
		PruneFs:   pruneFs,
		PrunePath: prunePath,
	}
	if err = csi.SetupWithManager(mgr, config); err != nil {
		panic(fmt.Sprintf(""unable to set up manager due to error %v"", err))
	}
	ctx := ctrl.SetupSignalHandler()
	if err = mgr.Start(ctx); err != nil {
		panic(fmt.Sprintf(""unable to start controller recover due to error %v"", err))
	}
}
func newPprofServer(pprofAddr string) {
	glog.Infof(""Enabling pprof with address %s"", pprofAddr)
	mux := http.NewServeMux()
	mux.HandleFunc(""/debug/pprof/"", pprof.Index)
	mux.HandleFunc(""/debug/pprof/cmdline"", pprof.Cmdline)
	mux.HandleFunc(""/debug/pprof/profile"", pprof.Profile)
	mux.HandleFunc(""/debug/pprof/symbol"", pprof.Symbol)
	mux.HandleFunc(""/debug/pprof/trace"", pprof.Trace)
	pprofServer := http.Server{
		Addr:    pprofAddr,
		Handler: mux,
	}
	glog.Infof(""Starting pprof HTTP server at %s"", pprofServer.Addr)
	go func() {
		go func() {
			ctx := context.Background()
			<-ctx.Done()
			ctx, cancelFunc := context.WithTimeout(context.Background(), 60*time.Minute)
			defer cancelFunc()
			if err := pprofServer.Shutdown(ctx); err != nil {
				glog.Error(err, ""Failed to shutdown debug HTTP server"")
			}
		}()
		if err := pprofServer.ListenAndServe(); !errors.Is(http.ErrServerClosed, err) {
			glog.Error(err, ""Failed to start debug HTTP server"")
			panic(err)
		}
	}()
}
",CWE-863,162.0,1
"/*
Copyright 2022 The Fluid Authors.
Licensed under the Apache License, Version 2.0 (the ""License"");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an ""AS IS"" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package config
type Config struct {
	NodeId    string
	Endpoint  string
	PruneFs   []string
	PrunePath string
}
",CWE-863,25.0,1
"/*
Copyright 2023 The Fluid Authors.
Licensed under the Apache License, Version 2.0 (the ""License"");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an ""AS IS"" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package plugins
import (
	""context""
	""fmt""
	""os""
	""path/filepath""
	""strings""
	""sigs.k8s.io/controller-runtime/pkg/client""
	""sigs.k8s.io/controller-runtime/pkg/manager""
	""github.com/container-storage-interface/spec/lib/go/csi""
	""github.com/fluid-cloudnative/fluid/pkg/utils""
	""github.com/golang/glog""
	csicommon ""github.com/kubernetes-csi/drivers/pkg/csi-common""
)
const (
	driverName = ""fuse.csi.fluid.io""
	version    = ""1.0.0""
)
type driver struct {
	client           client.Client
	apiReader        client.Reader
	csiDriver        *csicommon.CSIDriver
	nodeId, endpoint string
}
var _ manager.Runnable = &driver{}
func NewDriver(nodeID, endpoint string, client client.Client, apiReader client.Reader) *driver {
	glog.Infof(""Driver: %v version: %v"", driverName, version)
	proto, addr := utils.SplitSchemaAddr(endpoint)
	glog.Infof(""protocol: %v addr: %v"", proto, addr)
	if !strings.HasPrefix(addr, ""/"") {
		addr = fmt.Sprintf(""/%s"", addr)
	}
	socketDir := filepath.Dir(addr)
	err := os.MkdirAll(socketDir, 0755)
	if err != nil {
		glog.Errorf(""failed due to %v"", err)
		os.Exit(1)
	}
	csiDriver := csicommon.NewCSIDriver(driverName, version, nodeID)
	csiDriver.AddControllerServiceCapabilities([]csi.ControllerServiceCapability_RPC_Type{csi.ControllerServiceCapability_RPC_CREATE_DELETE_VOLUME})
	csiDriver.AddVolumeCapabilityAccessModes([]csi.VolumeCapability_AccessMode_Mode{csi.VolumeCapability_AccessMode_MULTI_NODE_MULTI_WRITER})
	return &driver{
		nodeId:    nodeID,
		endpoint:  endpoint,
		csiDriver: csiDriver,
		client:    client,
		apiReader: apiReader,
	}
}
func (d *driver) newControllerServer() *controllerServer {
	return &controllerServer{
		DefaultControllerServer: csicommon.NewDefaultControllerServer(d.csiDriver),
	}
}
func (d *driver) newNodeServer() *nodeServer {
	return &nodeServer{
		nodeId:            d.nodeId,
		DefaultNodeServer: csicommon.NewDefaultNodeServer(d.csiDriver),
		client:            d.client,
		apiReader:         d.apiReader,
	}
}
func (d *driver) run() {
	s := csicommon.NewNonBlockingGRPCServer()
	s.Start(
		d.endpoint,
		csicommon.NewDefaultIdentityServer(d.csiDriver),
		d.newControllerServer(),
		d.newNodeServer(),
	)
	s.Wait()
}
func (d *driver) Start(ctx context.Context) error {
	d.run()
	return nil
}
",CWE-863,109.0,1
"/*
Copyright 2022 The Fluid Authors.
Licensed under the Apache License, Version 2.0 (the ""License"");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an ""AS IS"" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package plugins
import (
	""github.com/fluid-cloudnative/fluid/pkg/csi/config""
	""sigs.k8s.io/controller-runtime/pkg/manager""
)
// Register initializes the csi driver and registers it to the controller manager.
func Register(mgr manager.Manager, cfg config.Config) error {
	csiDriver := NewDriver(cfg.NodeId, cfg.Endpoint, mgr.GetClient(), mgr.GetAPIReader())
	if err := mgr.Add(csiDriver); err != nil {
		return err
	}
	return nil
}
// Enabled checks if the csi driver should be enabled.
func Enabled() bool {
	return true
}
",CWE-863,39.0,1
"// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package configgenerator
import (
	""github.com/GoogleCloudPlatform/esp-v2/src/go/configgenerator/filtergen""
	ci ""github.com/GoogleCloudPlatform/esp-v2/src/go/configinfo""
	""github.com/GoogleCloudPlatform/esp-v2/src/go/util/httppattern""
	hcmpb ""github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3""
	anypb ""github.com/golang/protobuf/ptypes/any""
)
// FilterGenerator is an interface for objects that generate Envoy filters.
type FilterGenerator interface {
	// FilterName returns the name of the filter.
	FilterName() string
	// IsEnabled returns true if the filter config should be generated.
	// If false, none of the generation methods will be called.
	IsEnabled() bool
	// GenFilterConfig generates the filter config.
	//
	// Return (nil, nil) if the filter has no listener-level config, but may
	// have per-route configurations.
	GenFilterConfig(*ci.ServiceInfo) (*hcmpb.HttpFilter, error)
	// GenPerRouteConfig generates the per-route config for the given HTTP route (HTTP pattern).
	// The MethodInfo that contains the route is also provided.
	//
	// This method is called on all routes. Return (nil, nil) to indicate the
	// filter does NOT require a per-route config for the given route.
	GenPerRouteConfig(*ci.MethodInfo, *httppattern.Pattern) (*anypb.Any, error)
}
// MakeFilterGenerators provide of a slice of FilterGenerator in sequence.
func MakeFilterGenerators(serviceInfo *ci.ServiceInfo) ([]FilterGenerator, error) {
	return []FilterGenerator{
		filtergen.NewCORSGenerator(serviceInfo),
		// Health check filter is behind Path Matcher filter, since Service Control
		// filter needs to get the corresponding rule for health check in order to skip Report
		filtergen.NewHealthCheckGenerator(serviceInfo),
		filtergen.NewCompressorGenerator(serviceInfo, filtergen.GzipCompressor),
		filtergen.NewCompressorGenerator(serviceInfo, filtergen.BrotliCompressor),
		filtergen.NewJwtAuthnGenerator(serviceInfo),
		filtergen.NewServiceControlGenerator(serviceInfo),
		// grpc-web filter should be before grpc transcoder filter.
		// It converts content-type application/grpc-web to application/grpc and
		// grpc transcoder will bypass requests with application/grpc content type.
		// Otherwise grpc transcoder will try to transcode a grpc-web request which
		// will fail.
		filtergen.NewGRPCWebGenerator(serviceInfo),
		filtergen.NewGRPCTranscoderGenerator(serviceInfo),
		filtergen.NewBackendAuthGenerator(serviceInfo),
		filtergen.NewPathRewriteGenerator(serviceInfo),
		filtergen.NewGRPCMetadataScrubberGenerator(serviceInfo),
		// Add Envoy Router filter so requests are routed upstream.
		// Router filter should be the last.
		&filtergen.RouterGenerator{},
	}, nil
}
",CWE-287,79.0,1
"// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package util
import (
	""fmt""
	""io""
	""github.com/golang/protobuf/jsonpb""
	""github.com/golang/protobuf/proto""
	bapb ""github.com/GoogleCloudPlatform/esp-v2/src/go/proto/api/envoy/v11/http/backend_auth""
	gmspb ""github.com/GoogleCloudPlatform/esp-v2/src/go/proto/api/envoy/v11/http/grpc_metadata_scrubber""
	prpb ""github.com/GoogleCloudPlatform/esp-v2/src/go/proto/api/envoy/v11/http/path_rewrite""
	scpb ""github.com/GoogleCloudPlatform/esp-v2/src/go/proto/api/envoy/v11/http/service_control""
	listenerpb ""github.com/envoyproxy/go-control-plane/envoy/config/listener/v3""
	statspb ""github.com/envoyproxy/go-control-plane/envoy/config/metrics/v3""
	tracepb ""github.com/envoyproxy/go-control-plane/envoy/config/trace/v3""
	accessfilepb ""github.com/envoyproxy/go-control-plane/envoy/extensions/access_loggers/file/v3""
	accessgrpcpb ""github.com/envoyproxy/go-control-plane/envoy/extensions/access_loggers/grpc/v3""
	brpb ""github.com/envoyproxy/go-control-plane/envoy/extensions/compression/brotli/compressor/v3""
	gzippb ""github.com/envoyproxy/go-control-plane/envoy/extensions/compression/gzip/compressor/v3""
	comppb ""github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/compressor/v3""
	corspb ""github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/cors/v3""
	transcoderpb ""github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/grpc_json_transcoder/v3""
	gspb ""github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/grpc_stats/v3""
	grpcwebpb ""github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/grpc_web/v3""
	jwtpb ""github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/jwt_authn/v3""
	routerpb ""github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/router/v3""
	hcmpb ""github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3""
	tlspb ""github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3""
	httppb ""github.com/envoyproxy/go-control-plane/envoy/extensions/upstreams/http/v3""
	wrapperspb ""github.com/golang/protobuf/ptypes/wrappers""
	annotationspb ""google.golang.org/genproto/googleapis/api/annotations""
	confpb ""google.golang.org/genproto/googleapis/api/serviceconfig""
	servicecontrolpb ""google.golang.org/genproto/googleapis/api/servicecontrol/v1""
	smpb ""google.golang.org/genproto/googleapis/api/servicemanagement/v1""
	visibilitypb ""google.golang.org/genproto/googleapis/api/visibility""
)
// Helper to convert Json string to protobuf.Any.
type FuncResolver func(url string) (proto.Message, error)
func (fn FuncResolver) Resolve(url string) (proto.Message, error) {
	return fn(url)
}
var Resolver = FuncResolver(func(url string) (proto.Message, error) {
	switch url {
	case ""type.googleapis.com/google.api.servicemanagement.v1.ConfigFile"":
		return new(smpb.ConfigFile), nil
	case ""type.googleapis.com/google.api.HttpRule"":
		return new(annotationspb.HttpRule), nil
	case ""type.googleapis.com/google.api.VisibilityRule"":
		return new(visibilitypb.VisibilityRule), nil
	case ""type.googleapis.com/google.protobuf.BoolValue"":
		return new(wrapperspb.BoolValue), nil
	case ""type.googleapis.com/google.protobuf.StringValue"":
		return new(wrapperspb.StringValue), nil
	case ""type.googleapis.com/google.protobuf.BytesValue"":
		return new(wrapperspb.BytesValue), nil
	case ""type.googleapis.com/google.protobuf.DoubleValue"":
		return new(wrapperspb.DoubleValue), nil
	case ""type.googleapis.com/google.protobuf.FloatValue"":
		return new(wrapperspb.FloatValue), nil
	case ""type.googleapis.com/google.protobuf.Int64Value"":
		return new(wrapperspb.Int64Value), nil
	case ""type.googleapis.com/google.protobuf.UInt64Value"":
		return new(wrapperspb.UInt64Value), nil
	case ""type.googleapis.com/google.protobuf.Int32Value"":
		return new(wrapperspb.Int32Value), nil
	case ""type.googleapis.com/google.protobuf.UInt32Value"":
		return new(wrapperspb.UInt32Value), nil
	case ""type.googleapis.com/google.api.Service"":
		return new(confpb.Service), nil
	case ""type.googleapis.com/envoy.extensions.filters.http.compressor.v3.Compressor"":
		return new(comppb.Compressor), nil
	case ""type.googleapis.com/envoy.extensions.filters.http.cors.v3.Cors"":
		return new(corspb.Cors), nil
	case ""type.googleapis.com/envoy.extensions.filters.http.grpc_stats.v3.FilterConfig"":
		return new(gspb.FilterConfig), nil
	case ""type.googleapis.com/envoy.extensions.filters.http.grpc_json_transcoder.v3.GrpcJsonTranscoder"":
		return new(transcoderpb.GrpcJsonTranscoder), nil
	case ""type.googleapis.com/envoy.extensions.filters.http.grpc_web.v3.GrpcWeb"":
		return new(grpcwebpb.GrpcWeb), nil
	case ""type.googleapis.com/envoy.extensions.filters.http.jwt_authn.v3.JwtAuthentication"":
		return new(jwtpb.JwtAuthentication), nil
	case ""type.googleapis.com/envoy.extensions.filters.http.jwt_authn.v3.PerRouteConfig"":
		return new(jwtpb.PerRouteConfig), nil
	case ""type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager"":
		return new(hcmpb.HttpConnectionManager), nil
	case ""type.googleapis.com/espv2.api.envoy.v11.http.path_rewrite.FilterConfig"":
		return new(prpb.FilterConfig), nil
	case ""type.googleapis.com/espv2.api.envoy.v11.http.path_rewrite.PerRouteFilterConfig"":
		return new(prpb.PerRouteFilterConfig), nil
	case ""type.googleapis.com/espv2.api.envoy.v11.http.service_control.PerRouteFilterConfig"":
		return new(scpb.PerRouteFilterConfig), nil
	case ""type.googleapis.com/espv2.api.envoy.v11.http.service_control.FilterConfig"":
		return new(scpb.FilterConfig), nil
	case ""type.googleapis.com/espv2.api.envoy.v11.http.backend_auth.PerRouteFilterConfig"":
		return new(bapb.PerRouteFilterConfig), nil
	case ""type.googleapis.com/espv2.api.envoy.v11.http.backend_auth.FilterConfig"":
		return new(bapb.FilterConfig), nil
	case ""type.googleapis.com/espv2.api.envoy.v11.http.grpc_metadata_scrubber.FilterConfig"":
		return new(gmspb.FilterConfig), nil
	case ""type.googleapis.com/envoy.extensions.filters.http.router.v3.Router"":
		return new(routerpb.Router), nil
	case ""type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext"":
		return new(tlspb.UpstreamTlsContext), nil
	case ""type.googleapis.com/envoy.extensions.access_loggers.file.v3.FileAccessLog"":
		return new(accessfilepb.FileAccessLog), nil
	case ""type.googleapis.com/envoy.extensions.access_loggers.grpc.v3.HttpGrpcAccessLogConfig"":
		return new(accessgrpcpb.HttpGrpcAccessLogConfig), nil
	case ""type.googleapis.com/envoy.extensions.access_loggers.grpc.v3.TcpGrpcAccessLogConfig"":
		return new(accessgrpcpb.TcpGrpcAccessLogConfig), nil
	case ""type.googleapis.com/envoy.extensions.access_loggers.grpc.v3.CommonGrpcAccessLogConfig"":
		return new(accessgrpcpb.CommonGrpcAccessLogConfig), nil
	case ""type.googleapis.com/envoy.extensions.compression.brotli.compressor.v3.Brotli"":
		return new(brpb.Brotli), nil
	case ""type.googleapis.com/envoy.extensions.compression.gzip.compressor.v3.Gzip"":
		return new(gzippb.Gzip), nil
	case ""type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions"":
		return new(httppb.HttpProtocolOptions), nil
	case ""type.googleapis.com/envoy.config.listener.v3.Listener"":
		return new(listenerpb.Listener), nil
	case ""type.googleapis.com/envoy.config.metrics.v3.StatsConfig"":
		return new(statspb.StatsConfig), nil
	case ""type.googleapis.com/envoy.config.metrics.v3.StatsSink"":
		return new(statspb.StatsSink), nil
	case ""type.googleapis.com/envoy.config.metrics.v3.StatsdSink"":
		return new(statspb.StatsdSink), nil
	case ""type.googleapis.com/envoy.config.trace.v3.OpenCensusConfig"":
		return new(tracepb.OpenCensusConfig), nil
	default:
		return nil, fmt.Errorf(""unexpected protobuf.Any with url: %s"", url)
	}
})
// UnmarshalBytesToPbMessage converts bytes to corresponding pb message.
var UnmarshalBytesToPbMessage = func(input []byte, output proto.Message) error {
	switch t := output.(type) {
	case *confpb.Service:
		if err := proto.Unmarshal(input, output.(*confpb.Service)); err != nil {
			return fmt.Errorf(""fail to unmarshal %T: %v"", t, err)
		}
	case *smpb.ListServiceRolloutsResponse:
		if err := proto.Unmarshal(input, output.(*smpb.ListServiceRolloutsResponse)); err != nil {
			return fmt.Errorf(""fail to unmarshal %T: %v"", t, err)
		}
	case *servicecontrolpb.ReportResponse:
		if err := proto.Unmarshal(input, output.(*servicecontrolpb.ReportResponse)); err != nil {
			return fmt.Errorf(""fail to unmarshal %T: %v"", t, err)
		}
		return nil
	default:
		return fmt.Errorf(""not support unmarshalling %T"", t)
	}
	return nil
}
// UnmarshalServiceConfig converts service config in JSON to proto
func UnmarshalServiceConfig(config io.Reader) (*confpb.Service, error) {
	unmarshaler := &jsonpb.Unmarshaler{
		AllowUnknownFields: true,
		AnyResolver:        Resolver,
	}
	var serviceConfig confpb.Service
	if err := unmarshaler.Unmarshal(config, &serviceConfig); err != nil {
		return nil, fmt.Errorf(""fail to unmarshal serviceConfig: %s"", err)
	}
	return &serviceConfig, nil
}
func ProtoToJson(msg proto.Message) (string, error) {
	marshaler := &jsonpb.Marshaler{}
	return marshaler.MarshalToString(msg)
}
",CWE-287,192.0,1
"// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package util
import ""fmt""
const (
	// Upstream envoy http filter names.
	// Buffer HTTP filter
	Buffer = ""envoy.filters.http.buffer""
	// CORS HTTP filter
	CORS = ""envoy.filters.http.cors""
	// GRPCJSONTranscoder HTTP filter
	GRPCJSONTranscoder = ""envoy.filters.http.grpc_json_transcoder""
	// GRPCWeb HTTP filter
	GRPCWeb = ""envoy.filters.http.grpc_web""
	// Router HTTP filter
	Router = ""envoy.filters.http.router""
	// Health checking HTTP filter
	HealthCheck = ""envoy.filters.http.health_check""
	// Echo network filter
	Echo = ""envoy.filters.network.echo""
	// HTTPConnectionManager network filter
	HTTPConnectionManager = ""envoy.filters.network.http_connection_manager""
	// JwtAuthn filter.
	JwtAuthn = ""envoy.filters.http.jwt_authn""
	// TLSTransportSocket is Envoy TLS Transport Socket name.
	TLSTransportSocket = ""envoy.transport_sockets.tls""
	// AccessFileLogger filter name
	AccessFileLogger = ""envoy.access_loggers.file""
	// Upstream protocol options
	UpstreamProtocolOptions = ""envoy.extensions.upstreams.http.v3.HttpProtocolOptions""
	// Envoy compressor filter name
	EnvoyCompressorFilter = ""envoy.filters.http.compressor""
	EnvoyBrotliCompressor = ""envoy.compression.brotli.compressor""
	EnvoyGzipCompressor   = ""envoy.compression.gzip.compressor""
	// ESPv2 custom http filters.
	// ServiceControl filter.
	ServiceControl = ""com.google.espv2.filters.http.service_control""
	// PathRewrite filter.
	PathRewrite = ""com.google.espv2.filters.http.path_rewrite""
	// BackendAuth filter.
	BackendAuth = ""com.google.espv2.filters.http.backend_auth""
	// gRPC Metadata Scrubber filter.
	GrpcMetadataScrubber = ""com.google.espv2.filters.http.grpc_metadata_scrubber""
	// The metadata server cluster name.
	MetadataServerClusterName = ""metadata-cluster""
	// The token agent server cluster name.
	TokenAgentClusterName = ""token-agent-cluster""
	// The iam server cluster name.
	IamServerClusterName = ""iam-cluster""
	// The service control server cluster name.
	ServiceControlClusterName = ""service-control-cluster""
	IngressListenerName  = ""ingress_listener""
	LoopbackListenerName = ""loopback_listener""
)
// Jwt provider cluster's name will be in form of ""jwt-provider-cluster-${JWT_PROVIDER_ADDRESS}"".
func JwtProviderClusterName(address string) string {
	return fmt.Sprintf(""jwt-provider-cluster-%s"", address)
}
// Backend cluster'name will be in form of ""backend-cluster-${BACKEND_ADDRESS}""
func BackendClusterName(address string) string {
	return fmt.Sprintf(""backend-cluster-%s"", address)
}
",CWE-287,87.0,1
"/*
Copyright 2022 labring.
Licensed under the Apache License, Version 2.0 (the ""License"");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an ""AS IS"" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package main
import (
	""context""
	""flag""
	""os""
	""k8s.io/apimachinery/pkg/runtime""
	utilruntime ""k8s.io/apimachinery/pkg/util/runtime""
	clientgoscheme ""k8s.io/client-go/kubernetes/scheme""
	""github.com/labring/sealos/controllers/user/controllers/cache""
	// Import all Kubernetes client auth plugins (e.g. Azure, GCP, OIDC, etc.)
	// to ensure that exec-entrypoint and run can make use of them.
	_ ""k8s.io/client-go/plugin/pkg/client/auth""
	ctrl ""sigs.k8s.io/controller-runtime""
	""sigs.k8s.io/controller-runtime/pkg/healthz""
	""sigs.k8s.io/controller-runtime/pkg/log/zap""
	userv1 ""github.com/labring/sealos/controllers/user/api/v1""
	""github.com/labring/sealos/controllers/user/controllers""
	//+kubebuilder:scaffold:imports
)
var (
	scheme   = runtime.NewScheme()
	setupLog = ctrl.Log.WithName(""setup"")
)
func init() {
	utilruntime.Must(clientgoscheme.AddToScheme(scheme))
	utilruntime.Must(userv1.AddToScheme(scheme))
	//+kubebuilder:scaffold:scheme
}
func main() {
	var metricsAddr string
	var enableLeaderElection bool
	var probeAddr string
	flag.StringVar(&metricsAddr, ""metrics-bind-address"", "":8080"", ""The address the metric endpoint binds to."")
	flag.StringVar(&probeAddr, ""health-probe-bind-address"", "":8081"", ""The address the probe endpoint binds to."")
	flag.BoolVar(&enableLeaderElection, ""leader-elect"", false,
		""Enable leader election for controller manager. ""+
			""Enabling this will ensure there is only one active controller manager."")
	opts := zap.Options{
		Development: true,
	}
	opts.BindFlags(flag.CommandLine)
	flag.Parse()
	ctrl.SetLogger(zap.New(zap.UseFlagOptions(&opts)))
	mgr, err := ctrl.NewManager(ctrl.GetConfigOrDie(), ctrl.Options{
		Scheme:                 scheme,
		MetricsBindAddress:     metricsAddr,
		Port:                   9443,
		HealthProbeBindAddress: probeAddr,
		LeaderElection:         enableLeaderElection,
		LeaderElectionID:       ""785548a1.sealos.io"",
		// LeaderElectionReleaseOnCancel defines if the leader should step down voluntarily
		// when the Manager ends. This requires the binary to immediately end when the
		// Manager is stopped, otherwise, this setting is unsafe. Setting this significantly
		// speeds up voluntary leader transitions as the new leader don't have to wait
		// LeaseDuration time first.
		//
		// In the default scaffold provided, the program ends immediately after
		// the manager stops, so would be fine to enable this option. However,
		// if you are doing or is intended to do any operation such as perform cleanups
		// after the manager stops then its usage might be unsafe.
		// LeaderElectionReleaseOnCancel: true,
	})
	if err != nil {
		setupLog.Error(err, ""unable to start manager"")
		os.Exit(1)
	}
	if err = (&controllers.UserReconciler{}).SetupWithManager(mgr); err != nil {
		setupLog.Error(err, ""unable to create controller"", ""controller"", ""User"")
		os.Exit(1)
	}
	if err = (&controllers.UserGroupReconciler{}).SetupWithManager(mgr); err != nil {
		setupLog.Error(err, ""unable to create controller"", ""controller"", ""UserGroup"")
		os.Exit(1)
	}
	if err = (&controllers.UserGroupBindingReconciler{
		Client: mgr.GetClient(),
		Scheme: mgr.GetScheme(),
	}).SetupWithManager(mgr); err != nil {
		setupLog.Error(err, ""unable to create controller"", ""controller"", ""UserGroupBinding"")
		os.Exit(1)
	}
	//if err = (&controllers.UserExpirationReconciler{
	//	Client: mgr.GetClient(),
	//	Scheme: mgr.GetScheme(),
	//}).SetupWithManager(mgr); err != nil {
	//	setupLog.Error(err, ""unable to create controller"", ""controller"", ""Secret"")
	//	os.Exit(1)
	//}
	if err = cache.SetupCache(mgr); err != nil {
		setupLog.Error(err, ""unable to cache controller"")
		os.Exit(1)
	}
	if os.Getenv(""DISABLE_WEBHOOKS"") == ""true"" {
		setupLog.Info(""disable all webhooks"")
	} else {
		if err = (&userv1.User{}).SetupWebhookWithManager(mgr); err != nil {
			setupLog.Error(err, ""unable to create webhook"", ""webhook"", ""User"")
			os.Exit(1)
		}
		setupLog.Info(""add ug and ugb webhooks"")
		if err = (&userv1.UserGroup{}).SetupWebhookWithManager(mgr); err != nil {
			setupLog.Error(err, ""unable to create webhook"", ""webhook"", ""UserGroup"")
			os.Exit(1)
		}
		if err = (&userv1.UserGroupBinding{}).SetupWebhookWithManager(mgr); err != nil {
			setupLog.Error(err, ""unable to create webhook"", ""webhook"", ""UserGroupBinding"")
			os.Exit(1)
		}
	}
	//+kubebuilder:scaffold:builder
	if err := mgr.AddHealthzCheck(""healthz"", healthz.Ping); err != nil {
		setupLog.Error(err, ""unable to set up health check"")
		os.Exit(1)
	}
	if err := mgr.AddReadyzCheck(""readyz"", healthz.Ping); err != nil {
		setupLog.Error(err, ""unable to set up ready check"")
		os.Exit(1)
	}
	ctx, cancel := context.WithCancel(context.TODO())
	defer cancel()
	setupLog.Info(""starting manager"")
	if err = mgr.Start(ctx); err != nil {
		setupLog.Error(err, ""failed to running manager"")
		os.Exit(1)
	}
}
",CWE-863,159.0,1
"package main
import (
	""testing""
	""github.com/notaryproject/notation/internal/cmd""
)
func TestInspectCommand_SecretsFromArgs(t *testing.T) {
	opts := &inspectOpts{}
	command := inspectCommand(opts)
	expected := &inspectOpts{
		reference: ""ref"",
		SecureFlagOpts: SecureFlagOpts{
			Password:         ""password"",
			InsecureRegistry: true,
			Username:         ""user"",
		},
		outputFormat: cmd.OutputPlaintext,
	}
	if err := command.ParseFlags([]string{
		""--password"", expected.Password,
		expected.reference,
		""-u"", expected.Username,
		""--insecure-registry"",
		""--output"", ""text""}); err != nil {
		t.Fatalf(""Parse Flag failed: %v"", err)
	}
	if err := command.Args(command, command.Flags().Args()); err != nil {
		t.Fatalf(""Parse Args failed: %v"", err)
	}
	if *opts != *expected {
		t.Fatalf(""Expect inspect opts: %v, got: %v"", expected, opts)
	}
}
func TestInspectCommand_SecretsFromEnv(t *testing.T) {
	t.Setenv(defaultUsernameEnv, ""user"")
	t.Setenv(defaultPasswordEnv, ""password"")
	opts := &inspectOpts{}
	expected := &inspectOpts{
		reference: ""ref"",
		SecureFlagOpts: SecureFlagOpts{
			Password: ""password"",
			Username: ""user"",
		},
		outputFormat: cmd.OutputJSON,
	}
	command := inspectCommand(opts)
	if err := command.ParseFlags([]string{
		expected.reference,
		""--output"", ""json""}); err != nil {
		t.Fatalf(""Parse Flag failed: %v"", err)
	}
	if err := command.Args(command, command.Flags().Args()); err != nil {
		t.Fatalf(""Parse Args failed: %v"", err)
	}
	if *opts != *expected {
		t.Fatalf(""Expect inspect opts: %v, got: %v"", expected, opts)
	}
}
func TestInspectCommand_MissingArgs(t *testing.T) {
	command := inspectCommand(nil)
	if err := command.ParseFlags(nil); err != nil {
		t.Fatalf(""Parse Flag failed: %v"", err)
	}
	if err := command.Args(command, command.Flags().Args()); err == nil {
		t.Fatal(""Parse Args expected error, but ok"")
	}
}
",CWE-400,72.0,1
"package errors
// ErrorReferrersAPINotSupported is used when the target registry does not
// support the Referrers API
type ErrorReferrersAPINotSupported struct {
	Msg string
}
func (e ErrorReferrersAPINotSupported) Error() string {
	if e.Msg != """" {
		return e.Msg
	}
	return ""referrers API not supported""
}
// ErrorOCILayoutMissingReference is used when signing local content in oci
// layout folder but missing input tag or digest.
type ErrorOCILayoutMissingReference struct {
	Msg string
}
func (e ErrorOCILayoutMissingReference) Error() string {
	if e.Msg != """" {
		return e.Msg
	}
	return ""reference is missing either digest or tag""
}
",CWE-400,28.0,1
"package main
import (
	""context""
	""errors""
	""fmt""
	notationregistry ""github.com/notaryproject/notation-go/registry""
	""github.com/notaryproject/notation/cmd/notation/internal/experimental""
	""github.com/notaryproject/notation/internal/cmd""
	""github.com/opencontainers/go-digest""
	ocispec ""github.com/opencontainers/image-spec/specs-go/v1""
	""github.com/spf13/cobra""
)
type listOpts struct {
	cmd.LoggingFlagOpts
	SecureFlagOpts
	reference         string
	allowReferrersAPI bool
	ociLayout         bool
	inputType         inputType
}
func listCommand(opts *listOpts) *cobra.Command {
	if opts == nil {
		opts = &listOpts{
			inputType: inputTypeRegistry, // remote registry by default
		}
	}
	command := &cobra.Command{
		Use:     ""list [flags] <reference>"",
		Aliases: []string{""ls""},
		Short:   ""List signatures of the signed artifact"",
		Long:    ""List all the signatures associated with signed artifact"",
		Args: func(cmd *cobra.Command, args []string) error {
			if len(args) == 0 {
				return errors.New(""no reference specified"")
			}
			opts.reference = args[0]
			return nil
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if opts.ociLayout {
				opts.inputType = inputTypeOCILayout
			}
			return experimental.CheckFlagsAndWarn(cmd, ""allow-referrers-api"", ""oci-layout"")
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return runList(cmd.Context(), opts)
		},
	}
	opts.LoggingFlagOpts.ApplyFlags(command.Flags())
	opts.SecureFlagOpts.ApplyFlags(command.Flags())
	cmd.SetPflagReferrersAPI(command.Flags(), &opts.allowReferrersAPI, fmt.Sprintf(cmd.PflagReferrersUsageFormat, ""list""))
	command.Flags().BoolVar(&opts.ociLayout, ""oci-layout"", false, ""[Experimental] list signatures stored in OCI image layout"")
	experimental.HideFlags(command, """", []string{""allow-referrers-api"", ""oci-layout""})
	return command
}
func runList(ctx context.Context, opts *listOpts) error {
	// set log level
	ctx = opts.LoggingFlagOpts.SetLoggerLevel(ctx)
	// initialize
	reference := opts.reference
	sigRepo, err := getRepository(ctx, opts.inputType, reference, &opts.SecureFlagOpts, opts.allowReferrersAPI)
	if err != nil {
		return err
	}
	targetDesc, resolvedRef, err := resolveReferenceWithWarning(ctx, opts.inputType, reference, sigRepo, ""list"")
	if err != nil {
		return err
	}
	// print all signature manifest digests
	return printSignatureManifestDigests(ctx, targetDesc, sigRepo, resolvedRef)
}
// printSignatureManifestDigests returns the signature manifest digests of
// the subject manifest.
func printSignatureManifestDigests(ctx context.Context, targetDesc ocispec.Descriptor, sigRepo notationregistry.Repository, ref string) error {
	titlePrinted := false
	printTitle := func() {
		if !titlePrinted {
			fmt.Println(ref)
			fmt.Printf(""└── %s\n"", notationregistry.ArtifactTypeNotation)
			titlePrinted = true
		}
	}
	var prevDigest digest.Digest
	err := sigRepo.ListSignatures(ctx, targetDesc, func(signatureManifests []ocispec.Descriptor) error {
		for _, sigManifestDesc := range signatureManifests {
			if prevDigest != """" {
				// check and print title
				printTitle()
				// print each signature digest
				fmt.Printf(""    ├── %s\n"", prevDigest)
			}
			prevDigest = sigManifestDesc.Digest
		}
		return nil
	})
	if err != nil {
		return err
	}
	if prevDigest != """" {
		// check and print title
		printTitle()
		// print last signature digest
		fmt.Printf(""    └── %s\n"", prevDigest)
	}
	if !titlePrinted {
		fmt.Printf(""%s has no associated signature\n"", ref)
	}
	return nil
}
",CWE-400,123.0,1
"package main
import (
	""testing""
)
func TestListCommand_SecretsFromArgs(t *testing.T) {
	opts := &listOpts{}
	cmd := listCommand(opts)
	expected := &listOpts{
		reference: ""ref"",
		SecureFlagOpts: SecureFlagOpts{
			Password:         ""password"",
			InsecureRegistry: true,
			Username:         ""user"",
		},
	}
	if err := cmd.ParseFlags([]string{
		""--password"", expected.Password,
		expected.reference,
		""-u"", expected.Username,
		""--insecure-registry""}); err != nil {
		t.Fatalf(""Parse Flag failed: %v"", err)
	}
	if err := cmd.Args(cmd, cmd.Flags().Args()); err != nil {
		t.Fatalf(""Parse Args failed: %v"", err)
	}
	if *opts != *expected {
		t.Fatalf(""Expect list opts: %v, got: %v"", expected, opts)
	}
}
func TestListCommand_SecretsFromEnv(t *testing.T) {
	t.Setenv(defaultUsernameEnv, ""user"")
	t.Setenv(defaultPasswordEnv, ""password"")
	opts := &listOpts{}
	expected := &listOpts{
		reference: ""ref"",
		SecureFlagOpts: SecureFlagOpts{
			Password: ""password"",
			Username: ""user"",
		},
	}
	cmd := listCommand(opts)
	if err := cmd.ParseFlags([]string{
		expected.reference}); err != nil {
		t.Fatalf(""Parse Flag failed: %v"", err)
	}
	if err := cmd.Args(cmd, cmd.Flags().Args()); err != nil {
		t.Fatalf(""Parse Args failed: %v"", err)
	}
	if *opts != *expected {
		t.Fatalf(""Expect list opts: %v, got: %v"", expected, opts)
	}
}
func TestListCommand_MissingArgs(t *testing.T) {
	cmd := listCommand(nil)
	if err := cmd.ParseFlags(nil); err != nil {
		t.Fatalf(""Parse Flag failed: %v"", err)
	}
	if err := cmd.Args(cmd, cmd.Flags().Args()); err == nil {
		t.Fatal(""Parse Args expected error, but ok"")
	}
}
",CWE-400,66.0,1
"package main
import (
	""errors""
	""fmt""
	""math""
	""os""
	""reflect""
	""github.com/notaryproject/notation-go""
	""github.com/notaryproject/notation-go/verifier""
	""github.com/notaryproject/notation-go/verifier/trustpolicy""
	""github.com/notaryproject/notation/cmd/notation/internal/experimental""
	""github.com/notaryproject/notation/internal/cmd""
	""github.com/notaryproject/notation/internal/ioutil""
	""github.com/spf13/cobra""
)
const maxSignatureAttempts = math.MaxInt64
type verifyOpts struct {
	cmd.LoggingFlagOpts
	SecureFlagOpts
	reference         string
	pluginConfig      []string
	userMetadata      []string
	allowReferrersAPI bool
	ociLayout         bool
	trustPolicyScope  string
	inputType         inputType
}
func verifyCommand(opts *verifyOpts) *cobra.Command {
	if opts == nil {
		opts = &verifyOpts{
			inputType: inputTypeRegistry, // remote registry by default
		}
	}
	longMessage := `Verify OCI artifacts
Prerequisite: added a certificate into trust store and created a trust policy.
Example - Verify a signature on an OCI artifact identified by a digest:
  notation verify <registry>/<repository>@<digest>
Example - Verify a signature on an OCI artifact identified by a tag  (Notation will resolve tag to digest):
  notation verify <registry>/<repository>:<tag>
`
	experimentalExamples := `
Example - [Experimental] Verify an OCI artifact using the Referrers API, if not supported (returns 404), fallback to the Referrers tag schema
  notation verify --allow-referrers-api <registry>/<repository>@<digest>
Example - [Experimental] Verify a signature on an OCI artifact referenced in an OCI layout using trust policy statement specified by scope.
  notation verify --oci-layout <registry>/<repository>@<digest> --scope <trust_policy_scope>
Example - [Experimental] Verify a signature on an OCI artifact identified by a tag and referenced in an OCI layout using trust policy statement specified by scope.
  notation verify --oci-layout <registry>/<repository>:<tag> --scope <trust_policy_scope>
`
	command := &cobra.Command{
		Use:   ""verify [reference]"",
		Short: ""Verify OCI artifacts"",
		Long:  longMessage,
		Args: func(cmd *cobra.Command, args []string) error {
			if len(args) == 0 {
				return errors.New(""missing reference"")
			}
			opts.reference = args[0]
			return nil
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if opts.ociLayout {
				opts.inputType = inputTypeOCILayout
			}
			return experimental.CheckFlagsAndWarn(cmd, ""allow-referrers-api"", ""oci-layout"", ""scope"")
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return runVerify(cmd, opts)
		},
	}
	opts.LoggingFlagOpts.ApplyFlags(command.Flags())
	opts.SecureFlagOpts.ApplyFlags(command.Flags())
	command.Flags().StringArrayVar(&opts.pluginConfig, ""plugin-config"", nil, ""{key}={value} pairs that are passed as it is to a plugin, if the verification is associated with a verification plugin, refer plugin documentation to set appropriate values"")
	cmd.SetPflagUserMetadata(command.Flags(), &opts.userMetadata, cmd.PflagUserMetadataVerifyUsage)
	cmd.SetPflagReferrersAPI(command.Flags(), &opts.allowReferrersAPI, fmt.Sprintf(cmd.PflagReferrersUsageFormat, ""verify""))
	command.Flags().BoolVar(&opts.ociLayout, ""oci-layout"", false, ""[Experimental] verify the artifact stored as OCI image layout"")
	command.Flags().StringVar(&opts.trustPolicyScope, ""scope"", """", ""[Experimental] set trust policy scope for artifact verification, required and can only be used when flag \""--oci-layout\"" is set"")
	command.MarkFlagsRequiredTogether(""oci-layout"", ""scope"")
	experimental.HideFlags(command, experimentalExamples, []string{""allow-referrers-api"", ""oci-layout"", ""scope""})
	return command
}
func runVerify(command *cobra.Command, opts *verifyOpts) error {
	// set log level
	ctx := opts.LoggingFlagOpts.SetLoggerLevel(command.Context())
	// initialize
	sigVerifier, err := verifier.NewFromConfig()
	if err != nil {
		return err
	}
	// set up verification plugin config.
	configs, err := cmd.ParseFlagMap(opts.pluginConfig, cmd.PflagPluginConfig.Name)
	if err != nil {
		return err
	}
	// set up user metadata
	userMetadata, err := cmd.ParseFlagMap(opts.userMetadata, cmd.PflagUserMetadata.Name)
	if err != nil {
		return err
	}
	// core verify process
	reference := opts.reference
	sigRepo, err := getRepository(ctx, opts.inputType, reference, &opts.SecureFlagOpts, opts.allowReferrersAPI)
	if err != nil {
		return err
	}
	// resolve the given reference and set the digest
	_, resolvedRef, err := resolveReferenceWithWarning(ctx, opts.inputType, reference, sigRepo, ""verify"")
	if err != nil {
		return err
	}
	intendedRef := resolveArtifactDigestReference(resolvedRef, opts.trustPolicyScope)
	verifyOpts := notation.VerifyOptions{
		ArtifactReference: intendedRef,
		PluginConfig:      configs,
		// TODO: need to change MaxSignatureAttempts as a user input flag or
		// a field in config.json
		MaxSignatureAttempts: maxSignatureAttempts,
		UserMetadata:         userMetadata,
	}
	_, outcomes, err := notation.Verify(ctx, sigVerifier, sigRepo, verifyOpts)
	err = checkVerificationFailure(outcomes, resolvedRef, err)
	if err != nil {
		return err
	}
	reportVerificationSuccess(outcomes, resolvedRef)
	return nil
}
func checkVerificationFailure(outcomes []*notation.VerificationOutcome, printOut string, err error) error {
	// write out on failure
	if err != nil || len(outcomes) == 0 {
		if err != nil {
			var errorVerificationFailed notation.ErrorVerificationFailed
			if !errors.As(err, &errorVerificationFailed) {
				return fmt.Errorf(""signature verification failed: %w"", err)
			}
		}
		return fmt.Errorf(""signature verification failed for all the signatures associated with %s"", printOut)
	}
	return nil
}
func reportVerificationSuccess(outcomes []*notation.VerificationOutcome, printout string) {
	// write out on success
	outcome := outcomes[0]
	// print out warning for any failed result with logged verification action
	for _, result := range outcome.VerificationResults {
		if result.Error != nil {
			// at this point, the verification action has to be logged and
			// it's failed
			fmt.Fprintf(os.Stderr, ""Warning: %v was set to %q and failed with error: %v\n"", result.Type, result.Action, result.Error)
		}
	}
	if reflect.DeepEqual(outcome.VerificationLevel, trustpolicy.LevelSkip) {
		fmt.Println(""Trust policy is configured to skip signature verification for"", printout)
	} else {
		fmt.Println(""Successfully verified signature for"", printout)
		printMetadataIfPresent(outcome)
	}
}
func printMetadataIfPresent(outcome *notation.VerificationOutcome) {
	// the signature envelope is parsed as part of verification.
	// since user metadata is only printed on successful verification,
	// this error can be ignored
	metadata, _ := outcome.UserMetadata()
	if len(metadata) > 0 {
		fmt.Println(""\nThe artifact was signed with the following user metadata."")
		ioutil.PrintMetadataMap(os.Stdout, metadata)
	}
}
",CWE-400,187.0,1
"package main
import (
	""reflect""
	""testing""
)
func TestVerifyCommand_BasicArgs(t *testing.T) {
	opts := &verifyOpts{}
	command := verifyCommand(opts)
	expected := &verifyOpts{
		reference: ""ref"",
		SecureFlagOpts: SecureFlagOpts{
			Username: ""user"",
			Password: ""password"",
		},
		pluginConfig: []string{""key1=val1""},
	}
	if err := command.ParseFlags([]string{
		expected.reference,
		""--username"", expected.Username,
		""--password"", expected.Password,
		""--plugin-config"", ""key1=val1""}); err != nil {
		t.Fatalf(""Parse Flag failed: %v"", err)
	}
	if err := command.Args(command, command.Flags().Args()); err != nil {
		t.Fatalf(""Parse args failed: %v"", err)
	}
	if !reflect.DeepEqual(*expected, *opts) {
		t.Fatalf(""Expect verify opts: %v, got: %v"", expected, opts)
	}
}
func TestVerifyCommand_MoreArgs(t *testing.T) {
	opts := &verifyOpts{}
	command := verifyCommand(opts)
	expected := &verifyOpts{
		reference: ""ref"",
		SecureFlagOpts: SecureFlagOpts{
			InsecureRegistry: true,
		},
		pluginConfig: []string{""key1=val1"", ""key2=val2""},
	}
	if err := command.ParseFlags([]string{
		expected.reference,
		""--insecure-registry"",
		""--plugin-config"", ""key1=val1"",
		""--plugin-config"", ""key2=val2""}); err != nil {
		t.Fatalf(""Parse Flag failed: %v"", err)
	}
	if err := command.Args(command, command.Flags().Args()); err != nil {
		t.Fatalf(""Parse args failed: %v"", err)
	}
	if !reflect.DeepEqual(*expected, *opts) {
		t.Fatalf(""Expect verify opts: %v, got: %v"", expected, opts)
	}
}
func TestVerifyCommand_MissingArgs(t *testing.T) {
	cmd := verifyCommand(nil)
	if err := cmd.ParseFlags(nil); err != nil {
		t.Fatalf(""Parse Flag failed: %v"", err)
	}
	if err := cmd.Args(cmd, cmd.Flags().Args()); err == nil {
		t.Fatal(""Parse Args expected error, but ok"")
	}
}
",CWE-400,68.0,1
"/*
 * Copyright (c) 2022, MegaEase
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Package mysql is the client probe for MySQL.
package mysql
import (
	""crypto/tls""
	""database/sql""
	""fmt""
	""strconv""
	""strings""
	""time""
	""github.com/go-sql-driver/mysql""
	""github.com/megaease/easeprobe/global""
	""github.com/megaease/easeprobe/probe/client/conf""
	log ""github.com/sirupsen/logrus""
)
// Kind is the type of driver
const Kind string = ""MySQL""
// MySQL is the MySQL client
type MySQL struct {
	conf.Options `yaml:"",inline""`
	tls          *tls.Config `yaml:""-"" json:""-""`
	ConnStr      string      `yaml:""conn_str,omitempty"" json:""conn_str,omitempty""`
}
// New create a Mysql client
func New(opt conf.Options) (*MySQL, error) {
	var conn string
	if len(opt.Password) > 0 {
		conn = fmt.Sprintf(""%s:%s@tcp(%s)/?timeout=%s"",
			opt.Username, opt.Password, opt.Host, opt.Timeout().Round(time.Second))
	} else {
		conn = fmt.Sprintf(""%s@tcp(%s)/?timeout=%s"",
			opt.Username, opt.Host, opt.Timeout().Round(time.Second))
	}
	tls, err := opt.TLS.Config()
	if err != nil {
		log.Errorf(""[%s / %s / %s] - TLS Config Error - %v"", opt.ProbeKind, opt.ProbeName, opt.ProbeTag, err)
		return nil, fmt.Errorf(""TLS Config Error - %v"", err)
	} else if tls != nil {
		conn += ""&tls="" + global.DefaultProg
	}
	m := &MySQL{
		Options: opt,
		tls:     tls,
		ConnStr: conn,
	}
	if err := m.checkData(); err != nil {
		return nil, err
	}
	return m, nil
}
// Kind return the name of client
func (r *MySQL) Kind() string {
	return Kind
}
// checkData do the data checking
func (r *MySQL) checkData() error {
	for k := range r.Data {
		if _, err := r.getSQL(k); err != nil {
			return err
		}
	}
	return nil
}
// Probe do the health check
func (r *MySQL) Probe() (bool, string) {
	if r.tls != nil {
		mysql.RegisterTLSConfig(global.DefaultProg, r.tls)
	}
	db, err := sql.Open(""mysql"", r.ConnStr)
	if err != nil {
		return false, err.Error()
	}
	defer db.Close()
	// Check if we need to query specific data
	if len(r.Data) > 0 {
		for k, v := range r.Data {
			log.Debugf(""[%s / %s / %s] - Verifying Data - [%s] : [%s]"", r.ProbeKind, r.ProbeName, r.ProbeTag, k, v)
			sql, err := r.getSQL(k)
			if err != nil {
				return false, err.Error()
			}
			log.Debugf(""[%s / %s / %s] - SQL - [%s]"", r.ProbeKind, r.ProbeName, r.ProbeTag, sql)
			rows, err := db.Query(sql)
			if err != nil {
				return false, err.Error()
			}
			if !rows.Next() {
				rows.Close()
				return false, fmt.Sprintf(""No data found for [%s]"", k)
			}
			//check the value is equal to the value in data
			var value string
			if err := rows.Scan(&value); err != nil {
				rows.Close()
				return false, err.Error()
			}
			if value != v {
				rows.Close()
				return false, fmt.Sprintf(""Value not match for [%s] expected [%s] got [%s] "", k, v, value)
			}
			rows.Close()
			log.Debugf(""[%s / %s / %s] - Data Verified Successfully! - [%s] : [%s]"", r.ProbeKind, r.ProbeName, r.ProbeTag, k, v)
		}
	} else {
		err = db.Ping()
		if err != nil {
			return false, err.Error()
		}
		row, err := db.Query(""show status like \""uptime\"""") // run a SQL to test
		if err != nil {
			return false, err.Error()
		}
		defer row.Close()
	}
	return true, ""Check MySQL Server Successfully!""
}
// getSQL get the SQL statement
// input: database:table:column:key:value
// output: SELECT column FROM database.table WHERE key = value
func (r *MySQL) getSQL(str string) (string, error) {
	if len(strings.TrimSpace(str)) == 0 {
		return """", fmt.Errorf(""Empty SQL data"")
	}
	fields := strings.Split(str, "":"")
	if len(fields) != 5 {
		return """", fmt.Errorf(""Invalid SQL data - [%s]. (syntax: database:table:field:key:value)"", str)
	}
	db := fields[0]
	table := fields[1]
	field := fields[2]
	key := fields[3]
	value := fields[4]
	//check value is int or not
	if _, err := strconv.Atoi(value); err != nil {
		return """", fmt.Errorf(""Invalid SQL data - [%s], the value must be int"", str)
	}
	sql := fmt.Sprintf(""SELECT %s FROM %s.%s WHERE %s = %s"", field, db, table, key, value)
	return sql, nil
}
",CWE-89,177.0,1
"package runner
import (
	""context""
	""errors""
	""fmt""
	""github.com/hashicorp/terraform-exec/tfexec""
	""google.golang.org/grpc/codes""
	""google.golang.org/grpc/status""
	""sigs.k8s.io/controller-runtime""
)
func (r *TerraformRunnerServer) Plan(ctx context.Context, req *PlanRequest) (*PlanReply, error) {
	log := controllerruntime.LoggerFrom(ctx, ""instance-id"", r.InstanceID).WithName(loggerName)
	log.Info(""creating a plan"")
	ctx, cancel := context.WithCancel(ctx)
	go func() {
		select {
		case <-r.Done:
			cancel()
		case <-ctx.Done():
		}
	}()
	if req.TfInstance != r.InstanceID {
		err := fmt.Errorf(""no TF instance found"")
		log.Error(err, ""no terraform"")
		return nil, err
	}
	var planOpt []tfexec.PlanOption
	if req.Out != """" {
		planOpt = append(planOpt, tfexec.Out(req.Out))
	} else {
		// if backend is disabled completely, there will be no plan output file (req.Out = """")
		log.Info(""backend seems to be disabled completely, so there will be no plan output file"")
	}
	if req.Refresh == false {
		planOpt = append(planOpt, tfexec.Refresh(req.Refresh))
	}
	if req.Destroy {
		planOpt = append(planOpt, tfexec.Destroy(req.Destroy))
	}
	for _, target := range req.Targets {
		planOpt = append(planOpt, tfexec.Target(target))
	}
	drifted, err := r.tf.Plan(ctx, planOpt...)
	if err != nil {
		st := status.New(codes.Internal, err.Error())
		var stateErr *tfexec.ErrStateLocked
		if errors.As(err, &stateErr) {
			st, err = st.WithDetails(&PlanReply{Message: ""not ok"", StateLockIdentifier: stateErr.ID})
			if err != nil {
				return nil, err
			}
		}
		log.Error(err, ""error creating the plan"")
		return nil, st.Err()
	}
	planCreated := false
	if req.Out != """" {
		planCreated = true
		plan, err := r.tf.ShowPlanFile(ctx, req.Out)
		if err != nil {
			return nil, err
		}
		// This is the case when the plan is empty.
		if plan.PlannedValues.Outputs == nil &&
			plan.PlannedValues.RootModule.Resources == nil &&
			plan.ResourceChanges == nil &&
			plan.PriorState == nil &&
			plan.OutputChanges == nil {
			planCreated = false
		}
	}
	return &PlanReply{Message: ""ok"", Drifted: drifted, PlanCreated: planCreated}, nil
}
",CWE-200,88.0,1
"package runner
import (
	""context""
	""encoding/json""
	""fmt""
	""sigs.k8s.io/controller-runtime""
)
func (r *TerraformRunnerServer) ShowPlanFileRaw(ctx context.Context, req *ShowPlanFileRawRequest) (*ShowPlanFileRawReply, error) {
	log := controllerruntime.LoggerFrom(ctx, ""instance-id"", r.InstanceID).WithName(loggerName)
	log.Info(""show the raw plan file"")
	if req.TfInstance != r.InstanceID {
		err := fmt.Errorf(""no TF instance found"")
		log.Error(err, ""no terraform"")
		return nil, err
	}
	rawOutput, err := r.tf.ShowPlanFileRaw(ctx, req.Filename)
	if err != nil {
		log.Error(err, ""unable to get the raw plan output"")
		return nil, err
	}
	return &ShowPlanFileRawReply{RawOutput: rawOutput}, nil
}
func (r *TerraformRunnerServer) ShowPlanFile(ctx context.Context, req *ShowPlanFileRequest) (*ShowPlanFileReply, error) {
	log := controllerruntime.LoggerFrom(ctx, ""instance-id"", r.InstanceID).WithName(loggerName)
	log.Info(""show the raw plan file"")
	if req.TfInstance != r.InstanceID {
		err := fmt.Errorf(""no TF instance found"")
		log.Error(err, ""no terraform"")
		return nil, err
	}
	plan, err := r.tf.ShowPlanFile(ctx, req.Filename)
	if err != nil {
		log.Error(err, ""unable to get the json plan output"")
		return nil, err
	}
	jsonBytes, err := json.Marshal(plan)
	if err != nil {
		log.Error(err, ""unable to marshal the plan to json"")
		return nil, err
	}
	return &ShowPlanFileReply{JsonOutput: jsonBytes}, nil
}
",CWE-200,51.0,1
"package runner
import (
	""context""
	""fmt""
	""reflect""
	infrav1 ""github.com/weaveworks/tf-controller/api/v1alpha2""
	corev1 ""k8s.io/api/core/v1""
	apierrors ""k8s.io/apimachinery/pkg/api/errors""
	metav1 ""k8s.io/apimachinery/pkg/apis/meta/v1""
	""k8s.io/apimachinery/pkg/types""
	ctrl ""sigs.k8s.io/controller-runtime""
)
func (r *TerraformRunnerServer) Output(ctx context.Context, req *OutputRequest) (*OutputReply, error) {
	log := ctrl.LoggerFrom(ctx, ""instance-id"", r.InstanceID).WithName(loggerName)
	log.Info(""creating outputs"")
	if req.TfInstance != r.InstanceID {
		err := fmt.Errorf(""no TF instance found"")
		log.Error(err, ""no terraform"")
		return nil, err
	}
	outputs, err := r.tf.Output(ctx)
	if err != nil {
		log.Error(err, ""unable to get outputs"")
		return nil, err
	}
	outputReply := &OutputReply{Outputs: map[string]*OutputMeta{}}
	for k, v := range outputs {
		outputReply.Outputs[k] = &OutputMeta{
			Sensitive: v.Sensitive,
			Type:      v.Type,
			Value:     v.Value,
		}
	}
	return outputReply, nil
}
func (r *TerraformRunnerServer) WriteOutputs(ctx context.Context, req *WriteOutputsRequest) (*WriteOutputsReply, error) {
	log := ctrl.LoggerFrom(ctx, ""instance-id"", r.InstanceID).WithName(loggerName)
	log.Info(""write outputs to secret"")
	objectKey := types.NamespacedName{Namespace: req.Namespace, Name: req.SecretName}
	var outputSecret corev1.Secret
	drift := true
	create := true
	if err := r.Client.Get(ctx, objectKey, &outputSecret); err == nil {
		// if everything is there, we don't write anything
		if reflect.DeepEqual(outputSecret.Data, req.Data) {
			drift = false
		} else {
			// found, but need update
			create = false
		}
	} else if apierrors.IsNotFound(err) == false {
		log.Error(err, ""unable to get output secret"")
		return nil, err
	}
	if drift {
		if create {
			vTrue := true
			outputSecret = corev1.Secret{
				ObjectMeta: metav1.ObjectMeta{
					Name:        req.SecretName,
					Namespace:   req.Namespace,
					Labels:      req.Labels,
					Annotations: req.Annotations,
					OwnerReferences: []metav1.OwnerReference{
						{
							APIVersion: infrav1.GroupVersion.Group + ""/"" + infrav1.GroupVersion.Version,
							Kind:       infrav1.TerraformKind,
							Name:       req.Name,
							UID:        types.UID(req.Uuid),
							Controller: &vTrue,
						},
					},
				},
				Type: corev1.SecretTypeOpaque,
				Data: req.Data,
			}
			err := r.Client.Create(ctx, &outputSecret)
			if err != nil {
				log.Error(err, ""unable to create secret"")
				return nil, err
			}
		} else {
			outputSecret.Data = req.Data
			err := r.Client.Update(ctx, &outputSecret)
			if err != nil {
				log.Error(err, ""unable to update secret"")
				return nil, err
			}
		}
		return &WriteOutputsReply{Message: ""ok"", Changed: true}, nil
	}
	return &WriteOutputsReply{Message: ""ok"", Changed: false}, nil
}
func (r *TerraformRunnerServer) GetOutputs(ctx context.Context, req *GetOutputsRequest) (*GetOutputsReply, error) {
	log := ctrl.LoggerFrom(ctx, ""instance-id"", r.InstanceID).WithName(loggerName)
	log.Info(""get outputs"")
	outputKey := types.NamespacedName{Namespace: req.Namespace, Name: req.SecretName}
	outputSecret := corev1.Secret{}
	err := r.Client.Get(ctx, outputKey, &outputSecret)
	if err != nil {
		err = fmt.Errorf(""error getting terraform output for health checks: %s"", err)
		log.Error(err, ""unable to check terraform health"")
		return nil, err
	}
	outputs := map[string]string{}
	// parse map[string][]byte to map[string]string for go template parsing
	if len(outputSecret.Data) > 0 {
		for k, v := range outputSecret.Data {
			outputs[k] = string(v)
		}
	}
	return &GetOutputsReply{Outputs: outputs}, nil
}
",CWE-200,129.0,1
"// Copyright (c) 2022 Gobalsky Labs Limited
//
// Use of this software is governed by the Business Source License included
// in the LICENSE.VEGA file and at https://www.mariadb.com/bsl11.
//
// Change Date: 18 months from the later of the date of the first publicly
// available Distribution of this version of the repository, and 25 June 2022.
//
// On the date above, in accordance with the Business Source License, use
// of this software will be governed by version 3 or later of the GNU General
// Public License.
package stubs
import (
	""code.vegaprotocol.io/vega/core/types""
)
type BridgeViewStub struct{}
func NewBridgeViewStub() *BridgeViewStub {
	return &BridgeViewStub{}
}
func (*BridgeViewStub) FindAssetList(al *types.ERC20AssetList, blockNumber, logIndex uint64) error {
	return nil
}
func (*BridgeViewStub) FindBridgeStopped(al *types.ERC20EventBridgeStopped, blockNumber, logIndex uint64) error {
	return nil
}
func (*BridgeViewStub) FindBridgeResumed(al *types.ERC20EventBridgeResumed, blockNumber, logIndex uint64) error {
	return nil
}
func (*BridgeViewStub) FindDeposit(d *types.ERC20Deposit, blockNumber, logIndex uint64, ethAssetAddress string) error {
	return nil
}
func (*BridgeViewStub) FindAssetLimitsUpdated(w *types.ERC20AssetLimitsUpdated, blockNumber, logIndex uint64, ethAssetAddress string) error {
	return nil
}
",CWE-20,44.0,1
"package route
import (
	""net/http""
	""github.com/IceWhaleTech/CasaOS-Common/utils/logger""
	""github.com/IceWhaleTech/CasaOS-Gateway/service""
	""go.uber.org/zap""
)
type GatewayRoute struct {
	management *service.Management
}
func NewGatewayRoute(management *service.Management) *GatewayRoute {
	return &GatewayRoute{
		management: management,
	}
}
func (g *GatewayRoute) GetRoute() *http.ServeMux {
	gatewayMux := http.NewServeMux()
	gatewayMux.HandleFunc(""/"", func(w http.ResponseWriter, r *http.Request) {
		if r.URL.Path == ""/ping"" {
			w.WriteHeader(http.StatusOK)
			if _, err := w.Write([]byte(""pong from gateway service"")); err != nil {
				logger.Error(""Failed to `pong` in resposne to `ping`"", zap.Any(""error"", err))
			}
			return
		}
		proxy := g.management.GetProxy(r.URL.Path)
		if proxy == nil {
			w.WriteHeader(http.StatusNotFound)
			return
		}
		proxy.ServeHTTP(w, r)
	})
	return gatewayMux
}
",CWE-306,44.0,1
"package constant
import (
	""errors""
)
const (
	CodeSuccess           = 200
	CodeErrBadRequest     = 400
	CodeErrUnauthorized   = 401
	CodeErrUnSafety       = 402
	CodeErrForbidden      = 403
	CodeErrNotFound       = 404
	CodePasswordExpired   = 405
	CodeAuth              = 406
	CodeGlobalLoading     = 407
	CodeErrIP             = 408
	CodeErrDomain         = 409
	CodeErrInternalServer = 500
	CodeErrHeader         = 406
)
// internal
var (
	ErrCaptchaCode     = errors.New(""ErrCaptchaCode"")
	ErrAuth            = errors.New(""ErrAuth"")
	ErrRecordExist     = errors.New(""ErrRecordExist"")
	ErrRecordNotFound  = errors.New(""ErrRecordNotFound"")
	ErrStructTransform = errors.New(""ErrStructTransform"")
	ErrInitialPassword = errors.New(""ErrInitialPassword"")
	ErrNotSupportType  = errors.New(""ErrNotSupportType"")
	ErrInvalidParams   = errors.New(""ErrInvalidParams"")
	ErrTokenParse = errors.New(""ErrTokenParse"")
)
// api
var (
	ErrTypeInternalServer  = ""ErrInternalServer""
	ErrTypeInvalidParams   = ""ErrInvalidParams""
	ErrTypeNotLogin        = ""ErrNotLogin""
	ErrTypePasswordExpired = ""ErrPasswordExpired""
	ErrNameIsExist         = ""ErrNameIsExist""
	ErrDemoEnvironment     = ""ErrDemoEnvironment""
)
// app
var (
	ErrPortInUsed          = ""ErrPortInUsed""
	ErrAppLimit            = ""ErrAppLimit""
	ErrFileToLarge         = ""ErrFileToLarge""
	ErrFileCanNotRead      = ""ErrFileCanNotRead""
	ErrNotInstall          = ""ErrNotInstall""
	ErrPortInOtherApp      = ""ErrPortInOtherApp""
	ErrDbUserNotValid      = ""ErrDbUserNotValid""
	ErrUpdateBuWebsite     = ""ErrUpdateBuWebsite""
	Err1PanelNetworkFailed = ""Err1PanelNetworkFailed""
	ErrCmdTimeout          = ""ErrCmdTimeout""
	ErrFileParse           = ""ErrFileParse""
	ErrInstallDirNotFound  = ""ErrInstallDirNotFound""
	ErrContainerName       = ""ErrContainerName""
)
// website
var (
	ErrDomainIsExist      = ""ErrDomainIsExist""
	ErrAliasIsExist       = ""ErrAliasIsExist""
	ErrGroupIsUsed        = ""ErrGroupIsUsed""
	ErrUsernameIsExist    = ""ErrUsernameIsExist""
	ErrUsernameIsNotExist = ""ErrUsernameIsNotExist""
	ErrBackupMatch        = ""ErrBackupMatch""
	ErrBackupExist        = ""ErrBackupExist""
)
// ssl
var (
	ErrSSLCannotDelete     = ""ErrSSLCannotDelete""
	ErrAccountCannotDelete = ""ErrAccountCannotDelete""
	ErrSSLApply            = ""ErrSSLApply""
	ErrEmailIsExist        = ""ErrEmailIsExist""
)
// file
var (
	ErrPathNotFound     = ""ErrPathNotFound""
	ErrMovePathFailed   = ""ErrMovePathFailed""
	ErrLinkPathNotFound = ""ErrLinkPathNotFound""
	ErrFileIsExit       = ""ErrFileIsExit""
	ErrFileUpload       = ""ErrFileUpload""
	ErrFileDownloadDir  = ""ErrFileDownloadDir""
)
// mysql
var (
	ErrUserIsExist     = ""ErrUserIsExist""
	ErrDatabaseIsExist = ""ErrDatabaseIsExist""
	ErrExecTimeOut     = ""ErrExecTimeOut""
)
// redis
var (
	ErrTypeOfRedis = ""ErrTypeOfRedis""
)
// container
var (
	ErrInUsed       = ""ErrInUsed""
	ErrObjectInUsed = ""ErrObjectInUsed""
	ErrPortRules    = ""ErrPortRules""
	ErrRepoConn     = ""ErrRepoConn""
)
// runtime
var (
	ErrDirNotFound    = ""ErrDirNotFound""
	ErrFileNotExist   = ""ErrFileNotExist""
	ErrImageBuildErr  = ""ErrImageBuildErr""
	ErrImageExist     = ""ErrImageExist""
	ErrDelWithWebsite = ""ErrDelWithWebsite""
)
var (
	ErrBackupInUsed = ""ErrBackupInUsed""
	ErrOSSConn      = ""ErrOSSConn""
)
",CWE-78,126.0,1
"package service
import (
	""strconv""
	""github.com/1Panel-dev/1Panel/backend/app/dto""
	""github.com/1Panel-dev/1Panel/backend/buserr""
	""github.com/1Panel-dev/1Panel/backend/constant""
	""github.com/1Panel-dev/1Panel/backend/global""
	""github.com/1Panel-dev/1Panel/backend/utils/encrypt""
	""github.com/1Panel-dev/1Panel/backend/utils/jwt""
	""github.com/1Panel-dev/1Panel/backend/utils/mfa""
	""github.com/gin-gonic/gin""
	""github.com/google/uuid""
	""github.com/pkg/errors""
)
type AuthService struct{}
type IAuthService interface {
	CheckIsSafety(code string) (string, error)
	VerifyCode(code string) (bool, error)
	Login(c *gin.Context, info dto.Login, entrance string) (*dto.UserLoginInfo, error)
	LogOut(c *gin.Context) error
	MFALogin(c *gin.Context, info dto.MFALogin, entrance string) (*dto.UserLoginInfo, error)
}
func NewIAuthService() IAuthService {
	return &AuthService{}
}
func (u *AuthService) Login(c *gin.Context, info dto.Login, entrance string) (*dto.UserLoginInfo, error) {
	nameSetting, err := settingRepo.Get(settingRepo.WithByKey(""UserName""))
	if err != nil {
		return nil, errors.WithMessage(constant.ErrRecordNotFound, err.Error())
	}
	passwordSetting, err := settingRepo.Get(settingRepo.WithByKey(""Password""))
	if err != nil {
		return nil, errors.WithMessage(constant.ErrRecordNotFound, err.Error())
	}
	pass, err := encrypt.StringDecrypt(passwordSetting.Value)
	if err != nil {
		return nil, constant.ErrAuth
	}
	if info.Password != pass || nameSetting.Value != info.Name {
		return nil, constant.ErrAuth
	}
	entranceSetting, err := settingRepo.Get(settingRepo.WithByKey(""SecurityEntrance""))
	if err != nil {
		return nil, err
	}
	if len(entranceSetting.Value) != 0 && entranceSetting.Value != entrance {
		return nil, buserr.New(constant.ErrEntrance)
	}
	mfa, err := settingRepo.Get(settingRepo.WithByKey(""MFAStatus""))
	if err != nil {
		return nil, err
	}
	if err = settingRepo.Update(""Language"", info.Language); err != nil {
		return nil, err
	}
	if mfa.Value == ""enable"" {
		return &dto.UserLoginInfo{Name: nameSetting.Value, MfaStatus: mfa.Value}, nil
	}
	return u.generateSession(c, info.Name, info.AuthMethod)
}
func (u *AuthService) MFALogin(c *gin.Context, info dto.MFALogin, entrance string) (*dto.UserLoginInfo, error) {
	nameSetting, err := settingRepo.Get(settingRepo.WithByKey(""UserName""))
	if err != nil {
		return nil, errors.WithMessage(constant.ErrRecordNotFound, err.Error())
	}
	passwordSetting, err := settingRepo.Get(settingRepo.WithByKey(""Password""))
	if err != nil {
		return nil, errors.WithMessage(constant.ErrRecordNotFound, err.Error())
	}
	pass, err := encrypt.StringDecrypt(passwordSetting.Value)
	if err != nil {
		return nil, err
	}
	if info.Password != pass || nameSetting.Value != info.Name {
		return nil, constant.ErrAuth
	}
	entranceSetting, err := settingRepo.Get(settingRepo.WithByKey(""SecurityEntrance""))
	if err != nil {
		return nil, err
	}
	if len(entranceSetting.Value) != 0 && entranceSetting.Value != entrance {
		return nil, buserr.New(constant.ErrEntrance)
	}
	mfaSecret, err := settingRepo.Get(settingRepo.WithByKey(""MFASecret""))
	if err != nil {
		return nil, err
	}
	mfaInterval, err := settingRepo.Get(settingRepo.WithByKey(""MFAInterval""))
	if err != nil {
		return nil, err
	}
	success := mfa.ValidCode(info.Code, mfaInterval.Value, mfaSecret.Value)
	if !success {
		return nil, constant.ErrAuth
	}
	return u.generateSession(c, info.Name, info.AuthMethod)
}
func (u *AuthService) generateSession(c *gin.Context, name, authMethod string) (*dto.UserLoginInfo, error) {
	setting, err := settingRepo.Get(settingRepo.WithByKey(""SessionTimeout""))
	if err != nil {
		return nil, err
	}
	lifeTime, err := strconv.Atoi(setting.Value)
	if err != nil {
		return nil, err
	}
	if authMethod == constant.AuthMethodJWT {
		j := jwt.NewJWT()
		claims := j.CreateClaims(jwt.BaseClaims{
			Name: name,
		})
		token, err := j.CreateToken(claims)
		if err != nil {
			return nil, err
		}
		return &dto.UserLoginInfo{Name: name, Token: token}, nil
	}
	sID, _ := c.Cookie(constant.SessionName)
	sessionUser, err := global.SESSION.Get(sID)
	if err != nil {
		sID = uuid.New().String()
		c.SetCookie(constant.SessionName, sID, 0, """", """", false, false)
		err := global.SESSION.Set(sID, sessionUser, lifeTime)
		if err != nil {
			return nil, err
		}
		return &dto.UserLoginInfo{Name: name}, nil
	}
	if err := global.SESSION.Set(sID, sessionUser, lifeTime); err != nil {
		return nil, err
	}
	return &dto.UserLoginInfo{Name: name}, nil
}
func (u *AuthService) LogOut(c *gin.Context) error {
	sID, _ := c.Cookie(constant.SessionName)
	if sID != """" {
		c.SetCookie(constant.SessionName, sID, -1, """", """", false, false)
		err := global.SESSION.Delete(sID)
		if err != nil {
			return err
		}
	}
	return nil
}
func (u *AuthService) VerifyCode(code string) (bool, error) {
	setting, err := settingRepo.Get(settingRepo.WithByKey(""SecurityEntrance""))
	if err != nil {
		return false, err
	}
	return setting.Value == code, nil
}
func (u *AuthService) CheckIsSafety(code string) (string, error) {
	status, err := settingRepo.Get(settingRepo.WithByKey(""SecurityEntrance""))
	if err != nil {
		return """", err
	}
	if len(status.Value) == 0 {
		return ""disable"", nil
	}
	if status.Value == code {
		return ""pass"", nil
	}
	return ""unpass"", nil
}
",CWE-311,179.0,1
"/*
Copyright 2022 The Dapr Authors
Licensed under the Apache License, Version 2.0 (the ""License"");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an ""AS IS"" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package security
import (
	""os""
	""strings""
	""github.com/dapr/dapr/pkg/runtime/security/consts""
)
var excludedRoutes = []string{""/healthz""}
// GetAPIToken returns the value of the api token from an environment variable.
func GetAPIToken() string {
	return os.Getenv(consts.APITokenEnvVar)
}
// GetAppToken returns the value of the app api token from an environment variable.
func GetAppToken() string {
	return os.Getenv(consts.AppAPITokenEnvVar)
}
// ExcludedRoute returns whether a given route should be excluded from a token check.
func ExcludedRoute(route string) bool {
	for _, r := range excludedRoutes {
		if strings.Contains(route, r) {
			return true
		}
	}
	return false
}
",CWE-287,44.0,1
"/*
Copyright 2022 The Dapr Authors
Licensed under the Apache License, Version 2.0 (the ""License"");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
	http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an ""AS IS"" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package security
import (
	""testing""
	""github.com/stretchr/testify/assert""
	""github.com/dapr/dapr/pkg/runtime/security/consts""
)
func TestAPIToken(t *testing.T) {
	t.Run(""existing token"", func(t *testing.T) {
		/* 
		token := ""eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJPbmxpbmUgSldUIEJ1aWxkZXIiLCJpYXQiOjE1OTA1NTQ1NzMsImV4cCI6MTYyMjA5MDU3MywiYXVkIjoid3d3LmV4YW1wbGUuY29tIiwic3ViIjoianJvY2tldEBleGFtcGxlLmNvbSIsIkdpdmVuTmFtZSI6IkpvaG5ueSIsIlN1cm5hbWUiOiJSb2NrZXQiLCJFbWFpbCI6Impyb2NrZXRAZXhhbXBsZS5jb20iLCJSb2xlIjpbIk1hbmFnZXIiLCJQcm9qZWN0IEFkbWluaXN0cmF0b3IiXX0.QLFl8ZqC48DOsT7SmXA794nivmqGgylzjrUu6JhXPW4""
		t.Setenv(consts.APITokenEnvVar, token)
		apitoken := GetAPIToken()
		assert.Equal(t, token, apitoken)
	})
	t.Run(""non-existent token"", func(t *testing.T) {
		token := GetAPIToken()
		assert.Equal(t, """", token)
	})
}
func TestAppToken(t *testing.T) {
	t.Run(""existing token"", func(t *testing.T) {
		/* 
		token := ""eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJPbmxpbmUgSldUIEJ1aWxkZXIiLCJpYXQiOjE1OTA1NTQ1NzMsImV4cCI6MTYyMjA5MDU3MywiYXVkIjoid3d3LmV4YW1wbGUuY29tIiwic3ViIjoianJvY2tldEBleGFtcGxlLmNvbSIsIkdpdmVuTmFtZSI6IkpvaG5ueSIsIlN1cm5hbWUiOiJSb2NrZXQiLCJFbWFpbCI6Impyb2NrZXRAZXhhbXBsZS5jb20iLCJSb2xlIjpbIk1hbmFnZXIiLCJQcm9qZWN0IEFkbWluaXN0cmF0b3IiXX0.QLFl8ZqC48DOsT7SmXA794nivmqGgylzjrUu6JhXPW4""
		t.Setenv(consts.AppAPITokenEnvVar, token)
		apitoken := GetAppToken()
		assert.Equal(t, token, apitoken)
	})
	t.Run(""non-existent token"", func(t *testing.T) {
		token := GetAppToken()
		assert.Equal(t, """", token)
	})
}
func TestExcludedRoute(t *testing.T) {
	t.Run(""healthz route is excluded"", func(t *testing.T) {
		route := ""v1.0/healthz""
		excluded := ExcludedRoute(route)
		assert.True(t, excluded)
	})
	t.Run(""custom route is not excluded"", func(t *testing.T) {
		route := ""v1.0/state""
		excluded := ExcludedRoute(route)
		assert.False(t, excluded)
	})
}
",CWE-287,71.0,1
"package util
import (
	""mime""
	""strings""
)
func FixContentType(ct string) string {
	return strings.Split(ct, "";"")[0]
}
func ExtensionForContentType(ct string) string {
	exts, _ := mime.ExtensionsByType(ct)
	if len(exts) > 0 {
		return exts[0]
	}
	return "".bin""
}
",CWE-79,19.0,1
"package csrf
import (
	""errors""
	""github.com/gofiber/fiber/v2""
)
var (
	errMissingHeader = errors.New(""missing csrf token in header"")
	errMissingQuery  = errors.New(""missing csrf token in query"")
	errMissingParam  = errors.New(""missing csrf token in param"")
	errMissingForm   = errors.New(""missing csrf token in form"")
	errMissingCookie = errors.New(""missing csrf token in cookie"")
)
// csrfFromParam returns a function that extracts token from the url param string.
func CsrfFromParam(param string) func(c *fiber.Ctx) (string, error) {
	return func(c *fiber.Ctx) (string, error) {
		token := c.Params(param)
		if token == """" {
			return """", errMissingParam
		}
		return token, nil
	}
}
// csrfFromForm returns a function that extracts a token from a multipart-form.
func CsrfFromForm(param string) func(c *fiber.Ctx) (string, error) {
	return func(c *fiber.Ctx) (string, error) {
		token := c.FormValue(param)
		if token == """" {
			return """", errMissingForm
		}
		return token, nil
	}
}
// csrfFromCookie returns a function that extracts token from the cookie header.
func CsrfFromCookie(param string) func(c *fiber.Ctx) (string, error) {
	return func(c *fiber.Ctx) (string, error) {
		token := c.Cookies(param)
		if token == """" {
			return """", errMissingCookie
		}
		return token, nil
	}
}
// csrfFromHeader returns a function that extracts token from the request header.
func CsrfFromHeader(param string) func(c *fiber.Ctx) (string, error) {
	return func(c *fiber.Ctx) (string, error) {
		token := c.Get(param)
		if token == """" {
			return """", errMissingHeader
		}
		return token, nil
	}
}
// csrfFromQuery returns a function that extracts token from the query string.
func CsrfFromQuery(param string) func(c *fiber.Ctx) (string, error) {
	return func(c *fiber.Ctx) (string, error) {
		token := c.Query(param)
		if token == """" {
			return """", errMissingQuery
		}
		return token, nil
	}
}
",CWE-352,71.0,1
"package csrf
import (
	""errors""
	""github.com/gofiber/fiber/v2""
)
var (
	errMissingHeader = errors.New(""missing csrf token in header"")
	errMissingQuery  = errors.New(""missing csrf token in query"")
	errMissingParam  = errors.New(""missing csrf token in param"")
	errMissingForm   = errors.New(""missing csrf token in form"")
	errMissingCookie = errors.New(""missing csrf token in cookie"")
)
// csrfFromParam returns a function that extracts token from the url param string.
func CsrfFromParam(param string) func(c *fiber.Ctx) (string, error) {
	return func(c *fiber.Ctx) (string, error) {
		token := c.Params(param)
		if token == """" {
			return """", errMissingParam
		}
		return token, nil
	}
}
// csrfFromForm returns a function that extracts a token from a multipart-form.
func CsrfFromForm(param string) func(c *fiber.Ctx) (string, error) {
	return func(c *fiber.Ctx) (string, error) {
		token := c.FormValue(param)
		if token == """" {
			return """", errMissingForm
		}
		return token, nil
	}
}
// csrfFromCookie returns a function that extracts token from the cookie header.
func CsrfFromCookie(param string) func(c *fiber.Ctx) (string, error) {
	return func(c *fiber.Ctx) (string, error) {
		token := c.Cookies(param)
		if token == """" {
			return """", errMissingCookie
		}
		return token, nil
	}
}
// csrfFromHeader returns a function that extracts token from the request header.
func CsrfFromHeader(param string) func(c *fiber.Ctx) (string, error) {
	return func(c *fiber.Ctx) (string, error) {
		token := c.Get(param)
		if token == """" {
			return """", errMissingHeader
		}
		return token, nil
	}
}
// csrfFromQuery returns a function that extracts token from the query string.
func CsrfFromQuery(param string) func(c *fiber.Ctx) (string, error) {
	return func(c *fiber.Ctx) (string, error) {
		token := c.Query(param)
		if token == """" {
			return """", errMissingQuery
		}
		return token, nil
	}
}
",CWE-20,71.0,1
"package csrf
import (
	""errors""
	""github.com/gofiber/fiber/v2""
)
var (
	errMissingHeader = errors.New(""missing csrf token in header"")
	errMissingQuery  = errors.New(""missing csrf token in query"")
	errMissingParam  = errors.New(""missing csrf token in param"")
	errMissingForm   = errors.New(""missing csrf token in form"")
	errMissingCookie = errors.New(""missing csrf token in cookie"")
)
// csrfFromParam returns a function that extracts token from the url param string.
func CsrfFromParam(param string) func(c *fiber.Ctx) (string, error) {
	return func(c *fiber.Ctx) (string, error) {
		token := c.Params(param)
		if token == """" {
			return """", errMissingParam
		}
		return token, nil
	}
}
// csrfFromForm returns a function that extracts a token from a multipart-form.
func CsrfFromForm(param string) func(c *fiber.Ctx) (string, error) {
	return func(c *fiber.Ctx) (string, error) {
		token := c.FormValue(param)
		if token == """" {
			return """", errMissingForm
		}
		return token, nil
	}
}
// csrfFromCookie returns a function that extracts token from the cookie header.
func CsrfFromCookie(param string) func(c *fiber.Ctx) (string, error) {
	return func(c *fiber.Ctx) (string, error) {
		token := c.Cookies(param)
		if token == """" {
			return """", errMissingCookie
		}
		return token, nil
	}
}
// csrfFromHeader returns a function that extracts token from the request header.
func CsrfFromHeader(param string) func(c *fiber.Ctx) (string, error) {
	return func(c *fiber.Ctx) (string, error) {
		token := c.Get(param)
		if token == """" {
			return """", errMissingHeader
		}
		return token, nil
	}
}
// csrfFromQuery returns a function that extracts token from the query string.
func CsrfFromQuery(param string) func(c *fiber.Ctx) (string, error) {
	return func(c *fiber.Ctx) (string, error) {
		token := c.Query(param)
		if token == """" {
			return """", errMissingQuery
		}
		return token, nil
	}
}
",CWE-565,71.0,1
"package csrf
import (
	""errors""
	""github.com/gofiber/fiber/v2""
)
var (
	errMissingHeader = errors.New(""missing csrf token in header"")
	errMissingQuery  = errors.New(""missing csrf token in query"")
	errMissingParam  = errors.New(""missing csrf token in param"")
	errMissingForm   = errors.New(""missing csrf token in form"")
	errMissingCookie = errors.New(""missing csrf token in cookie"")
)
// csrfFromParam returns a function that extracts token from the url param string.
func CsrfFromParam(param string) func(c *fiber.Ctx) (string, error) {
	return func(c *fiber.Ctx) (string, error) {
		token := c.Params(param)
		if token == """" {
			return """", errMissingParam
		}
		return token, nil
	}
}
// csrfFromForm returns a function that extracts a token from a multipart-form.
func CsrfFromForm(param string) func(c *fiber.Ctx) (string, error) {
	return func(c *fiber.Ctx) (string, error) {
		token := c.FormValue(param)
		if token == """" {
			return """", errMissingForm
		}
		return token, nil
	}
}
// csrfFromCookie returns a function that extracts token from the cookie header.
func CsrfFromCookie(param string) func(c *fiber.Ctx) (string, error) {
	return func(c *fiber.Ctx) (string, error) {
		token := c.Cookies(param)
		if token == """" {
			return """", errMissingCookie
		}
		return token, nil
	}
}
// csrfFromHeader returns a function that extracts token from the request header.
func CsrfFromHeader(param string) func(c *fiber.Ctx) (string, error) {
	return func(c *fiber.Ctx) (string, error) {
		token := c.Get(param)
		if token == """" {
			return """", errMissingHeader
		}
		return token, nil
	}
}
// csrfFromQuery returns a function that extracts token from the query string.
func CsrfFromQuery(param string) func(c *fiber.Ctx) (string, error) {
	return func(c *fiber.Ctx) (string, error) {
		token := c.Query(param)
		if token == """" {
			return """", errMissingQuery
		}
		return token, nil
	}
}
",CWE-807,71.0,1
"package csrf
import (
	""crypto/subtle""
)
func compareTokens(a, b []byte) bool {
	return subtle.ConstantTimeCompare(a, b) == 1
}
",CWE-352,10.0,1
"package csrf
import (
	""crypto/subtle""
)
func compareTokens(a, b []byte) bool {
	return subtle.ConstantTimeCompare(a, b) == 1
}
",CWE-20,10.0,1
"package csrf
import (
	""crypto/subtle""
)
func compareTokens(a, b []byte) bool {
	return subtle.ConstantTimeCompare(a, b) == 1
}
",CWE-565,10.0,1
"package csrf
import (
	""crypto/subtle""
)
func compareTokens(a, b []byte) bool {
	return subtle.ConstantTimeCompare(a, b) == 1
}
",CWE-807,10.0,1
"package parser
import (
	""bytes""
	""github.com/gomarkdown/markdown/ast""
)
// citation parses a citation. In its most simple form [@ref], we allow multiple
// being separated by semicolons and a sub reference inside ala pandoc: [@ref, p. 23].
// Each citation can have a modifier: !, ? or - wich mean:
//
// ! - normative
// ? - formative
// - - suppressed
//
// The suffix starts after a comma, we strip any whitespace before and after. If the output
// allows for it, this can be rendered.
func citation(p *Parser, data []byte, offset int) (int, ast.Node) {
	// look for the matching closing bracket
	i := offset + 1
	for level := 1; level > 0 && i < len(data); i++ {
		switch {
		case data[i] == '\n':
			// no newlines allowed.
			return 0, nil
		case data[i-1] == '\\':
			continue
		case data[i] == '[':
			level++
		case data[i] == ']':
			level--
			if level <= 0 {
				i-- // compensate for extra i++ in for loop
			}
		}
	}
	if i >= len(data) {
		return 0, nil
	}
	node := &ast.Citation{}
	citations := bytes.Split(data[1:i], []byte("";""))
	for _, citation := range citations {
		var suffix []byte
		citation = bytes.TrimSpace(citation)
		j := 0
		if citation[j] != '@' {
			// not a citation, drop out entirely.
			return 0, nil
		}
		if c := bytes.Index(citation, []byte("","")); c > 0 {
			part := citation[:c]
			suff := citation[c+1:]
			part = bytes.TrimSpace(part)
			suff = bytes.TrimSpace(suff)
			citation = part
			suffix = suff
		}
		citeType := ast.CitationTypeInformative
		j = 1
		switch citation[j] {
		case '!':
			citeType = ast.CitationTypeNormative
			j++
		case '?':
			citeType = ast.CitationTypeInformative
			j++
		case '-':
			citeType = ast.CitationTypeSuppressed
			j++
		}
		node.Destination = append(node.Destination, citation[j:])
		node.Type = append(node.Type, citeType)
		node.Suffix = append(node.Suffix, suffix)
	}
	return i + 1, node
}
",CWE-125,87.0,1
"package ssh
import (
	""fmt""
	""time""
	""github.com/charmbracelet/log""
	""github.com/charmbracelet/soft-serve/server/backend""
	""github.com/charmbracelet/soft-serve/server/config""
	""github.com/charmbracelet/soft-serve/server/db""
	""github.com/charmbracelet/soft-serve/server/proto""
	""github.com/charmbracelet/soft-serve/server/ssh/cmd""
	""github.com/charmbracelet/soft-serve/server/sshutils""
	""github.com/charmbracelet/soft-serve/server/store""
	""github.com/charmbracelet/ssh""
	""github.com/prometheus/client_golang/prometheus""
	""github.com/prometheus/client_golang/prometheus/promauto""
	""github.com/spf13/cobra""
)
// ContextMiddleware adds the config, backend, and logger to the session context.
func ContextMiddleware(cfg *config.Config, dbx *db.DB, datastore store.Store, be *backend.Backend, logger *log.Logger) func(ssh.Handler) ssh.Handler {
	return func(sh ssh.Handler) ssh.Handler {
		return func(s ssh.Session) {
			s.Context().SetValue(sshutils.ContextKeySession, s)
			s.Context().SetValue(config.ContextKey, cfg)
			s.Context().SetValue(db.ContextKey, dbx)
			s.Context().SetValue(store.ContextKey, datastore)
			s.Context().SetValue(backend.ContextKey, be)
			s.Context().SetValue(log.ContextKey, logger.WithPrefix(""ssh""))
			sh(s)
		}
	}
}
var cliCommandCounter = promauto.NewCounterVec(prometheus.CounterOpts{
	Namespace: ""soft_serve"",
	Subsystem: ""cli"",
	Name:      ""commands_total"",
	Help:      ""Total times each command was called"",
}, []string{""command""})
// CommandMiddleware handles git commands and CLI commands.
// This middleware must be run after the ContextMiddleware.
func CommandMiddleware(sh ssh.Handler) ssh.Handler {
	return func(s ssh.Session) {
		func() {
			_, _, ptyReq := s.Pty()
			if ptyReq {
				return
			}
			ctx := s.Context()
			cfg := config.FromContext(ctx)
			args := s.Command()
			cliCommandCounter.WithLabelValues(cmd.CommandName(args)).Inc()
			rootCmd := &cobra.Command{
				Short:        ""Soft Serve is a self-hostable Git server for the command line."",
				SilenceUsage: true,
			}
			rootCmd.CompletionOptions.DisableDefaultCmd = true
			rootCmd.SetUsageTemplate(cmd.UsageTemplate)
			rootCmd.SetUsageFunc(cmd.UsageFunc)
			rootCmd.AddCommand(
				cmd.GitUploadPackCommand(),
				cmd.GitUploadArchiveCommand(),
				cmd.GitReceivePackCommand(),
				cmd.RepoCommand(),
				cmd.SettingsCommand(),
				cmd.UserCommand(),
				cmd.InfoCommand(),
				cmd.PubkeyCommand(),
				cmd.SetUsernameCommand(),
				cmd.JWTCommand(),
				cmd.TokenCommand(),
			)
			if cfg.LFS.Enabled {
				rootCmd.AddCommand(
					cmd.GitLFSAuthenticateCommand(),
				)
				if cfg.LFS.SSHEnabled {
					rootCmd.AddCommand(
						cmd.GitLFSTransfer(),
					)
				}
			}
			rootCmd.SetArgs(args)
			if len(args) == 0 {
				// otherwise it'll default to os.Args, which is not what we want.
				rootCmd.SetArgs([]string{""--help""})
			}
			rootCmd.SetIn(s)
			rootCmd.SetOut(s)
			rootCmd.SetErr(s.Stderr())
			rootCmd.SetContext(ctx)
			if err := rootCmd.ExecuteContext(ctx); err != nil {
				s.Exit(1) // nolint: errcheck
				return
			}
		}()
		sh(s)
	}
}
// LoggingMiddleware logs the ssh connection and command.
func LoggingMiddleware(sh ssh.Handler) ssh.Handler {
	return func(s ssh.Session) {
		ctx := s.Context()
		logger := log.FromContext(ctx).WithPrefix(""ssh"")
		ct := time.Now()
		hpk := sshutils.MarshalAuthorizedKey(s.PublicKey())
		ptyReq, _, isPty := s.Pty()
		addr := s.RemoteAddr().String()
		user := proto.UserFromContext(ctx)
		logArgs := []interface{}{
			""addr"",
			addr,
			""cmd"",
			s.Command(),
		}
		if user != nil {
			logArgs = append([]interface{}{
				""username"",
				user.Username(),
			}, logArgs...)
		}
		if isPty {
			logArgs = []interface{}{
				""term"", ptyReq.Term,
				""width"", ptyReq.Window.Width,
				""height"", ptyReq.Window.Height,
			}
		}
		if config.IsVerbose() {
			logArgs = append(logArgs,
				""key"", hpk,
				""envs"", s.Environ(),
			)
		}
		msg := fmt.Sprintf(""user %q"", s.User())
		logger.Debug(msg+"" connected"", logArgs...)
		sh(s)
		logger.Debug(msg+"" disconnected"", append(logArgs, ""duration"", time.Since(ct))...)
	}
}
",CWE-287,156.0,1
"/*
Copyright © 2021 ConsenSys Software Inc.
Licensed under the Apache License, Version 2.0 (the ""License"");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an ""AS IS"" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package frontend
import (
	""math/big""
	""github.com/consensys/gnark/constraint/solver""
)
// API represents the available functions to circuit developers
type API interface {
	// ---------------------------------------------------------------------------------------------
	// Arithmetic
	// Add returns res = i1+i2+...in
	Add(i1, i2 Variable, in ...Variable) Variable
	// MulAcc sets and return a = a + (b*c).
	//
	// ! The method may mutate a without allocating a new result. If the input
	// is used elsewhere, then first initialize new variable, for example by
	// doing:
	//
	//     acopy := api.Mul(a, 1)
	//     acopy = MulAcc(acopy, b, c)
	//
	// ! But it may not modify a, always use MulAcc(...) result for correctness.
	MulAcc(a, b, c Variable) Variable
	// Neg returns -i
	Neg(i1 Variable) Variable
	// Sub returns res = i1 - i2 - ...in
	Sub(i1, i2 Variable, in ...Variable) Variable
	// Mul returns res = i1 * i2 * ... in
	Mul(i1, i2 Variable, in ...Variable) Variable
	// DivUnchecked returns i1 / i2 . if i1 == i2 == 0, returns 0
	DivUnchecked(i1, i2 Variable) Variable
	// Div returns i1 / i2
	Div(i1, i2 Variable) Variable
	// Inverse returns res = 1 / i1
	Inverse(i1 Variable) Variable
	// ---------------------------------------------------------------------------------------------
	// Bit operations
	// TODO @gbotrel move bit operations in std/math/bits
	// ToBinary unpacks a Variable in binary,
	// n is the number of bits to select (starting from lsb)
	// n default value is fr.Bits the number of bits needed to represent a field element
	//
	// The result in little endian (first bit= lsb)
	ToBinary(i1 Variable, n ...int) []Variable
	// FromBinary packs b, seen as a fr.Element in little endian
	FromBinary(b ...Variable) Variable
	// Xor returns a ^ b
	// a and b must be 0 or 1
	Xor(a, b Variable) Variable
	// Or returns a | b
	// a and b must be 0 or 1
	Or(a, b Variable) Variable
	// Or returns a & b
	// a and b must be 0 or 1
	And(a, b Variable) Variable
	// ---------------------------------------------------------------------------------------------
	// Conditionals
	// Select if b is true, yields i1 else yields i2
	Select(b Variable, i1, i2 Variable) Variable
	// Lookup2 performs a 2-bit lookup between i1, i2, i3, i4 based on bits b0
	// and b1. Returns i0 if b0=b1=0, i1 if b0=1 and b1=0, i2 if b0=0 and b1=1
	// and i3 if b0=b1=1.
	Lookup2(b0, b1 Variable, i0, i1, i2, i3 Variable) Variable
	// IsZero returns 1 if a is zero, 0 otherwise
	IsZero(i1 Variable) Variable
	// Cmp returns 1 if i1>i2, 0 if i1=i2, -1 if i1<i2
	Cmp(i1, i2 Variable) Variable
	// ---------------------------------------------------------------------------------------------
	// Assertions
	// AssertIsEqual fails if i1 != i2
	AssertIsEqual(i1, i2 Variable)
	// AssertIsDifferent fails if i1 == i2
	AssertIsDifferent(i1, i2 Variable)
	// AssertIsBoolean fails if v != 0 ∥ v != 1
	AssertIsBoolean(i1 Variable)
	// AssertIsLessOrEqual fails if  v > bound
	AssertIsLessOrEqual(v Variable, bound Variable)
	// Println behaves like fmt.Println but accepts cd.Variable as parameter
	// whose value will be resolved at runtime when computed by the solver
	Println(a ...Variable)
	// Compiler returns the compiler object for advanced circuit development
	Compiler() Compiler
	// Deprecated APIs
	// NewHint is a shortcut to api.Compiler().NewHint()
	// Deprecated: use api.Compiler().NewHint() instead
	NewHint(f solver.Hint, nbOutputs int, inputs ...Variable) ([]Variable, error)
	// ConstantValue is a shortcut to api.Compiler().ConstantValue()
	// Deprecated: use api.Compiler().ConstantValue() instead
	ConstantValue(v Variable) (*big.Int, bool)
}
// BatchInvert returns a slice of variables containing the inverse of each element in i1
// This is a temporary API, do not use it in your circuit
type BatchInverter interface {
	// BatchInvert returns a slice of variables containing the inverse of each element in i1
	// This is a temporary API, do not use it in your circuit
	BatchInvert(i1 []Variable) []Variable
}
",CWE-191,146.0,1
"/*
Copyright © 2021 ConsenSys Software Inc.
Licensed under the Apache License, Version 2.0 (the ""License"");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an ""AS IS"" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package frontend
import (
	""math/big""
	""github.com/consensys/gnark/constraint/solver""
)
// API represents the available functions to circuit developers
type API interface {
	// ---------------------------------------------------------------------------------------------
	// Arithmetic
	// Add returns res = i1+i2+...in
	Add(i1, i2 Variable, in ...Variable) Variable
	// MulAcc sets and return a = a + (b*c).
	//
	// ! The method may mutate a without allocating a new result. If the input
	// is used elsewhere, then first initialize new variable, for example by
	// doing:
	//
	//     acopy := api.Mul(a, 1)
	//     acopy = MulAcc(acopy, b, c)
	//
	// ! But it may not modify a, always use MulAcc(...) result for correctness.
	MulAcc(a, b, c Variable) Variable
	// Neg returns -i
	Neg(i1 Variable) Variable
	// Sub returns res = i1 - i2 - ...in
	Sub(i1, i2 Variable, in ...Variable) Variable
	// Mul returns res = i1 * i2 * ... in
	Mul(i1, i2 Variable, in ...Variable) Variable
	// DivUnchecked returns i1 / i2 . if i1 == i2 == 0, returns 0
	DivUnchecked(i1, i2 Variable) Variable
	// Div returns i1 / i2
	Div(i1, i2 Variable) Variable
	// Inverse returns res = 1 / i1
	Inverse(i1 Variable) Variable
	// ---------------------------------------------------------------------------------------------
	// Bit operations
	// TODO @gbotrel move bit operations in std/math/bits
	// ToBinary unpacks a Variable in binary,
	// n is the number of bits to select (starting from lsb)
	// n default value is fr.Bits the number of bits needed to represent a field element
	//
	// The result in little endian (first bit= lsb)
	ToBinary(i1 Variable, n ...int) []Variable
	// FromBinary packs b, seen as a fr.Element in little endian
	FromBinary(b ...Variable) Variable
	// Xor returns a ^ b
	// a and b must be 0 or 1
	Xor(a, b Variable) Variable
	// Or returns a | b
	// a and b must be 0 or 1
	Or(a, b Variable) Variable
	// Or returns a & b
	// a and b must be 0 or 1
	And(a, b Variable) Variable
	// ---------------------------------------------------------------------------------------------
	// Conditionals
	// Select if b is true, yields i1 else yields i2
	Select(b Variable, i1, i2 Variable) Variable
	// Lookup2 performs a 2-bit lookup between i1, i2, i3, i4 based on bits b0
	// and b1. Returns i0 if b0=b1=0, i1 if b0=1 and b1=0, i2 if b0=0 and b1=1
	// and i3 if b0=b1=1.
	Lookup2(b0, b1 Variable, i0, i1, i2, i3 Variable) Variable
	// IsZero returns 1 if a is zero, 0 otherwise
	IsZero(i1 Variable) Variable
	// Cmp returns 1 if i1>i2, 0 if i1=i2, -1 if i1<i2
	Cmp(i1, i2 Variable) Variable
	// ---------------------------------------------------------------------------------------------
	// Assertions
	// AssertIsEqual fails if i1 != i2
	AssertIsEqual(i1, i2 Variable)
	// AssertIsDifferent fails if i1 == i2
	AssertIsDifferent(i1, i2 Variable)
	// AssertIsBoolean fails if v != 0 ∥ v != 1
	AssertIsBoolean(i1 Variable)
	// AssertIsLessOrEqual fails if  v > bound
	AssertIsLessOrEqual(v Variable, bound Variable)
	// Println behaves like fmt.Println but accepts cd.Variable as parameter
	// whose value will be resolved at runtime when computed by the solver
	Println(a ...Variable)
	// Compiler returns the compiler object for advanced circuit development
	Compiler() Compiler
	// Deprecated APIs
	// NewHint is a shortcut to api.Compiler().NewHint()
	// Deprecated: use api.Compiler().NewHint() instead
	NewHint(f solver.Hint, nbOutputs int, inputs ...Variable) ([]Variable, error)
	// ConstantValue is a shortcut to api.Compiler().ConstantValue()
	// Deprecated: use api.Compiler().ConstantValue() instead
	ConstantValue(v Variable) (*big.Int, bool)
}
// BatchInvert returns a slice of variables containing the inverse of each element in i1
// This is a temporary API, do not use it in your circuit
type BatchInverter interface {
	// BatchInvert returns a slice of variables containing the inverse of each element in i1
	// This is a temporary API, do not use it in your circuit
	BatchInvert(i1 []Variable) []Variable
}
",CWE-697,146.0,1
"package circuits
import (
	""fmt""
	""math/big""
	""github.com/consensys/gnark/frontend""
	""github.com/consensys/gnark/std/math/bits""
)
type hintCircuit struct {
	A, B frontend.Variable
}
func (circuit *hintCircuit) Define(api frontend.API) error {
	res, err := api.Compiler().NewHint(mulBy7, 1, circuit.A)
	if err != nil {
		return fmt.Errorf(""mulBy7: %w"", err)
	}
	a7 := res[0]
	_a7 := api.Mul(circuit.A, 7)
	api.AssertIsEqual(a7, _a7)
	api.AssertIsEqual(a7, circuit.B)
	res, err = api.Compiler().NewHint(make3, 1)
	if err != nil {
		return fmt.Errorf(""make3: %w"", err)
	}
	c := res[0]
	c = api.Mul(c, c)
	api.AssertIsEqual(c, 9)
	return nil
}
type vectorDoubleCircuit struct {
	A []frontend.Variable
	B []frontend.Variable
}
func (c *vectorDoubleCircuit) Define(api frontend.API) error {
	res, err := api.Compiler().NewHint(dvHint, len(c.B), c.A...)
	if err != nil {
		return fmt.Errorf(""double newhint: %w"", err)
	}
	if len(res) != len(c.B) {
		return fmt.Errorf(""expected len %d, got %d"", len(c.B), len(res))
	}
	for i := range res {
		api.AssertIsEqual(api.Mul(2, c.A[i]), c.B[i])
		api.AssertIsEqual(res[i], c.B[i])
	}
	return nil
}
type recursiveHint struct {
	A frontend.Variable
}
func (circuit *recursiveHint) Define(api frontend.API) error {
	// first hint produces wire w1
	w1, _ := api.Compiler().NewHint(make3, 1)
	// this linear expression is not recorded in a R1CS just yet
	linearExpression := api.Add(circuit.A, w1[0])
	// api.ToBinary calls another hint (bits.NBits) with linearExpression as input
	// however, when the solver will resolve bits[...] it will need to detect w1 as a dependency
	// in order to compute the correct linearExpression value
	bits := api.ToBinary(linearExpression, 10)
	a := api.FromBinary(bits...)
	api.AssertIsEqual(a, 45)
	return nil
}
func init() {
	{
		good := []frontend.Circuit{
			&recursiveHint{
				A: 42,
			},
		}
		bad := []frontend.Circuit{
			&recursiveHint{
				A: 1,
			},
		}
		addNewEntry(""recursive_hint"", &recursiveHint{}, good, bad, nil, make3, bits.GetHints()[1])
	}
	{
		good := []frontend.Circuit{
			&hintCircuit{
				A: 42,
				B: 42 * 7,
			},
		}
		bad := []frontend.Circuit{
			&hintCircuit{
				A: 42,
				B: 42,
			},
		}
		addNewEntry(""hint"", &hintCircuit{}, good, bad, nil, mulBy7, make3)
	}
	{
		good := []frontend.Circuit{
			&vectorDoubleCircuit{
				A: []frontend.Variable{
					1, 2, 3, 4, 5, 6, 7, 8,
				},
				B: []frontend.Variable{
					2, 4, 6, 8, 10, 12, 14, 16,
				},
			},
		}
		bad := []frontend.Circuit{
			&vectorDoubleCircuit{
				A: []frontend.Variable{
					1, 2, 3, 4, 5, 6, 7, 8,
				},
				B: []frontend.Variable{
					1, 2, 3, 4, 5, 6, 7, 8,
				},
			},
		}
		addNewEntry(""multi-output-hint"", &vectorDoubleCircuit{A: make([]frontend.Variable, 8), B: make([]frontend.Variable, 8)}, good, bad, nil, dvHint)
	}
}
var mulBy7 = func(q *big.Int, inputs []*big.Int, result []*big.Int) error {
	result[0].Mul(inputs[0], big.NewInt(7)).Mod(result[0], q)
	return nil
}
var make3 = func(_ *big.Int, inputs []*big.Int, result []*big.Int) error {
	result[0].SetUint64(3)
	return nil
}
var dvHint = func(_ *big.Int, inputs []*big.Int, res []*big.Int) error {
	two := big.NewInt(2)
	for i := range inputs {
		res[i].Mul(two, inputs[i])
	}
	return nil
}
",CWE-191,157.0,1
"package circuits
import (
	""fmt""
	""math/big""
	""github.com/consensys/gnark/frontend""
	""github.com/consensys/gnark/std/math/bits""
)
type hintCircuit struct {
	A, B frontend.Variable
}
func (circuit *hintCircuit) Define(api frontend.API) error {
	res, err := api.Compiler().NewHint(mulBy7, 1, circuit.A)
	if err != nil {
		return fmt.Errorf(""mulBy7: %w"", err)
	}
	a7 := res[0]
	_a7 := api.Mul(circuit.A, 7)
	api.AssertIsEqual(a7, _a7)
	api.AssertIsEqual(a7, circuit.B)
	res, err = api.Compiler().NewHint(make3, 1)
	if err != nil {
		return fmt.Errorf(""make3: %w"", err)
	}
	c := res[0]
	c = api.Mul(c, c)
	api.AssertIsEqual(c, 9)
	return nil
}
type vectorDoubleCircuit struct {
	A []frontend.Variable
	B []frontend.Variable
}
func (c *vectorDoubleCircuit) Define(api frontend.API) error {
	res, err := api.Compiler().NewHint(dvHint, len(c.B), c.A...)
	if err != nil {
		return fmt.Errorf(""double newhint: %w"", err)
	}
	if len(res) != len(c.B) {
		return fmt.Errorf(""expected len %d, got %d"", len(c.B), len(res))
	}
	for i := range res {
		api.AssertIsEqual(api.Mul(2, c.A[i]), c.B[i])
		api.AssertIsEqual(res[i], c.B[i])
	}
	return nil
}
type recursiveHint struct {
	A frontend.Variable
}
func (circuit *recursiveHint) Define(api frontend.API) error {
	// first hint produces wire w1
	w1, _ := api.Compiler().NewHint(make3, 1)
	// this linear expression is not recorded in a R1CS just yet
	linearExpression := api.Add(circuit.A, w1[0])
	// api.ToBinary calls another hint (bits.NBits) with linearExpression as input
	// however, when the solver will resolve bits[...] it will need to detect w1 as a dependency
	// in order to compute the correct linearExpression value
	bits := api.ToBinary(linearExpression, 10)
	a := api.FromBinary(bits...)
	api.AssertIsEqual(a, 45)
	return nil
}
func init() {
	{
		good := []frontend.Circuit{
			&recursiveHint{
				A: 42,
			},
		}
		bad := []frontend.Circuit{
			&recursiveHint{
				A: 1,
			},
		}
		addNewEntry(""recursive_hint"", &recursiveHint{}, good, bad, nil, make3, bits.GetHints()[1])
	}
	{
		good := []frontend.Circuit{
			&hintCircuit{
				A: 42,
				B: 42 * 7,
			},
		}
		bad := []frontend.Circuit{
			&hintCircuit{
				A: 42,
				B: 42,
			},
		}
		addNewEntry(""hint"", &hintCircuit{}, good, bad, nil, mulBy7, make3)
	}
	{
		good := []frontend.Circuit{
			&vectorDoubleCircuit{
				A: []frontend.Variable{
					1, 2, 3, 4, 5, 6, 7, 8,
				},
				B: []frontend.Variable{
					2, 4, 6, 8, 10, 12, 14, 16,
				},
			},
		}
		bad := []frontend.Circuit{
			&vectorDoubleCircuit{
				A: []frontend.Variable{
					1, 2, 3, 4, 5, 6, 7, 8,
				},
				B: []frontend.Variable{
					1, 2, 3, 4, 5, 6, 7, 8,
				},
			},
		}
		addNewEntry(""multi-output-hint"", &vectorDoubleCircuit{A: make([]frontend.Variable, 8), B: make([]frontend.Variable, 8)}, good, bad, nil, dvHint)
	}
}
var mulBy7 = func(q *big.Int, inputs []*big.Int, result []*big.Int) error {
	result[0].Mul(inputs[0], big.NewInt(7)).Mod(result[0], q)
	return nil
}
var make3 = func(_ *big.Int, inputs []*big.Int, result []*big.Int) error {
	result[0].SetUint64(3)
	return nil
}
var dvHint = func(_ *big.Int, inputs []*big.Int, res []*big.Int) error {
	two := big.NewInt(2)
	for i := range inputs {
		res[i].Mul(two, inputs[i])
	}
	return nil
}
",CWE-697,157.0,1
"package bits
import (
	""errors""
	""github.com/consensys/gnark/frontend""
)
// Base defines the base for decomposing the scalar into digits.
type Base uint8
const (
	// Binary base decomposes scalar into bits (0-1)
	Binary Base = 2
	// Ternary base decomposes scalar into trits (0-1-2)
	Ternary Base = 3
)
// ToBase decomposes scalar v into digits in given base using options opts. The
// decomposition is in little-endian order.
func ToBase(api frontend.API, base Base, v frontend.Variable, opts ...BaseConversionOption) []frontend.Variable {
	switch base {
	case Binary:
		return toBinary(api, v, opts...)
	case Ternary:
		return toTernary(api, v, opts...)
	default:
		panic(""not implemented"")
	}
}
// FromBase compute from a set of digits its canonical representation in
// little-endian order.
// For example for base 2, it returns Σbi = Σ (2**i * digits[i])
func FromBase(api frontend.API, base Base, digits []frontend.Variable, opts ...BaseConversionOption) frontend.Variable {
	if len(digits) == 0 {
		panic(""FromBase needs at least 1 digit"")
	}
	switch base {
	case Binary:
		return fromBinary(api, digits, opts...)
	case Ternary:
		return fromTernary(api, digits, opts...)
	default:
		panic(""not implemented"")
	}
}
type baseConversionConfig struct {
	NbDigits             int
	UnconstrainedOutputs bool
	UnconstrainedInputs  bool
}
// BaseConversionOption configures the behaviour of scalar decomposition.
type BaseConversionOption func(opt *baseConversionConfig) error
// WithNbDigits sets the resulting number of digits (nbDigits) to be used in the base conversion.
// nbDigits must be > 0. If nbDigits is lower than the length of full decomposition and
// WithUnconstrainedOutputs option is not used, then the conversion functions will generate an
// unsatisfiable constraint. If WithNbDigits option is not set, then the full decomposition is
// returned.
func WithNbDigits(nbDigits int) BaseConversionOption {
	return func(opt *baseConversionConfig) error {
		if nbDigits <= 0 {
			return errors.New(""nbDigits <= 0"")
		}
		opt.NbDigits = nbDigits
		return nil
	}
}
// WithUnconstrainedOutputs sets the bit conversion API to NOT constrain the output bits.
// This is UNSAFE but is useful when the outputs are already constrained by other circuit
// constraints.
// The sum of the digits will is constrained like so Σbi = Σ (base**i * digits[i])
// But the individual digits are not constrained to be valid digits in base b.
func WithUnconstrainedOutputs() BaseConversionOption {
	return func(opt *baseConversionConfig) error {
		opt.UnconstrainedOutputs = true
		return nil
	}
}
// WithUnconstrainedInputs indicates to the FromBase apis to constrain its inputs (digits) to
// ensure they are valid digits in base b. For example, FromBinary without this option will add
// 1 constraint per bit to ensure it is either 0 or 1.
func WithUnconstrainedInputs() BaseConversionOption {
	return func(opt *baseConversionConfig) error {
		opt.UnconstrainedInputs = true
		return nil
	}
}
",CWE-191,95.0,1
"package bits
import (
	""errors""
	""github.com/consensys/gnark/frontend""
)
// Base defines the base for decomposing the scalar into digits.
type Base uint8
const (
	// Binary base decomposes scalar into bits (0-1)
	Binary Base = 2
	// Ternary base decomposes scalar into trits (0-1-2)
	Ternary Base = 3
)
// ToBase decomposes scalar v into digits in given base using options opts. The
// decomposition is in little-endian order.
func ToBase(api frontend.API, base Base, v frontend.Variable, opts ...BaseConversionOption) []frontend.Variable {
	switch base {
	case Binary:
		return toBinary(api, v, opts...)
	case Ternary:
		return toTernary(api, v, opts...)
	default:
		panic(""not implemented"")
	}
}
// FromBase compute from a set of digits its canonical representation in
// little-endian order.
// For example for base 2, it returns Σbi = Σ (2**i * digits[i])
func FromBase(api frontend.API, base Base, digits []frontend.Variable, opts ...BaseConversionOption) frontend.Variable {
	if len(digits) == 0 {
		panic(""FromBase needs at least 1 digit"")
	}
	switch base {
	case Binary:
		return fromBinary(api, digits, opts...)
	case Ternary:
		return fromTernary(api, digits, opts...)
	default:
		panic(""not implemented"")
	}
}
type baseConversionConfig struct {
	NbDigits             int
	UnconstrainedOutputs bool
	UnconstrainedInputs  bool
}
// BaseConversionOption configures the behaviour of scalar decomposition.
type BaseConversionOption func(opt *baseConversionConfig) error
// WithNbDigits sets the resulting number of digits (nbDigits) to be used in the base conversion.
// nbDigits must be > 0. If nbDigits is lower than the length of full decomposition and
// WithUnconstrainedOutputs option is not used, then the conversion functions will generate an
// unsatisfiable constraint. If WithNbDigits option is not set, then the full decomposition is
// returned.
func WithNbDigits(nbDigits int) BaseConversionOption {
	return func(opt *baseConversionConfig) error {
		if nbDigits <= 0 {
			return errors.New(""nbDigits <= 0"")
		}
		opt.NbDigits = nbDigits
		return nil
	}
}
// WithUnconstrainedOutputs sets the bit conversion API to NOT constrain the output bits.
// This is UNSAFE but is useful when the outputs are already constrained by other circuit
// constraints.
// The sum of the digits will is constrained like so Σbi = Σ (base**i * digits[i])
// But the individual digits are not constrained to be valid digits in base b.
func WithUnconstrainedOutputs() BaseConversionOption {
	return func(opt *baseConversionConfig) error {
		opt.UnconstrainedOutputs = true
		return nil
	}
}
// WithUnconstrainedInputs indicates to the FromBase apis to constrain its inputs (digits) to
// ensure they are valid digits in base b. For example, FromBinary without this option will add
// 1 constraint per bit to ensure it is either 0 or 1.
func WithUnconstrainedInputs() BaseConversionOption {
	return func(opt *baseConversionConfig) error {
		opt.UnconstrainedInputs = true
		return nil
	}
}
",CWE-697,95.0,1
"package bits
import (
	""math/big""
	""github.com/consensys/gnark/frontend""
)
// ToBinary is an alias of ToBase(api, Binary, v, opts)
func ToBinary(api frontend.API, v frontend.Variable, opts ...BaseConversionOption) []frontend.Variable {
	return ToBase(api, Binary, v, opts...)
}
// FromBinary is an alias of FromBase(api, Binary, digits)
func FromBinary(api frontend.API, digits []frontend.Variable, opts ...BaseConversionOption) frontend.Variable {
	return FromBase(api, Binary, digits, opts...)
}
func fromBinary(api frontend.API, digits []frontend.Variable, opts ...BaseConversionOption) frontend.Variable {
	cfg := baseConversionConfig{}
	for _, o := range opts {
		if err := o(&cfg); err != nil {
			panic(err)
		}
	}
	// Σbi = Σ (2**i * b[i])
	Σbi := frontend.Variable(0)
	c := big.NewInt(1)
	for i := 0; i < len(digits); i++ {
		if !cfg.UnconstrainedInputs {
			api.AssertIsBoolean(digits[i]) // ensures the digits are actual bits
		}
		Σbi = api.Add(Σbi, api.Mul(c, digits[i])) // no constraint is recorded
		c.Lsh(c, 1)
	}
	return Σbi
}
func toBinary(api frontend.API, v frontend.Variable, opts ...BaseConversionOption) []frontend.Variable {
	// parse options
	cfg := baseConversionConfig{
		NbDigits:             api.Compiler().FieldBitLen(),
		UnconstrainedOutputs: false,
	}
	for _, o := range opts {
		if err := o(&cfg); err != nil {
			panic(err)
		}
	}
	// when cfg.NbDigits == 1, v itself has to be a binary digit. This if clause
	// saves one constraint.
	if cfg.NbDigits == 1 {
		api.AssertIsBoolean(v)
		return []frontend.Variable{v}
	}
	c := big.NewInt(1)
	bits, err := api.Compiler().NewHint(nBits, cfg.NbDigits, v)
	if err != nil {
		panic(err)
	}
	var Σbi frontend.Variable
	Σbi = 0
	for i := 0; i < cfg.NbDigits; i++ {
		Σbi = api.Add(Σbi, api.Mul(bits[i], c))
		c.Lsh(c, 1)
		if !cfg.UnconstrainedOutputs {
			api.AssertIsBoolean(bits[i])
		}
	}
	// record the constraint Σ (2**i * b[i]) == a
	api.AssertIsEqual(Σbi, v)
	return bits
}
",CWE-191,88.0,1
"package bits
import (
	""math/big""
	""github.com/consensys/gnark/frontend""
)
// ToBinary is an alias of ToBase(api, Binary, v, opts)
func ToBinary(api frontend.API, v frontend.Variable, opts ...BaseConversionOption) []frontend.Variable {
	return ToBase(api, Binary, v, opts...)
}
// FromBinary is an alias of FromBase(api, Binary, digits)
func FromBinary(api frontend.API, digits []frontend.Variable, opts ...BaseConversionOption) frontend.Variable {
	return FromBase(api, Binary, digits, opts...)
}
func fromBinary(api frontend.API, digits []frontend.Variable, opts ...BaseConversionOption) frontend.Variable {
	cfg := baseConversionConfig{}
	for _, o := range opts {
		if err := o(&cfg); err != nil {
			panic(err)
		}
	}
	// Σbi = Σ (2**i * b[i])
	Σbi := frontend.Variable(0)
	c := big.NewInt(1)
	for i := 0; i < len(digits); i++ {
		if !cfg.UnconstrainedInputs {
			api.AssertIsBoolean(digits[i]) // ensures the digits are actual bits
		}
		Σbi = api.Add(Σbi, api.Mul(c, digits[i])) // no constraint is recorded
		c.Lsh(c, 1)
	}
	return Σbi
}
func toBinary(api frontend.API, v frontend.Variable, opts ...BaseConversionOption) []frontend.Variable {
	// parse options
	cfg := baseConversionConfig{
		NbDigits:             api.Compiler().FieldBitLen(),
		UnconstrainedOutputs: false,
	}
	for _, o := range opts {
		if err := o(&cfg); err != nil {
			panic(err)
		}
	}
	// when cfg.NbDigits == 1, v itself has to be a binary digit. This if clause
	// saves one constraint.
	if cfg.NbDigits == 1 {
		api.AssertIsBoolean(v)
		return []frontend.Variable{v}
	}
	c := big.NewInt(1)
	bits, err := api.Compiler().NewHint(nBits, cfg.NbDigits, v)
	if err != nil {
		panic(err)
	}
	var Σbi frontend.Variable
	Σbi = 0
	for i := 0; i < cfg.NbDigits; i++ {
		Σbi = api.Add(Σbi, api.Mul(bits[i], c))
		c.Lsh(c, 1)
		if !cfg.UnconstrainedOutputs {
			api.AssertIsBoolean(bits[i])
		}
	}
	// record the constraint Σ (2**i * b[i]) == a
	api.AssertIsEqual(Σbi, v)
	return bits
}
",CWE-697,88.0,1
"// Copyright 2017 Eric Zhou. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package base64Captcha
import (
	""container/list""
	""sync""
	""time""
)
// expValue stores timestamp and id of captchas. It is used in the list inside
// memoryStore for indexing generated captchas by timestamp to enable garbage
// collection of expired captchas.
type idByTimeValue struct {
	timestamp time.Time
	id        string
}
// memoryStore is an internal store for captcha ids and their values.
type memoryStore struct {
	sync.RWMutex
	digitsById map[string]string
	idByTime   *list.List
	// Number of items stored since last collection.
	numStored int
	// Number of saved items that triggers collection.
	collectNum int
	// Expiration time of captchas.
	expiration time.Duration
}
// NewMemoryStore returns a new standard memory store for captchas with the
// given collection threshold and expiration time (duration). The returned
// store must be registered with SetCustomStore to replace the default one.
func NewMemoryStore(collectNum int, expiration time.Duration) Store {
	s := new(memoryStore)
	s.digitsById = make(map[string]string)
	s.idByTime = list.New()
	s.collectNum = collectNum
	s.expiration = expiration
	return s
}
func (s *memoryStore) Set(id string, value string) error {
	s.Lock()
	s.digitsById[id] = value
	s.idByTime.PushBack(idByTimeValue{time.Now(), id})
	s.numStored++
	s.Unlock()
	if s.numStored > s.collectNum {
		go s.collect()
	}
	return nil
}
func (s *memoryStore) Verify(id, answer string, clear bool) bool {
	v := s.Get(id, clear)
	return v == answer
}
func (s *memoryStore) Get(id string, clear bool) (value string) {
	if !clear {
		// When we don't need to clear captcha, acquire read lock.
		s.RLock()
		defer s.RUnlock()
	} else {
		s.Lock()
		defer s.Unlock()
	}
	value, ok := s.digitsById[id]
	if !ok {
		return
	}
	if clear {
		delete(s.digitsById, id)
	}
	return
}
func (s *memoryStore) collect() {
	now := time.Now()
	s.Lock()
	defer s.Unlock()
	for e := s.idByTime.Front(); e != nil; {
		e = s.collectOne(e, now)
	}
}
func (s *memoryStore) collectOne(e *list.Element, specifyTime time.Time) *list.Element {
	ev, ok := e.Value.(idByTimeValue)
	if !ok {
		return nil
	}
	if ev.timestamp.Add(s.expiration).Before(specifyTime) {
		delete(s.digitsById, ev.id)
		next := e.Next()
		s.idByTime.Remove(e)
		s.numStored--
		return next
	}
	return nil
}
",CWE-345,117.0,1
"// Copyright 2017 Eric Zhou. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package base64Captcha
import (
	""container/list""
	""sync""
	""time""
)
// expValue stores timestamp and id of captchas. It is used in the list inside
// memoryStore for indexing generated captchas by timestamp to enable garbage
// collection of expired captchas.
type idByTimeValue struct {
	timestamp time.Time
	id        string
}
// memoryStore is an internal store for captcha ids and their values.
type memoryStore struct {
	sync.RWMutex
	digitsById map[string]string
	idByTime   *list.List
	// Number of items stored since last collection.
	numStored int
	// Number of saved items that triggers collection.
	collectNum int
	// Expiration time of captchas.
	expiration time.Duration
}
// NewMemoryStore returns a new standard memory store for captchas with the
// given collection threshold and expiration time (duration). The returned
// store must be registered with SetCustomStore to replace the default one.
func NewMemoryStore(collectNum int, expiration time.Duration) Store {
	s := new(memoryStore)
	s.digitsById = make(map[string]string)
	s.idByTime = list.New()
	s.collectNum = collectNum
	s.expiration = expiration
	return s
}
func (s *memoryStore) Set(id string, value string) error {
	s.Lock()
	s.digitsById[id] = value
	s.idByTime.PushBack(idByTimeValue{time.Now(), id})
	s.numStored++
	s.Unlock()
	if s.numStored > s.collectNum {
		go s.collect()
	}
	return nil
}
func (s *memoryStore) Verify(id, answer string, clear bool) bool {
	v := s.Get(id, clear)
	return v != """" && v == answer
}
func (s *memoryStore) Get(id string, clear bool) (value string) {
	if !clear {
		// When we don't need to clear captcha, acquire read lock.
		s.RLock()
		defer s.RUnlock()
	} else {
		s.Lock()
		defer s.Unlock()
	}
	value, ok := s.digitsById[id]
	if !ok {
		return
	}
	if clear {
		delete(s.digitsById, id)
	}
	return
}
func (s *memoryStore) collect() {
	now := time.Now()
	s.Lock()
	defer s.Unlock()
	for e := s.idByTime.Front(); e != nil; {
		e = s.collectOne(e, now)
	}
}
func (s *memoryStore) collectOne(e *list.Element, specifyTime time.Time) *list.Element {
	ev, ok := e.Value.(idByTimeValue)
	if !ok {
		return nil
	}
	if ev.timestamp.Add(s.expiration).Before(specifyTime) {
		delete(s.digitsById, ev.id)
		next := e.Next()
		s.idByTime.Remove(e)
		s.numStored--
		return next
	}
	return nil
}
",CWE-345,117.0,1
"// Copyright 2017 Eric Zhou. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package base64Captcha
import (
	""fmt""
	""math/rand""
	""testing""
	""time""
)
func TestSetGet(t *testing.T) {
	s := NewMemoryStore(GCLimitNumber, Expiration)
	id := ""captcha id""
	d := ""random-string""
	_ = s.Set(id, d)
	d2 := s.Get(id, false)
	if d2 != d {
		t.Errorf(""saved %v, getDigits returned got %v"", d, d2)
	}
}
func TestGetClear(t *testing.T) {
	s := NewMemoryStore(GCLimitNumber, Expiration)
	id := ""captcha id""
	d := ""932839jfffjkdss""
	_ = s.Set(id, d)
	d2 := s.Get(id, true)
	if d != d2 {
		t.Errorf(""saved %v, getDigitsClear returned got %v"", d, d2)
	}
	d2 = s.Get(id, false)
	if d2 != """" {
		t.Errorf(""getDigitClear didn't clear (%q=%v)"", id, d2)
	}
}
func BenchmarkSetCollect(b *testing.B) {
	b.StopTimer()
	d := ""fdskfew9832232r""
	s := NewMemoryStore(9999, -1)
	ids := make([]string, 1000)
	for i := range ids {
		ids[i] = fmt.Sprintf(""%d"", rand.Int63())
	}
	b.StartTimer()
	for i := 0; i < b.N; i++ {
		for j := 0; j < 1000; j++ {
			_ = s.Set(ids[j], d)
		}
	}
}
func TestMemoryStore_SetGoCollect(t *testing.T) {
	s := NewMemoryStore(10, -1)
	for i := 0; i <= 100; i++ {
		_ = s.Set(fmt.Sprint(i), fmt.Sprint(i))
	}
}
func TestMemoryStore_CollectNotExpire(t *testing.T) {
	s := NewMemoryStore(10, time.Hour)
	for i := 0; i < 50; i++ {
		_ = s.Set(fmt.Sprint(i), fmt.Sprint(i))
	}
	// let background goroutine to go
	time.Sleep(time.Second)
	if v := s.Get(""0"", false); v != ""0"" {
		t.Error(""mem store get failed"")
	}
}
func TestNewMemoryStore(t *testing.T) {
	type args struct {
		collectNum int
		expiration time.Duration
	}
	tests := []struct {
		name string
		args args
		want Store
	}{
		{"""", args{20, time.Hour}, nil},
		{"""", args{20, time.Hour * 5}, nil},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := NewMemoryStore(tt.args.collectNum, tt.args.expiration); got == nil {
				t.Errorf(""NewMemoryStore() = %v, want %v"", got, tt.want)
			}
		})
	}
}
func Test_memoryStore_Set(t *testing.T) {
	thisStore := NewMemoryStore(10, time.Hour)
	type args struct {
		id    string
		value string
	}
	tests := []struct {
		name string
		s    Store
		args args
	}{
		{"""", thisStore, args{RandomId(), RandomId()}},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			_ = tt.s.Set(tt.args.id, tt.args.value)
		})
	}
}
func Test_memoryStore_Verify(t *testing.T) {
	thisStore := NewMemoryStore(10, time.Hour)
	_ = thisStore.Set(""xx"", ""xx"")
	got := thisStore.Verify(""xx"", ""xx"", false)
	if !got {
		t.Error(""failed1"")
	}
	got = thisStore.Verify(""xx"", ""xx"", true)
	if !got {
		t.Error(""failed2"")
	}
	got = thisStore.Verify(""xx"", ""xx"", true)
	if got {
		t.Error(""failed3"")
	}
}
func Test_memoryStore_Get(t *testing.T) {
	thisStore := NewMemoryStore(10, time.Hour)
	_ = thisStore.Set(""xx"", ""xx"")
	got := thisStore.Get(""xx"", false)
	if got != ""xx"" {
		t.Error(""failed1"")
	}
	got = thisStore.Get(""xx"", true)
	if got != ""xx"" {
		t.Error(""failed2"")
	}
	got = thisStore.Get(""xx"", false)
	if got == ""xx"" {
		t.Error(""failed3"")
	}
}
",CWE-345,165.0,1
"// Copyright 2020-2023 Project Capsule Authors.
// SPDX-License-Identifier: Apache-2.0
package request
import (
	""fmt""
	h ""net/http""
	""strings""
	authenticationv1 ""k8s.io/api/authentication/v1""
	authorizationv1 ""k8s.io/api/authorization/v1""
	""sigs.k8s.io/controller-runtime/pkg/client""
)
type http struct {
	*h.Request
	authTypes          []AuthType
	usernameClaimField string
	client             client.Writer
}
func NewHTTP(request *h.Request, authTypes []AuthType, usernameClaimField string, client client.Writer) Request {
	return &http{Request: request, authTypes: authTypes, usernameClaimField: usernameClaimField, client: client}
}
func (h http) GetHTTPRequest() *h.Request {
	return h.Request
}
//nolint:funlen
func (h http) GetUserAndGroups() (username string, groups []string, err error) {
	for _, fn := range h.authenticationFns() {
		// User authentication data is extracted according to the preferred order:
		// in case of first match blocking the iteration
		if username, groups, err = fn(); err == nil {
			break
		}
	}
	// In case of error, we're blocking the request flow here
	if err != nil {
		return """", nil, err
	}
	// In case the requester is asking for impersonation, we have to be sure that's allowed by creating a
	// SubjectAccessReview with the requested data, before proceeding.
	if impersonateGroups := GetImpersonatingGroups(h.Request); len(impersonateGroups) > 0 {
		for _, impersonateGroup := range impersonateGroups {
			ac := &authorizationv1.SubjectAccessReview{
				Spec: authorizationv1.SubjectAccessReviewSpec{
					ResourceAttributes: &authorizationv1.ResourceAttributes{
						Verb:     ""impersonate"",
						Resource: ""groups"",
						Name:     impersonateGroup,
					},
					User:   username,
					Groups: groups,
				},
			}
			if err = h.client.Create(h.Request.Context(), ac); err != nil {
				return """", nil, err
			}
			if !ac.Status.Allowed {
				return """", nil, NewErrUnauthorized(fmt.Sprintf(""the current user %s cannot impersonate the group %s"", username, impersonateGroup))
			}
		}
		defer func() {
			groups = impersonateGroups
		}()
	}
	if impersonateUser := GetImpersonatingUser(h.Request); len(impersonateUser) > 0 {
		ac := &authorizationv1.SubjectAccessReview{
			Spec: authorizationv1.SubjectAccessReviewSpec{
				ResourceAttributes: &authorizationv1.ResourceAttributes{
					Verb:     ""impersonate"",
					Resource: ""users"",
					Name:     impersonateUser,
				},
				User:   username,
				Groups: groups,
			},
		}
		if err = h.client.Create(h.Request.Context(), ac); err != nil {
			return """", nil, err
		}
		if !ac.Status.Allowed {
			return """", nil, NewErrUnauthorized(fmt.Sprintf(""the current user %s cannot impersonate the user %s"", username, impersonateUser))
		}
		// Assign impersonate user after group impersonation with current user
		// As defer func works in LIFO, if user is also impersonating groups, they will be set to correct value in the previous defer func.
		// Otherwise, groups will be set to nil, meaning we are checking just user permissions.
		defer func() {
			username = impersonateUser
			groups = nil
		}()
	}
	return username, groups, nil
}
func (h http) processBearerToken() (username string, groups []string, err error) {
	tr := &authenticationv1.TokenReview{
		Spec: authenticationv1.TokenReviewSpec{
			Token: h.bearerToken(),
		},
	}
	if err = h.client.Create(h.Request.Context(), tr); err != nil {
		return """", nil, fmt.Errorf(""cannot create TokenReview"")
	}
	if statusErr := tr.Status.Error; len(statusErr) > 0 {
		return """", nil, fmt.Errorf(""cannot verify the token due to error"")
	}
	return tr.Status.User.Username, tr.Status.User.Groups, nil
}
func (h http) bearerToken() string {
	return strings.ReplaceAll(h.Header.Get(""Authorization""), ""Bearer "", """")
}
type authenticationFn func() (username string, groups []string, err error)
func (h http) authenticationFns() []authenticationFn {
	fns := make([]authenticationFn, 0, len(h.authTypes)+1)
	for _, authType := range h.authTypes {
		//nolint:exhaustive
		switch authType {
		case BearerToken:
			fns = append(fns, func() (username string, groups []string, err error) {
				if len(h.bearerToken()) == 0 {
					return """", nil, NewErrUnauthorized(""unauthenticated users not supported"")
				}
				return h.processBearerToken()
			})
		case TLSCertificate:
			// If the proxy is handling a non TLS connection, we have to skip the authentication strategy,
			// since the TLS section of the request would be nil.
			if h.TLS == nil {
				break
			}
			fns = append(fns, func() (username string, groups []string, err error) {
				if pc := h.TLS.PeerCertificates; len(pc) == 0 {
					err = NewErrUnauthorized(""no provided peer certificates"")
				} else {
					username, groups = pc[0].Subject.CommonName, pc[0].Subject.Organization
				}
				return
			})
		}
	}
	// Dead man switch, if no strategy worked, the proxy cannot work
	fns = append(fns, func() (string, []string, error) {
		return """", nil, NewErrUnauthorized(""unauthenticated users not supported"")
	})
	return fns
}
",CWE-287,169.0,1
"package models
import (
	""encoding/json""
	""strings""
	""github.com/gofrs/uuid""
	""github.com/layer5io/meshkit/database""
)
// MesheryApplicationPersister is the persister for persisting
// applications on the database
type MesheryApplicationPersister struct {
	DB *database.Handler
}
// MesheryApplicationPage represents a page of applications
type MesheryApplicationPage struct {
	Page         uint64                `json:""page""`
	PageSize     uint64                `json:""page_size""`
	TotalCount   int                   `json:""total_count""`
	Applications []*MesheryApplication `json:""applications""`
}
// GetMesheryApplications returns all of the applications
func (maap *MesheryApplicationPersister) GetMesheryApplications(search, order string, page, pageSize uint64, updatedAfter string) ([]byte, error) {
	order = sanitizeOrderInput(order, []string{""created_at"", ""updated_at"", ""name""})
	if order == """" {
		order = ""updated_at desc""
	}
	count := int64(0)
	applications := []*MesheryApplication{}
	query := maap.DB.Where(""updated_at > ?"", updatedAfter).Order(order)
	if search != """" {
		like := ""%"" + strings.ToLower(search) + ""%""
		query = query.Where(""(lower(meshery_applications.name) like ?)"", like)
	}
	query.Table(""meshery_applications"").Count(&count)
	Paginate(uint(page), uint(pageSize))(query).Find(&applications)
	mesheryApplicationPage := &MesheryApplicationPage{
		Page:         page,
		PageSize:     pageSize,
		TotalCount:   int(count),
		Applications: applications,
	}
	return marshalMesheryApplicationPage(mesheryApplicationPage), nil
}
// DeleteMesheryApplication takes in an application id and delete it if it already exists
func (maap *MesheryApplicationPersister) DeleteMesheryApplication(id uuid.UUID) ([]byte, error) {
	application := MesheryApplication{ID: &id}
	err := maap.DB.Delete(&application).Error
	return marshalMesheryApplication(&application), err
}
func (maap *MesheryApplicationPersister) SaveMesheryApplication(application *MesheryApplication) ([]byte, error) {
	if application.ID == nil {
		id, err := uuid.NewV4()
		if err != nil {
			return nil, ErrGenerateUUID(err)
		}
		application.ID = &id
	}
	return marshalMesheryApplications([]MesheryApplication{*application}), maap.DB.Save(application).Error
}
// SaveMesheryApplications batch inserts the given applications
func (maap *MesheryApplicationPersister) SaveMesheryApplications(applications []MesheryApplication) ([]byte, error) {
	finalApplications := []MesheryApplication{}
	for _, application := range applications {
		if application.ID == nil {
			id, err := uuid.NewV4()
			if err != nil {
				return nil, ErrGenerateUUID(err)
			}
			application.ID = &id
		}
		finalApplications = append(finalApplications, application)
	}
	return marshalMesheryApplications(finalApplications), maap.DB.Create(finalApplications).Error
}
func (maap *MesheryApplicationPersister) GetMesheryApplication(id uuid.UUID) ([]byte, error) {
	var mesheryApplication MesheryApplication
	err := maap.DB.First(&mesheryApplication, id).Error
	return marshalMesheryApplication(&mesheryApplication), err
}
func (maap *MesheryApplicationPersister) GetMesheryApplicationSource(id uuid.UUID) ([]byte, error) {
	var mesheryApplication MesheryApplication
	err := maap.DB.First(&mesheryApplication, id).Error
	return mesheryApplication.SourceContent, err
}
func marshalMesheryApplicationPage(maap *MesheryApplicationPage) []byte {
	res, _ := json.Marshal(maap)
	return res
}
func marshalMesheryApplication(ma *MesheryApplication) []byte {
	res, _ := json.Marshal(ma)
	return res
}
func marshalMesheryApplications(mas []MesheryApplication) []byte {
	res, _ := json.Marshal(mas)
	return res
}
",CWE-89,126.0,1
"package models
import (
	""encoding/json""
	""strings""
	""github.com/layer5io/meshery/server/models/connections""
	""github.com/layer5io/meshkit/database""
	""gorm.io/gorm""
)
// MesheryK8sContextPersister is the persister for persisting
// applications on the database
type MesheryK8sContextPersister struct {
	DB *database.Handler
}
// MesheryK8sContextPage represents a page of contexts
type MesheryK8sContextPage struct {
	Page       uint64        `json:""page""`
	PageSize   uint64        `json:""page_size""`
	TotalCount int           `json:""total_count""`
	Contexts   []*K8sContext `json:""contexts""`
}
// GetMesheryK8sContexts returns all of the contexts
func (mkcp *MesheryK8sContextPersister) GetMesheryK8sContexts(search, order string, page, pageSize uint64) ([]byte, error) {
	order = sanitizeOrderInput(order, []string{""created_at"", ""updated_at"", ""name""})
	if order == """" {
		order = ""updated_at desc""
	}
	count := int64(0)
	contexts := []*K8sContext{}
	query := mkcp.DB.Order(order)
	if search != """" {
		like := ""%"" + strings.ToLower(search) + ""%""
		query = query.Where(""(lower(name) like ?)"", like)
	}
	query.Model(K8sContext{}).Count(&count)
	Paginate(uint(page), uint(pageSize))(query).Find(&contexts)
	mesheryK8sContextPage := MesheryK8sContextPage{
		Page:       page,
		PageSize:   pageSize,
		TotalCount: int(count),
		Contexts:   contexts,
	}
	resp, _ := json.Marshal(mesheryK8sContextPage)
	return resp, nil
}
// DeleteMesheryK8sContext takes in an application id and delete it if it already exists
func (mkcp *MesheryK8sContextPersister) DeleteMesheryK8sContext(id string) (K8sContext, error) {
	context := K8sContext{ID: id}
	mkcp.DB.Delete(&context)
	return context, nil
}
func (mkcp *MesheryK8sContextPersister) SaveMesheryK8sContext(mkc K8sContext) (connections.Connection, error) {
	conn := connections.Connection{}
	if mkc.ID == """" {
		id, err := K8sContextGenerateID(mkc)
		if err != nil {
			return conn, ErrContextID
		}
		mkc.ID = id
	}
	// Perform the operation in a transaction
	err := mkcp.DB.Transaction(func(tx *gorm.DB) error {
		var mesheryK8sContext K8sContext
		// Check if there is already an entry for this context
		if err := tx.First(&mesheryK8sContext, ""id = ?"", mkc.ID).Error; err == nil {
			return ErrContextAlreadyPersisted
		}
		return tx.Save(&mkc).Error
	})
	return conn, err
}
func (mkcp *MesheryK8sContextPersister) GetMesheryK8sContext(id string) (K8sContext, error) {
	var mesheryK8sContext K8sContext
	err := mkcp.DB.First(&mesheryK8sContext, ""id = ?"", id).Error
	return mesheryK8sContext, err
}
// func (mkcp *MesheryK8sContextPersister) SetMesheryK8sCurrentContext(id string) error {
// 	// Perform the operation in a transaction
// 	return mkcp.DB.Transaction(func(tx *gorm.DB) error {
// 		var mesheryK8sContext K8sContext
// 		// Get context which is currently in use
// 		if err := tx.First(&mesheryK8sContext, ""is_current_context = true"").Error; err != nil {
// 			return err
// 		}
// 		// If the context id matches with the provided id then skip the next steps
// 		if mesheryK8sContext.ID == id {
// 			return nil
// 		}
// 		if err := tx.Save(&mesheryK8sContext).Error; err != nil {
// 			return err
// 		}
// 		// Set the specified context as active
// 		return tx.Model(K8sContext{}).Where(""id = ?"", id).Update(""is_current_context"", true).Error
// 	})
// }
// func (mkcp *MesheryK8sContextPersister) GetMesheryK8sCurrentContext() (K8sContext, error) {
// 	var mesheryK8sContext K8sContext
// 	err := mkcp.DB.First(&mesheryK8sContext, ""is_current_context = true"").Error
// 	return mesheryK8sContext, err
// }
",CWE-89,131.0,1
"package models
import (
	""strings""
	""github.com/gofrs/uuid""
	""github.com/layer5io/meshkit/database""
)
type PatternResourcePersister struct {
	DB *database.Handler
}
type PatternResourcePage struct {
	Page       uint64             `json:""page,omitempty""`
	PageSize   uint64             `json:""page_size,omitempty""`
	TotalCount int                `json:""total_count,omitempty""`
	Resources  []*PatternResource `json:""resources,omitempty""`
}
func (prp *PatternResourcePersister) SavePatternResource(pr *PatternResource) (*PatternResource, error) {
	if pr.ID == nil {
		id, err := uuid.NewV4()
		if err != nil {
			return nil, ErrGenerateUUID(err)
		}
		pr.ID = &id
	}
	return pr, prp.DB.Create(pr).Error
}
func (prp *PatternResourcePersister) DeletePatternResource(id uuid.UUID) error {
	return prp.DB.Model(&PatternResource{}).Where(""id = ?"", id).Update(""deleted"", true).Error
}
func (prp *PatternResourcePersister) GetPatternResource(id uuid.UUID) (*PatternResource, error) {
	var pr PatternResource
	err := prp.DB.First(&pr, id).Error
	return &pr, err
}
func (prp *PatternResourcePersister) GetPatternResourceByAttributes(name, namespace, typ, oamType string) (*PatternResource, error) {
	var pr PatternResource
	err := Paginate(0, 1)(prp.DB.Model(&PatternResource{}).Where(
		""name = ? AND namespace = ? AND type = ? AND oam_type = ? AND deleted = false"",
		name,
		namespace,
		typ,
		oamType,
	)).Scan(&pr).Error
	return &pr, err
}
func (prp *PatternResourcePersister) GetPatternResources(search, order, name, namespace, typ, oamType string, page, pageSize uint64) (*PatternResourcePage, error) {
	order = sanitizeOrderInput(order, []string{""created_at"", ""updated_at"", ""name""})
	if order == """" {
		order = ""updated_at desc""
	}
	count := int64(0)
	resources := []*PatternResource{}
	query := prp.DB.Order(order).Where(""deleted = false"")
	if search != """" {
		like := ""%"" + strings.ToLower(search) + ""%""
		query = query.Where(""(lower(pattern_resources.name) like ?)"", like)
	}
	if name != """" {
		query = query.Where(""name = ?"", name)
	}
	if namespace != """" {
		query = query.Where(""namespace = ?"", namespace)
	}
	if typ != """" {
		query = query.Where(""type = ?"", typ)
	}
	if oamType != """" {
		query = query.Where(""oam_type = ?"", oamType)
	}
	query.Model(&PatternResource{}).Count(&count)
	Paginate(uint(page), uint(pageSize))(query).Find(&resources)
	patternResourcePage := &PatternResourcePage{
		Page:       page,
		PageSize:   pageSize,
		TotalCount: int(count),
		Resources:  resources,
	}
	return patternResourcePage, nil
}
func (prp *PatternResourcePersister) Exists(name, namespace, typ, oamType string) bool {
	var result struct {
		Found bool
	}
	prp.DB.
		Raw(`
	SELECT 
		EXISTS(SELECT 1 FROM pattern_resources WHERE name = ? AND namespace = ? AND type = ? AND oam_type = ? AND deleted = false) AS ""found""`,
			name,
			namespace,
			typ,
			oamType,
		).
		Scan(&result)
	return result.Found
}
",CWE-89,120.0,1
"package models
import (
	""encoding/json""
	""strings""
	""github.com/gofrs/uuid""
	""github.com/layer5io/meshkit/database""
)
// PerformanceProfilePersister is the persister for persisting
// performance profiles on the database
type PerformanceProfilePersister struct {
	DB *database.Handler
}
// PerformanceProfilePage represents a page of performance profiles
type PerformanceProfilePage struct {
	Page       uint64                `json:""page""`
	PageSize   uint64                `json:""page_size""`
	TotalCount int                   `json:""total_count""`
	Profiles   []*PerformanceProfile `json:""profiles""`
}
// GetPerformanceProfiles returns all of the performance profiles
func (ppp *PerformanceProfilePersister) GetPerformanceProfiles(_, search, order string, page, pageSize uint64) ([]byte, error) {
	order = sanitizeOrderInput(order, []string{""updated_at"", ""created_at"", ""name"", ""last_run""})
	if order == """" {
		order = ""updated_at desc""
	}
	count := int64(0)
	profiles := []*PerformanceProfile{}
	query := ppp.DB.
		Select(`
		id, name, load_generators,
		endpoints, qps, service_mesh,
		duration, request_headers, request_cookies,
		request_body, content_type, created_at,
		updated_at, (?) as last_run, (?) as total_results`,
			ppp.DB.Table(""meshery_results"").Select(""DATETIME(MAX(meshery_results.test_start_time))"").Where(""performance_profile = performance_profiles.id""),
			ppp.DB.Table(""meshery_results"").Select(""COUNT(meshery_results.name)"").Where(""performance_profile = performance_profiles.id""),
		).
		Order(order)
	if search != """" {
		like := ""%"" + strings.ToLower(search) + ""%""
		query = query.Where(""(lower(performance_profiles.name) like ?)"", like)
	}
	query.Table(""performance_profiles"").Count(&count)
	Paginate(uint(page), uint(pageSize))(query).Find(&profiles)
	performanceProfilePage := &PerformanceProfilePage{
		Page:       page,
		PageSize:   pageSize,
		TotalCount: int(count),
		Profiles:   profiles,
	}
	return marshalPerformanceProfilePage(performanceProfilePage), nil
}
// DeletePerformanceProfile takes in a profile id and delete it if it already exists
func (ppp *PerformanceProfilePersister) DeletePerformanceProfile(id uuid.UUID) ([]byte, error) {
	profile := PerformanceProfile{ID: &id}
	ppp.DB.Delete(profile)
	return marshalPerformanceProfile(&profile), nil
}
func (ppp *PerformanceProfilePersister) SavePerformanceProfile(_ uuid.UUID, profile *PerformanceProfile) error {
	return ppp.DB.Save(profile).Error
}
func (ppp *PerformanceProfilePersister) GetPerformanceProfile(id uuid.UUID) (*PerformanceProfile, error) {
	var performanceProfile PerformanceProfile
	err := ppp.DB.First(&performanceProfile, id).Error
	return &performanceProfile, err
}
func marshalPerformanceProfilePage(ppp *PerformanceProfilePage) []byte {
	res, _ := json.Marshal(ppp)
	return res
}
func marshalPerformanceProfile(pp *PerformanceProfile) []byte {
	res, _ := json.Marshal(pp)
	return res
}
",CWE-89,96.0,1
"package models
import (
	""fmt""
	""os""
	""strings""
	""sync""
	""github.com/layer5io/meshkit/database""
	""github.com/layer5io/meshkit/logger""
	""github.com/sirupsen/logrus""
	""github.com/spf13/viper""
)
// sanitizeOrderInput takes in the ""order by"" query, a validColums
// string slice and returns a sanitized query
//
// it will allow to run order by query only on the columns that are present
// in the validColumns string slice, if any other column is requested in the
// query then it will be IGNORED and an empty query would be returned instead
//
// sanitizeOrderInput also expects the query to be no longer than two words, that is
// the query may look like ""updated_at DESC"" or ""name ASC""
func sanitizeOrderInput(order string, validColumns []string) string {
	parsedOrderStr := strings.Split(order, "" "")
	if len(parsedOrderStr) != 2 {
		return """"
	}
	inputCol := parsedOrderStr[0]
	typ := strings.ToLower(parsedOrderStr[1])
	for _, col := range validColumns {
		if col == inputCol {
			if typ == ""desc"" {
				return fmt.Sprintf(""%s desc"", col)
			}
			return fmt.Sprintf(""%s asc"", col)
		}
	}
	return """"
}
var (
	dbHandler database.Handler
	mx        sync.Mutex
)
func setNewDBInstance() {
	mx.Lock()
	defer mx.Unlock()
	// Initialize Logger instance
	log, err := logger.New(""meshery"", logger.Options{
		Format: logger.SyslogLogFormat,
	})
	if err != nil {
		log.Error(err)
		os.Exit(1)
	}
	dbHandler, err = database.New(database.Options{
		Filename: fmt.Sprintf(""file:%s/mesherydb.sql?cache=private&mode=rwc&_busy_timeout=10000&_journal_mode=WAL"", viper.GetString(""USER_DATA_FOLDER"")),
		Engine:   database.SQLITE,
		Logger:   log,
	})
	if err != nil {
		logrus.Fatal(err)
	}
}
func GetNewDBInstance() *database.Handler {
	setNewDBInstance()
	return &dbHandler
}
",CWE-89,77.0,1
"// Copyright 2019 The CubeFS Authors.
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
// implied. See the License for the specific language governing
// permissions and limitations under the License.
package objectnode
import ""os""
const (
	MaxRetry = 3
)
const (
	S3Namespace        = ""http://s3.amazonaws.com/doc/2006-03-01/""
	Server             = ""Server""
	Host               = ""Host""
	LastModified       = ""Last-Modified""
	ETag               = ""ETag""
	Date               = ""Date""
	ContentMD5         = ""Content-MD5""
	ContentEncoding    = ""Content-Encoding""
	ContentType        = ""Content-Type""
	ContentLength      = ""Content-Length""
	ContentRange       = ""Content-Range""
	ContentDisposition = ""Content-Disposition""
	Authorization      = ""Authorization""
	AcceptRanges       = ""Accept-Ranges""
	Range              = ""Range""
	Expect             = ""Expect""
	XForwardedExpect   = ""X-Forwarded-Expect""
	Location           = ""Location""
	CacheControl       = ""Cache-Control""
	Expires            = ""Expires""
	Connection         = ""Connection""
	Signature          = ""Signature""
	Origin             = ""Origin""
	AccessControlRequestMethod    = ""Access-Control-Request-Method""
	AccessControlRequestHeaders   = ""Access-Control-Request-Headers""
	AccessControlAllowOrigin      = ""Access-Control-Allow-Origin""
	AccessControlAllowCredentials = ""Access-Control-Allow-Credentials""
	AccessControlMaxAge           = ""Access-Control-Max-Age""
	AccessControlAllowMethods     = ""Access-Control-Allow-Methods""
	AccessControlAllowHeaders     = ""Access-Control-Allow-Headers""
	AccessControlExposeHeaders    = ""Access-Control-Expose-Headers""
	IfMatch           = ""If-Match""
	IfNoneMatch       = ""If-None-Match""
	IfModifiedSince   = ""If-Modified-Since""
	IfUnmodifiedSince = ""If-Unmodified-Since""
	XAmzRequestId                   = ""x-amz-request-id""
	XAmzCopySource                  = ""x-amz-copy-source""
	XAmzCopySourceRange             = ""x-amz-copy-source-range""
	XAmzCopySourceIfMatch           = ""x-amz-copy-source-if-match""
	XAmzCopySourceIfNoneMatch       = ""x-amz-copy-source-if-none-match""
	XAmzCopySourceIfModifiedSince   = ""x-amz-copy-source-if-modified-since""
	XAmzCopySourceIfUnmodifiedSince = ""x-amz-copy-source-if-unmodified-since""
	XAmzDecodedContentLength        = ""x-amz-decoded-content-length""
	XAmzTagging                     = ""x-amz-tagging""
	XAmzMetaPrefix                  = ""x-amz-meta-""
	XAmzMpPartsCount                = ""x-amz-mp-parts-count""
	XAmzMetadataDirective           = ""x-amz-metadata-directive""
	XAmzBucketRegion                = ""x-amz-bucket-region""
	XAmzStorageClass                = ""x-amz-storage-class""
	XAmzTaggingCount                = ""x-amz-tagging-count""
	XAmzContentSha256               = ""X-Amz-Content-Sha256""
	XAmzCredential                  = ""X-Amz-Credential""
	XAmzSignature                   = ""X-Amz-Signature""
	XAmzSignedHeaders               = ""X-Amz-SignedHeaders""
	XAmzAlgorithm                   = ""X-Amz-Algorithm""
	XAmzDate                        = ""X-Amz-Date""
	XAmzExpires                     = ""X-Amz-Expires""
	XAmzSecurityToken               = ""X-Amz-Security-Token""
	XAmzObjectLockMode              = ""X-Amz-Object-Lock-Mode""
	XAmzObjectLockRetainUntilDate   = ""X-Amz-Object-Lock-Retain-Until-Date""
	HeaderNameXAmzDecodedContentLength = ""x-amz-decoded-content-length""
)
const (
	ValueServer               = ""CubeFS""
	ValueAcceptRanges         = ""bytes""
	ValueContentTypeStream    = ""application/octet-stream""
	ValueContentTypeXML       = ""application/xml""
	ValueContentTypeJSON      = ""application/json""
	ValueContentTypeDirectory = ""application/directory""
	ValueMultipartFormData    = ""multipart/form-data""
)
const (
	SubObjectDelete    = ""delete""
	SubMultipartUpload = ""uploads""
)
const (
	ParamUploadId   = ""uploadId""
	ParamPartNumber = ""partNumber""
	ParamKeyMarker  = ""key-marker""
	ParamMarker     = ""marker""
	ParamPrefix     = ""prefix""
	ParamContToken  = ""continuation-token""
	ParamFetchOwner = ""fetch-owner""
	ParamMaxKeys    = ""max-keys""
	ParamStartAfter = ""start-after""
	ParamKey        = ""key""
	ParamMaxParts       = ""max-parts""
	ParamUploadIdMarker = ""upload-id-marker""
	ParamPartNoMarker   = ""part-number-marker""
	ParamPartMaxUploads = ""max-uploads""
	ParamPartDelimiter  = ""delimiter""
	ParamEncodingType   = ""encoding-type""
	ParamResponseCacheControl       = ""response-cache-control""
	ParamResponseContentType        = ""response-content-type""
	ParamResponseContentDisposition = ""response-content-disposition""
	ParamResponseExpires            = ""response-expires""
)
const (
	MaxKeys        = 1000
	MaxParts       = 1000
	MaxUploads     = 1000
	SinglePutLimit = 5 * 1 << 30 // 5G
)
const (
	StorageClassStandard = ""STANDARD""
)
// XAttr keys for ObjectNode compatible feature
const (
	XAttrKeyOSSPrefix       = ""oss:""
	XAttrKeyOSSETag         = ""oss:etag""
	XAttrKeyOSSTagging      = ""oss:tagging""
	XAttrKeyOSSPolicy       = ""oss:policy""
	XAttrKeyOSSACL          = ""oss:acl""
	XAttrKeyOSSMIME         = ""oss:mime""
	XAttrKeyOSSDISPOSITION  = ""oss:disposition""
	XAttrKeyOSSCORS         = ""oss:cors""
	XAttrKeyOSSLock         = ""oss:lock""
	XAttrKeyOSSCacheControl = ""oss:cache""
	XAttrKeyOSSExpires      = ""oss:expires""
	// Deprecated
	XAttrKeyOSSETagDeprecated = ""oss:tag""
)
const (
	DateLayout              = ""20060102""
	ISO8601Format           = ""20060102T150405Z""
	ISO8601Layout           = ""2006-01-02T15:04:05.000Z""
	ISO8601LayoutCompatible = ""2006-01-02T15:04:05Z""
	RFC1123Format           = ""Mon, 02 Jan 2006 15:04:05 GMT""
)
const (
	EmptyContentMD5String = ""d41d8cd98f00b204e9800998ecf8427e""
)
const (
	DefaultFileMode = 0644
	DefaultDirMode  = DefaultFileMode | os.ModeDir
)
const (
	SplitFileRangeBlockSize     = 10 * 1024 * 1024 // 10MB
	ParallelDownloadPartSize    = 10 * 1024 * 1024
	MinParallelDownloadFileSize = 2 * ParallelDownloadPartSize
)
const (
	MaxCopyObjectSize = 5 * 1024 * 1024 * 1024
)
const (
	MetadataDirectiveCopy    = ""COPY""
	MetadataDirectiveReplace = ""REPLACE""
)
const (
	TaggingCounts         = 10
	TaggingKeyMaxLength   = 128
	TaggingValueMaxLength = 256
)
",CWE-770,197.0,1
"// Copyright 2023 The CubeFS Authors.
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
// implied. See the License for the specific language governing
// permissions and limitations under the License.
package objectnode
import (
	""encoding/xml""
	""io""
	""io/ioutil""
	""net/http""
	""github.com/cubefs/cubefs/proto""
	""github.com/cubefs/cubefs/util/log""
)
// API reference: https://docs.aws.amazon.com/zh_cn/AmazonS3/latest/API/API_GetBucketLifecycleConfiguration.html
func (o *ObjectNode) getBucketLifecycleConfigurationHandler(w http.ResponseWriter, r *http.Request) {
	var err error
	var errorCode *ErrorCode
	defer func() {
		o.errorResponse(w, r, err, errorCode)
	}()
	var param = ParseRequestParam(r)
	if param.Bucket() == """" {
		errorCode = InvalidBucketName
		return
	}
	if _, err = o.vm.Volume(param.Bucket()); err != nil {
		errorCode = NoSuchBucket
		return
	}
	var lcConf *proto.LcConfiguration
	if lcConf, err = o.mc.AdminAPI().GetBucketLifecycle(param.Bucket()); err != nil {
		log.LogErrorf(""getBucketLifecycle failed: bucket[%v] err(%v)"", param.Bucket(), err)
		errorCode = NoSuchLifecycleConfiguration
		return
	}
	var lifeCycle = NewLifeCycle()
	lifeCycle.Rules = make([]*Rule, 0)
	for _, lc := range lcConf.Rules {
		rule := &Rule{
			ID:     lc.ID,
			Status: lc.Status,
		}
		if lc.Expire != nil {
			rule.Expire = &Expiration{}
			if lc.Expire.Date != nil {
				rule.Expire.Date = lc.Expire.Date
			}
			if lc.Expire.Days != 0 {
				rule.Expire.Days = &lc.Expire.Days
			}
		}
		if lc.Filter != nil {
			rule.Filter = &Filter{
				Prefix: lc.Filter.Prefix,
			}
		}
		lifeCycle.Rules = append(lifeCycle.Rules, rule)
	}
	var data []byte
	data, err = xml.Marshal(lifeCycle)
	if err != nil {
		log.LogErrorf(""getBucketLifecycle failed: bucket[%v] err(%v)"", param.Bucket(), err)
		errorCode = NoSuchLifecycleConfiguration
		return
	}
	writeSuccessResponseXML(w, data)
	return
}
// API reference: https://docs.aws.amazon.com/zh_cn/AmazonS3/latest/API/API_PutBucketLifecycleConfiguration.html
func (o *ObjectNode) putBucketLifecycleConfigurationHandler(w http.ResponseWriter, r *http.Request) {
	var err error
	var errorCode *ErrorCode
	defer func() {
		o.errorResponse(w, r, err, errorCode)
	}()
	var param = ParseRequestParam(r)
	if param.Bucket() == """" {
		errorCode = InvalidBucketName
		return
	}
	if _, err = o.vm.Volume(param.Bucket()); err != nil {
		errorCode = NoSuchBucket
		return
	}
	var requestBody []byte
	if requestBody, err = ioutil.ReadAll(r.Body); err != nil && err != io.EOF {
		log.LogErrorf(""putBucketLifecycle failed: read request body data err: requestID(%v) err(%v)"", GetRequestID(r), err)
		errorCode = &ErrorCode{
			ErrorCode:    http.StatusText(http.StatusBadRequest),
			ErrorMessage: err.Error(),
			StatusCode:   http.StatusBadRequest,
		}
		return
	}
	var lifeCycle = NewLifeCycle()
	if err = UnmarshalXMLEntity(requestBody, lifeCycle); err != nil {
		log.LogWarnf(""putBucketLifecycle failed: decode request body err: requestID(%v) err(%v)"", GetRequestID(r), err)
		errorCode = LifeCycleErrMalformedXML
		return
	}
	ok, errorCode := lifeCycle.Validate()
	if !ok {
		log.LogErrorf(""putBucketLifecycle failed: validate err: requestID(%v) lifeCycle(%v) err(%v)"", GetRequestID(r), lifeCycle, errorCode)
		return
	}
	req := proto.LcConfiguration{
		VolName: param.Bucket(),
		Rules:   make([]*proto.Rule, 0),
	}
	for _, lr := range lifeCycle.Rules {
		rule := &proto.Rule{
			ID:     lr.ID,
			Status: lr.Status,
		}
		if lr.Expire != nil {
			rule.Expire = &proto.ExpirationConfig{}
			if lr.Expire.Date != nil {
				rule.Expire.Date = lr.Expire.Date
			}
			if lr.Expire.Days != nil {
				rule.Expire.Days = *lr.Expire.Days
			}
		}
		if lr.Filter != nil {
			rule.Filter = &proto.FilterConfig{
				Prefix: lr.Filter.Prefix,
			}
		}
		req.Rules = append(req.Rules, rule)
	}
	if err = o.mc.AdminAPI().SetBucketLifecycle(&req); err != nil {
		log.LogErrorf(""putBucketLifecycle failed: SetBucketLifecycle err: bucket[%v] err(%v)"", param.Bucket(), err)
		return
	}
	log.LogInfof(""putBucketLifecycle success: requestID(%v) volume(%v) lifeCycle(%v)"",
		GetRequestID(r), param.Bucket(), lifeCycle)
}
// API reference: https://docs.aws.amazon.com/zh_cn/AmazonS3/latest/API/API_DeleteBucketLifecycle.html
func (o *ObjectNode) deleteBucketLifecycleConfigurationHandler(w http.ResponseWriter, r *http.Request) {
	var err error
	var errorCode *ErrorCode
	defer func() {
		o.errorResponse(w, r, err, errorCode)
	}()
	var param = ParseRequestParam(r)
	if param.Bucket() == """" {
		errorCode = InvalidBucketName
		return
	}
	if _, err = o.vm.Volume(param.Bucket()); err != nil {
		errorCode = NoSuchBucket
		return
	}
	if err = o.mc.AdminAPI().DelBucketLifecycle(param.Bucket()); err != nil {
		log.LogErrorf(""deleteBucketLifecycle failed: bucket[%v] err(%v)"", param.Bucket(), err)
		return
	}
	w.WriteHeader(http.StatusNoContent)
}
",CWE-770,194.0,1
"// Copyright 2018 The CubeFS Authors.
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
// implied. See the License for the specific language governing
// permissions and limitations under the License.
package util
import (
	""math/rand""
	""strings""
	""time""
)
func SubString(sourceString string, begin, end int) string {
	bytes := []byte(sourceString)
	stringLength := len(bytes)
	if begin < 0 {
		begin = 0
	}
	if end > stringLength {
		end = stringLength
	}
	return string(bytes[begin:end])
}
type RandomSeed byte
func (s RandomSeed) Runes() []rune {
	sourceBuilder := strings.Builder{}
	if s&Numeric > 0 {
		sourceBuilder.WriteString(""0123456789"")
	}
	if s&LowerLetter > 0 {
		sourceBuilder.WriteString(""abcdefghijklmnopqrstuvwxyz"")
	}
	if s&UpperLetter > 0 {
		sourceBuilder.WriteString(""ABCDEFGHIJKLMNOPQRSTUVWXYZ"")
	}
	return []rune(sourceBuilder.String())
}
const (
	Numeric RandomSeed = 1 << iota
	LowerLetter
	UpperLetter
)
func RandomString(length int, seed RandomSeed) string {
	runs := seed.Runes()
	result := """"
	for i := 0; i < length; i++ {
		rand.Seed(time.Now().UnixNano())
		randNumber := rand.Intn(len(runs))
		result += string(runs[randNumber])
	}
	return result
}
",CWE-330,68.0,1
"//
// Copyright 2022 The Sigstore Authors.
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package root
import (
	""bytes""
	""context""
	""errors""
	""fmt""
	""io""
	""os""
	""github.com/sigstore/gitsign/internal/fulcio""
	""github.com/sigstore/gitsign/internal/git""
	""github.com/sigstore/gitsign/internal/gpg""
	gsio ""github.com/sigstore/gitsign/internal/io""
	""github.com/sigstore/gitsign/internal/rekor""
	""github.com/sigstore/gitsign/internal/signature""
)
// commandSign implements gitsign commit signing.
// This is implemented as a root command so that user can specify the
// gitsign binary directly in their gitconfigs.
func commandSign(o *options, s *gsio.Streams, args ...string) error {
	ctx := context.Background()
	// Flag validation
	if o.FlagVerify {
		return errors.New(""specify --help, --sign, or --verify"")
	}
	if len(o.FlagLocalUser) == 0 {
		return errors.New(""specify a USER-ID to sign with"")
	}
	userIdent, err := fulcio.NewIdentity(ctx, o.Config, s.TTYIn, s.TTYOut)
	if err != nil {
		return fmt.Errorf(""failed to get identity: %w"", err)
	}
	// Git is looking for ""\n[GNUPG:] SIG_CREATED "", meaning we need to print a
	// line before SIG_CREATED. BEGIN_SIGNING seems appropriate. GPG emits this,
	// though GPGSM does not.
	gpgout := gpg.NewStatusWriterFromFD(uintptr(o.FlagStatusFD))
	gpgout.Emit(gpg.StatusBeginSigning)
	var f io.Reader
	if len(args) == 1 {
		f2, err := os.Open(args[0])
		if err != nil {
			return fmt.Errorf(""failed to open message file (%s): %w"", args[0], err)
		}
		defer f2.Close()
		f = f2
	} else {
		f = s.In
	}
	dataBuf := new(bytes.Buffer)
	if _, err = io.Copy(dataBuf, f); err != nil {
		return fmt.Errorf(""failed to read message from stdin: %w"", err)
	}
	rekor, err := rekor.NewClient(o.Config.Rekor)
	if err != nil {
		return fmt.Errorf(""failed to create rekor client: %w"", err)
	}
	opts := signature.SignOptions{
		Detached:           o.FlagDetachedSignature,
		TimestampAuthority: o.Config.TimestampURL,
		Armor:              o.FlagArmor,
		IncludeCerts:       o.FlagIncludeCerts,
	}
	if o.Config.MatchCommitter {
		opts.UserName = o.Config.CommitterName
		opts.UserEmail = o.Config.CommitterEmail
	}
	var fn git.SignFunc = git.LegacySHASign
	if o.Config.RekorMode == ""offline"" {
		fn = git.Sign
	}
	resp, err := fn(ctx, rekor, userIdent, dataBuf.Bytes(), opts)
	if err != nil {
		return fmt.Errorf(""failed to sign message: %w"", err)
	}
	if tlog := resp.LogEntry; tlog != nil && tlog.LogIndex != nil {
		fmt.Fprintf(s.TTYOut, ""tlog entry created with index: %d\n"", *tlog.LogIndex)
	}
	gpgout.EmitSigCreated(resp.Cert, o.FlagDetachedSignature)
	if _, err := s.Out.Write(resp.Signature); err != nil {
		return errors.New(""failed to write signature"")
	}
	return nil
}
",CWE-347,113.0,1
"// Copyright 2023 The Sigstore Authors
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package gitsign
import (
	""context""
	""crypto/x509""
	""fmt""
	""os""
	cosignopts ""github.com/sigstore/cosign/v2/cmd/cosign/cli/options""
	""github.com/sigstore/cosign/v2/pkg/cosign""
	""github.com/sigstore/gitsign/internal/cert""
	""github.com/sigstore/gitsign/internal/config""
	""github.com/sigstore/gitsign/internal/fulcio/fulcioroots""
	rekorinternal ""github.com/sigstore/gitsign/internal/rekor""
	""github.com/sigstore/gitsign/pkg/git""
	""github.com/sigstore/gitsign/pkg/rekor""
	""github.com/sigstore/sigstore/pkg/cryptoutils""
)
type Verifier struct {
	git   git.Verifier
	cert  cert.Verifier
	rekor rekor.Verifier
}
// NewVerifierWithCosignOpts implements a Gitsign verifier using Cosign CertVerifyOptions.
// Note: not all options are supported.
//   - cert: This is always taken from the commit.
func NewVerifierWithCosignOpts(ctx context.Context, cfg *config.Config, opts *cosignopts.CertVerifyOptions) (*Verifier, error) {
	root, intermediate, err := fulcioroots.NewFromConfig(ctx, cfg)
	if err != nil {
		return nil, fmt.Errorf(""error getting certificate root: %w"", err)
	}
	tsa, err := x509.SystemCertPool()
	if err != nil {
		return nil, fmt.Errorf(""error getting system root pool: %w"", err)
	}
	if path := cfg.TimestampCert; path != """" {
		f, err := os.Open(path)
		if err != nil {
			return nil, err
		}
		defer f.Close()
		cert, err := cryptoutils.LoadCertificatesFromPEM(f)
		if err != nil {
			return nil, fmt.Errorf(""error loading certs from %s: %w"", path, err)
		}
		for _, c := range cert {
			tsa.AddCert(c)
		}
	}
	gitverifier, err := git.NewCertVerifier(
		git.WithRootPool(root),
		git.WithIntermediatePool(intermediate),
		git.WithTimestampCertPool(tsa),
	)
	if err != nil {
		return nil, fmt.Errorf(""error creating Git verifier: %w"", err)
	}
	rekor, err := rekorinternal.NewClient(cfg.Rekor)
	if err != nil {
		return nil, fmt.Errorf(""failed to create rekor client: %w"", err)
	}
	// Optionally include cert.Verifier.
	// This needs to be optional because when verifying with
	// `git verify-commit` we don't have access to issuer / identity details.
	// In these cases, clients should look for the certificate validated claim
	// and warn if missing.
	var certverifier cert.Verifier
	if opts != nil {
		ctpub, err := cosign.GetCTLogPubs(ctx)
		if err != nil {
			return nil, fmt.Errorf(""error getting CT log public key: %w"", err)
		}
		identities, err := opts.Identities()
		if err != nil {
			return nil, fmt.Errorf(""error parsing identities: %w"", err)
		}
		certverifier = cert.NewCosignVerifier(&cosign.CheckOpts{
			RekorClient:                  rekor.Rekor,
			RootCerts:                    root,
			IntermediateCerts:            intermediate,
			CTLogPubKeys:                 ctpub,
			RekorPubKeys:                 rekor.PublicKeys(),
			CertGithubWorkflowTrigger:    opts.CertGithubWorkflowTrigger,
			CertGithubWorkflowSha:        opts.CertGithubWorkflowSha,
			CertGithubWorkflowName:       opts.CertGithubWorkflowName,
			CertGithubWorkflowRepository: opts.CertGithubWorkflowRepository,
			CertGithubWorkflowRef:        opts.CertGithubWorkflowRef,
			Identities:                   identities,
			IgnoreSCT:                    opts.IgnoreSCT,
		})
	}
	return &Verifier{
		git:   gitverifier,
		cert:  certverifier,
		rekor: rekor,
	}, nil
}
func (v *Verifier) Verify(ctx context.Context, data []byte, sig []byte, detached bool) (*git.VerificationSummary, error) {
	// TODO: we probably want to deprecate git.Verify in favor of this struct.
	summary, err := git.Verify(ctx, v.git, v.rekor, data, sig, detached)
	if err != nil {
		return summary, err
	}
	if v.cert != nil {
		if err := v.cert.Verify(summary.Cert); err != nil {
			summary.Claims = append(summary.Claims, git.NewClaim(git.ClaimValidatedCerificate, false))
			return summary, err
		}
		summary.Claims = append(summary.Claims, git.NewClaim(git.ClaimValidatedCerificate, true))
	} else {
		summary.Claims = append(summary.Claims, git.NewClaim(git.ClaimValidatedCerificate, false))
	}
	return summary, nil
}
",CWE-347,139.0,1
"// Copyright 2022 The Sigstore Authors
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package rekor
import (
	gitrekor ""github.com/sigstore/gitsign/pkg/rekor""
	rekor ""github.com/sigstore/rekor/pkg/client""
)
// NewClient returns a new Rekor client with common client options set.
func NewClient(url string) (*gitrekor.Client, error) {
	return gitrekor.New(url, rekor.WithUserAgent(""gitsign""))
}
",CWE-347,26.0,1
"// Code generated by tools/cmd/genoptions/main.go. DO NOT EDIT.
package jwe
import (
	""testing""
	""github.com/stretchr/testify/require""
)
func TestOptionIdent(t *testing.T) {
	require.Equal(t, ""WithCEK"", identCEK{}.String())
	require.Equal(t, ""WithCompress"", identCompress{}.String())
	require.Equal(t, ""WithContentEncryption"", identContentEncryptionAlgorithm{}.String())
	require.Equal(t, ""WithFS"", identFS{}.String())
	require.Equal(t, ""WithKey"", identKey{}.String())
	require.Equal(t, ""WithKeyProvider"", identKeyProvider{}.String())
	require.Equal(t, ""WithKeyUsed"", identKeyUsed{}.String())
	require.Equal(t, ""WithMergeProtectedHeaders"", identMergeProtectedHeaders{}.String())
	require.Equal(t, ""WithMessage"", identMessage{}.String())
	require.Equal(t, ""WithPerRecipientHeaders"", identPerRecipientHeaders{}.String())
	require.Equal(t, ""WithPretty"", identPretty{}.String())
	require.Equal(t, ""WithProtectedHeaders"", identProtectedHeaders{}.String())
	require.Equal(t, ""WithRequireKid"", identRequireKid{}.String())
	require.Equal(t, ""WithSerialization"", identSerialization{}.String())
}
",CWE-400,27.0,1
"package ffcss
import (
	""fmt""
	""os""
	""path/filepath""
	""regexp""
	""strings""
	""github.com/hbollon/go-edlib""
	""golang.org/x/text/unicode/norm""
)
// Catalog represents a collection of themes
type Catalog map[string]Theme
// Lookup looks up a theme by its name in the theme store.
// It also returns an error starting with ""did you mean:"" when
// a theme name is not found but themes with similar names exist.
func (store Catalog) Lookup(query string) (Theme, error) {
	originalQuery := query
	query = lookupPreprocess(query)
	LogDebug(""using query %q"", query)
	processedThemeNames := make([]string, 0, len(store))
	for _, theme := range store {
		LogDebug(""\tlooking up against %q (%q)"", lookupPreprocess(theme.Name()), theme.Name())
		if lookupPreprocess(theme.Name()) == query {
			return theme, nil
		}
		processedThemeNames = append(processedThemeNames, lookupPreprocess(theme.Name()))
	}
	// Use fuzzy search for did-you-mean errors
	suggestion, _ := edlib.FuzzySearchThreshold(query, processedThemeNames, 0.75, edlib.Levenshtein)
	if suggestion != """" {
		return Theme{}, fmt.Errorf(""theme %q not found. did you mean [blue][bold]%s[reset]?"", originalQuery, suggestion)
	}
	return Theme{}, fmt.Errorf(""theme %q not found"", originalQuery)
}
// lookupPreprocess applies transformations to s so that it can be compared
// to search for something.
// For example, it is used by (ThemeStore).Lookup
func lookupPreprocess(s string) string {
	return strings.ToLower(norm.NFKD.String(regexp.MustCompile(`[-_ .]`).ReplaceAllString(s, """")))
}
// LoadCatalog loads a directory of theme manifests.
// Keys are theme names (files' basenames with the .yaml removed).
func LoadCatalog(storeDirectory string) (themes Catalog, err error) {
	themeNamePattern := regexp.MustCompile(`^(.+)\.ya?ml$`)
	themes = make(Catalog)
	manifests, err := os.ReadDir(storeDirectory)
	if err != nil {
		return
	}
	LogDebug(""loading potential themes %v into catalog"", func() []string {
		dirNames := make([]string, 0, len(manifests))
		for _, dir := range manifests {
			dirNames = append(dirNames, dir.Name())
		}
		return dirNames
	}())
	for _, manifest := range manifests {
		if !themeNamePattern.MatchString(manifest.Name()) {
			continue
		}
		themeName := themeNamePattern.FindStringSubmatch(manifest.Name())[1]
		theme, err := LoadManifest(filepath.Join(storeDirectory, manifest.Name()))
		if err != nil {
			return nil, fmt.Errorf(""while loading theme %q: %w"", themeName, err)
		}
		LogDebug(""\tadding theme from manifest %q"", manifest.Name())
		themes[themeName] = theme
	}
	return
}
",CWE-74,78.0,1
"package main
import (
	""fmt""
	""os""
	""os/exec""
	""path/filepath""
	""github.com/ggerganov/whisper.cpp/bindings/go/pkg/whisper""
	""github.com/go-audio/wav""
	""github.com/go-skynet/LocalAI/core/schema""
)
func sh(c string) (string, error) {
	cmd := exec.Command(""/bin/sh"", ""-c"", c)
	cmd.Env = os.Environ()
	o, err := cmd.CombinedOutput()
	return string(o), err
}
// AudioToWav converts audio to wav for transcribe. It bashes out to ffmpeg
// TODO: use https://github.com/mccoyst/ogg?
func audioToWav(src, dst string) error {
	out, err := sh(fmt.Sprintf(""ffmpeg -i %s -format s16le -ar 16000 -ac 1 -acodec pcm_s16le %s"", src, dst))
	if err != nil {
		return fmt.Errorf(""error: %w out: %s"", err, out)
	}
	return nil
}
func Transcript(model whisper.Model, audiopath, language string, threads uint) (schema.Result, error) {
	res := schema.Result{}
	dir, err := os.MkdirTemp("""", ""whisper"")
	if err != nil {
		return res, err
	}
	defer os.RemoveAll(dir)
	convertedPath := filepath.Join(dir, ""converted.wav"")
	if err := audioToWav(audiopath, convertedPath); err != nil {
		return res, err
	}
	// Open samples
	fh, err := os.Open(convertedPath)
	if err != nil {
		return res, err
	}
	defer fh.Close()
	// Read samples
	d := wav.NewDecoder(fh)
	buf, err := d.FullPCMBuffer()
	if err != nil {
		return res, err
	}
	data := buf.AsFloat32Buffer().Data
	// Process samples
	context, err := model.NewContext()
	if err != nil {
		return res, err
	}
	context.SetThreads(threads)
	if language != """" {
		context.SetLanguage(language)
	} else {
		context.SetLanguage(""auto"")
	}
	if err := context.Process(data, nil, nil); err != nil {
		return res, err
	}
	for {
		s, err := context.NextSegment()
		if err != nil {
			break
		}
		var tokens []int
		for _, t := range s.Tokens {
			tokens = append(tokens, t.Id)
		}
		segment := schema.Segment{Id: s.Num, Text: s.Text, Start: s.Start, End: s.End, Tokens: tokens}
		res.Segments = append(res.Segments, segment)
		res.Text += s.Text
	}
	return res, nil
}
",CWE-78,101.0,1
"package config_test
import (
	""os""
	. ""github.com/go-skynet/LocalAI/core/config""
	. ""github.com/onsi/ginkgo/v2""
	. ""github.com/onsi/gomega""
)
var _ = Describe(""Test cases for config related functions"", func() {
	var (
		configFile string
	)
	Context(""Test Read configuration functions"", func() {
		configFile = os.Getenv(""CONFIG_FILE"")
		It(""Test ReadConfigFile"", func() {
			config, err := ReadBackendConfigFile(configFile)
			Expect(err).To(BeNil())
			Expect(config).ToNot(BeNil())
			// two configs in config.yaml
			Expect(config[0].Name).To(Equal(""list1""))
			Expect(config[1].Name).To(Equal(""list2""))
		})
		It(""Test LoadConfigs"", func() {
			cm := NewBackendConfigLoader()
			opts := NewApplicationConfig()
			err := cm.LoadBackendConfigsFromPath(opts.ModelPath)
			Expect(err).To(BeNil())
			Expect(cm.ListBackendConfigs()).ToNot(BeNil())
			// config should includes gpt4all models's api.config
			Expect(cm.ListBackendConfigs()).To(ContainElements(""gpt4all""))
			// config should includes gpt2 models's api.config
			Expect(cm.ListBackendConfigs()).To(ContainElements(""gpt4all-2""))
			// config should includes text-embedding-ada-002 models's api.config
			Expect(cm.ListBackendConfigs()).To(ContainElements(""text-embedding-ada-002""))
			// config should includes rwkv_test models's api.config
			Expect(cm.ListBackendConfigs()).To(ContainElements(""rwkv_test""))
			// config should includes whisper-1 models's api.config
			Expect(cm.ListBackendConfigs()).To(ContainElements(""whisper-1""))
		})
	})
})
",CWE-78,53.0,1
"package config_test
import (
	""os""
	. ""github.com/go-skynet/LocalAI/core/config""
	. ""github.com/onsi/ginkgo/v2""
	. ""github.com/onsi/gomega""
)
var _ = Describe(""Test cases for config related functions"", func() {
	var (
		configFile string
	)
	Context(""Test Read configuration functions"", func() {
		configFile = os.Getenv(""CONFIG_FILE"")
		It(""Test ReadConfigFile"", func() {
			config, err := ReadBackendConfigFile(configFile)
			Expect(err).To(BeNil())
			Expect(config).ToNot(BeNil())
			// two configs in config.yaml
			Expect(config[0].Name).To(Equal(""list1""))
			Expect(config[1].Name).To(Equal(""list2""))
		})
		It(""Test LoadConfigs"", func() {
			cm := NewBackendConfigLoader()
			opts := NewApplicationConfig()
			err := cm.LoadBackendConfigsFromPath(opts.ModelPath)
			Expect(err).To(BeNil())
			Expect(cm.ListBackendConfigs()).ToNot(BeNil())
			// config should includes gpt4all models's api.config
			Expect(cm.ListBackendConfigs()).To(ContainElements(""gpt4all""))
			// config should includes gpt2 models's api.config
			Expect(cm.ListBackendConfigs()).To(ContainElements(""gpt4all-2""))
			// config should includes text-embedding-ada-002 models's api.config
			Expect(cm.ListBackendConfigs()).To(ContainElements(""text-embedding-ada-002""))
			// config should includes rwkv_test models's api.config
			Expect(cm.ListBackendConfigs()).To(ContainElements(""rwkv_test""))
			// config should includes whisper-1 models's api.config
			Expect(cm.ListBackendConfigs()).To(ContainElements(""whisper-1""))
		})
	})
})
",CWE-22,53.0,1
"package model
import (
	""errors""
	""fmt""
	""os""
	""os/signal""
	""strconv""
	""strings""
	""syscall""
	""time""
	""github.com/hpcloud/tail""
	process ""github.com/mudler/go-processmanager""
	""github.com/rs/zerolog/log""
)
func (ml *ModelLoader) StopAllExcept(s string) error {
	return ml.StopGRPC(func(id string, p *process.Process) bool {
		if id != s {
			for ml.models[id].GRPC(false, ml.wd).IsBusy() {
				log.Debug().Msgf(""%s busy. Waiting."", id)
				time.Sleep(2 * time.Second)
			}
			log.Debug().Msgf(""[single-backend] Stopping %s"", id)
			return true
		}
		return false
	})
}
func (ml *ModelLoader) deleteProcess(s string) error {
	if err := ml.grpcProcesses[s].Stop(); err != nil {
		return err
	}
	delete(ml.grpcProcesses, s)
	delete(ml.models, s)
	return nil
}
type GRPCProcessFilter = func(id string, p *process.Process) bool
func includeAllProcesses(_ string, _ *process.Process) bool {
	return true
}
func (ml *ModelLoader) StopGRPC(filter GRPCProcessFilter) error {
	var err error = nil
	for k, p := range ml.grpcProcesses {
		if filter(k, p) {
			e := ml.deleteProcess(k)
			err = errors.Join(err, e)
		}
	}
	return err
}
func (ml *ModelLoader) StopAllGRPC() error {
	return ml.StopGRPC(includeAllProcesses)
}
func (ml *ModelLoader) GetGRPCPID(id string) (int, error) {
	p, exists := ml.grpcProcesses[id]
	if !exists {
		return -1, fmt.Errorf(""no grpc backend found for %s"", id)
	}
	return strconv.Atoi(p.PID)
}
func (ml *ModelLoader) startProcess(grpcProcess, id string, serverAddress string) error {
	// Make sure the process is executable
	if err := os.Chmod(grpcProcess, 0700); err != nil {
		return err
	}
	log.Debug().Msgf(""Loading GRPC Process: %s"", grpcProcess)
	log.Debug().Msgf(""GRPC Service for %s will be running at: '%s'"", id, serverAddress)
	grpcControlProcess := process.New(
		process.WithTemporaryStateDir(),
		process.WithName(grpcProcess),
		process.WithArgs(""--addr"", serverAddress),
		process.WithEnvironment(os.Environ()...),
	)
	if ml.wd != nil {
		ml.wd.Add(serverAddress, grpcControlProcess)
		ml.wd.AddAddressModelMap(serverAddress, id)
	}
	ml.grpcProcesses[id] = grpcControlProcess
	if err := grpcControlProcess.Run(); err != nil {
		return err
	}
	log.Debug().Msgf(""GRPC Service state dir: %s"", grpcControlProcess.StateDir())
	// clean up process
	go func() {
		c := make(chan os.Signal, 1)
		signal.Notify(c, os.Interrupt, syscall.SIGTERM)
		<-c
		grpcControlProcess.Stop()
	}()
	go func() {
		t, err := tail.TailFile(grpcControlProcess.StderrPath(), tail.Config{Follow: true})
		if err != nil {
			log.Debug().Msgf(""Could not tail stderr"")
		}
		for line := range t.Lines {
			log.Debug().Msgf(""GRPC(%s): stderr %s"", strings.Join([]string{id, serverAddress}, ""-""), line.Text)
		}
	}()
	go func() {
		t, err := tail.TailFile(grpcControlProcess.StdoutPath(), tail.Config{Follow: true})
		if err != nil {
			log.Debug().Msgf(""Could not tail stdout"")
		}
		for line := range t.Lines {
			log.Debug().Msgf(""GRPC(%s): stdout %s"", strings.Join([]string{id, serverAddress}, ""-""), line.Text)
		}
	}()
	return nil
}
",CWE-78,128.0,1
"package model
import (
	""errors""
	""fmt""
	""os""
	""os/signal""
	""strconv""
	""strings""
	""syscall""
	""time""
	""github.com/hpcloud/tail""
	process ""github.com/mudler/go-processmanager""
	""github.com/rs/zerolog/log""
)
func (ml *ModelLoader) StopAllExcept(s string) error {
	return ml.StopGRPC(func(id string, p *process.Process) bool {
		if id != s {
			for ml.models[id].GRPC(false, ml.wd).IsBusy() {
				log.Debug().Msgf(""%s busy. Waiting."", id)
				time.Sleep(2 * time.Second)
			}
			log.Debug().Msgf(""[single-backend] Stopping %s"", id)
			return true
		}
		return false
	})
}
func (ml *ModelLoader) deleteProcess(s string) error {
	if err := ml.grpcProcesses[s].Stop(); err != nil {
		return err
	}
	delete(ml.grpcProcesses, s)
	delete(ml.models, s)
	return nil
}
type GRPCProcessFilter = func(id string, p *process.Process) bool
func includeAllProcesses(_ string, _ *process.Process) bool {
	return true
}
func (ml *ModelLoader) StopGRPC(filter GRPCProcessFilter) error {
	var err error = nil
	for k, p := range ml.grpcProcesses {
		if filter(k, p) {
			e := ml.deleteProcess(k)
			err = errors.Join(err, e)
		}
	}
	return err
}
func (ml *ModelLoader) StopAllGRPC() error {
	return ml.StopGRPC(includeAllProcesses)
}
func (ml *ModelLoader) GetGRPCPID(id string) (int, error) {
	p, exists := ml.grpcProcesses[id]
	if !exists {
		return -1, fmt.Errorf(""no grpc backend found for %s"", id)
	}
	return strconv.Atoi(p.PID)
}
func (ml *ModelLoader) startProcess(grpcProcess, id string, serverAddress string) error {
	// Make sure the process is executable
	if err := os.Chmod(grpcProcess, 0700); err != nil {
		return err
	}
	log.Debug().Msgf(""Loading GRPC Process: %s"", grpcProcess)
	log.Debug().Msgf(""GRPC Service for %s will be running at: '%s'"", id, serverAddress)
	grpcControlProcess := process.New(
		process.WithTemporaryStateDir(),
		process.WithName(grpcProcess),
		process.WithArgs(""--addr"", serverAddress),
		process.WithEnvironment(os.Environ()...),
	)
	if ml.wd != nil {
		ml.wd.Add(serverAddress, grpcControlProcess)
		ml.wd.AddAddressModelMap(serverAddress, id)
	}
	ml.grpcProcesses[id] = grpcControlProcess
	if err := grpcControlProcess.Run(); err != nil {
		return err
	}
	log.Debug().Msgf(""GRPC Service state dir: %s"", grpcControlProcess.StateDir())
	// clean up process
	go func() {
		c := make(chan os.Signal, 1)
		signal.Notify(c, os.Interrupt, syscall.SIGTERM)
		<-c
		grpcControlProcess.Stop()
	}()
	go func() {
		t, err := tail.TailFile(grpcControlProcess.StderrPath(), tail.Config{Follow: true})
		if err != nil {
			log.Debug().Msgf(""Could not tail stderr"")
		}
		for line := range t.Lines {
			log.Debug().Msgf(""GRPC(%s): stderr %s"", strings.Join([]string{id, serverAddress}, ""-""), line.Text)
		}
	}()
	go func() {
		t, err := tail.TailFile(grpcControlProcess.StdoutPath(), tail.Config{Follow: true})
		if err != nil {
			log.Debug().Msgf(""Could not tail stdout"")
		}
		for line := range t.Lines {
			log.Debug().Msgf(""GRPC(%s): stdout %s"", strings.Join([]string{id, serverAddress}, ""-""), line.Text)
		}
	}()
	return nil
}
",CWE-22,128.0,1
"package embedded
import (
	""embed""
	""fmt""
	""slices""
	""strings""
	""github.com/go-skynet/LocalAI/pkg/downloader""
	""github.com/rs/zerolog/log""
	""github.com/go-skynet/LocalAI/pkg/assets""
	""gopkg.in/yaml.v3""
)
var modelShorteners map[string]string
//go:embed model_library.yaml
var modelLibrary []byte
//go:embed models/*
var embeddedModels embed.FS
func ModelShortURL(s string) string {
	if _, ok := modelShorteners[s]; ok {
		s = modelShorteners[s]
	}
	return s
}
func init() {
	err := yaml.Unmarshal(modelLibrary, &modelShorteners)
	if err != nil {
		log.Error().Err(err).Msg(""error while unmarshalling embedded modelLibrary"")
	}
}
func GetRemoteLibraryShorteners(url string) (map[string]string, error) {
	remoteLibrary := map[string]string{}
	err := downloader.GetURI(url, func(_ string, i []byte) error {
		return yaml.Unmarshal(i, &remoteLibrary)
	})
	if err != nil {
		return nil, fmt.Errorf(""error downloading remote library: %s"", err.Error())
	}
	return remoteLibrary, err
}
// ExistsInModelsLibrary checks if a model exists in the embedded models library
func ExistsInModelsLibrary(s string) bool {
	f := fmt.Sprintf(""%s.yaml"", s)
	a := []string{}
	for _, j := range assets.ListFiles(embeddedModels) {
		a = append(a, strings.TrimPrefix(j, ""models/""))
	}
	return slices.Contains(a, f)
}
// ResolveContent returns the content in the embedded model library
func ResolveContent(s string) ([]byte, error) {
	if ExistsInModelsLibrary(s) {
		return embeddedModels.ReadFile(fmt.Sprintf(""models/%s.yaml"", s))
	}
	return nil, fmt.Errorf(""cannot find model %s"", s)
}
",CWE-918,73.0,1
"package downloader_test
import (
	. ""github.com/go-skynet/LocalAI/pkg/downloader""
	. ""github.com/onsi/ginkgo/v2""
	. ""github.com/onsi/gomega""
)
var _ = Describe(""Gallery API tests"", func() {
	Context(""URI"", func() {
		It(""parses github with a branch"", func() {
			Expect(
				GetURI(""github:go-skynet/model-gallery/gpt4all-j.yaml"", func(url string, i []byte) error {
					Expect(url).To(Equal(""https://raw.githubusercontent.com/go-skynet/model-gallery/main/gpt4all-j.yaml""))
					return nil
				}),
			).ToNot(HaveOccurred())
		})
		It(""parses github without a branch"", func() {
			Expect(
				GetURI(""github:go-skynet/model-gallery/gpt4all-j.yaml@main"", func(url string, i []byte) error {
					Expect(url).To(Equal(""https://raw.githubusercontent.com/go-skynet/model-gallery/main/gpt4all-j.yaml""))
					return nil
				}),
			).ToNot(HaveOccurred())
		})
		It(""parses github with urls"", func() {
			Expect(
				GetURI(""https://raw.githubusercontent.com/go-skynet/model-gallery/main/gpt4all-j.yaml"", func(url string, i []byte) error {
					Expect(url).To(Equal(""https://raw.githubusercontent.com/go-skynet/model-gallery/main/gpt4all-j.yaml""))
					return nil
				}),
			).ToNot(HaveOccurred())
		})
	})
})
",CWE-918,37.0,1
"package gallery_test
import (
	. ""github.com/go-skynet/LocalAI/pkg/gallery""
	. ""github.com/onsi/ginkgo/v2""
	. ""github.com/onsi/gomega""
)
var _ = Describe(""Gallery API tests"", func() {
	Context(""requests"", func() {
		It(""parses github with a branch"", func() {
			req := GalleryModel{URL: ""github:go-skynet/model-gallery/gpt4all-j.yaml@main""}
			e, err := GetGalleryConfigFromURL(req.URL)
			Expect(err).ToNot(HaveOccurred())
			Expect(e.Name).To(Equal(""gpt4all-j""))
		})
	})
})
",CWE-918,19.0,1
"package startup
import (
	""errors""
	""os""
	""path/filepath""
	""github.com/go-skynet/LocalAI/embedded""
	""github.com/go-skynet/LocalAI/pkg/downloader""
	""github.com/go-skynet/LocalAI/pkg/utils""
	""github.com/rs/zerolog/log""
)
// PreloadModelsConfigurations will preload models from the given list of URLs
// It will download the model if it is not already present in the model path
// It will also try to resolve if the model is an embedded model YAML configuration
func PreloadModelsConfigurations(modelLibraryURL string, modelPath string, models ...string) {
	for _, url := range models {
		// As a best effort, try to resolve the model from the remote library
		// if it's not resolved we try with the other method below
		if modelLibraryURL != """" {
			lib, err := embedded.GetRemoteLibraryShorteners(modelLibraryURL)
			if err == nil {
				if lib[url] != """" {
					log.Debug().Msgf(""[startup] model configuration is defined remotely: %s (%s)"", url, lib[url])
					url = lib[url]
				}
			}
		}
		url = embedded.ModelShortURL(url)
		switch {
		case embedded.ExistsInModelsLibrary(url):
			modelYAML, err := embedded.ResolveContent(url)
			// If we resolve something, just save it to disk and continue
			if err != nil {
				log.Error().Err(err).Msg(""error resolving model content"")
				continue
			}
			log.Debug().Msgf(""[startup] resolved embedded model: %s"", url)
			md5Name := utils.MD5(url)
			modelDefinitionFilePath := filepath.Join(modelPath, md5Name) + "".yaml""
			if err := os.WriteFile(modelDefinitionFilePath, modelYAML, os.ModePerm); err != nil {
				log.Error().Err(err).Str(""filepath"", modelDefinitionFilePath).Msg(""error writing model definition"")
			}
		case downloader.LooksLikeURL(url):
			log.Debug().Msgf(""[startup] resolved model to download: %s"", url)
			// md5 of model name
			md5Name := utils.MD5(url)
			// check if file exists
			if _, err := os.Stat(filepath.Join(modelPath, md5Name)); errors.Is(err, os.ErrNotExist) {
				modelDefinitionFilePath := filepath.Join(modelPath, md5Name) + "".yaml""
				err := downloader.DownloadFile(url, modelDefinitionFilePath, """", 0, 0, func(fileName, current, total string, percent float64) {
					utils.DisplayDownloadFunction(fileName, current, total, percent)
				})
				if err != nil {
					log.Error().Err(err).Str(""url"", url).Str(""filepath"", modelDefinitionFilePath).Msg(""error downloading model"")
				}
			}
		default:
			if _, err := os.Stat(url); err == nil {
				log.Debug().Msgf(""[startup] resolved local model: %s"", url)
				// copy to modelPath
				md5Name := utils.MD5(url)
				modelYAML, err := os.ReadFile(url)
				if err != nil {
					log.Error().Err(err).Str(""filepath"", url).Msg(""error reading model definition"")
					continue
				}
				modelDefinitionFilePath := filepath.Join(modelPath, md5Name) + "".yaml""
				if err := os.WriteFile(modelDefinitionFilePath, modelYAML, os.ModePerm); err != nil {
					log.Error().Err(err).Str(""filepath"", modelDefinitionFilePath).Msg(""error loading model: %s"")
				}
			} else {
				log.Warn().Msgf(""[startup] failed resolving model '%s'"", url)
			}
		}
	}
}
",CWE-918,86.0,1
"package system
import (
    ""github.com/0xJacky/Nginx-UI/api""
    ""github.com/0xJacky/Nginx-UI/settings""
    ""github.com/gin-gonic/gin""
    ""net/http""
)
func GetSettings(c *gin.Context) {
    c.JSON(http.StatusOK, gin.H{
        ""server"": settings.ServerSettings,
        ""nginx"":  settings.NginxSettings,
        ""openai"": settings.OpenAISettings,
    })
}
func SaveSettings(c *gin.Context) {
    var json struct {
        Server settings.Server `json:""server""`
        Nginx  settings.Nginx  `json:""nginx""`
        Openai settings.OpenAI `json:""openai""`
    }
    if !api.BindAndValid(c, &json) {
        return
    }
    settings.ServerSettings = json.Server
    settings.NginxSettings = json.Nginx
    settings.OpenAISettings = json.Openai
    settings.ReflectFrom()
    err := settings.Save()
    if err != nil {
        api.ErrHandler(c, err)
        return
    }
    GetSettings(c)
}
",CWE-77,43.0,1
"package settings
type Nginx struct {
	AccessLogPath string `json:""access_log_path""`
	ErrorLogPath  string `json:""error_log_path""`
	ConfigDir     string `json:""config_dir""`
	PIDPath       string `json:""pid_path""`
	TestConfigCmd string `json:""test_config_cmd""`
	ReloadCmd     string `json:""reload_cmd""`
	RestartCmd    string `json:""restart_cmd""`
}
var NginxSettings = Nginx{
	AccessLogPath: """",
	ErrorLogPath:  """",
}
",CWE-77,17.0,1
"package settings
type Server struct {
	HttpHost          string `json:""http_host""`
	HttpPort          string `json:""http_port""`
	RunMode           string `json:""run_mode""`
	JwtSecret         string `json:""jwt_secret""`
	NodeSecret        string `json:""node_secret""`
	HTTPChallengePort string `json:""http_challenge_port""`
	Email             string `json:""email""`
	Database          string `json:""database""`
	StartCmd          string `json:""start_cmd""`
	CADir             string `json:""ca_dir""`
	Demo              bool   `json:""demo""`
	PageSize          int    `json:""page_size""`
	GithubProxy       string `json:""github_proxy""`
}
var ServerSettings = Server{
	HttpHost:          ""0.0.0.0"",
	HttpPort:          ""9000"",
	RunMode:           ""debug"",
	HTTPChallengePort: ""9180"",
	Database:          ""database"",
	StartCmd:          ""login"",
	Demo:              false,
	PageSize:          10,
	CADir:             """",
	GithubProxy:       """",
}
",CWE-77,31.0,1
"package cosy
import (
	""fmt""
	""github.com/gin-gonic/gin""
	""gorm.io/gorm""
)
func (c *Ctx[T]) SortOrder() func(db *gorm.DB) *gorm.DB {
	return func(db *gorm.DB) *gorm.DB {
		sort := c.ctx.DefaultQuery(""order"", ""desc"")
		order := fmt.Sprintf(""%s %s"", DefaultQuery(c.ctx, ""sort_by"", c.itemKey), sort)
		return db.Order(order)
	}
}
func (c *Ctx[T]) OrderAndPaginate() func(db *gorm.DB) *gorm.DB {
	return func(db *gorm.DB) *gorm.DB {
		sort := c.ctx.DefaultQuery(""order"", ""desc"")
		order := fmt.Sprintf(""%s %s"", DefaultQuery(c.ctx, ""sort_by"", c.itemKey), sort)
		db = db.Order(order)
		_, offset, pageSize := GetPagingParams(c.ctx)
		return db.Offset(offset).Limit(pageSize)
	}
}
func DefaultValue(c *gin.Context, key string, defaultValue any) any {
	if value, ok := c.Get(key); ok {
		return value
	}
	return defaultValue
}
func DefaultQuery(c *gin.Context, key string, defaultValue any) string {
	return c.DefaultQuery(key, DefaultValue(c, key, defaultValue).(string))
}
",CWE-89,40.0,1
"{
	""name"": ""@tablepress/tablepress"",
	""version"": ""2.2.4"",
	""description"": ""Embed beautiful and feature-rich tables into your posts and pages, without having to write code."",
	""author"": ""Tobias Bäthge"",
	""license"": ""GPL-2.0-only"",
	""private"": true,
	""keywords"": [
		""wordpress"",
		""plugin"",
		""table""
	],
	""homepage"": ""https://tablepress.org/"",
	""funding"": ""https://tablepress.org/donate/"",
	""repository"": ""github:TablePress/TablePress"",
	""bugs"": ""https://github.com/TablePress/TablePress/issues"",
	""devDependencies"": {
		""@wordpress/icons"": ""^9.36.0"",
		""@wordpress/scripts"": ""^26.16.0"",
		""autoprefixer"": ""^9.8.8"",
		""grunt"": ""^1.6.1"",
		""grunt-contrib-csslint"": ""^2.0.0"",
		""grunt-contrib-jshint"": ""^3.2.0"",
		""grunt-jsonlint"": ""^2.1.3"",
		""grunt-postcss"": ""^0.9.0"",
		""matchdep"": ""^2.0.0"",
		""webpack-remove-empty-scripts"": ""^1.0.4""
	},
	""scripts"": {
		""grunt"": ""grunt"",
		""prebuild"": ""grunt lint && wp-scripts lint-js && wp-scripts lint-style"",
		""build"": ""wp-scripts build"",
		""postbuild"": ""find ./admin/css/build/ ./css/build/ -type f -name \""*.css\"" -exec sed -i '' 's||\\\\f053|g;s||\\\\f054|g;s||\\\\f0dc|g;s||\\\\f0d8|g;s||\\\\f0d7|g;s|●|\\\\25cf|g;s|✓|\\\\2713|g' {} +"",
		""build:block"": ""wp-scripts build --config-name tablepress-block"",
		""build:css"": ""wp-scripts build --config-name tablepress-admin-css && wp-scripts build --config-name tablepress-frontend-css"",
		""build:js"": ""wp-scripts build --config-name tablepress-admin-js"",
		""build-dev"": ""DEVELOP=true npm run build"",
		""format"": ""wp-scripts format"",
		""lint:css"": ""wp-scripts lint-style"",
		""lint:js"": ""wp-scripts lint-js"",
		""start"": ""DEVELOP=true wp-scripts start"",
		""packages-update"": ""wp-scripts packages-update""
	}
}
",CWE-918,45.0,1
"package shell
import (
	""bytes""
	""fmt""
	""io""
	""os/exec""
	""strings""
	""github.com/caarlos0/log""
	""github.com/charmbracelet/x/exp/ordered""
	""github.com/goreleaser/goreleaser/internal/gio""
	""github.com/goreleaser/goreleaser/internal/logext""
	""github.com/goreleaser/goreleaser/pkg/context""
)
// Run a shell command with given arguments and envs
func Run(ctx *context.Context, dir string, command, env []string, output bool) error {
	log := log.
		WithField(""cmd"", command).
		WithField(""env"", env).
		WithField(""dir"", dir)
	/* 
	cmd := exec.CommandContext(ctx, command[0], command[1:]...)
	cmd.Env = env
	var b bytes.Buffer
	w := gio.Safe(&b)
	cmd.Stderr = io.MultiWriter(logext.NewConditionalWriter(output), w)
	cmd.Stdout = io.MultiWriter(logext.NewConditionalWriter(output), w)
	if dir != """" {
		cmd.Dir = dir
	}
	log.Debug(""running"")
	if err := cmd.Run(); err != nil {
		return fmt.Errorf(
			""shell: '%s': %w: %s"",
			strings.Join(command, "" ""),
			err,
			ordered.First(
				strings.TrimSpace(b.String()),
				""[no output]"",
			),
		)
	}
	return nil
}
",CWE-532,53.0,1
"package file
import (
	""archive/tar""
	""fmt""
	""io""
	""os""
	""path/filepath""
	""github.com/pkg/errors""
	""github.com/anchore/stereoscope/internal/log""
)
const perFileReadLimit = 2 * GB
var ErrTarStopIteration = fmt.Errorf(""halt iterating tar"")
// tarFile is a ReadCloser of a tar file on disk.
type tarFile struct {
	io.Reader
	io.Closer
}
// TarFileEntry represents the header, contents, and list position of an entry within a tar file.
type TarFileEntry struct {
	Sequence int64
	Header   tar.Header
	Reader   io.Reader
}
// TarFileVisitor is a visitor function meant to be used in conjunction with the IterateTar.
type TarFileVisitor func(TarFileEntry) error
// ErrFileNotFound returned from ReaderFromTar if a file is not found in the given archive.
type ErrFileNotFound struct {
	Path string
}
func (e *ErrFileNotFound) Error() string {
	return fmt.Sprintf(""file not found (path=%s)"", e.Path)
}
// IterateTar is a function that reads across a tar and invokes a visitor function for each entry discovered. The iterator
// stops when there are no more entries to read, if there is an error in the underlying reader or visitor function,
// or if the visitor function returns a ErrTarStopIteration sentinel error.
func IterateTar(reader io.Reader, visitor TarFileVisitor) error {
	tarReader := tar.NewReader(reader)
	var sequence int64 = -1
	for {
		sequence++
		hdr, err := tarReader.Next()
		if errors.Is(err, io.EOF) {
			break
		}
		if err != nil {
			return err
		}
		if hdr == nil {
			continue
		}
		if err := visitor(TarFileEntry{
			Sequence: sequence,
			Header:   *hdr,
			Reader:   tarReader,
		}); err != nil {
			if errors.Is(err, ErrTarStopIteration) {
				return nil
			}
			return fmt.Errorf(""failed to visit tar entry=%q : %w"", hdr.Name, err)
		}
	}
	return nil
}
// ReaderFromTar returns a io.ReadCloser for the Path within a tar file.
func ReaderFromTar(reader io.ReadCloser, tarPath string) (io.ReadCloser, error) {
	var result io.ReadCloser
	visitor := func(entry TarFileEntry) error {
		if entry.Header.Name == tarPath {
			result = &tarFile{
				Reader: entry.Reader,
				Closer: reader,
			}
			return ErrTarStopIteration
		}
		return nil
	}
	if err := IterateTar(reader, visitor); err != nil {
		return nil, err
	}
	if result == nil {
		return nil, &ErrFileNotFound{tarPath}
	}
	return result, nil
}
// MetadataFromTar returns the tar metadata from the header info.
func MetadataFromTar(reader io.ReadCloser, tarPath string) (Metadata, error) {
	var metadata *Metadata
	visitor := func(entry TarFileEntry) error {
		if entry.Header.Name == tarPath {
			var content io.Reader
			if entry.Header.Size > 0 {
				content = reader
			}
			m := NewMetadata(entry.Header, content)
			metadata = &m
			return ErrTarStopIteration
		}
		return nil
	}
	if err := IterateTar(reader, visitor); err != nil {
		return Metadata{}, err
	}
	if metadata == nil {
		return Metadata{}, &ErrFileNotFound{tarPath}
	}
	return *metadata, nil
}
// UntarToDirectory writes the contents of the given tar reader to the given destination
func UntarToDirectory(reader io.Reader, dst string) error {
	visitor := func(entry TarFileEntry) error {
		target := filepath.Join(dst, entry.Header.Name)
		switch entry.Header.Typeflag {
		case tar.TypeDir:
			if _, err := os.Stat(target); err != nil {
				if err := os.MkdirAll(target, 0755); err != nil {
					return err
				}
			}
		case tar.TypeReg:
			f, err := os.OpenFile(target, os.O_CREATE|os.O_RDWR, os.FileMode(entry.Header.Mode))
			if err != nil {
				return err
			}
			// limit the reader on each file read to prevent decompression bomb attacks
			numBytes, err := io.Copy(f, io.LimitReader(entry.Reader, perFileReadLimit))
			if numBytes >= perFileReadLimit || errors.Is(err, io.EOF) {
				return fmt.Errorf(""zip read limit hit (potential decompression bomb attack)"")
			}
			if err != nil {
				return fmt.Errorf(""unable to copy file: %w"", err)
			}
			if err = f.Close(); err != nil {
				log.Errorf(""failed to close file during untar of path=%q: %w"", f.Name(), err)
			}
		}
		return nil
	}
	return IterateTar(reader, visitor)
}
",CWE-22,164.0,1
"
BEGIN {
	FS = ""\t""
	if (!iso_table) iso_table = ""iso3166.tab""
	if (!zone_table) zone_table = ""zone.tab""
	if (!want_warnings) want_warnings = -1
	while (getline <iso_table) {
		iso_NR++
		if ($0 ~ /^
		if (NF != 2) {
			printf ""%s:%d: wrong number of columns\n"", \
				iso_table, iso_NR >>""/dev/stderr""
			status = 1
		}
		cc = $1
		name = $2
		if (cc !~ /^[A-Z][A-Z]$/) {
			printf ""%s:%d: invalid country code `%s'\n"", \
				iso_table, iso_NR, cc >>""/dev/stderr""
			status = 1
		}
		if (cc <= cc0) {
			if (cc == cc0) {
				s = ""duplicate"";
			} else {
				s = ""out of order"";
			}
			printf ""%s:%d: country code `%s' is %s\n"", \
				iso_table, iso_NR, cc, s \
				>>""/dev/stderr""
			status = 1
		}
		cc0 = cc
		if (name2cc[name]) {
			printf ""%s:%d: `%s' and `%s' have the sname name\n"", \
				iso_table, iso_NR, name2cc[name], cc \
				>>""/dev/stderr""
			status = 1
		}
		name2cc[name] = cc
		cc2name[cc] = name
		cc2NR[cc] = iso_NR
	}
	zone_table = ""zone.tab""
	cc0 = """"
	while (getline <zone_table) {
		zone_NR++
		if ($0 ~ /^
		if (NF != 3 && NF != 4) {
			printf ""%s:%d: wrong number of columns\n"", \
				zone_table, zone_NR >>""/dev/stderr""
			status = 1
		}
		cc = $1
		coordinates = $2
		tz = $3
		comments = $4
		if (cc < cc0) {
			printf ""%s:%d: country code `%s' is out of order\n"", \
				zone_table, zone_NR, cc >>""/dev/stderr""
			status = 1
		}
		cc0 = cc
		if (tz2cc[tz]) {
			printf ""%s:%d: %s: duplicate TZ column\n"", \
				zone_table, zone_NR, tz >>""/dev/stderr""
			status = 1
		}
		tz2cc[tz] = cc
		tz2comments[tz] = comments
		tz2NR[tz] = zone_NR
		if (cc2name[cc]) {
			cc_used[cc]++
		} else {
			printf ""%s:%d: %s: unknown country code\n"", \
				zone_table, zone_NR, cc >>""/dev/stderr""
			status = 1
		}
		if (coordinates !~ /^[-+][0-9][0-9][0-5][0-9][-+][01][0-9][0-9][0-5][0-9]$/ \
		    && coordinates !~ /^[-+][0-9][0-9][0-5][0-9][0-5][0-9][-+][01][0-9][0-9][0-5][0-9][0-5][0-9]$/) {
			printf ""%s:%d: %s: invalid coordinates\n"", \
				zone_table, zone_NR, coordinates >>""/dev/stderr""
			status = 1
		}
	}
	for (tz in tz2cc) {
		if (cc_used[tz2cc[tz]] == 1) {
			if (tz2comments[tz]) {
				printf ""%s:%d: unnecessary comment `%s'\n"", \
					zone_table, tz2NR[tz], tz2comments[tz] \
					>>""/dev/stderr""
				status = 1
			}
		} else {
			if (!tz2comments[tz]) {
				printf ""%s:%d: missing comment\n"", \
					zone_table, tz2NR[tz] >>""/dev/stderr""
				status = 1
			}
		}
	}
	FS = "" ""
}
{
	tz = """"
	if ($1 == ""Zone"") tz = $2
	if ($1 == ""Link"") {
		
		
		src = $2
		dst = $3
		while ((i = index(src, ""/""))) src = substr(src, i+1)
		while ((i = index(dst, ""/""))) dst = substr(dst, i+1)
		if (src != dst) tz = $3
	}
	if (tz && tz ~ /\//) {
		if (!tz2cc[tz]) {
			printf ""%s: no data for `%s'\n"", zone_table, tz \
				>>""/dev/stderr""
			status = 1
		}
		zoneSeen[tz] = 1
	}
}
END {
	for (tz in tz2cc) {
		if (!zoneSeen[tz]) {
			printf ""%s:%d: no Zone table for `%s'\n"", \
				zone_table, tz2NR[tz], tz >>""/dev/stderr""
			status = 1
		}
	}
	if (0 < want_warnings) {
		for (cc in cc2name) {
			if (!cc_used[cc]) {
				printf ""%s:%d: warning: "" \
					""no Zone entries for %s (%s)\n"", \
					iso_table, cc2NR[cc], cc, cc2name[cc]
			}
		}
	}
	exit status
}
",CWE-252,160.0,0
"Linux ACPI Custom Control Method How To
=======================================
Written by Zhang Rui <rui.zhang@intel.com>
Linux supports customizing ACPI control methods at runtime.
Users can use this to
1. override an existing method which may not work correctly,
   or just for debugging purposes.
2. insert a completely new method in order to create a missing
   method such as _OFF, _ON, _STA, _INI, etc.
For these cases, it is far simpler to dynamically install a single
control method rather than override the entire DSDT, because kernel
rebuild/reboot is not needed and test result can be got in minutes.
Note: Only ACPI METHOD can be overridden, any other object types like
      ""Device"", ""OperationRegion"", are not recognized.
Note: The same ACPI control method can be overridden for many times,
      and it's always the latest one that used by Linux/kernel.
Note: To get the ACPI debug object output (Store (AAAA, Debug)),
      please run ""echo 1 > /sys/module/acpi/parameters/aml_debug_output"".
1. override an existing method
   a) get the ACPI table via ACPI sysfs I/F. e.g. to get the DSDT,
      just run ""cat /sys/firmware/acpi/tables/DSDT > /tmp/dsdt.dat""
   b) disassemble the table by running ""iasl -d dsdt.dat"".
   c) rewrite the ASL code of the method and save it in a new file,
   d) package the new file (psr.asl) to an ACPI table format.
      Here is an example of a customized \_SB._AC._PSR method,
      DefinitionBlock ("""", ""SSDT"", 1, """", """", 0x20080715)
      {
	External (ACON)
	Method (\_SB_.AC._PSR, 0, NotSerialized)
	{
		Store (""In AC _PSR"", Debug)
		Return (ACON)
	}
      }
      Note that the full pathname of the method in ACPI namespace
      should be used.
      And remember to use ""External"" to declare external objects.
   e) assemble the file to generate the AML code of the method.
      e.g. ""iasl psr.asl"" (psr.aml is generated as a result)
   f) mount debugfs by ""mount -t debugfs none /sys/kernel/debug""
   g) override the old method via the debugfs by running
      ""cat /tmp/psr.aml > /sys/kernel/debug/acpi/custom_method""
2. insert a new method
   This is easier than overriding an existing method.
   We just need to create the ASL code of the method we want to
   insert and then follow the step c) ~ g) in section 1.
3. undo your changes
   The ""undo"" operation is not supported for a new inserted method
   right now, i.e. we can not remove a method currently.
   For an overrided method, in order to undo your changes, please
   save a copy of the method original ASL code in step c) section 1,
   and redo step c) ~ g) to override the method with the original one.
Note: We can use a kernel with multiple custom ACPI method running,
      But each individual write to debugfs can implement a SINGLE
      method override. i.e. if we want to insert/override multiple
      ACPI methods, we need to redo step c) ~ g) for multiple times.
Note: Be aware that root can mis-use this driver to modify arbitrary
      memory and gain additional rights, if root's privileges got
      restricted (for example if root is not allowed to load additional
      modules after boot).
",CWE-264,74.0,0
"// Transport Security Layer (TLS)
// Copyright (c) 2003-2004 Carlos Guzman Alvarez
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
// 
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
using System;
using System.Globalization;
using System.IO;
using Mono.Security.Protocol.Tls.Handshake;
using Mono.Security.Protocol.Tls.Handshake.Server;
namespace Mono.Security.Protocol.Tls
{
	internal class ServerRecordProtocol : RecordProtocol
	{
		TlsClientCertificate cert;
		
		
		public ServerRecordProtocol(
			Stream			innerStream, 
			ServerContext	context) : base(innerStream, context)
		{
		}
		
		
		public override HandshakeMessage GetMessage(HandshakeType type)
		{
			// Create and process the record message
			HandshakeMessage msg = this.createServerHandshakeMessage(type);
			return msg;
		}
		
		
		protected override void ProcessHandshakeMessage(TlsStream handMsg)
		{
			HandshakeType		handshakeType	= (HandshakeType)handMsg.ReadByte();
			HandshakeMessage	message			= null;
			// Read message length
			int length = handMsg.ReadInt24();
			// Read message data
			byte[] data = new byte[length];
			handMsg.Read(data, 0, length);
			// Create and process the server message
			message = this.createClientHandshakeMessage(handshakeType, data);
			message.Process();
			// Update the last handshake message
			this.Context.LastHandshakeMsg = handshakeType;
			// Update session
			if (message != null)
			{
				message.Update();
				this.Context.HandshakeMessages.WriteByte ((byte) handshakeType);
				this.Context.HandshakeMessages.WriteInt24 (length);
				this.Context.HandshakeMessages.Write (data, 0, data.Length);
			}
		}
		
		
		private HandshakeMessage createClientHandshakeMessage(
			HandshakeType type, byte[] buffer)
		{
			var last = context.LastHandshakeMsg;
			switch (type)
			{
				case HandshakeType.ClientHello:
					return new TlsClientHello(this.context, buffer);
				case HandshakeType.Certificate:
					if (last != HandshakeType.ClientHello)
						break;
					cert = new TlsClientCertificate(this.context, buffer);
					return cert;
				case HandshakeType.ClientKeyExchange:
					if (last == HandshakeType.ClientHello || last == HandshakeType.Certificate)
						return new TlsClientKeyExchange(this.context, buffer);
					break;
				case HandshakeType.CertificateVerify:
					if (last == HandshakeType.ClientKeyExchange && cert != null)
						return new TlsClientCertificateVerify(this.context, buffer);
					break;
				case HandshakeType.Finished:
					// Certificates are optional, but if provided, they should send a CertificateVerify
					bool check = (cert == null) ? (last == HandshakeType.ClientKeyExchange) : (last == HandshakeType.CertificateVerify);
					// ChangeCipherSpecDone is not an handshake message (it's a content type) but still needs to be happens before finished
					if (check && context.ChangeCipherSpecDone) {
						context.ChangeCipherSpecDone = false;
						return new TlsClientFinished(this.context, buffer);
					}
					break;
					
				default:
					throw new TlsException(AlertDescription.UnexpectedMessage, String.Format(CultureInfo.CurrentUICulture,
														 ""Unknown server handshake message received ({0})"", 
														 type.ToString()));
					break;
			}
			throw new TlsException (AlertDescription.HandshakeFailiure, String.Format (""Protocol error, unexpected protocol transition from {0} to {1}"", last, type));
		}
		private HandshakeMessage createServerHandshakeMessage(
			HandshakeType type)
		{
			switch (type)
			{
				case HandshakeType.HelloRequest:
					this.SendRecord(HandshakeType.ClientHello);
					return null;
				case HandshakeType.ServerHello:
					return new TlsServerHello(this.context);
				case HandshakeType.Certificate:
					return new TlsServerCertificate(this.context);
				case HandshakeType.ServerKeyExchange:
					return new TlsServerKeyExchange(this.context);
				case HandshakeType.CertificateRequest:
					return new TlsServerCertificateRequest(this.context);
				case HandshakeType.ServerHelloDone:
					return new TlsServerHelloDone(this.context);
				case HandshakeType.Finished:
					return new TlsServerFinished(this.context);
				default:
					throw new InvalidOperationException(""Unknown server handshake message type: "" + type.ToString() );					
			}
		}
		
	}
}
",CWE-295,174.0,0
"// Transport Security Layer (TLS)
// Copyright (c) 2003-2004 Carlos Guzman Alvarez
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// ""Software""), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
// 
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
using System;
using System.Globalization;
using System.IO;
using Mono.Security.Protocol.Tls.Handshake;
using Mono.Security.Protocol.Tls.Handshake.Client;
namespace Mono.Security.Protocol.Tls
{
	internal class ClientRecordProtocol : RecordProtocol
	{
		
		public ClientRecordProtocol(
			Stream			innerStream, 
			ClientContext	context) : base(innerStream, context)
		{
		}
		
		
		public override HandshakeMessage GetMessage(HandshakeType type)
		{
			HandshakeMessage msg = this.createClientHandshakeMessage(type);
			return msg;
		}
		
		
		protected override void ProcessHandshakeMessage(TlsStream handMsg)
		{
			HandshakeType		handshakeType	= (HandshakeType)handMsg.ReadByte();
			HandshakeMessage	message			= null;
			DebugHelper.WriteLine("">>>> Processing Handshake record ({0})"", handshakeType);
			// Read message length
			int length = handMsg.ReadInt24();
			// Read message data
			byte[] data = null;
			if (length > 0)
			{
				data = new byte[length];
				handMsg.Read (data, 0, length);
			}
			// Create and process the server message
			message = this.createServerHandshakeMessage(handshakeType, data);
			if (message != null)
			{
				message.Process();
			}
			// Update the last handshake message
			this.Context.LastHandshakeMsg = handshakeType;
			// Update session
			if (message != null)
			{
				message.Update();
				this.Context.HandshakeMessages.WriteByte ((byte) handshakeType);
				this.Context.HandshakeMessages.WriteInt24 (length);
				if (length > 0) 
				{
					this.Context.HandshakeMessages.Write (data, 0, data.Length);
				}
			}
		}
		
		
		private HandshakeMessage createClientHandshakeMessage(HandshakeType type)
		{
			switch (type)
			{
				case HandshakeType.ClientHello:
					return new TlsClientHello(this.context);
				case HandshakeType.Certificate:
					return new TlsClientCertificate(this.context);
				case HandshakeType.ClientKeyExchange:
					return new TlsClientKeyExchange(this.context);
				case HandshakeType.CertificateVerify:
					return new TlsClientCertificateVerify(this.context);
				case HandshakeType.Finished:
					return new TlsClientFinished(this.context);
				default:
					throw new InvalidOperationException(""Unknown client handshake message type: "" + type.ToString() );
			}
		}
		private HandshakeMessage createServerHandshakeMessage(
			HandshakeType type, byte[] buffer)
		{
			ClientContext context = (ClientContext)this.context;
			var last = context.LastHandshakeMsg;
			switch (type)
			{
				case HandshakeType.HelloRequest:
					if (context.HandshakeState != HandshakeState.Started)
					{
						context.HandshakeState = HandshakeState.None;
						// re-negotiation will occur at next read/write
						// (i.e. not during an existing encode/decode op)
					}
					else
					{
						this.SendAlert(
							AlertLevel.Warning,
							AlertDescription.NoRenegotiation);
					}
					return null;
				case HandshakeType.ServerHello:
					if (last != HandshakeType.HelloRequest)
						break;
					return new TlsServerHello(this.context, buffer);
					// Optional
				case HandshakeType.Certificate:
					if (last != HandshakeType.ServerHello)
						break;
					return new TlsServerCertificate(this.context, buffer);
					// Optional
				case HandshakeType.CertificateRequest:
					if (last == HandshakeType.ServerKeyExchange || last == HandshakeType.Certificate)
						return new TlsServerCertificateRequest(this.context, buffer);
					break;
				case HandshakeType.ServerHelloDone:
					if (last == HandshakeType.CertificateRequest || last == HandshakeType.Certificate || last == HandshakeType.ServerHello)
						return new TlsServerHelloDone(this.context, buffer);
					break;
				case HandshakeType.Finished:
					// depends if a full (ServerHelloDone) or an abbreviated handshake (ServerHello) is being done
					bool check = context.AbbreviatedHandshake ? (last == HandshakeType.ServerHello) : (last == HandshakeType.ServerHelloDone);
					// ChangeCipherSpecDone is not an handshake message (it's a content type) but still needs to be happens before finished
					if (check && context.ChangeCipherSpecDone) {
						context.ChangeCipherSpecDone = false;
						return new TlsServerFinished (this.context, buffer);
					}
					break;
					
				default:
					throw new TlsException(
						AlertDescription.UnexpectedMessage,
						String.Format(CultureInfo.CurrentUICulture,
							""Unknown server handshake message received ({0})"", 
							type.ToString()));
			}
			throw new TlsException (AlertDescription.HandshakeFailiure, String.Format (""Protocol error, unexpected protocol transition from {0} to {1}"", last, type));
		}
		
	}
}
",CWE-295,196.0,0
"// Copyright 2012 Samuel Stauffer. All rights reserved.
// Use of this source code is governed by a 3-clause BSD
// license that can be found in the LICENSE file.
package socks
import (
	""net""
	""time""
)
type proxiedConn struct {
	conn       net.Conn
	remoteAddr *proxiedAddr
	boundAddr  *proxiedAddr
}
func (c *proxiedConn) Read(b []byte) (int, error) {
	return c.conn.Read(b)
}
func (c *proxiedConn) Write(b []byte) (int, error) {
	return c.conn.Write(b)
}
func (c *proxiedConn) Close() error {
	return c.conn.Close()
}
func (c *proxiedConn) LocalAddr() net.Addr {
	if c.boundAddr != nil {
		return c.boundAddr
	}
	return c.conn.LocalAddr()
}
func (c *proxiedConn) RemoteAddr() net.Addr {
	if c.remoteAddr != nil {
		return c.remoteAddr
	}
	return c.conn.RemoteAddr()
}
func (c *proxiedConn) SetDeadline(t time.Time) error {
	return c.conn.SetDeadline(t)
}
func (c *proxiedConn) SetReadDeadline(t time.Time) error {
	return c.conn.SetReadDeadline(t)
}
func (c *proxiedConn) SetWriteDeadline(t time.Time) error {
	return c.conn.SetWriteDeadline(t)
}
",CWE-835,55.0,0
"package lz4
// 
// 
// 
import ""C""
import (
	""errors""
	""fmt""
	""unsafe""
)
// p gets a char pointer to the first byte of a []byte slice
func p(in []byte) *C.char {
	if len(in) == 0 {
		return (*C.char)(unsafe.Pointer(nil))
	}
	return (*C.char)(unsafe.Pointer(&in[0]))
}
// clen gets the length of a []byte slice as a char *
func clen(s []byte) C.int {
	return C.int(len(s))
}
// Uncompress with a known output size. len(out) should be equal to
// the length of the uncompressed out.
func Uncompress(in, out []byte) (error) {
	if int(C.LZ4_decompress_safe(p(in), p(out), clen(in), clen(out))) < 0 {
		return errors.New(""Malformed compression stream"")
	}
	return nil
}
// CompressBound calculates the size of the output buffer needed by
// Compress. This is based on the following macro:
//
// 
//      ((unsigned int)(isize) > (unsigned int)LZ4_MAX_INPUT_SIZE ? 0 : (isize) + ((isize)/255) + 16)
func CompressBound(in []byte) int {
	return len(in) + ((len(in) / 255) + 16)
}
// Compress compresses in and puts the content in out. len(out)
// should have enough space for the compressed data (use CompressBound
// to calculate). Returns the number of bytes in the out slice.
func Compress(in, out []byte) (outSize int, err error) {
	outSize = int(C.LZ4_compress_limitedOutput(p(in), p(out), clen(in), clen(out)))
	if outSize == 0 {
		err = fmt.Errorf(""insufficient space for compression"")
	}
	return
}
",CWE-787,56.0,0
"package scrypt
import (
	""bytes""
	""crypto/rand""
	""crypto/sha256""
	""crypto/subtle""
	""encoding/binary""
	""log""
	""code.google.com/p/go.crypto/scrypt""
)
// EncryptPassphrase returns a keylen_bytes+60 bytes of encrypted text
// from the input passphrase.
// It runs the scrypt function for this.
func EncryptPassphrase(passphrase string, keylen_bytes int) (key []byte, err error) {
	// Generate salt
	salt := generateSalt()
	// Set params
	var N int32 = 16384
	var r int32 = 8
	var p int32 = 1
	// Generate key
	key, err = scrypt.Key([]byte(passphrase),
		salt,
		int(N), // Must be a power of 2 greater than 1
		int(r),
		int(p), // r*p must be < 2^30
		keylen_bytes)
	if err != nil {
		log.Fatalf(""Error in encrypting passphrase: %s\n"", err)
		return
	}
	// Appending the salt
	key = append(key, salt...)
	// Encoding the params to be stored
	buf := new(bytes.Buffer)
	for _, elem := range [3]int32{N, r, p} {
		err = binary.Write(buf, binary.LittleEndian, elem)
		if err != nil {
			log.Fatalf(""binary.Write failed: %s\n"", err)
			return
		}
		key = append(key, buf.Bytes()...)
		buf.Reset()
	}
	// appending the sha-256 of the entire header at the end
	hash_digest := sha256.New()
	hash_digest.Write(key)
	if err != nil {
		log.Fatalf(""hash_digest.Write failed: %s\n"", err)
		return
	}
	hash := hash_digest.Sum(nil)
	key = append(key, hash...)
	return
}
// VerifyPassphrase takes the passphrase and the target_key to match against.
// And returns a boolean result whether it matched or not
func VerifyPassphrase(passphrase string, keylen_bytes int, target_key []byte) (result bool, err error) {
	// Get the master_key
	target_master_key := target_key[:keylen_bytes]
	// Get the salt
	salt := target_key[keylen_bytes:48]
	// Get the params
	var N, r, p int32
	err = binary.Read(bytes.NewReader(target_key[48:52]), // byte 48:52 for N
		binary.LittleEndian,
		&N)
	if err != nil {
		log.Fatalf(""binary.Read failed for N: %s\n"", err)
		return
	}
	err = binary.Read(bytes.NewReader(target_key[52:56]), // byte 52:56 for r
		binary.LittleEndian,
		&r)
	if err != nil {
		log.Fatalf(""binary.Read failed for r: %s\n"", err)
		return
	}
	err = binary.Read(bytes.NewReader(target_key[56:60]), // byte 56:60 for p
		binary.LittleEndian,
		&p)
	if err != nil {
		log.Fatalf(""binary.Read failed for p: %s\n"", err)
		return
	}
	var source_master_key []byte
	source_master_key, err = scrypt.Key([]byte(passphrase),
		salt,
		int(N), // Must be a power of 2 greater than 1
		int(r),
		int(p), // r*p must be < 2^30
		keylen_bytes)
	if err != nil {
		log.Fatalf(""Error in encrypting passphrase: %s\n"", err)
		return
	}
	target_hash := target_key[60:]
	// Doing the sha-256 checksum at the last because we want the attacker
	// to spend as much time possible cracking
	hash_digest := sha256.New()
	_, err = hash_digest.Write(target_key[:60])
	if err != nil {
		log.Fatalf(""hash_digest.Write failed: %s\n"", err)
		return
	}
	source_hash := hash_digest.Sum(nil)
	// ConstantTimeCompare returns ints. Converting it to bool
	key_comp := subtle.ConstantTimeCompare(source_master_key,
		target_master_key) != 0
	hash_comp := subtle.ConstantTimeCompare(target_hash,
		source_hash) != 0
	result = key_comp && hash_comp
	return
}
func generateSalt() (salt []byte) {
	salt = make([]byte, 16)
	_, err := rand.Read(salt)
	if err != nil {
		log.Fatalf(""Error in generating salt: %s\n"", err)
		return
	}
	return
}
",CWE-208,139.0,0
"$Id: Changelog.txt,v 1.45 2016/03/01 18:06:46 nanard Exp $
2016/03/01:
	Fix broken overflow test (p+l > buf+n) thanks to Salva Piero
VERSION 1.5:
2016/01/13:
	add ""notification"" mode (command 5)
2015/08/06:
	disable multicast loop
	add -f command line option to filter for a specific device type
VERSION 1.4:
2015/08/06:
	added command 0 (version)
2015/07/21:
	set multicast TTL to 2 by default and configurable
2015/05/27:
	support larger buffer size (useful for type 3 requests)
VERSION 1.3:
2014/12/05:
	clean up select call()
	fix non blocking write to sockets
2014/12/04:
	Fixes removing of devices on ssdp:byebye
	handle ssdp:update messages
2014/11/28:
	revert ""listen on only 1 IPv4 if only 1 interface is specified""
	because it prevents broadcast messages to be received
	Change the list of LAN addresses/interfaces (code taken from miniupnpd)
	Check that the peer is from a LAN for each SSDP packet
2014/11/06:
	listen on only 1 IPv4 if only 1 interface is specified
	also when ENABLE_IPV6 is not defined
2014/09/06:
	freebsd-glue for Debian/kFreeBSD
	use LDFLAGS when linking binary
2014/05/01:
	listen on only 1 IPv4 if only 1 interface is specified
2014/02/03:
	silently ignore EAGAIN, EWOULDBLOCK, EINTR of recv calls
	Discover devices on the network at startup
2013/08/19:
	Translate README in english
2012/09/27:
	Rename all include guards to not clash with C99
	(7.1.3 Reserved identifiers).
VERSION 1.2:
2012/05/21:
	Clean signal handling
	Set sockets non blocking
2012/05/18:
	Improve ProcessInterfaceWatch() under BSD.
2012/05/15:
	Improve ProcessInterfaceWatch() under linux.
2012/05/02:
	Clean CLFAGS in Makefile.
	Remove a few signed/unsigned compares
2012/04/09:
	Added -ansi to compilation flags.
	Handle ssdp:update messages and update logging
2012/01/02:
	Install manpage. Fix installation under Mac OS X.
2011/10/07:
	unlink unix socket before binding.
	set SO_REUSEADDR on SSDP socket.
	daemonize after init
VERSION 1.1:
2011/07/30:
	fixes. More overflow checks
2011/07/29:
	added a lot of buffer overflow checks. Check malloc() failure, etc.
	Better cleanup in case of crash at start.
	network interface watch to add/drop multicast membership when the interface get live.
2011/06/18:
	Starting to add support for UPnP Device Architecture v1.1
2011/05/23:
	Added IPv6 support.
	-i option now understands interface names as well as addresses.
VERSION 1.0:
2008/10/07:
	added codelength.h
	Fixing response to M-SEARCH
	Doc update
2008/10/06:
	UPnP server support (answering M-SEARCH)
2008/10/04:
	listening on several interfaces.
2008/10/01:
	use of daemon() instead of home made daemonize.
2007/12/19:
	added uuid in responses
	3 types of requests supported.
	preventing buffer overflow
2007/12/18:
	It is now possible to change the location of both pid file and
	unix socket.
2007/10/08:
	Added a man page
2007/09/27:
	Support for install in different location $ PREFIX=... make install
2007/09/23:
	added a script for use in /etc/init.d
	improved Makefile
	creating /var/run/minissdpd.pid
	adding synthetic messages for new devices/removed devices
2007/09/19:
	Take SSDP announce packets lifetime into account.
",CWE-125,149.0,0
"// +build go1.2
// Copyright 2014 The Gogs Authors. All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.
// Gogs(Go Git Service) is a painless self-hosted Git Service written in Go.
package main
import (
	""os""
	""runtime""
	""github.com/codegangsta/cli""
	""github.com/gogits/gogs/cmd""
	""github.com/gogits/gogs/modules/setting""
)
const APP_VER = ""0.5.6.1025 Beta""
func init() {
	runtime.GOMAXPROCS(runtime.NumCPU())
	setting.AppVer = APP_VER
}
func main() {
	app := cli.NewApp()
	app.Name = ""Gogs""
	app.Usage = ""Go Git Service""
	app.Version = APP_VER
	app.Commands = []cli.Command{
		cmd.CmdWeb,
		cmd.CmdServ,
		cmd.CmdUpdate,
		cmd.CmdFix,
		cmd.CmdDump,
		cmd.CmdCert,
	}
	app.Flags = append(app.Flags, []cli.Flag{}...)
	app.Run(os.Args)
}
",CWE-89,43.0,0
"// Copyright 2014 The Gogs Authors. All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.
package v1
import (
	""fmt""
	""path""
	""strings""
	""github.com/Unknwon/com""
	""github.com/gogits/gogs/models""
	""github.com/gogits/gogs/modules/auth""
	""github.com/gogits/gogs/modules/log""
	""github.com/gogits/gogs/modules/middleware""
)
type repo struct {
	RepoLink string `json:""repolink""`
}
func SearchRepos(ctx *middleware.Context) {
	opt := models.SearchOption{
		Keyword: path.Base(ctx.Query(""q"")),
		Uid:     com.StrTo(ctx.Query(""uid"")).MustInt64(),
		Limit:   com.StrTo(ctx.Query(""limit"")).MustInt(),
	}
	if opt.Limit == 0 {
		opt.Limit = 10
	}
	// Check visibility.
	if ctx.IsSigned && opt.Uid > 0 {
		if ctx.User.Id == opt.Uid {
			opt.Private = true
		} else {
			u, err := models.GetUserById(opt.Uid)
			if err != nil {
				ctx.JSON(500, map[string]interface{}{
					""ok"":    false,
					""error"": err.Error(),
				})
				return
			}
			if u.IsOrganization() && u.IsOrgOwner(ctx.User.Id) {
				opt.Private = true
			}
			// FIXME: how about collaborators?
		}
	}
	repos, err := models.SearchRepositoryByName(opt)
	if err != nil {
		ctx.JSON(500, map[string]interface{}{
			""ok"":    false,
			""error"": err.Error(),
		})
		return
	}
	results := make([]*repo, len(repos))
	for i := range repos {
		if err = repos[i].GetOwner(); err != nil {
			ctx.JSON(500, map[string]interface{}{
				""ok"":    false,
				""error"": err.Error(),
			})
			return
		}
		results[i] = &repo{
			RepoLink: path.Join(repos[i].Owner.Name, repos[i].Name),
		}
	}
	ctx.Render.JSON(200, map[string]interface{}{
		""ok"":   true,
		""data"": results,
	})
}
func Migrate(ctx *middleware.Context, form auth.MigrateRepoForm) {
	u, err := models.GetUserByName(ctx.Query(""username""))
	if err != nil {
		ctx.JSON(500, map[string]interface{}{
			""ok"":    false,
			""error"": err.Error(),
		})
		return
	}
	if !u.ValidtePassword(ctx.Query(""password"")) {
		ctx.JSON(500, map[string]interface{}{
			""ok"":    false,
			""error"": ""username or password is not correct"",
		})
		return
	}
	ctxUser := u
	// Not equal means current user is an organization.
	if form.Uid != u.Id {
		org, err := models.GetUserById(form.Uid)
		if err != nil {
			ctx.JSON(500, map[string]interface{}{
				""ok"":    false,
				""error"": err.Error(),
			})
			return
		}
		ctxUser = org
	}
	if ctx.HasError() {
		ctx.JSON(500, map[string]interface{}{
			""ok"":    false,
			""error"": ctx.GetErrMsg(),
		})
		return
	}
	if ctxUser.IsOrganization() {
		// Check ownership of organization.
		if !ctxUser.IsOrgOwner(u.Id) {
			ctx.JSON(403, map[string]interface{}{
				""ok"":    false,
				""error"": ""given user is not owner of organization"",
			})
			return
		}
	}
	authStr := strings.Replace(fmt.Sprintf(""://%s:%s"",
		form.AuthUserName, form.AuthPasswd), ""@"", ""%40"", -1)
	url := strings.Replace(form.HttpsUrl, ""://"", authStr+""@"", 1)
	repo, err := models.MigrateRepository(ctxUser, form.RepoName, form.Description, form.Private,
		form.Mirror, url)
	if err == nil {
		log.Trace(""Repository migrated: %s/%s"", ctxUser.Name, form.RepoName)
		ctx.JSON(200, map[string]interface{}{
			""ok"":   true,
			""data"": ""/"" + ctxUser.Name + ""/"" + form.RepoName,
		})
		return
	}
	if repo != nil {
		if errDelete := models.DeleteRepository(ctxUser.Id, repo.Id, ctxUser.Name); errDelete != nil {
			log.Error(4, ""DeleteRepository: %v"", errDelete)
		}
	}
	ctx.JSON(500, map[string]interface{}{
		""ok"":    false,
		""error"": err.Error(),
	})
}
",CWE-89,158.0,0
"// +build go1.2
// Copyright 2014 The Gogs Authors. All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.
// Gogs(Go Git Service) is a painless self-hosted Git Service written in Go.
package main
import (
	""os""
	""runtime""
	""github.com/codegangsta/cli""
	""github.com/gogits/gogs/cmd""
	""github.com/gogits/gogs/modules/setting""
)
const APP_VER = ""0.5.6.1104 Beta""
func init() {
	runtime.GOMAXPROCS(runtime.NumCPU())
	setting.AppVer = APP_VER
}
func main() {
	app := cli.NewApp()
	app.Name = ""Gogs""
	app.Usage = ""Go Git Service""
	app.Version = APP_VER
	app.Commands = []cli.Command{
		cmd.CmdWeb,
		cmd.CmdServ,
		cmd.CmdUpdate,
		cmd.CmdFix,
		cmd.CmdDump,
		cmd.CmdCert,
	}
	app.Flags = append(app.Flags, []cli.Flag{}...)
	app.Run(os.Args)
}
",CWE-89,43.0,0
"00:0c:29:31:85:a5 > 00:0c:29:ac:b9:50, ethertype IPv4 (0x0800), length 321: (tos 0xc0, ttl 254, id 20061, offset 0, flags [none], proto TCP (6), length 307)
    10.0.0.4.179 > 10.0.0.2.64588: Flags [P.], cksum 0x707c (incorrect -> 0x6883), seq 786752827:786753082, ack 3829861902, win 16357, options [nop,nop,TS val 6993003 ecr 4502201], length 255: BGP
	Update Message (2), length: 100
	  Origin (1), length: 1, Flags [T]: IGP
	    0x0000:  00
	  AS Path (2), length: 0, Flags [T]: empty
	  Local Preference (5), length: 4, Flags [T]: 100
	    0x0000:  0000 0064
	  Extended Community (16), length: 24, Flags [OT]: 
	    target (0x0002), Flags [none]: 1:1 (= 0.0.0.1)
	    source-AS (0x0009), Flags [none]: AS 1
	    unknown extd community typecode (0x010a), Flags [none]
	      0x0000:  010a 0a00 0004 0006
	    0x0000:  0002 0001 0000 0001 0009 0001 0000 0000
	    0x0010:  010a 0a00 0004 0006
	  Multi-Protocol Reach NLRI (14), length: 32, Flags [OE]: 
	    AFI: IPv4 (1), SAFI: labeled VPN Unicast (128)
	    nexthop: RD: 0:0 (= 0.0.0.0), 10.0.0.4, nh-length: 12, no SNPA
	      RD: 1:1 (= 0.0.0.1), 172.16.4.0/24, label:16 (bottom)
	    0x0000:  0001 800c 0000 0000 0000 0000 0a00 0004
	    0x0010:  0070 0001 0100 0000 0100 0000 01ac 1004
	Update Message (2), length: 95
	  Origin (1), length: 1, Flags [T]: IGP
	    0x0000:  00
	  AS Path (2), length: 0, Flags [T]: empty
	  Local Preference (5), length: 4, Flags [T]: 100
	    0x0000:  0000 0064
	  Extended Community (16), length: 8, Flags [OT]: 
	    target (0x0002), Flags [none]: 1:1 (= 0.0.0.1)
	    0x0000:  0002 0001 0000 0001
	  PMSI Tunnel (22), length: 17, Flags [OT]: 
	    Tunnel-type RSVP-TE P2MP LSP (1), Flags [none], MPLS Label 0
	      Extended-Tunnel-ID 10.0.0.4, P2MP-ID 0x00008173
	    0x0000:  0001 0000 000a 0000 0400 0081 730a 0000
	    0x0010:  04
	  Multi-Protocol Reach NLRI (14), length: 23, Flags [OE]: 
	    AFI: IPv4 (1), SAFI: Multicast VPN (5)
	    nexthop: 10.0.0.4, nh-length: 4
	    8 SNPA
	      1 bytes
	      0 bytes
	      0 bytes
	      0 bytes
	      1 bytes
	      0 bytes
	      0 bytes
	      1 bytes
	      Route-Type: Unknown (0), length: 0
	      Route-Type: Intra-AS Segment-Leaf (4), length: 255
	    0x0000:  0001 0504 0a00 0004 0801 0c00 0000 0100
	    0x0010:  0000 010a 0000 04
	Update Message (2), length: 30
	  Multi-Protocol Unreach NLRI (15), length: 3, Flags [OE]: 
	    AFI: IPv4 (1), SAFI: labeled VPN Unicast (128)
	      End-of-Rib Marker (empty NLRI)
	    0x0000:  0001 80
	Update Message (2), length: 30
	  Withdrawn routes: 1 bytes
	  Unknown Attribute (0), length: 3, Flags [+f]: 
	    no Attribute 0 decoder
	    0x0000:  0001 05[|BGP]
",CWE-125,62.0,0
"UI 22! Pad! IS-IS, length 1644274306
	L2 Lan IIH, hlen: 27, v: 1, pdu-v: 1, sys-id-len: 6 (0), max-area: 224 (224)
	  source-id: fe02.0000.d0f9,  holding time: 3928s, Flags: [unknown circuit type 0x00]
	  lan-id:    1000.4101.0000.88, Priority: 127, PDU length: 44959
	    unknown TLV 
		0x0000:  e2
	    IS Reachability TLV 
	      bogus virtual flag 0x07
	      IS Neighbor: 0100.1001.9de0.00, Default Metric: 34, Internal
		  Delay Metric: 5, Internal
		  Error Metric: 27, Internal
	    Authentication TLV 
	      unknown Authentication type 0x05: 
	    unknown TLV 
		0x0000:  2020 2020 2020 2020 2020 2020 2020 2020
		0x0010:  2020 2020 2020 2020 2020 2220 2020 2020
	    unknown TLV 
		0x0000:  2000 0001 0020 2020 2020 2020 207f 0020
		0x0010:  2020 2020 2020 2020 2020 2e20 2020 20c9
	    unknown TLV 
		0x0000:  2020 2010 0020 2020 2020 0b20 2020 2020
		0x0010:  2020 2020 2020 8181 7281 8181 8181 8181
	    Multi-Topology-Aware Port Capability TLV 
	       RES: 8, MTID(s): 385
	       unknown subTLV 
	       unknown subTLV 
	       unknown subTLV 
		 [|isis] [|isis]
",CWE-125,29.0,0
"IP (tos 0x41,ECT(1), id 40256, offset 0, flags [none], proto PGM (113), length 768, options (unknown 89 [bad length 232]), bad cksum 5959 (->5afd)!)
    89.121.89.107 > 89.89.89.89: 89.121.89.107.32322 > 89.89.89.89.500: PGM, length 24818 0x00ff7f010347 [|pgm]
",CWE-125,3.0,0
"UI 22! IS-IS, length 469869187
	L2 Lan IIH, hlen: 27, v: 1, pdu-v: 1, sys-id-len: 6 (0), max-area: 224 (224)
	  source-id: fed0.f90f.58af,  holding time: 34047s, Flags: [unknown circuit type 0x00]
	  lan-id:    0105.0088.a204.00, Priority: 65, PDU length: 4096
	    unknown TLV 
		0x0000:  ff10 8e12 0001 1b01 0000 6b00 fbcf f90f
		0x0010:  58af 84ff 1000 4901 0000 88a2 011c 000c
		0x0020:  0281 0083 1b01 0010 019d e000 fed0 f90f
		0x0030:  58af 84ff 1000 4101 0500 88a2 011c 0272
		0x0040:  0c2a 2205 831b 011c 0010 0000 0583 1b01
		0x0050:  0010 01ab e000 fe08 0808 0808 08cb 0808
		0x0060:  0808 0808 0808 0880 0008 7f08 0808 0808
		0x0070:  08fd 0808 080c 0608 0807 0808 0808 0408
	    Padding TLV 
	    Padding TLV 
	    Padding TLV 
	    Padding TLV 
	    Padding TLV 
	    Padding TLV 
	    unknown TLV 
	    unknown TLV 
		0x0000:  2020 2020 3c20 2020 2020 2020 205a 1a31
	    IS Neighbor(s) (variable length) TLV 
	      LAN address length 1 bytes 
		IS Neighbor: 5a
		IS Neighbor: 45
		IS Neighbor: 50
		IS Neighbor: 48
		IS Neighbor: 59
		IS Neighbor: 52
		IS Neighbor: 5f
		IS Neighbor: 43
		IS Neighbor: 54
		IS Neighbor: 4c
		IS Neighbor: 08
		IS Neighbor: 08
		IS Neighbor: 08
		IS Neighbor: 08
		IS Neighbor: 08
		IS Neighbor: 08
		IS Neighbor: 08
		IS Neighbor: 08
		IS Neighbor: 08
		IS Neighbor: 08
		IS Neighbor: 08
		IS Neighbor: 08
		IS Neighbor: 08
		IS Neighbor: 08
		IS Neighbor: 08
		IS Neighbor: 08
		IS Neighbor: 08
		IS Neighbor: 08
		IS Neighbor: 08
		IS Neighbor: 08
		IS Neighbor: 00
		IS Neighbor: 00
		IS Neighbor: 08
		IS Neighbor: 00
		IS Neighbor: 20
		IS Neighbor: 64
		IS Neighbor: 00
		IS Neighbor: 20
		IS Neighbor: 10
		IS Neighbor: 20
		IS Neighbor: 20
		IS Neighbor: 20
		IS Neighbor: 20
		IS Neighbor: 20
		IS Neighbor: 20
		IS Neighbor: 20
		IS Neighbor: 20 [|isis]
",CWE-125,72.0,0
"package main
import (
	""database/sql""
	""fmt""
	""log""
	""net/http""
	""github.com/gorilla/mux""
	_ ""github.com/lib/pq""
)
var servport = "":6862""
func failOnError(err error, msg string) {
	if err != nil {
		log.Fatalf(""[X] %s, %s"", msg, err)
		panic(fmt.Sprintf(""%s, %s"", msg, err))
	}
}
func main() {
	log.Println(""[i] Server started"")
	// Connect to DB
	db, err := sql.Open(""postgres"", ""user=appread dbname='quantifiedSelf' sslmode=disable"")
	failOnError(err, ""Error connecting to database"")
	defer db.Close()
	http.HandleFunc(""/data/all/"", func(w http.ResponseWriter, r *http.Request) {
		// TODO: Allow filtering via URL
		// Get rows from DB
		var output string
		err := db.QueryRow(`SELECT json_agg(r) FROM (SELECT * FROM trello.cards) r;`).Scan(&output)
		if err != nil {
			log.Println(""Error retriving from DB, "", err)
			w.WriteHeader(http.StatusInternalServerError)
			fmt.Fprintln(w, ""Error retriving from DB, "", err)
			return
		}
		// Print out returned
		fmt.Fprint(w, output)
	})
	// Restful handler
	r := mux.NewRouter()
	r.HandleFunc(""/api"", func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintln(w, ""dla;jfkdlsajflkdsa;jfk;ldsajfklds;a"")
	})
	r.HandleFunc(""/api/totals/last/{num}"", func(w http.ResponseWriter, r *http.Request) {
		// Grab vars
		vars := mux.Vars(r)
		var output string
		// This is bad... don't do this.... omg
		query := `SELECT json_agg(r) FROM (select EXTRACT(epoch FROM day) as day, end_of_day_total from trello.dailytallies order by day DESC limit $1) r;`
		err := db.QueryRow(query, vars[""num""]).Scan(&output)
		if err != nil {
			log.Println(""Error retriving from DB, "", err)
			w.WriteHeader(http.StatusInternalServerError)
			fmt.Fprintln(w, ""Error retriving from DB, "", err)
			return
		}
		// Print out returned
		w.Header().Set(""Content-Type"", ""application/json"")
		fmt.Fprint(w, output)
	})
	r.HandleFunc(""/api/diffs/last/{num}"", func(w http.ResponseWriter, r *http.Request) {
		// Grab vars
		vars := mux.Vars(r)
		var output string
		// This is bad... don't do this.... omg
		query := `SELECT json_agg(r) FROM (select EXTRACT(epoch FROM day) as day, up_count, down_count, finished_count from trello.dailytallies order by day DESC limit $1) r;`
		err := db.QueryRow(query, vars[""num""]).Scan(&output)
		if err != nil {
			log.Println(""Error retriving from DB, "", err)
			w.WriteHeader(http.StatusInternalServerError)
			fmt.Fprintln(w, ""Error retriving from DB, "", err)
			return
		}
		// Print out returned
		w.Header().Set(""Content-Type"", ""application/json"")
		fmt.Fprint(w, output)
	})
	r.PathPrefix(""/"").Handler(http.FileServer(http.Dir(""../ui"")))
	http.Handle(""/"", r)
	// Die gracefully
	// killchan := make(chan os.Signal)
	// signal.Notify(killchan, os.Interrupt, os.Kill)
	log.Println(""[i] Serving on "", servport, ""\n\tWaiting..."")
	log.Fatal(http.ListenAndServe(servport, nil))
	// <-killchan
	log.Println(""[i] Shutting down..."")
}
",CWE-89,107.0,0
"package content
import (
	""errors""
	""io""
	""os""
	""path""
	""path/filepath""
	""strings""
	""github.com/hoffie/larasync/helpers/atomic""
)
const (
	// default permissions
	defaultFilePerms = 0600
	defaultDirPerms  = 0700
)
// ErrInvalidPath is returned if storage at a path not rooted at the FileStorage's
// root path is attempted.
var ErrInvalidPath = errors.New(""invalid path"")
// FileStorage is the basic implementation of the Storage
// implementation which stores the data into the file system.
type FileStorage struct {
	path string
}
// NewFileStorage generates a file content storage with the
// given path.
func NewFileStorage(path string) *FileStorage {
	return &FileStorage{
		path: path,
	}
}
// CreateDir ensures that the file blob storage directory exists.
func (f *FileStorage) CreateDir() error {
	err := os.Mkdir(f.path, defaultDirPerms)
	if err != nil && !os.IsExist(err) {
		return err
	}
	return nil
}
// storagePathFor returns the storage path for the data entry.
func (f *FileStorage) storagePathFor(contentID string) (string, error) {
	p := path.Join(f.path, contentID)
	p = filepath.Clean(p)
	root := f.path
	/*if len(root) > 1 && root[len(root)-1] != filepath.Separator {
		root += filepath.Separator
	}*/
	if !strings.HasPrefix(p, root) {
		return """", ErrInvalidPath
	}
	return p, nil
}
// Get returns the file handle for the given contentID.
// If there is no data stored for the Id it should return a
// os.ErrNotExists error.
func (f *FileStorage) Get(contentID string) (io.ReadCloser, error) {
	if !f.Exists(contentID) {
		return nil, os.ErrNotExist
	}
	// FIXME TOCTU race
	p, err := f.storagePathFor(contentID)
	if err != nil {
		return nil, err
	}
	return os.Open(p)
}
// Set sets the data of the given contentID in the blob storage.
func (f *FileStorage) Set(contentID string, reader io.Reader) error {
	blobStoragePath, err := f.storagePathFor(contentID)
	if err != nil {
		return err
	}
	writer, err := atomic.NewStandardWriter(blobStoragePath, defaultFilePerms)
	if err != nil {
		return err
	}
	_, err = io.Copy(writer, reader)
	if err != nil {
		writer.Abort()
		writer.Close()
		return err
	}
	err = writer.Close()
	if err != nil {
		return err
	}
	return nil
}
// Exists checks if the given entry is stored in the database.
func (f *FileStorage) Exists(contentID string) bool {
	p, err := f.storagePathFor(contentID)
	if err != nil {
		// FIXME maybe return error instead?
		return false
	}
	_, err = os.Stat(p)
	if err != nil {
		return !os.IsNotExist(err)
	}
	return true
}
// Delete removes the data with the given contentID from the store.
func (f *FileStorage) Delete(contentID string) error {
	p, err := f.storagePathFor(contentID)
	if err != nil {
		return err
	}
	return os.Remove(p)
}
",CWE-22,126.0,0
"package content
import (
	""bytes""
	""crypto/sha256""
	""encoding/hex""
	""io""
	""io/ioutil""
	""os""
	""path""
	. ""gopkg.in/check.v1""
)
type FileStorageTests struct {
	dir     string
	storage *FileStorage
	data    []byte
}
var _ = Suite(&FileStorageTests{})
var dangerousNames = []string{"".."", ""../xyz""}
func (t *FileStorageTests) SetUpTest(c *C) {
	t.dir = c.MkDir()
	t.storage = NewFileStorage(t.dir)
	t.data = []byte(""This is a test blob storage file input."")
}
func (t *FileStorageTests) blobID() string {
	blobIDBytes := sha256.New().Sum(t.data)
	return hex.EncodeToString(blobIDBytes[:])
}
func (t *FileStorageTests) blobPath() string {
	return path.Join(t.dir, t.blobID())
}
func (t *FileStorageTests) testReader() io.Reader {
	return bytes.NewReader(t.data)
}
func (t *FileStorageTests) setData() error {
	return t.storage.Set(t.blobID(), t.testReader())
}
func (t *FileStorageTests) TestSetDangerousName(c *C) {
	r := t.testReader()
	for _, id := range dangerousNames {
		err := t.storage.Set(id, r)
		c.Assert(err, NotNil)
	}
}
func (t *FileStorageTests) TestSet(c *C) {
	err := t.setData()
	c.Assert(err, IsNil)
	_, err = os.Stat(t.blobPath())
	c.Assert(err, IsNil)
}
func (t *FileStorageTests) TestSetInputData(c *C) {
	t.setData()
	file, _ := os.Open(t.blobPath())
	fileData, _ := ioutil.ReadAll(file)
	c.Assert(fileData[:], DeepEquals, t.data[:])
}
func (t *FileStorageTests) TestExistsNegative(c *C) {
	c.Assert(t.storage.Exists(t.blobID()), Equals, false)
}
func (t *FileStorageTests) TestExistsPositive(c *C) {
	t.setData()
	c.Assert(t.storage.Exists(t.blobID()), Equals, true)
}
func (t *FileStorageTests) TestGet(c *C) {
	t.storage.Set(t.blobID(), t.testReader())
	_, err := t.storage.Get(t.blobID())
	c.Assert(err, IsNil)
}
func (t *FileStorageTests) TestGetDangerousName(c *C) {
	for _, id := range dangerousNames {
		_, err := t.storage.Get(id)
		c.Assert(err, NotNil)
	}
}
func (t *FileStorageTests) TestGetData(c *C) {
	t.setData()
	file, _ := t.storage.Get(t.blobID())
	fileData, _ := ioutil.ReadAll(file)
	c.Assert(fileData[:], DeepEquals, t.data)
}
func (t *FileStorageTests) TestGetError(c *C) {
	_, err := t.storage.Get(t.blobID())
	c.Assert(err, NotNil)
}
func (t *FileStorageTests) TestSetError(c *C) {
	os.RemoveAll(t.dir)
	err := t.storage.Set(t.blobID(),
		t.testReader())
	c.Assert(err, NotNil)
}
func (t *FileStorageTests) TestDelete(c *C) {
	t.setData()
	err := t.storage.Delete(t.blobID())
	c.Assert(err, IsNil)
	c.Assert(t.storage.Exists(t.blobID()), Equals, false)
}
func (t *FileStorageTests) TestDeleteError(c *C) {
	err := t.storage.Delete(t.blobID())
	c.Assert(err, NotNil)
}
",CWE-22,123.0,0
"/* no session management needed
 * Credentials are stored at user side using secure cookies
 *
 * credits:
 * http://www.mschoebel.info/2014/03/09/snippet-golang-webapp-login-logout.html
 */
package main
import (
	""github.com/gorilla/securecookie""
	""net/http""
)
var cookieHandler = securecookie.New(
	securecookie.GenerateRandomKey(64),
	securecookie.GenerateRandomKey(32))
func getCredentials(request *http.Request) (userName string, password string, host string, port string) {
	if cookie, err := request.Cookie(""Datasource""); err == nil {
		cookieValue := make(map[string]string)
		if err = cookieHandler.Decode(""Datasource"", cookie.Value, &cookieValue); err == nil {
			userName = cookieValue[""user""]
			password = cookieValue[""passwd""]
			host = cookieValue[""host""]
			port = cookieValue[""port""]
		}
	}
	return userName, password, host, port
}
func setCredentials( w http.ResponseWriter, userName string, pw string, host string, port string) {
	value := map[string]string{
		""user"":   userName,
		""passwd"": pw,
		""host"": host,
		""port"": port,
	}
	if encoded, err := cookieHandler.Encode(""Datasource"", value); err == nil {
		cookie := &http.Cookie{
			Name:  ""Datasource"",
			Value: encoded,
			Path:  ""/"",
		}
		http.SetCookie(w, cookie)
	}
}
func clearCredentials(w http.ResponseWriter) {
	cookie := &http.Cookie{
		Name:   ""Datasource"",
		Value:  """",
		Path:   ""/"",
		MaxAge: -1,
	}
	http.SetCookie(w, cookie)
}
func loginHandler(w http.ResponseWriter, request *http.Request) {
	user := request.FormValue(""user"")
	pass := request.FormValue(""password"")
	host := request.FormValue(""host"")
	port := request.FormValue(""port"")
	if user != """" && pass != """" {
		setCredentials(w, user, pass, host, port)
	}
	http.Redirect(w, request, ""/"", 302)
}
func logoutHandler(w http.ResponseWriter, request *http.Request) {
	clearCredentials(w)
	http.Redirect(w, request, ""/"", 302)
}
const loginPage = `
<h1>Login</h1>
<form method=""post"" action=""/login"">
   <label for=""user"">User name</label><input type=""text"" id=""user"" name=""user""><br>
   <label for=""password"">Password</label><input type=""password"" id=""password"" name=""password""><br>
   <label for=""host"">Host</label><input type=""text"" id=""host"" name=""host"" value=""localhost""><br>
   <label for=""port"">Port</label><input type=""text"" id=""port"" name=""port"" value=""3306""><br>
   <button type=""submit"">Login</button>
</form>
`
",CWE-89,85.0,0
"package main
import (
	""fmt""
	""net/http""
	""os""
	""strings""
)
// simple error checker
func checkY(err error) {
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
}
// will create a link into one level deeper
func linkDeeper(cwd string, link string, name string) string {
	return ""<a href=\"""" + cwd + ""/"" + link + ""\"">"" + name + ""</a>""
}
// Compose dataSourceName from components and globals
func dsn(user string, pw string, host string, port string, db string) string {
	return user + "":"" + pw + ""@tcp("" + host + "":"" + port + "")/"" + db
}
// Converts an URL into an array of strings
func url2array(r *http.Request) []string {
	path := r.URL.Path
	path = strings.TrimSpace(path)
	if strings.HasPrefix(path, ""/"") {
		path = path[1:]
	}
	if strings.HasSuffix(path, ""/"") {
		path = path[:len(path)-1]
	}
	return strings.Split(path, ""/"")
}
",CWE-89,40.0,0
"package main
/* TODO
 * turn into more generic functions for printing into tables
 */
import (
	""database/sql""
	""fmt""
	_ ""github.com/go-sql-driver/mysql""
	""net/http""
	""strconv""
	""strings""
	""text/template""
)
// Shows selection of databases at top level
func home(w http.ResponseWriter, r *http.Request) {
	user, pw, h , p := getCredentials(r)
	conn, err := sql.Open(""mysql"", dsn(user, pw, h, p, database))
	checkY(err)
	defer conn.Close()
	statement, err := conn.Prepare(""show databases"")
	checkY(err)
	rows, err := statement.Query()
	checkY(err)
	defer rows.Close()
	var n int = 1
	for rows.Next() {
		var field string
		rows.Scan(&field)
		fmt.Fprint(w, linkDeeper("""", field, ""DB[""+strconv.Itoa(n)+""]""))
		fmt.Fprintln(w, "" "", field, ""<br>"")
		n = n + 1
	}
}
//  Dump all tables of a database
func dumpdb(w http.ResponseWriter, r *http.Request, parray []string) {
	user, pw, h, p := getCredentials(r)
	database := parray[0]
	conn, err := sql.Open(""mysql"", dsn(user, pw, h, p, database))
	checkY(err)
	defer conn.Close()
	statement, err := conn.Prepare(""show tables"")
	checkY(err)
	rows, err := statement.Query()
	checkY(err)
	defer rows.Close()
	var n int = 1
	for rows.Next() {
		var field string
		rows.Scan(&field)
		fmt.Fprint(w, linkDeeper(r.URL.Path, field, ""T[""+strconv.Itoa(n)+""]""))
		fmt.Fprintln(w, ""  "", field, ""<br>"")
		n = n + 1
	}
}
//  Dump all records of a table, one per line
func dumptable(w http.ResponseWriter, r *http.Request, parray []string) {
	user, pw, h, p := getCredentials(r)
	database := parray[0]
	table := parray[1]
	conn, err := sql.Open(""mysql"", dsn(user, pw, h, p, database))
	checkY(err)
	defer conn.Close()
	statement, err := conn.Prepare(""select * from "" + template.HTMLEscapeString(table))
	checkY(err)
	rows, err := statement.Query()
	checkY(err)
	defer rows.Close()
	cols, err := rows.Columns()
	checkY(err)
	fmt.Fprintln(w, ""<p>""+""
	/*  credits:
	 * 	http://stackoverflow.com/questions/19991541/dumping-mysql-tables-to-json-with-golang
	 * 	http://go-database-sql.org/varcols.html
	 */
	raw := make([]interface{}, len(cols))
	val := make([]interface{}, len(cols))
	for i := range val {
		raw[i] = &val[i]
	}
	var n int = 1
	for rows.Next() {
		fmt.Fprint(w, linkDeeper(r.URL.Path, strconv.Itoa(n), strconv.Itoa(n)))
		err = rows.Scan(raw...)
		checkY(err)
		for _, col := range val {
			if col != nil {
				fmt.Fprintf(w, ""%s "", string(col.([]byte)))
			}
		}
		fmt.Fprintln(w, ""<br>"")
		n = n + 1
	}
}
// Dump all fields of a record, one column per line
func dumprecord(w http.ResponseWriter, r *http.Request, parray []string) {
	database := parray[0]
	table := parray[1]
	rec, err := strconv.Atoi(parray[2])
	checkY(err)
	user, pw, h, p := getCredentials(r)
	conn, err := sql.Open(""mysql"", dsn(user, pw, h, p, database))
	checkY(err)
	defer conn.Close()
	statement, err := conn.Prepare(""select * from "" + template.HTMLEscapeString(table))
	checkY(err)
	rows, err := statement.Query()
	checkY(err)
	defer rows.Close()
	columns, err := rows.Columns()
	checkY(err)
	raw := make([]interface{}, len(columns))
	val := make([]interface{}, len(columns))
	for i := range val {
		raw[i] = &val[i]
	}
	var n int = 1
rowLoop:
	for rows.Next() {
		// unfortunately we have to iterate up to row of interest
		if n == rec {
			err = rows.Scan(raw...)
			checkY(err)
			fmt.Fprintln(w, ""<p>"")
			for i, col := range val {
				if col != nil {
					fmt.Fprintln(w, columns[i], "":"", string(col.([]byte)), ""<br>"")
				}
			}
			fmt.Fprintln(w, ""</p>"")
			break rowLoop
		}
		n = n + 1
	}
}
",CWE-89,171.0,0
"package main
import (
	""fmt""
	_ ""github.com/go-sql-driver/mysql""
	""net/http""
)
var base_url = ""http://localhost""
var database = ""information_schema""
func faviconHandler(w http.ResponseWriter, r *http.Request) {
	http.StatusText(404)
}
func loginPageHandler(w http.ResponseWriter, request *http.Request) {
	fmt.Fprintf(w, loginPage)
}
func pathHandler(w http.ResponseWriter, r *http.Request) {
	if r.URL.Path == ""/"" {
		home(w, r)
	} else {
		parray := url2array(r)
		switch len(parray) {
		case 1:
			dumpdb(w, r, parray)
		case 2:
			dumptable(w, r, parray)
		case 3:
			dumprecord(w, r, parray)
		}
	}
}
func indexHandler(w http.ResponseWriter, r *http.Request) {
	user , _ , host , port := getCredentials(r)
	if user != """" {
		fmt.Fprintln(w, ""<p>"", user + ""@"" + host + "":"" + port, ""</p>"")
		pathHandler(w, r)
	} else {
		loginPageHandler(w, r)
	}
}
func main() {
	http.HandleFunc(""/favicon.ico"", faviconHandler)
	http.HandleFunc(""/login"", loginHandler)
	http.HandleFunc(""/logout"", logoutHandler)
	http.HandleFunc(""/"", indexHandler)
	fmt.Println(""Listening at localhost:8080"")
	http.ListenAndServe("":8080"", nil)
}
",CWE-89,59.0,0
"﻿using IcepayRestClient.Classes.Refund;
namespace IcepayRestClient
{
    public class Refund : ServiceBase
    {
        public Refund(int merchantID, string merchantSecret) : base(merchantID, merchantSecret) { }
        public RequestRefundResponse Checkout(RequestRefundRequest request)
        {
            return IcepayRestClient.Classes.RestClient.SendAndReceive<RequestRefundRequest, RequestRefundResponse>(""Refund"", ""RequestRefund"", request, this.MerchantID, this.MerchantSecret);
        }
        public CancelRefundResponse Checkout(CancelRefundRequest request)
        {
            return IcepayRestClient.Classes.RestClient.SendAndReceive<CancelRefundRequest, CancelRefundResponse>(""Refund"", ""CancelRefund"", request, this.MerchantID, this.MerchantSecret);
        }
        public GetPaymentRefundsResponse Checkout(GetPaymentRefundsRequest request)
        {
            return IcepayRestClient.Classes.RestClient.SendAndReceive<GetPaymentRefundsRequest, GetPaymentRefundsResponse>(""Refund"", ""GetPaymentRefunds"", request, this.MerchantID, this.MerchantSecret);
        }
    }
}
",CWE-354,25.0,0
"package main
import (
	""fmt""
	""log""
	""net/http""
	""time""
	""github.com/deis/workflow-manager/config""
	""github.com/deis/workflow-manager/data""
	""github.com/deis/workflow-manager/handlers""
	""github.com/deis/workflow-manager/jobs""
	""github.com/deis/workflow-manager/k8s""
	""github.com/gorilla/mux""
	kcl ""k8s.io/kubernetes/pkg/client/unversioned""
)
func main() {
	kubeClient, err := kcl.NewInCluster()
	if err != nil {
		log.Fatalf(""Error creating new Kubernetes client (%s)"", err)
	}
	apiClient, err := config.GetSwaggerClient(config.Spec.VersionsAPIURL)
	if err != nil {
		log.Fatalf(""Error creating new swagger api client (%s)"", err)
	}
	deisK8sResources := k8s.NewResourceInterfaceNamespaced(kubeClient, config.Spec.DeisNamespace)
	clusterID := data.NewClusterIDFromPersistentStorage(deisK8sResources.Secrets())
	installedDeisData := data.NewInstalledDeisData(deisK8sResources)
	availableVersion := data.NewAvailableVersionsFromAPI(
		apiClient,
		config.Spec.VersionsAPIURL,
	)
	availableComponentVersion := data.NewLatestReleasedComponent(deisK8sResources, availableVersion)
	pollDur := time.Duration(config.Spec.Polling) * time.Second
	// we want to do the following jobs according to our remote API interval:
	// 1. get latest stable deis component versions
	// 2. send diagnostic data, if appropriate
	glvdPeriodic := jobs.NewGetLatestVersionDataPeriodic(
		installedDeisData,
		clusterID,
		availableVersion,
		availableComponentVersion,
		pollDur,
	)
	svPeriodic := jobs.NewSendVersionsPeriodic(
		apiClient,
		clusterID,
		deisK8sResources,
		availableVersion,
		pollDur,
	)
	toDo := []jobs.Periodic{glvdPeriodic, svPeriodic}
	log.Printf(""Starting periodic jobs at interval %s"", pollDur)
	ch := jobs.DoPeriodic(toDo)
	defer close(ch)
	// Get a new router, with handler functions
	r := handlers.RegisterRoutes(mux.NewRouter(), availableVersion, deisK8sResources)
	// Bind to a port and pass our router in
	hostStr := fmt.Sprintf("":%s"", config.Spec.Port)
	log.Printf(""Serving on %s"", hostStr)
	if err := http.ListenAndServe(hostStr, r); err != nil {
		close(ch)
		log.Println(""Unable to open up TLS listener"")
		log.Fatal(""ListenAndServe: "", err)
	}
}
",CWE-362,71.0,0
"package data
import (
	""sync""
	""github.com/deis/workflow-manager/k8s""
	""github.com/satori/go.uuid""
	""k8s.io/kubernetes/pkg/api""
	apierrors ""k8s.io/kubernetes/pkg/api/errors""
)
// ClusterID is an interface for managing cluster ID data
type ClusterID interface {
	// will have a Get method to retrieve the cluster ID
	Get() (string, error)
	// Cached returns the internal cache of the cluster ID. returns the empty string on a miss
	Cached() string
	// StoreInCache stores the given string in the internal cluster ID cache
	StoreInCache(string)
}
// GetID gets the cluster ID from the cache. on a cache miss, uses the k8s API to get it
func GetID(id ClusterID) (string, error) {
	// First, check to see if we have an in-memory copy
	data := id.Cached()
	// If we haven't yet cached the ID in memory, invoke the passed-in getter
	if data == """" {
		d, err := id.Get()
		if err != nil {
			return """", err
		}
		data = d
	}
	return data, nil
}
type clusterIDFromPersistentStorage struct {
	rwm                 *sync.RWMutex
	cache               string
	secretGetterCreator k8s.KubeSecretGetterCreator
}
// NewClusterIDFromPersistentStorage returns a new ClusterID implementation that uses the kubernetes API to get its cluster information
func NewClusterIDFromPersistentStorage(sgc k8s.KubeSecretGetterCreator) ClusterID {
	return &clusterIDFromPersistentStorage{
		rwm:                 new(sync.RWMutex),
		cache:               """",
		secretGetterCreator: sgc,
	}
}
// Get is the ClusterID interface implementation
func (c clusterIDFromPersistentStorage) Get() (string, error) {
	c.rwm.Lock()
	defer c.rwm.Unlock()
	secret, err := c.secretGetterCreator.Get(wfmSecretName)
	//If we don't have the secret we shouldn't be returning error and instead a create a new one
	if err != nil && !apierrors.IsNotFound(err) {
		return """", err
	}
	// if we don't have secret data for the cluster ID we assume a new cluster
	// and create a new secret
	if secret.Data[clusterIDSecretKey] == nil {
		newSecret := new(api.Secret)
		newSecret.Name = wfmSecretName
		newSecret.Data = make(map[string][]byte)
		newSecret.Data[clusterIDSecretKey] = []byte(uuid.NewV4().String())
		fromAPI, err := c.secretGetterCreator.Create(newSecret)
		if err != nil {
			return """", err
		}
		secret = fromAPI
	}
	return string(secret.Data[clusterIDSecretKey]), nil
}
// StoreInCache is the ClusterID interface implementation
func (c *clusterIDFromPersistentStorage) StoreInCache(cid string) {
	c.rwm.Lock()
	defer c.rwm.Unlock()
	c.cache = cid
}
// Cached is the ClusterID interface implementation
func (c clusterIDFromPersistentStorage) Cached() string {
	c.rwm.RLock()
	defer c.rwm.RUnlock()
	return c.cache
}
",CWE-362,90.0,0
"package jobs
import (
	""log""
	""time""
	""github.com/deis/workflow-manager/config""
	""github.com/deis/workflow-manager/data""
	""github.com/deis/workflow-manager/k8s""
	apiclient ""github.com/deis/workflow-manager/pkg/swagger/client""
	""github.com/deis/workflow-manager/pkg/swagger/client/operations""
)
// Periodic is an interface for managing periodic job invocation
type Periodic interface {
	// Do begins the periodic job. It starts the first execution of the job, and then is
	// repsonsible for executing it every Frequency() thereafter
	Do() error
	Frequency() time.Duration
}
// SendVersions fulfills the Periodic interface
type sendVersions struct {
	k8sResources      *k8s.ResourceInterfaceNamespaced
	clusterID         data.ClusterID
	apiClient         *apiclient.WorkflowManager
	availableVersions data.AvailableVersions
	frequency         time.Duration
}
// NewSendVersionsPeriodic creates a new SendVersions using sgc and rcl as the the secret getter / creator and replication controller lister implementations (respectively)
func NewSendVersionsPeriodic(
	apiClient *apiclient.WorkflowManager,
	clusterID data.ClusterID,
	ri *k8s.ResourceInterfaceNamespaced,
	availableVersions data.AvailableVersions,
	frequency time.Duration,
) Periodic {
	return &sendVersions{
		k8sResources:      ri,
		clusterID:         clusterID,
		apiClient:         apiClient,
		availableVersions: availableVersions,
		frequency:         frequency,
	}
}
// Do is the Periodic interface implementation
func (s sendVersions) Do() error {
	if config.Spec.CheckVersions {
		err := sendVersionsImpl(s.apiClient, s.clusterID, s.k8sResources, s.availableVersions)
		if err != nil {
			return err
		}
	}
	return nil
}
// Frequency is the Periodic interface implementation
func (s sendVersions) Frequency() time.Duration {
	return s.frequency
}
type getLatestVersionData struct {
	vsns                  data.AvailableVersions
	installedData         data.InstalledData
	clusterID             data.ClusterID
	availableComponentVsn data.AvailableComponentVersion
	k8sResources          k8s.ResourceInterfaceNamespaced
	frequency             time.Duration
}
// NewGetLatestVersionDataPeriodic creates a new periodic implementation that gets latest version data. It uses sgc and rcl as the secret getter/creator and replication controller lister implementations (respectively)
func NewGetLatestVersionDataPeriodic(
	installedData data.InstalledData,
	clusterID data.ClusterID,
	availVsn data.AvailableVersions,
	availCompVsn data.AvailableComponentVersion,
	frequency time.Duration,
) Periodic {
	return &getLatestVersionData{
		vsns:                  availVsn,
		installedData:         installedData,
		clusterID:             clusterID,
		availableComponentVsn: availCompVsn,
		frequency:             frequency,
	}
}
// Do is the Periodic interface implementation
func (u *getLatestVersionData) Do() error {
	cluster, err := data.GetCluster(u.installedData, u.clusterID, u.availableComponentVsn)
	if err != nil {
		return err
	}
	if _, err := u.vsns.Refresh(cluster); err != nil {
		return err
	}
	return nil
}
// Frequency is the Periodic interface implementation
func (u getLatestVersionData) Frequency() time.Duration {
	return u.frequency
}
// DoPeriodic calls p.Do() once, and then again every p.Frequency() on each element p in pSlice.
// For each p in pSlice, a new goroutine is started, and the returned channel can be closed
// to stop all of the goroutines.
func DoPeriodic(pSlice []Periodic) chan<- struct{} {
	doneCh := make(chan struct{})
	for _, p := range pSlice {
		go func(p Periodic) {
			// execute once at the beginning
			err := p.Do()
			if err != nil {
				log.Printf(""periodic job ran and returned error (%s)"", err)
			}
			ticker := time.NewTicker(p.Frequency())
			for {
				select {
				case <-ticker.C:
					err := p.Do()
					if err != nil {
						log.Printf(""periodic job ran and returned error (%s)"", err)
					}
				case <-doneCh:
					ticker.Stop()
					return
				}
			}
		}(p)
	}
	return doneCh
}
//  sendVersions sends cluster version data
func sendVersionsImpl(
	apiClient *apiclient.WorkflowManager,
	clusterID data.ClusterID,
	k8sResources *k8s.ResourceInterfaceNamespaced,
	availableVersions data.AvailableVersions,
) error {
	cluster, err := data.GetCluster(
		data.NewInstalledDeisData(k8sResources),
		clusterID,
		data.NewLatestReleasedComponent(k8sResources, availableVersions),
	)
	if err != nil {
		log.Println(""error getting installed components data"")
		return err
	}
	_, err = apiClient.Operations.CreateClusterDetails(&operations.CreateClusterDetailsParams{Body: &cluster})
	if err != nil {
		log.Println(""error sending diagnostic data"")
		return err
	}
	return nil
}
",CWE-362,162.0,0
"package utils
import (
	""encoding/binary""
	""encoding/json""
	""fmt""
	""io""
	""os""
	""path/filepath""
	""strconv""
	""strings""
	""unsafe""
	""github.com/cyphar/filepath-securejoin""
	""golang.org/x/sys/unix""
)
const (
	exitSignalOffset = 128
)
// NativeEndian is the native byte order of the host system.
var NativeEndian binary.ByteOrder
func init() {
	// Copied from <golang.org/x/net/internal/socket/sys.go>.
	i := uint32(1)
	b := (*[4]byte)(unsafe.Pointer(&i))
	if b[0] == 1 {
		NativeEndian = binary.LittleEndian
	} else {
		NativeEndian = binary.BigEndian
	}
}
// ResolveRootfs ensures that the current working directory is
// not a symlink and returns the absolute path to the rootfs
func ResolveRootfs(uncleanRootfs string) (string, error) {
	rootfs, err := filepath.Abs(uncleanRootfs)
	if err != nil {
		return """", err
	}
	return filepath.EvalSymlinks(rootfs)
}
// ExitStatus returns the correct exit status for a process based on if it
// was signaled or exited cleanly
func ExitStatus(status unix.WaitStatus) int {
	if status.Signaled() {
		return exitSignalOffset + int(status.Signal())
	}
	return status.ExitStatus()
}
// WriteJSON writes the provided struct v to w using standard json marshaling
func WriteJSON(w io.Writer, v interface{}) error {
	data, err := json.Marshal(v)
	if err != nil {
		return err
	}
	_, err = w.Write(data)
	return err
}
// CleanPath makes a path safe for use with filepath.Join. This is done by not
// only cleaning the path, but also (if the path is relative) adding a leading
// '/' and cleaning it (then removing the leading '/'). This ensures that a
// path resulting from prepending another path will always resolve to lexically
// be a subdirectory of the prefixed path. This is all done lexically, so paths
// that include symlinks won't be safe as a result of using CleanPath.
func CleanPath(path string) string {
	// Deal with empty strings nicely.
	if path == """" {
		return """"
	}
	// Ensure that all paths are cleaned (especially problematic ones like
	// ""/../../../../../"" which can cause lots of issues).
	path = filepath.Clean(path)
	// If the path isn't absolute, we need to do more processing to fix paths
	// such as ""../../../../<etc>/some/path"". We also shouldn't convert absolute
	// paths to relative ones.
	if !filepath.IsAbs(path) {
		path = filepath.Clean(string(os.PathSeparator) + path)
		// This can't fail, as (by definition) all paths are relative to root.
		path, _ = filepath.Rel(string(os.PathSeparator), path)
	}
	// Clean the path again for good measure.
	return filepath.Clean(path)
}
// stripRoot returns the passed path, stripping the root path if it was
// (lexicially) inside it. Note that both passed paths will always be treated
// as absolute, and the returned path will also always be absolute. In
// addition, the paths are cleaned before stripping the root.
func stripRoot(root, path string) string {
	// Make the paths clean and absolute.
	root, path = CleanPath(""/""+root), CleanPath(""/""+path)
	switch {
	case path == root:
		path = ""/""
	case root == ""/"":
		// do nothing
	case strings.HasPrefix(path, root+""/""):
		path = strings.TrimPrefix(path, root+""/"")
	}
	return CleanPath(""/"" + path)
}
// WithProcfd runs the passed closure with a procfd path (/proc/self/fd/...)
// corresponding to the unsafePath resolved within the root. Before passing the
// fd, this path is verified to have been inside the root -- so operating on it
// through the passed fdpath should be safe. Do not access this path through
// the original path strings, and do not attempt to use the pathname outside of
// the passed closure (the file handle will be freed once the closure returns).
func WithProcfd(root, unsafePath string, fn func(procfd string) error) error {
	// Remove the root then forcefully resolve inside the root.
	unsafePath = stripRoot(root, unsafePath)
	path, err := securejoin.SecureJoin(root, unsafePath)
	if err != nil {
		return fmt.Errorf(""resolving path inside rootfs failed: %v"", err)
	}
	// Open the target path.
	fh, err := os.OpenFile(path, unix.O_PATH|unix.O_CLOEXEC, 0)
	if err != nil {
		return fmt.Errorf(""open o_path procfd: %w"", err)
	}
	defer fh.Close()
	// Double-check the path is the one we expected.
	procfd := ""/proc/self/fd/"" + strconv.Itoa(int(fh.Fd()))
	if realpath, err := os.Readlink(procfd); err != nil {
		return fmt.Errorf(""procfd verification failed: %w"", err)
	} else if realpath != path {
		return fmt.Errorf(""possibly malicious path detected -- refusing to operate on %s"", realpath)
	}
	// Run the closure.
	return fn(procfd)
}
// SearchLabels searches a list of key-value pairs for the provided key and
// returns the corresponding value. The pairs must be separated with '='.
func SearchLabels(labels []string, query string) string {
	for _, l := range labels {
		parts := strings.SplitN(l, ""="", 2)
		if len(parts) < 2 {
			continue
		}
		if parts[0] == query {
			return parts[1]
		}
	}
	return """"
}
// Annotations returns the bundle path and user defined annotations from the
// libcontainer state.  We need to remove the bundle because that is a label
// added by libcontainer.
func Annotations(labels []string) (bundle string, userAnnotations map[string]string) {
	userAnnotations = make(map[string]string)
	for _, l := range labels {
		parts := strings.SplitN(l, ""="", 2)
		if len(parts) < 2 {
			continue
		}
		if parts[0] == ""bundle"" {
			bundle = parts[1]
		} else {
			userAnnotations[parts[0]] = parts[1]
		}
	}
	return
}
",CWE-362,178.0,0
"package utils
import (
	""bytes""
	""os""
	""path/filepath""
	""testing""
	""golang.org/x/sys/unix""
)
var labelTest = []struct {
	labels        []string
	query         string
	expectedValue string
}{
	{[]string{""bundle=/path/to/bundle""}, ""bundle"", ""/path/to/bundle""},
	{[]string{""test=a"", ""test=b""}, ""bundle"", """"},
	{[]string{""bundle=a"", ""test=b"", ""bundle=c""}, ""bundle"", ""a""},
	{[]string{"""", ""test=a"", ""bundle=b""}, ""bundle"", ""b""},
	{[]string{""test"", ""bundle=a""}, ""bundle"", ""a""},
	{[]string{""test=a"", ""bundle=""}, ""bundle"", """"},
}
func TestSearchLabels(t *testing.T) {
	for _, tt := range labelTest {
		if v := SearchLabels(tt.labels, tt.query); v != tt.expectedValue {
			t.Errorf(""expected value '%s' for query '%s'; got '%s'"", tt.expectedValue, tt.query, v)
		}
	}
}
func TestResolveRootfs(t *testing.T) {
	dir := ""rootfs""
	if err := os.Mkdir(dir, 0600); err != nil {
		t.Fatal(err)
	}
	defer os.Remove(dir)
	path, err := ResolveRootfs(dir)
	if err != nil {
		t.Fatal(err)
	}
	pwd, err := os.Getwd()
	if err != nil {
		t.Fatal(err)
	}
	if path != pwd+""/rootfs"" {
		t.Errorf(""expected rootfs to be abs and was %s"", path)
	}
}
func TestResolveRootfsWithSymlink(t *testing.T) {
	dir := ""rootfs""
	tmpDir, _ := filepath.EvalSymlinks(os.TempDir())
	if err := os.Symlink(tmpDir, dir); err != nil {
		t.Fatal(err)
	}
	defer os.Remove(dir)
	path, err := ResolveRootfs(dir)
	if err != nil {
		t.Fatal(err)
	}
	if path != tmpDir {
		t.Errorf(""expected rootfs to be the real path %s and was %s"", path, os.TempDir())
	}
}
func TestResolveRootfsWithNonExistingDir(t *testing.T) {
	_, err := ResolveRootfs(""foo"")
	if err == nil {
		t.Error(""expected error to happen but received nil"")
	}
}
func TestExitStatus(t *testing.T) {
	status := unix.WaitStatus(0)
	ex := ExitStatus(status)
	if ex != 0 {
		t.Errorf(""expected exit status to equal 0 and received %d"", ex)
	}
}
func TestExitStatusSignaled(t *testing.T) {
	status := unix.WaitStatus(2)
	ex := ExitStatus(status)
	if ex != 130 {
		t.Errorf(""expected exit status to equal 130 and received %d"", ex)
	}
}
func TestWriteJSON(t *testing.T) {
	person := struct {
		Name string
		Age  int
	}{
		Name: ""Alice"",
		Age:  30,
	}
	var b bytes.Buffer
	err := WriteJSON(&b, person)
	if err != nil {
		t.Fatal(err)
	}
	expected := `{""Name"":""Alice"",""Age"":30}`
	if b.String() != expected {
		t.Errorf(""expected to write %s but was %s"", expected, b.String())
	}
}
func TestCleanPath(t *testing.T) {
	path := CleanPath("""")
	if path != """" {
		t.Errorf(""expected to receive empty string and received %s"", path)
	}
	path = CleanPath(""rootfs"")
	if path != ""rootfs"" {
		t.Errorf(""expected to receive 'rootfs' and received %s"", path)
	}
	path = CleanPath(""../../../var"")
	if path != ""var"" {
		t.Errorf(""expected to receive 'var' and received %s"", path)
	}
	path = CleanPath(""/../../../var"")
	if path != ""/var"" {
		t.Errorf(""expected to receive '/var' and received %s"", path)
	}
	path = CleanPath(""/foo/bar/"")
	if path != ""/foo/bar"" {
		t.Errorf(""expected to receive '/foo/bar' and received %s"", path)
	}
	path = CleanPath(""/foo/bar/../"")
	if path != ""/foo"" {
		t.Errorf(""expected to receive '/foo' and received %s"", path)
	}
}
func TestStripRoot(t *testing.T) {
	for _, test := range []struct {
		root, path, out string
	}{
		// Works with multiple components.
		{""/a/b"", ""/a/b/c"", ""/c""},
		{""/hello/world"", ""/hello/world/the/quick-brown/fox"", ""/the/quick-brown/fox""},
		// '/' must be a no-op.
		{""/"", ""/a/b/c"", ""/a/b/c""},
		// Must be the correct order.
		{""/a/b"", ""/a/c/b"", ""/a/c/b""},
		// Must be at start.
		{""/abc/def"", ""/foo/abc/def/bar"", ""/foo/abc/def/bar""},
		// Must be a lexical parent.
		{""/foo/bar"", ""/foo/barSAMECOMPONENT"", ""/foo/barSAMECOMPONENT""},
		// Must only strip the root once.
		{""/foo/bar"", ""/foo/bar/foo/bar/baz"", ""/foo/bar/baz""},
		// Deal with .. in a fairly sane way.
		{""/foo/bar"", ""/foo/bar/../baz"", ""/foo/baz""},
		{""/foo/bar"", ""../../../../../../foo/bar/baz"", ""/baz""},
		{""/foo/bar"", ""/../../../../../../foo/bar/baz"", ""/baz""},
		{""/foo/bar/../baz"", ""/foo/baz/bar"", ""/bar""},
		{""/foo/bar/../baz"", ""/foo/baz/../bar/../baz/./foo"", ""/foo""},
		// All paths are made absolute before stripping.
		{""foo/bar"", ""/foo/bar/baz/bee"", ""/baz/bee""},
		{""/foo/bar"", ""foo/bar/baz/beef"", ""/baz/beef""},
		{""foo/bar"", ""foo/bar/baz/beets"", ""/baz/beets""},
	} {
		got := stripRoot(test.root, test.path)
		if got != test.out {
			t.Errorf(""stripRoot(%q, %q) -- got %q, expected %q"", test.root, test.path, got, test.out)
		}
	}
}
",CWE-362,181.0,0
"package configs
import ""golang.org/x/sys/unix""
const (
	// EXT_COPYUP is a directive to copy up the contents of a directory when
	// a tmpfs is mounted over it.
	EXT_COPYUP = 1 << iota //nolint:golint // ignore ""don't use ALL_CAPS"" warning
)
type Mount struct {
	// Source path for the mount.
	Source string `json:""source""`
	// Destination path for the mount inside the container.
	Destination string `json:""destination""`
	// Device the mount is for.
	Device string `json:""device""`
	// Mount flags.
	Flags int `json:""flags""`
	// Propagation Flags
	PropagationFlags []int `json:""propagation_flags""`
	// Mount data applied to the mount.
	Data string `json:""data""`
	// Relabel source if set, ""z"" indicates shared, ""Z"" indicates unshared.
	Relabel string `json:""relabel""`
	// Extensions are additional flags that are specific to runc.
	Extensions int `json:""extensions""`
	// Optional Command to be run before Source is mounted.
	PremountCmds []Command `json:""premount_cmds""`
	// Optional Command to be run after Source is mounted.
	PostmountCmds []Command `json:""postmount_cmds""`
}
func (m *Mount) IsBind() bool {
	return m.Flags&unix.MS_BIND != 0
}
",CWE-190,46.0,0
"package libcontainer
import (
	""github.com/vishvananda/netlink/nl""
	""golang.org/x/sys/unix""
)
// list of known message types we want to send to bootstrap program
// The number is randomly chosen to not conflict with known netlink types
const (
	InitMsg          uint16 = 62000
	CloneFlagsAttr   uint16 = 27281
	NsPathsAttr      uint16 = 27282
	UidmapAttr       uint16 = 27283
	GidmapAttr       uint16 = 27284
	SetgroupAttr     uint16 = 27285
	OomScoreAdjAttr  uint16 = 27286
	RootlessEUIDAttr uint16 = 27287
	UidmapPathAttr   uint16 = 27288
	GidmapPathAttr   uint16 = 27289
	MountSourcesAttr uint16 = 27290
)
type Int32msg struct {
	Type  uint16
	Value uint32
}
// Serialize serializes the message.
// Int32msg has the following representation
// | nlattr len | nlattr type |
// | uint32 value             |
func (msg *Int32msg) Serialize() []byte {
	buf := make([]byte, msg.Len())
	native := nl.NativeEndian()
	native.PutUint16(buf[0:2], uint16(msg.Len()))
	native.PutUint16(buf[2:4], msg.Type)
	native.PutUint32(buf[4:8], msg.Value)
	return buf
}
func (msg *Int32msg) Len() int {
	return unix.NLA_HDRLEN + 4
}
// Bytemsg has the following representation
// | nlattr len | nlattr type |
// | value              | pad |
type Bytemsg struct {
	Type  uint16
	Value []byte
}
func (msg *Bytemsg) Serialize() []byte {
	l := msg.Len()
	buf := make([]byte, (l+unix.NLA_ALIGNTO-1) & ^(unix.NLA_ALIGNTO-1))
	native := nl.NativeEndian()
	native.PutUint16(buf[0:2], uint16(l))
	native.PutUint16(buf[2:4], msg.Type)
	copy(buf[4:], msg.Value)
	return buf
}
func (msg *Bytemsg) Len() int {
	return unix.NLA_HDRLEN + len(msg.Value) + 1 // null-terminated
}
type Boolmsg struct {
	Type  uint16
	Value bool
}
func (msg *Boolmsg) Serialize() []byte {
	buf := make([]byte, msg.Len())
	native := nl.NativeEndian()
	native.PutUint16(buf[0:2], uint16(msg.Len()))
	native.PutUint16(buf[2:4], msg.Type)
	if msg.Value {
		native.PutUint32(buf[4:8], uint32(1))
	} else {
		native.PutUint32(buf[4:8], uint32(0))
	}
	return buf
}
func (msg *Boolmsg) Len() int {
	return unix.NLA_HDRLEN + 4 // alignment
}
",CWE-190,89.0,0
"package libcontainer
import (
	""fmt""
	""math""
	""github.com/vishvananda/netlink/nl""
	""golang.org/x/sys/unix""
)
// list of known message types we want to send to bootstrap program
// The number is randomly chosen to not conflict with known netlink types
const (
	InitMsg          uint16 = 62000
	CloneFlagsAttr   uint16 = 27281
	NsPathsAttr      uint16 = 27282
	UidmapAttr       uint16 = 27283
	GidmapAttr       uint16 = 27284
	SetgroupAttr     uint16 = 27285
	OomScoreAdjAttr  uint16 = 27286
	RootlessEUIDAttr uint16 = 27287
	UidmapPathAttr   uint16 = 27288
	GidmapPathAttr   uint16 = 27289
	MountSourcesAttr uint16 = 27290
)
type Int32msg struct {
	Type  uint16
	Value uint32
}
// Serialize serializes the message.
// Int32msg has the following representation
// | nlattr len | nlattr type |
// | uint32 value             |
func (msg *Int32msg) Serialize() []byte {
	buf := make([]byte, msg.Len())
	native := nl.NativeEndian()
	native.PutUint16(buf[0:2], uint16(msg.Len()))
	native.PutUint16(buf[2:4], msg.Type)
	native.PutUint32(buf[4:8], msg.Value)
	return buf
}
func (msg *Int32msg) Len() int {
	return unix.NLA_HDRLEN + 4
}
// Bytemsg has the following representation
// | nlattr len | nlattr type |
// | value              | pad |
type Bytemsg struct {
	Type  uint16
	Value []byte
}
func (msg *Bytemsg) Serialize() []byte {
	l := msg.Len()
	if l > math.MaxUint16 {
		// We cannot return nil nor an error here, so we panic with
		// a specific type instead, which is handled via recover in
		// bootstrapData.
		panic(netlinkError{fmt.Errorf(""netlink: cannot serialize bytemsg of length %d (larger than UINT16_MAX)"", l)})
	}
	buf := make([]byte, (l+unix.NLA_ALIGNTO-1) & ^(unix.NLA_ALIGNTO-1))
	native := nl.NativeEndian()
	native.PutUint16(buf[0:2], uint16(l))
	native.PutUint16(buf[2:4], msg.Type)
	copy(buf[4:], msg.Value)
	return buf
}
func (msg *Bytemsg) Len() int {
	return unix.NLA_HDRLEN + len(msg.Value) + 1 // null-terminated
}
type Boolmsg struct {
	Type  uint16
	Value bool
}
func (msg *Boolmsg) Serialize() []byte {
	buf := make([]byte, msg.Len())
	native := nl.NativeEndian()
	native.PutUint16(buf[0:2], uint16(msg.Len()))
	native.PutUint16(buf[2:4], msg.Type)
	if msg.Value {
		native.PutUint32(buf[4:8], uint32(1))
	} else {
		native.PutUint32(buf[4:8], uint32(0))
	}
	return buf
}
func (msg *Boolmsg) Len() int {
	return unix.NLA_HDRLEN + 4 // alignment
}
",CWE-190,98.0,0
"/*-
 * Copyright 2014 Square Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package josecipher
import (
	""bytes""
	""crypto/cipher""
	""crypto/hmac""
	""crypto/sha256""
	""crypto/sha512""
	""crypto/subtle""
	""encoding/binary""
	""errors""
	""hash""
)
const (
	nonceBytes = 16
)
// NewCBCHMAC instantiates a new AEAD based on CBC+HMAC.
func NewCBCHMAC(key []byte, newBlockCipher func([]byte) (cipher.Block, error)) (cipher.AEAD, error) {
	keySize := len(key) / 2
	integrityKey := key[:keySize]
	encryptionKey := key[keySize:]
	blockCipher, err := newBlockCipher(encryptionKey)
	if err != nil {
		return nil, err
	}
	var hash func() hash.Hash
	switch keySize {
	case 16:
		hash = sha256.New
	case 24:
		hash = sha512.New384
	case 32:
		hash = sha512.New
	}
	return &cbcAEAD{
		hash:         hash,
		blockCipher:  blockCipher,
		authtagBytes: keySize,
		integrityKey: integrityKey,
	}, nil
}
// An AEAD based on CBC+HMAC
type cbcAEAD struct {
	hash         func() hash.Hash
	authtagBytes int
	integrityKey []byte
	blockCipher  cipher.Block
}
func (ctx *cbcAEAD) NonceSize() int {
	return nonceBytes
}
func (ctx *cbcAEAD) Overhead() int {
	// Maximum overhead is block size (for padding) plus auth tag length, where
	// the length of the auth tag is equivalent to the key size.
	return ctx.blockCipher.BlockSize() + ctx.authtagBytes
}
// Seal encrypts and authenticates the plaintext.
func (ctx *cbcAEAD) Seal(dst, nonce, plaintext, data []byte) []byte {
	// Output buffer -- must take care not to mangle plaintext input.
	ciphertext := make([]byte, uint64(len(plaintext))+uint64(ctx.Overhead()))[:len(plaintext)]
	copy(ciphertext, plaintext)
	ciphertext = padBuffer(ciphertext, ctx.blockCipher.BlockSize())
	cbc := cipher.NewCBCEncrypter(ctx.blockCipher, nonce)
	cbc.CryptBlocks(ciphertext, ciphertext)
	authtag := ctx.computeAuthTag(data, nonce, ciphertext)
	ret, out := resize(dst, uint64(len(dst))+uint64(len(ciphertext))+uint64(len(authtag)))
	copy(out, ciphertext)
	copy(out[len(ciphertext):], authtag)
	return ret
}
// Open decrypts and authenticates the ciphertext.
func (ctx *cbcAEAD) Open(dst, nonce, ciphertext, data []byte) ([]byte, error) {
	if len(ciphertext) < ctx.authtagBytes {
		return nil, errors.New(""square/go-jose: invalid ciphertext (too short)"")
	}
	offset := len(ciphertext) - ctx.authtagBytes
	expectedTag := ctx.computeAuthTag(data, nonce, ciphertext[:offset])
	match := subtle.ConstantTimeCompare(expectedTag, ciphertext[offset:])
	if match != 1 {
		return nil, errors.New(""square/go-jose: invalid ciphertext (auth tag mismatch)"")
	}
	cbc := cipher.NewCBCDecrypter(ctx.blockCipher, nonce)
	// Make copy of ciphertext buffer, don't want to modify in place
	buffer := append([]byte{}, []byte(ciphertext[:offset])...)
	if len(buffer)%ctx.blockCipher.BlockSize() > 0 {
		return nil, errors.New(""square/go-jose: invalid ciphertext (invalid length)"")
	}
	cbc.CryptBlocks(buffer, buffer)
	// Remove padding
	plaintext, err := unpadBuffer(buffer, ctx.blockCipher.BlockSize())
	if err != nil {
		return nil, err
	}
	ret, out := resize(dst, uint64(len(dst))+uint64(len(plaintext)))
	copy(out, plaintext)
	return ret, nil
}
// Compute an authentication tag
func (ctx *cbcAEAD) computeAuthTag(aad, nonce, ciphertext []byte) []byte {
	buffer := make([]byte, uint64(len(aad))+uint64(len(nonce))+uint64(len(ciphertext))+8)
	n := 0
	n += copy(buffer, aad)
	n += copy(buffer[n:], nonce)
	n += copy(buffer[n:], ciphertext)
	binary.BigEndian.PutUint64(buffer[n:], uint64(len(aad))*8)
	// According to documentation, Write() on hash.Hash never fails.
	hmac := hmac.New(ctx.hash, ctx.integrityKey)
	_, _ = hmac.Write(buffer)
	return hmac.Sum(nil)[:ctx.authtagBytes]
}
// resize ensures the the given slice has a capacity of at least n bytes.
// If the capacity of the slice is less than n, a new slice is allocated
// and the existing data will be copied.
func resize(in []byte, n uint64) (head, tail []byte) {
	if uint64(cap(in)) >= n {
		head = in[:n]
	} else {
		head = make([]byte, n)
		copy(head, in)
	}
	tail = head[len(in):]
	return
}
// Apply padding
func padBuffer(buffer []byte, blockSize int) []byte {
	missing := blockSize - (len(buffer) % blockSize)
	ret, out := resize(buffer, uint64(len(buffer))+uint64(missing))
	padding := bytes.Repeat([]byte{byte(missing)}, missing)
	copy(out, padding)
	return ret
}
// Remove padding
func unpadBuffer(buffer []byte, blockSize int) ([]byte, error) {
	if len(buffer)%blockSize != 0 {
		return nil, errors.New(""square/go-jose: invalid padding"")
	}
	last := buffer[len(buffer)-1]
	count := int(last)
	if count == 0 || count > blockSize || count > len(buffer) {
		return nil, errors.New(""square/go-jose: invalid padding"")
	}
	padding := bytes.Repeat([]byte{last}, count)
	if !bytes.HasSuffix(buffer, padding) {
		return nil, errors.New(""square/go-jose: invalid padding"")
	}
	return buffer[:len(buffer)-count], nil
}
",CWE-190,197.0,0
"/*-
 * Copyright 2014 Square Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package josecipher
import (
	""crypto""
	""encoding/binary""
	""hash""
	""io""
)
type concatKDF struct {
	z, info []byte
	i       uint32
	cache   []byte
	hasher  hash.Hash
}
// NewConcatKDF builds a KDF reader based on the given inputs.
func NewConcatKDF(hash crypto.Hash, z, algID, ptyUInfo, ptyVInfo, supPubInfo, supPrivInfo []byte) io.Reader {
	buffer := make([]byte, uint64(len(algID))+uint64(len(ptyUInfo))+uint64(len(ptyVInfo))+uint64(len(supPubInfo))+uint64(len(supPrivInfo)))
	n := 0
	n += copy(buffer, algID)
	n += copy(buffer[n:], ptyUInfo)
	n += copy(buffer[n:], ptyVInfo)
	n += copy(buffer[n:], supPubInfo)
	copy(buffer[n:], supPrivInfo)
	hasher := hash.New()
	return &concatKDF{
		z:      z,
		info:   buffer,
		hasher: hasher,
		cache:  []byte{},
		i:      1,
	}
}
func (ctx *concatKDF) Read(out []byte) (int, error) {
	copied := copy(out, ctx.cache)
	ctx.cache = ctx.cache[copied:]
	for copied < len(out) {
		ctx.hasher.Reset()
		// Write on a hash.Hash never fails
		_ = binary.Write(ctx.hasher, binary.BigEndian, ctx.i)
		_, _ = ctx.hasher.Write(ctx.z)
		_, _ = ctx.hasher.Write(ctx.info)
		hash := ctx.hasher.Sum(nil)
		chunkCopied := copy(out[copied:], hash)
		copied += chunkCopied
		ctx.cache = hash[chunkCopied:]
		ctx.i++
	}
	return copied, nil
}
",CWE-190,76.0,0
"/*-
 * Copyright 2014 Square Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package josecipher
import (
	""crypto""
	""crypto/ecdsa""
	""encoding/binary""
)
// DeriveECDHES derives a shared encryption key using ECDH/ConcatKDF as described in JWE/JWA.
// It is an error to call this function with a private/public key that are not on the same
// curve. Callers must ensure that the keys are valid before calling this function. Output
// size may be at most 1<<16 bytes (64 KiB).
func DeriveECDHES(alg string, apuData, apvData []byte, priv *ecdsa.PrivateKey, pub *ecdsa.PublicKey, size int) []byte {
	if size > 1<<16 {
		panic(""ECDH-ES output size too large, must be less than 1<<16"")
	}
	// algId, partyUInfo, partyVInfo inputs must be prefixed with the length
	algID := lengthPrefixed([]byte(alg))
	ptyUInfo := lengthPrefixed(apuData)
	ptyVInfo := lengthPrefixed(apvData)
	// suppPubInfo is the encoded length of the output size in bits
	supPubInfo := make([]byte, 4)
	binary.BigEndian.PutUint32(supPubInfo, uint32(size)*8)
	if !priv.PublicKey.Curve.IsOnCurve(pub.X, pub.Y) {
		panic(""public key not on same curve as private key"")
	}
	z, _ := priv.PublicKey.Curve.ScalarMult(pub.X, pub.Y, priv.D.Bytes())
	reader := NewConcatKDF(crypto.SHA256, z.Bytes(), algID, ptyUInfo, ptyVInfo, supPubInfo, []byte{})
	key := make([]byte, size)
	// Read on the KDF will never fail
	_, _ = reader.Read(key)
	return key
}
func lengthPrefixed(data []byte) []byte {
	out := make([]byte, len(data)+4)
	binary.BigEndian.PutUint32(out, uint32(len(data)))
	copy(out[4:], data)
	return out
}
",CWE-190,63.0,0
"<!--
Copyright 2017 Google Inc. All rights reserved.
Licensed under the Apache License, Version 2.0 (the ""License""); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
-->
<meta name=""render:status_code"" content=""401"">
<meta name=""render:status_code"" content=""402"">",CWE-79,17.0,0
"<!--
Copyright 2017 Google Inc. All rights reserved.
Licensed under the Apache License, Version 2.0 (the ""License""); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
-->
<meta name=""render:status_code"" content=""401"">
<meta name=""render:status_code"" content=""402"">",CWE-22,17.0,0
"<!--
Copyright 2017 Google Inc. All rights reserved.
Licensed under the Apache License, Version 2.0 (the ""License""); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
-->
<meta name=""render:status_code"" content=""401"">
<meta name=""render:status_code"" content=""402"">",CWE-200,17.0,0
"<!--
Copyright 2017 Google Inc. All rights reserved.
Licensed under the Apache License, Version 2.0 (the ""License""); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
-->
<meta name=""render:status_code"" content=""400"">",CWE-79,16.0,0
"<!--
Copyright 2017 Google Inc. All rights reserved.
Licensed under the Apache License, Version 2.0 (the ""License""); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
-->
<meta name=""render:status_code"" content=""400"">",CWE-22,16.0,0
"<!--
Copyright 2017 Google Inc. All rights reserved.
Licensed under the Apache License, Version 2.0 (the ""License""); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
-->
<meta name=""render:status_code"" content=""400"">",CWE-200,16.0,0
"// Sandstorm - Personal Cloud Sandbox
// Copyright (c) 2016 Sandstorm Development Group, Inc. and contributors
// All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
const ACCOUNT_DELETION_SUSPENSION_TIME = 7 * 60 * 60 * 24 * 1000; // 7 days in ms
// Lists below developed from RFC6890, which is an overview of all special addresses.
const PRIVATE_IPV4_ADDRESSES = [
  ""10.0.0.0/8"",            // RFC1918 reserved for internal network
  ""127.0.0.0/8"",           // RFC1122 loopback / localhost
  ""169.254.0.0/16"",        // RFC3927 ""link local"" (auto-configured LAN in absence of DHCP)
  ""172.16.0.0/12"",         // RFC1918 reserved for internal network
  ""192.168.0.0/16"",        // RFC1918 reserved for internal network
];
const PRIVATE_IPV6_ADDRESSES = [
  ""::1/128"",               // RFC4291 loopback / localhost
  ""fc00::/7"",              // RFC4193 unique private network
  ""fe80::/10"",             // RFC4291 ""link local"" (auto-configured LAN in absence of DHCP)
];
const SPECIAL_IPV4_ADDRESSES = [
  ""0.0.0.0/8"",             // RFC1122 ""this host"" / wildcard
  ""100.64.0.0/10"",         // RFC6598 ""shared address space"" for carrier-grade NAT
  ""192.0.0.0/24"",          // RFC6890 reserved for special protocols
  ""192.0.2.0/24"",          // RFC5737 ""example address"" block 1 -- like example.com for IPs
  ""192.88.99.0/24"",        // RFC3068 6to4 relay
  ""198.18.0.0/15"",         // RFC2544 standard benchmarks
  ""198.51.100.0/24"",       // RFC5737 ""example address"" block 2 -- like example.com for IPs
  ""203.0.113.0/24"",        // RFC5737 ""example address"" block 3 -- like example.com for IPs
  ""224.0.0.0/4"",           // RFC1112 multicast
  ""240.0.0.0/4"",           // RFC1112 multicast / reserved for future use
  ""255.255.255.255/32""     // RFC0919 broadcast address
];
const SPECIAL_IPV6_ADDRESSES = [
  ""::/128"",                // RFC4291 unspecified address / wildcard
  ""64:ff9b::/96"",          // RFC6052 IPv4-IPv6 translation
  ""::ffff:0:0/96"",         // RFC4291 IPv4-mapped address
                           // TODO(someday): I don't understand the difference between the above
                           //     two. Both are described as mapping ip4 addresses into the ip6
                           //     space. Perhaps this should be allowed, however, we'd need to
                           //     filter the ip4 address against the ip4 blacklist, so special
                           //     handling would be needed.
  ""100::/64"",              // RFC6666 discard-only address block
  ""2001::/23"",             // RFC2928 reserved for special protocols
  ""2001:2::/48"",           // RFC5180 standard benchmarks
  ""2001:db8::/32"",         // RFC3849 ""example address"" block -- like example.com for IPs
  ""2001:10::/28"",          // RFC4843 ORCHID
  ""2002::/16"",             // RFC3056 6to4 relay
  ""ff00::/8"",              // RFC4291 multicast
];
export {
  ACCOUNT_DELETION_SUSPENSION_TIME, PRIVATE_IPV4_ADDRESSES, PRIVATE_IPV6_ADDRESSES,
  SPECIAL_IPV4_ADDRESSES, SPECIAL_IPV6_ADDRESSES
};
",CWE-918,70.0,0
"// Copyright JS Foundation and other contributors, http://js.foundation
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
'\
'
",CWE-476,17.0,0
"/*
 * Minio Cloud Storage, (C) 2017 Minio, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package hash
import (
	""bytes""
	""crypto/md5""
	""encoding/base64""
	""encoding/hex""
	""errors""
	""hash""
	""io""
	sha256 ""github.com/minio/sha256-simd""
)
var errNestedReader = errors.New(""Nesting of Reader detected, not allowed"")
// Reader writes what it reads from an io.Reader to an MD5 and SHA256 hash.Hash.
// Reader verifies that the content of the io.Reader matches the expected checksums.
type Reader struct {
	src  io.Reader
	size int64
	md5sum, sha256sum   []byte // Byte values of md5sum, sha256sum of client sent values.
	md5Hash, sha256Hash hash.Hash
}
// NewReader returns a new hash Reader which computes the MD5 sum and
// SHA256 sum (if set) of the provided io.Reader at EOF.
func NewReader(src io.Reader, size int64, md5Hex, sha256Hex string) (*Reader, error) {
	if _, ok := src.(*Reader); ok {
		return nil, errNestedReader
	}
	sha256sum, err := hex.DecodeString(sha256Hex)
	if err != nil {
		return nil, SHA256Mismatch{}
	}
	md5sum, err := hex.DecodeString(md5Hex)
	if err != nil {
		return nil, BadDigest{}
	}
	var sha256Hash hash.Hash
	if len(sha256sum) != 0 {
		sha256Hash = sha256.New()
	}
	if size >= 0 {
		src = io.LimitReader(src, size)
	}
	return &Reader{
		md5sum:     md5sum,
		sha256sum:  sha256sum,
		src:        src,
		size:       size,
		md5Hash:    md5.New(),
		sha256Hash: sha256Hash,
	}, nil
}
func (r *Reader) Read(p []byte) (n int, err error) {
	n, err = r.src.Read(p)
	if n > 0 {
		r.md5Hash.Write(p[:n])
		if r.sha256Hash != nil {
			r.sha256Hash.Write(p[:n])
		}
	}
	// At io.EOF verify if the checksums are right.
	if err == io.EOF {
		if cerr := r.Verify(); cerr != nil {
			return 0, cerr
		}
	}
	return
}
// Size returns the absolute number of bytes the Reader
// will return during reading. It returns -1 for unlimited
// data.
func (r *Reader) Size() int64 { return r.size }
// MD5 - returns byte md5 value
func (r *Reader) MD5() []byte {
	return r.md5sum
}
// MD5Current - returns byte md5 value of the current state
// of the md5 hash after reading the incoming content.
// NOTE: Calling this function multiple times might yield
// different results if they are intermixed with Reader.
func (r *Reader) MD5Current() []byte {
	return r.md5Hash.Sum(nil)
}
// SHA256 - returns byte sha256 value
func (r *Reader) SHA256() []byte {
	return r.sha256sum
}
// MD5HexString returns hex md5 value.
func (r *Reader) MD5HexString() string {
	return hex.EncodeToString(r.md5sum)
}
// MD5Base64String returns base64 encoded MD5sum value.
func (r *Reader) MD5Base64String() string {
	return base64.StdEncoding.EncodeToString(r.md5sum)
}
// SHA256HexString returns hex sha256 value.
func (r *Reader) SHA256HexString() string {
	return hex.EncodeToString(r.sha256sum)
}
// Verify verifies if the computed MD5 sum and SHA256 sum are
// equal to the ones specified when creating the Reader.
func (r *Reader) Verify() error {
	if r.sha256Hash != nil && len(r.sha256sum) > 0 {
		if sum := r.sha256Hash.Sum(nil); !bytes.Equal(r.sha256sum, sum) {
			return SHA256Mismatch{hex.EncodeToString(r.sha256sum), hex.EncodeToString(sum)}
		}
	}
	if len(r.md5sum) > 0 {
		if sum := r.md5Hash.Sum(nil); !bytes.Equal(r.md5sum, sum) {
			return BadDigest{hex.EncodeToString(r.md5sum), hex.EncodeToString(sum)}
		}
	}
	return nil
}
",CWE-774,149.0,0
"package archiver
import (
	""fmt""
	""io""
	""log""
	""os""
	""path/filepath""
	""runtime""
	""strings""
)
// Archiver represent a archive format
type Archiver interface {
	// Match checks supported files
	Match(filename string) bool
	// Make makes an archive file on disk.
	Make(destination string, sources []string) error
	// Open extracts an archive file on disk.
	Open(source, destination string) error
	// Write writes an archive to a Writer.
	Write(output io.Writer, sources []string) error
	// Read reads an archive from a Reader.
	Read(input io.Reader, destination string) error
}
// SupportedFormats contains all supported archive formats
var SupportedFormats = map[string]Archiver{}
// RegisterFormat adds a supported archive format
func RegisterFormat(name string, format Archiver) {
	if _, ok := SupportedFormats[name]; ok {
		log.Printf(""Format %s already exists, skip!\n"", name)
		return
	}
	SupportedFormats[name] = format
}
// MatchingFormat returns the first archive format that matches
// the given file, or nil if there is no match
func MatchingFormat(fpath string) Archiver {
	for _, fmt := range SupportedFormats {
		if fmt.Match(fpath) {
			return fmt
		}
	}
	return nil
}
func writeNewFile(fpath string, in io.Reader, fm os.FileMode) error {
	err := os.MkdirAll(filepath.Dir(fpath), 0755)
	if err != nil {
		return fmt.Errorf(""%s: making directory for file: %v"", fpath, err)
	}
	out, err := os.Create(fpath)
	if err != nil {
		return fmt.Errorf(""%s: creating new file: %v"", fpath, err)
	}
	defer out.Close()
	err = out.Chmod(fm)
	if err != nil && runtime.GOOS != ""windows"" {
		return fmt.Errorf(""%s: changing file mode: %v"", fpath, err)
	}
	_, err = io.Copy(out, in)
	if err != nil {
		return fmt.Errorf(""%s: writing file: %v"", fpath, err)
	}
	return nil
}
func writeNewSymbolicLink(fpath string, target string) error {
	err := os.MkdirAll(filepath.Dir(fpath), 0755)
	if err != nil {
		return fmt.Errorf(""%s: making directory for file: %v"", fpath, err)
	}
	err = os.Symlink(target, fpath)
	if err != nil {
		return fmt.Errorf(""%s: making symbolic link for: %v"", fpath, err)
	}
	return nil
}
func writeNewHardLink(fpath string, target string) error {
	err := os.MkdirAll(filepath.Dir(fpath), 0755)
	if err != nil {
		return fmt.Errorf(""%s: making directory for file: %v"", fpath, err)
	}
	err = os.Link(target, fpath)
	if err != nil {
		return fmt.Errorf(""%s: making hard link for: %v"", fpath, err)
	}
	return nil
}
func mkdir(dirPath string) error {
	err := os.MkdirAll(dirPath, 0755)
	if err != nil {
		return fmt.Errorf(""%s: making directory: %v"", dirPath, err)
	}
	return nil
}
func sanitizeExtractPath(filePath string, destination string) error {
	// to avoid zip slip (writing outside of the destination), we resolve
	// the target path, and make sure it's nested in the intended
	// destination, or bail otherwise.
	destpath := filepath.Join(destination, filePath)
	if !strings.HasPrefix(destpath, destination) {
		return fmt.Errorf(""%s: illegal file path"", filePath)
	}
	return nil
}
",CWE-22,120.0,0
"package main
import (
	""fmt""
	""os""
	""github.com/mholt/archiver""
)
func main() {
	if len(os.Args) < 3 {
		fatal(usage)
	}
	cmd, filename := os.Args[1], os.Args[2]
	ff := archiver.MatchingFormat(filename)
	if ff == nil {
		fatalf(""%s: Unsupported file extension"", filename)
	}
	var err error
	switch cmd {
	case ""make"":
		if len(os.Args) < 4 {
			fatal(usage)
		}
		err = ff.Make(filename, os.Args[3:])
	case ""open"":
		dest, osErr := os.Getwd()
		if osErr != nil {
			fatal(err)
		}
		if len(os.Args) == 4 {
			dest = os.Args[3]
		} else if len(os.Args) > 4 {
			fatal(usage)
		}
		err = ff.Open(filename, dest)
	default:
		fatal(usage)
	}
	if err != nil {
		fatal(err)
	}
}
func fatal(v ...interface{}) {
	fmt.Fprintln(os.Stderr, v...)
	os.Exit(1)
}
func fatalf(s string, v ...interface{}) {
	fmt.Fprintf(os.Stderr, s+""\n"", v...)
	os.Exit(1)
}
const usage = `Usage: archiver {make|open} <archive file> [files...]
  make
    Create a new archive file. List the files/folders
    to include in the archive; at least one required.
  open
    Extract an archive file. Give only the archive to
    open and the destination folder to extract into.
  Specifying archive format:
    The format of the archive is determined by its
    file extension. Supported extensions:
      .zip
      .tar
      .tar.gz
      .tgz
      .tar.bz2
      .tbz2
      .tar.xz
      .txz
      .tar.lz4
      .tlz4
      .tar.sz
      .tsz
      .rar (open only)
  Existing files:
    When creating an archive file that already exists,
    archiver will overwrite the existing file. When
    extracting files, archiver will NOT overwrite files
    that already exist in the destination path; this
    is treated as an error and extraction will abort.`
",CWE-22,89.0,0
"package archiver
import (
	""bytes""
	""fmt""
	""io""
	""os""
	""path/filepath""
	""strings""
	""github.com/nwaples/rardecode""
)
// Rar is for RAR archive format
var Rar rarFormat
func init() {
	RegisterFormat(""Rar"", Rar)
}
type rarFormat struct{}
func (rarFormat) Match(filename string) bool {
	return strings.HasSuffix(strings.ToLower(filename), "".rar"") || isRar(filename)
}
// isRar checks the file has the RAR 1.5 or 5.0 format signature by reading its
// beginning bytes and matching it
func isRar(rarPath string) bool {
	f, err := os.Open(rarPath)
	if err != nil {
		return false
	}
	defer f.Close()
	buf := make([]byte, 8)
	if n, err := f.Read(buf); err != nil || n < 8 {
		return false
	}
	return bytes.Equal(buf[:7], []byte(""Rar!\x1a\x07\x00"")) || // ver 1.5
		bytes.Equal(buf, []byte(""Rar!\x1a\x07\x01\x00"")) // ver 5.0
}
// Write outputs a .rar archive, but this is not implemented because
// RAR is a proprietary format. It is here only for symmetry with
// the other archive formats in this package.
func (rarFormat) Write(output io.Writer, filePaths []string) error {
	return fmt.Errorf(""write: RAR not implemented (proprietary format)"")
}
// Make makes a .rar archive, but this is not implemented because
// RAR is a proprietary format. It is here only for symmetry with
// the other archive formats in this package.
func (rarFormat) Make(rarPath string, filePaths []string) error {
	return fmt.Errorf(""make %s: RAR not implemented (proprietary format)"", rarPath)
}
// Read extracts the RAR file read from input and puts the contents
// into destination.
func (rarFormat) Read(input io.Reader, destination string) error {
	rr, err := rardecode.NewReader(input, """")
	if err != nil {
		return fmt.Errorf(""read: failed to create reader: %v"", err)
	}
	for {
		header, err := rr.Next()
		if err == io.EOF {
			break
		} else if err != nil {
			return err
		}
		err = sanitizeExtractPath(header.Name, destination)
		if err != nil {
			return err
		}
		destpath := filepath.Join(destination, header.Name)
		if header.IsDir {
			err = mkdir(destpath)
			if err != nil {
				return err
			}
			continue
		}
		// if files come before their containing folders, then we must
		// create their folders before writing the file
		err = mkdir(filepath.Dir(destpath))
		if err != nil {
			return err
		}
		err = writeNewFile(destpath, rr, header.Mode())
		if err != nil {
			return err
		}
	}
	return nil
}
// Open extracts the RAR file at source and puts the contents
// into destination.
func (rarFormat) Open(source, destination string) error {
	rf, err := os.Open(source)
	if err != nil {
		return fmt.Errorf(""%s: failed to open file: %v"", source, err)
	}
	defer rf.Close()
	return Rar.Read(rf, destination)
}
",CWE-22,117.0,0
"// +build go1.7
// Copyright 2014 The Gogs Authors. All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.
// Gogs is a painless self-hosted Git Service.
package main
import (
	""os""
	""github.com/urfave/cli""
	""github.com/gogs/gogs/cmd""
	""github.com/gogs/gogs/pkg/setting""
)
const APP_VER = ""0.11.82.1218""
func init() {
	setting.AppVer = APP_VER
}
func main() {
	app := cli.NewApp()
	app.Name = ""Gogs""
	app.Usage = ""A painless self-hosted Git service""
	app.Version = APP_VER
	app.Commands = []cli.Command{
		cmd.Web,
		cmd.Serv,
		cmd.Hook,
		cmd.Cert,
		cmd.Admin,
		cmd.Import,
		cmd.Backup,
		cmd.Restore,
	}
	app.Run(os.Args)
}
",CWE-22,42.0,0
"// Copyright 2018 The Gogs Authors. All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.
package tool
import (
	""strings""
)
// IsSameSiteURLPath returns true if the URL path belongs to the same site, false otherwise.
// False: //url, http://url, /\url
// True: /url
func IsSameSiteURLPath(url string) bool {
	return len(url) >= 2 && url[0] == '/' && url[1] != '/' && url[1] != '\\'
}
// SanitizePath sanitizes user-defined file paths to prevent remote code execution.
func SanitizePath(path string) string {
	path = strings.TrimLeft(path, ""/"")
	path = strings.Replace(path, ""../"", """", -1)
	return path
}
",CWE-22,24.0,0
"// Copyright 2018 The Gogs Authors. All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.
package tool
import (
	""testing""
	. ""github.com/smartystreets/goconvey/convey""
)
func Test_IsSameSiteURLPath(t *testing.T) {
	Convey(""Check if a path belongs to the same site"", t, func() {
		testCases := []struct {
			url    string
			expect bool
		}{
			{""//github.com"", false},
			{""http://github.com"", false},
			{""https://github.com"", false},
			{""/\\github.com"", false},
			{""/admin"", true},
			{""/user/repo"", true},
		}
		for _, tc := range testCases {
			So(IsSameSiteURLPath(tc.url), ShouldEqual, tc.expect)
		}
	})
}
func Test_SanitizePath(t *testing.T) {
	Convey(""Sanitize malicious user-defined path"", t, func() {
		testCases := []struct {
			path   string
			expect string
		}{
			{""../../../../../../../../../data/gogs/data/sessions/a/9/a9f0ab6c3ef63dd8"", ""data/gogs/data/sessions/a/9/a9f0ab6c3ef63dd8""},
			{""data/gogs/../../../../../../../../../data/sessions/a/9/a9f0ab6c3ef63dd8"", ""data/gogs/data/sessions/a/9/a9f0ab6c3ef63dd8""},
			{""data/sessions/a/9/a9f0ab6c3ef63dd8"", ""data/sessions/a/9/a9f0ab6c3ef63dd8""},
		}
		for _, tc := range testCases {
			So(SanitizePath(tc.path), ShouldEqual, tc.expect)
		}
	})
}
",CWE-22,50.0,0
"// Copyright 2022 The Gogs Authors. All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.
package netutil
import (
	""fmt""
	""net""
)
var localCIDRs []*net.IPNet
func init() {
	// Parsing hardcoded CIDR strings should never fail, if in case it does, let's
	// fail it at start.
	rawCIDRs := []string{
		// https://datatracker.ietf.org/doc/html/rfc5735:
		""127.0.0.0/8"",        // Loopback
		""0.0.0.0/8"",          // ""This"" network
		""100.64.0.0/10"",      // Shared address space
		""169.254.0.0/16"",     // Link local
		""172.16.0.0/12"",      // Private-use networks
		""192.0.0.0/24"",       // IETF Protocol assignments
		""192.0.2.0/24"",       // TEST-NET-1
		""192.88.99.0/24"",     // 6to4 Relay anycast
		""192.168.0.0/16"",     // Private-use networks
		""198.18.0.0/15"",      // Network interconnect
		""198.51.100.0/24"",    // TEST-NET-2
		""203.0.113.0/24"",     // TEST-NET-3
		""255.255.255.255/32"", // Limited broadcast
		// https://datatracker.ietf.org/doc/html/rfc1918:
		""10.0.0.0/8"", // Private-use networks
		// https://datatracker.ietf.org/doc/html/rfc6890:
		""::1/128"",   // Loopback
		""FC00::/7"",  // Unique local address
		""FE80::/10"", // Multicast address
	}
	for _, raw := range rawCIDRs {
		_, cidr, err := net.ParseCIDR(raw)
		if err != nil {
			panic(fmt.Sprintf(""parse CIDR %q: %v"", raw, err))
		}
		localCIDRs = append(localCIDRs, cidr)
	}
}
// IsBlockedLocalHostname returns true if given hostname is resolved to a local
// network address that is implicitly blocked (i.e. not exempted from the
// allowlist).
func IsBlockedLocalHostname(hostname string, allowlist []string) bool {
	for _, allow := range allowlist {
		if hostname == allow {
			return false
		}
	}
	ips, err := net.LookupIP(hostname)
	if err != nil {
		return true
	}
	for _, ip := range ips {
		for _, cidr := range localCIDRs {
			if cidr.Contains(ip) {
				return true
			}
		}
	}
	return false
}
",CWE-918,73.0,0
"// Copyright 2022 The Gogs Authors. All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.
package netutil
import (
	""testing""
	""github.com/stretchr/testify/assert""
)
func TestIsLocalHostname(t *testing.T) {
	tests := []struct {
		hostname  string
		allowlist []string
		want      bool
	}{
		{hostname: ""localhost"", want: true},       // 
		{hostname: ""127.0.0.1"", want: true},       // 
		{hostname: ""::1"", want: true},             // 
		{hostname: ""0:0:0:0:0:0:0:1"", want: true}, // 
		{hostname: ""fuf.me"", want: true},          // 
		{hostname: ""127.0.0.95"", want: true},      // 
		{hostname: ""0.0.0.0"", want: true},         // 
		{hostname: ""192.168.123.45"", want: true},  // 
		{hostname: ""gogs.io"", want: false},         // 
		{hostname: ""google.com"", want: false},      // 
		{hostname: ""165.232.140.255"", want: false}, // 
		{hostname: ""192.168.123.45"", allowlist: []string{""10.0.0.17""}, want: true}, // 
		{hostname: ""gogs.local"", allowlist: []string{""gogs.local""}, want: false},   // 
	}
	for _, test := range tests {
		t.Run("""", func(t *testing.T) {
			assert.Equal(t, test.want, IsBlockedLocalHostname(test.hostname, test.allowlist))
		})
	}
}
",CWE-918,41.0,0
"// Copyright 2020 The Gogs Authors. All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.
package repo
import (
	""testing""
	""github.com/stretchr/testify/assert""
	""gogs.io/gogs/internal/db""
	""gogs.io/gogs/internal/mocks""
)
func Test_validateWebhook(t *testing.T) {
	l := &mocks.Locale{
		MockLang: ""en"",
		MockTr: func(s string, _ ...interface{}) string {
			return s
		},
	}
	tests := []struct {
		name     string
		actor    *db.User
		webhook  *db.Webhook
		expField string
		expMsg   string
		expOK    bool
	}{
		{
			name:    ""admin bypass local address check"",
			webhook: &db.Webhook{URL: ""https://www.google.com""},
			expOK:   true,
		},
		{
			name:     ""local address not allowed"",
			webhook:  &db.Webhook{URL: ""http://localhost:3306""},
			expField: ""PayloadURL"",
			expMsg:   ""repo.settings.webhook.url_resolved_to_blocked_local_address"",
			expOK:    false,
		},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			field, msg, ok := validateWebhook(l, test.webhook)
			assert.Equal(t, test.expOK, ok)
			assert.Equal(t, test.expMsg, msg)
			assert.Equal(t, test.expField, field)
		})
	}
}
",CWE-918,55.0,0
"// Copyright 2018 The Gogs Authors. All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.
package db
import (
	""testing""
	""github.com/stretchr/testify/assert""
)
func Test_isRepositoryGitPath(t *testing.T) {
	tests := []struct {
		path    string
		wantVal bool
	}{
		{path: "".git"", wantVal: true},
		{path: ""./.git"", wantVal: true},
		{path: "".git/hooks/pre-commit"", wantVal: true},
		{path: "".git/hooks"", wantVal: true},
		{path: ""dir/.git"", wantVal: true},
		{path: "".gitignore"", wantVal: false},
		{path: ""dir/.gitkeep"", wantVal: false},
		// Windows-specific
		{path: `.git\`, wantVal: true},
		{path: `.git\hooks\pre-commit`, wantVal: true},
		{path: `.git\hooks`, wantVal: true},
		{path: `dir\.git`, wantVal: true},
		{path: `.\.git.`, wantVal: true},
		{path: `.\.git.\`, wantVal: true},
		{path: `.git.\hooks\pre-commit`, wantVal: true},
		{path: `.git.\hooks`, wantVal: true},
		{path: `dir\.git.`, wantVal: true},
		{path: ""./.git."", wantVal: true},
		{path: ""./.git./"", wantVal: true},
		{path: "".git./hooks/pre-commit"", wantVal: true},
		{path: "".git./hooks"", wantVal: true},
		{path: ""dir/.git."", wantVal: true},
		{path: `dir\.gitkeep`, wantVal: false},
	}
	for _, test := range tests {
		t.Run(test.path, func(t *testing.T) {
			assert.Equal(t, test.wantVal, isRepositoryGitPath(test.path))
		})
	}
}
",CWE-78,53.0,0
"// Copyright 2020 The Gogs Authors. All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.
package pathutil
import (
	""path""
	""strings""
)
// Clean cleans up given path and returns a relative path that goes straight
// down to prevent path traversal.
func Clean(p string) string {
	p = strings.ReplaceAll(p, `\`, ""/"")
	return strings.Trim(path.Clean(""/""+p), ""/"")
}
",CWE-22,18.0,0
"// Copyright 2020 The Gogs Authors. All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.
package pathutil
import (
	""testing""
	""github.com/stretchr/testify/assert""
)
func TestClean(t *testing.T) {
	tests := []struct {
		path    string
		wantVal string
	}{
		{
			path:    ""../../../readme.txt"",
			wantVal: ""readme.txt"",
		},
		{
			path:    ""a/../../../readme.txt"",
			wantVal: ""readme.txt"",
		},
		{
			path:    ""/../a/b/../c/../readme.txt"",
			wantVal: ""a/readme.txt"",
		},
		{
			path:    ""/a/readme.txt"",
			wantVal: ""a/readme.txt"",
		},
		{
			path:    ""/"",
			wantVal: """",
		},
		{
			path:    ""/a/b/c/readme.txt"",
			wantVal: ""a/b/c/readme.txt"",
		},
		// Windows-specific
		{
			path:    `..\..\..\readme.txt`,
			wantVal: ""readme.txt"",
		},
		{
			path:    `a\..\..\..\readme.txt`,
			wantVal: ""readme.txt"",
		},
		{
			path:    `\..\a\b\..\c\..\readme.txt`,
			wantVal: ""a/readme.txt"",
		},
		{
			path:    `\a\readme.txt`,
			wantVal: ""a/readme.txt"",
		},
		{
			path:    `..\..\..\../README.md`,
			wantVal: ""README.md"",
		},
		{
			path:    `\`,
			wantVal: """",
		},
		{
			path:    `\a\b\c\readme.txt`,
			wantVal: `a/b/c/readme.txt`,
		},
	}
	for _, test := range tests {
		t.Run(test.path, func(t *testing.T) {
			assert.Equal(t, test.wantVal, Clean(test.path))
		})
	}
}
",CWE-22,81.0,0
"// Copyright 2020 The Gogs Authors. All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.
package pathutil
import (
	""testing""
	""github.com/stretchr/testify/assert""
)
func TestClean(t *testing.T) {
	tests := []struct {
		path    string
		wantVal string
	}{
		{
			path:    ""../../../readme.txt"",
			wantVal: ""readme.txt"",
		},
		{
			path:    ""a/../../../readme.txt"",
			wantVal: ""readme.txt"",
		},
		{
			path:    ""/../a/b/../c/../readme.txt"",
			wantVal: ""a/readme.txt"",
		},
		{
			path:    ""../../objects/info/.."",
			wantVal: ""objects"",
		},
		{
			path:    ""/a/readme.txt"",
			wantVal: ""a/readme.txt"",
		},
		{
			path:    ""/"",
			wantVal: """",
		},
		{
			path:    ""/a/b/c/readme.txt"",
			wantVal: ""a/b/c/readme.txt"",
		},
		// Windows-specific
		{
			path:    `..\..\..\readme.txt`,
			wantVal: ""readme.txt"",
		},
		{
			path:    `a\..\..\..\readme.txt`,
			wantVal: ""readme.txt"",
		},
		{
			path:    `\..\a\b\..\c\..\readme.txt`,
			wantVal: ""a/readme.txt"",
		},
		{
			path:    `\a\readme.txt`,
			wantVal: ""a/readme.txt"",
		},
		{
			path:    `..\..\..\../README.md`,
			wantVal: ""README.md"",
		},
		{
			path:    `\`,
			wantVal: """",
		},
		{
			path:    `\a\b\c\readme.txt`,
			wantVal: `a/b/c/readme.txt`,
		},
	}
	for _, test := range tests {
		t.Run(test.path, func(t *testing.T) {
			assert.Equal(t, test.wantVal, Clean(test.path))
		})
	}
}
",CWE-22,85.0,0
"// Copyright 2018 The Gogs Authors. All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.
package db
import (
	""testing""
	""github.com/stretchr/testify/assert""
)
func TestIsRepositoryGitPath(t *testing.T) {
	tests := []struct {
		path    string
		wantVal bool
	}{
		{path: "".git"", wantVal: true},
		{path: ""./.git"", wantVal: true},
		{path: "".git/hooks/pre-commit"", wantVal: true},
		{path: "".git/hooks"", wantVal: true},
		{path: ""dir/.git"", wantVal: true},
		// Case-insensitive file system
		{path: "".Git"", wantVal: true},
		{path: ""./.Git"", wantVal: true},
		{path: "".Git/hooks/pre-commit"", wantVal: true},
		{path: "".Git/hooks"", wantVal: true},
		{path: ""dir/.Git"", wantVal: true},
		{path: "".gitignore"", wantVal: false},
		{path: ""dir/.gitkeep"", wantVal: false},
		// Windows-specific
		{path: `.git\`, wantVal: true},
		{path: `.git\hooks\pre-commit`, wantVal: true},
		{path: `.git\hooks`, wantVal: true},
		{path: `dir\.git`, wantVal: true},
		{path: `.\.git.`, wantVal: true},
		{path: `.\.git.\`, wantVal: true},
		{path: `.git.\hooks\pre-commit`, wantVal: true},
		{path: `.git.\hooks`, wantVal: true},
		{path: `dir\.git.`, wantVal: true},
		{path: ""./.git."", wantVal: true},
		{path: ""./.git./"", wantVal: true},
		{path: "".git./hooks/pre-commit"", wantVal: true},
		{path: "".git./hooks"", wantVal: true},
		{path: ""dir/.git."", wantVal: true},
		{path: `dir\.gitkeep`, wantVal: false},
	}
	for _, test := range tests {
		t.Run(test.path, func(t *testing.T) {
			assert.Equal(t, test.wantVal, isRepositoryGitPath(test.path))
		})
	}
}
",CWE-78,60.0,0
"package extractor
import (
	""archive/tar""
	""compress/gzip""
	""fmt""
	""io""
	""os""
	""os/exec""
	""path/filepath""
	securejoin ""github.com/cyphar/filepath-securejoin""
)
type tgzExtractor struct{}
func NewTgz() Extractor {
	return &tgzExtractor{}
}
func (e *tgzExtractor) Extract(src, dest string) error {
	srcType, err := mimeType(src)
	if err != nil {
		return err
	}
	switch srcType {
	case ""application/x-gzip"":
		err := extractTgz(src, dest)
		if err != nil {
			return err
		}
	default:
		return fmt.Errorf(""%s is not a tgz archive: %s"", src, srcType)
	}
	return nil
}
func extractTgz(src, dest string) error {
	tarPath, err := exec.LookPath(""tar"")
	if err == nil {
		err := os.MkdirAll(dest, 0755)
		if err != nil {
			return err
		}
		return exec.Command(tarPath, ""pzxf"", src, ""-C"", dest).Run()
	}
	fd, err := os.Open(src)
	if err != nil {
		return err
	}
	defer fd.Close()
	gReader, err := gzip.NewReader(fd)
	if err != nil {
		return err
	}
	defer gReader.Close()
	tarReader := tar.NewReader(gReader)
	return extractTarArchive(tarReader, dest)
}
func extractTarArchive(tarReader *tar.Reader, dest string) error {
	for {
		hdr, err := tarReader.Next()
		if err == io.EOF {
			break
		}
		if err != nil {
			return err
		}
		if hdr.Name == ""."" {
			continue
		}
		err = extractTarArchiveFile(hdr, dest, tarReader)
		if err != nil {
			return err
		}
	}
	return nil
}
func extractTarArchiveFile(header *tar.Header, dest string, input io.Reader) error {
	filePath, err := securejoin.SecureJoin(dest, header.Name)
	if err != nil {
		return err
	}
	fileInfo := header.FileInfo()
	if fileInfo.IsDir() {
		return os.MkdirAll(filePath, fileInfo.Mode())
	}
	err = os.MkdirAll(filepath.Dir(filePath), 0755)
	if err != nil {
		return err
	}
	if fileInfo.Mode()&os.ModeSymlink != 0 {
		return os.Symlink(header.Linkname, filePath)
	}
	fileCopy, err := os.OpenFile(filePath, os.O_RDWR|os.O_CREATE|os.O_TRUNC, fileInfo.Mode())
	if err != nil {
		return err
	}
	defer fileCopy.Close()
	_, err = io.Copy(fileCopy, input)
	return err
}
",CWE-22,121.0,0
"package extractor
import (
	""archive/zip""
	""fmt""
	""io""
	""io/ioutil""
	""os""
	""os/exec""
	""path/filepath""
	securejoin ""github.com/cyphar/filepath-securejoin""
)
type zipExtractor struct{}
func NewZip() Extractor {
	return &zipExtractor{}
}
func (e *zipExtractor) Extract(src, dest string) error {
	srcType, err := mimeType(src)
	if err != nil {
		return err
	}
	switch srcType {
	case ""application/zip"":
		err := extractZip(src, dest)
		if err != nil {
			return err
		}
	default:
		return fmt.Errorf(""%s is not a zip archive: %s"", src, srcType)
	}
	return nil
}
func extractZip(src, dest string) error {
	path, err := exec.LookPath(""unzip"")
	if err == nil {
		err := os.MkdirAll(dest, 0755)
		if err != nil {
			return err
		}
		unzipCmd := exec.Command(path, src)
		unzipCmd.Dir = dest
		return unzipCmd.Run()
	} else {
		files, err := zip.OpenReader(src)
		if err != nil {
			return err
		}
		defer files.Close()
		for _, file := range files.File {
			err = func() error {
				readCloser, err := file.Open()
				if err != nil {
					return err
				}
				defer readCloser.Close()
				return extractZipArchiveFile(file, dest, readCloser)
			}()
			if err != nil {
				return err
			}
		}
		return nil
	}
}
func extractZipArchiveFile(file *zip.File, dest string, input io.Reader) error {
	filePath, err := securejoin.SecureJoin(dest, file.Name)
	fileInfo := file.FileInfo()
	if fileInfo.IsDir() {
		err = os.MkdirAll(filePath, fileInfo.Mode())
		if err != nil {
			return err
		}
	} else {
		err = os.MkdirAll(filepath.Dir(filePath), 0755)
		if err != nil {
			return err
		}
		if fileInfo.Mode()&os.ModeSymlink != 0 {
			linkName, err := ioutil.ReadAll(input)
			if err != nil {
				return err
			}
			return os.Symlink(string(linkName), filePath)
		}
		fileCopy, err := os.OpenFile(filePath, os.O_RDWR|os.O_CREATE|os.O_TRUNC, fileInfo.Mode())
		if err != nil {
			return err
		}
		defer fileCopy.Close()
		_, err = io.Copy(fileCopy, input)
		if err != nil {
			return err
		}
	}
	return nil
}
",CWE-22,118.0,0
"// Copyright 2018 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * Module containing settings for merlin server.
 */
const settings = {
  // Merlin synthesis pipeline might not handle these characters as expected
  // and also they are typically not needed during tts synthesis.
  // Therefore we replace them with spaces.
  CHARACTERS_TO_REPLACE_WITH_SPACES: '!""
};
module.exports = settings;
",CWE-78,25.0,0
"// Copyright 2018 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * Module containing settings for merlin server.
 */
const settings = {
  // Festival synthesis pipeline might not handle these characters as expected
  // and also they are typically not needed during tts synthesis.
  // Therefore we replace them with spaces.
  CHARACTERS_TO_REPLACE_WITH_SPACES: '!""
};
module.exports = settings;
",CWE-78,25.0,0
"
package.json",CWE-78,2.0,0
"/*
 * Copyright 2019-present Facebook, Inc.
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package thrift
import (
	""strings""
	""testing""
	""time""
)
func TestReadWriteBinaryProtocol(t *testing.T) {
	ReadWriteProtocolTest(t, NewBinaryProtocolFactoryDefault())
}
func TestSkipUnknownTypeBinaryProtocol(t *testing.T) {
	var m MyTestStruct
	d := NewDeserializer()
	f := NewBinaryProtocolFactoryDefault()
	d.Protocol = f.GetProtocol(d.Transport)
	// skip over a map with invalid key/value type and 1.7B entries
	data := []byte(""\n\x10\rO\t6\x03\n\n\n\x10\r\n\tslice\x00"")
	start := time.Now()
	err := d.Read(&m, data)
	if err == nil {
		t.Fatalf(""Parsed invalid message correctly"")
	} else if !strings.Contains(err.Error(), ""unknown type"") {
		t.Fatalf(""Failed for reason besides unknown type"")
	}
	if time.Now().Sub(start).Seconds() > 5 {
		t.Fatalf(""It should not take seconds to parse a small message"")
	}
}
",CWE-755,52.0,0
"/*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package thrift
import (
	""bytes""
	""fmt""
	""strings""
	""testing""
	""time""
)
func TestReadWriteBinaryProtocol(t *testing.T) {
	ReadWriteProtocolTest(t, NewBinaryProtocolFactoryDefault())
}
func TestSkipUnknownTypeBinaryProtocol(t *testing.T) {
	var m MyTestStruct
	d := NewDeserializer()
	f := NewBinaryProtocolFactoryDefault()
	d.Protocol = f.GetProtocol(d.Transport)
	// skip over a map with invalid key/value type and ~550M entries
	data := make([]byte, 1100000000)
	copy(data[:], []byte(""\n\x10\rO\t6\x03\n\n\n\x10\r\n\tsl ce\x00""))
	transport, _ := d.Transport.(*MemoryBuffer)
	transport.Buffer = bytes.NewBuffer(data)
	start := time.Now()
	err := m.Read(d.Protocol)
	if err == nil {
		t.Fatalf(""Parsed invalid message correctly"")
	} else if !strings.Contains(err.Error(), ""unknown type"") {
		t.Fatalf(""Failed for reason besides unknown type"")
	}
	if time.Now().Sub(start).Seconds() > 5 {
		t.Fatalf(""It should not take seconds to parse a small message"")
	}
}
func TestInitialAllocationMapBinaryProtocol(t *testing.T) {
	var m MyTestStruct
	d := NewDeserializer()
	f := NewBinaryProtocolFactoryDefault()
	d.Protocol = f.GetProtocol(d.Transport)
	// attempts to allocate a map with 1.8B elements for a 20 byte message
	data := []byte(""\n\x10\rO\t6\x03\n\n\n\x10\r\n\tslice\x00"")
	err := d.Read(&m, data)
	if err == nil {
		t.Fatalf(""Parsed invalid message correctly"")
	} else if !strings.Contains(err.Error(), ""Invalid data length"") {
		t.Fatalf(""Failed for reason besides Invalid data length"")
	}
}
func TestInitialAllocationListBinaryProtocol(t *testing.T) {
	var m MyTestStruct
	d := NewDeserializer()
	f := NewBinaryProtocolFactoryDefault()
	d.Protocol = f.GetProtocol(d.Transport)
	// attempts to allocate a list with 1.8B elements for a 20 byte message
	data := []byte(""\n\x10\rO\t6\x03\n\n\n\x10\x0f\n\tslice\x00"")
	err := d.Read(&m, data)
	if err == nil {
		t.Fatalf(""Parsed invalid message correctly"")
	} else if !strings.Contains(err.Error(), ""Invalid data length"") {
		t.Fatalf(""Failed for reason besides Invalid data length"")
	}
}
func TestInitialAllocationSetBinaryProtocol(t *testing.T) {
	var m MyTestStruct
	d := NewDeserializer()
	f := NewBinaryProtocolFactoryDefault()
	d.Protocol = f.GetProtocol(d.Transport)
	// attempts to allocate a set with 1.8B elements for a 20 byte message
	data := []byte(""\n\x12\rO\t6\x03\n\n\n\x10\x0e\n\tslice\x00"")
	err := d.Read(&m, data)
	if err == nil {
		t.Fatalf(""Parsed invalid message correctly"")
	} else if !strings.Contains(err.Error(), ""Invalid data length"") {
		fmt.Printf(""Got %+v"", err)
		t.Fatalf(""Failed for reason besides Invalid data length"")
	}
}
",CWE-770,99.0,0
"/*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package thrift
import (
	""bytes""
	""strings""
	""testing""
)
func TestReadWriteCompactProtocol(t *testing.T) {
	ReadWriteProtocolTest(t, NewCompactProtocolFactory())
	// CompactProtocol is capable of reading and writing in different goroutines.
	ReadWriteProtocolParallelTest(t, NewCompactProtocolFactory())
	transports := []Transport{
		NewMemoryBuffer(),
		NewFramedTransport(NewMemoryBuffer()),
	}
	for _, trans := range transports {
		p := NewCompactProtocol(trans)
		ReadWriteBool(t, p, trans)
		p = NewCompactProtocol(trans)
		ReadWriteByte(t, p, trans)
		p = NewCompactProtocol(trans)
		ReadWriteI16(t, p, trans)
		p = NewCompactProtocol(trans)
		ReadWriteI32(t, p, trans)
		p = NewCompactProtocol(trans)
		ReadWriteI64(t, p, trans)
		p = NewCompactProtocol(trans)
		ReadWriteDouble(t, p, trans)
		p = NewCompactProtocol(trans)
		ReadWriteFloat(t, p, trans)
		p = NewCompactProtocol(trans)
		ReadWriteString(t, p, trans)
		p = NewCompactProtocol(trans)
		ReadWriteBinary(t, p, trans)
		p = NewCompactProtocol(trans)
		ReadWriteStruct(t, p, trans)
		trans.Close()
	}
}
func TestInitialAllocationMapCompactProtocol(t *testing.T) {
	var m MyTestStruct
	d := NewDeserializer()
	f := NewCompactProtocolFactory()
	d.Protocol = f.GetProtocol(d.Transport)
	// attempts to allocate a map of 930M elements for a 9 byte message
	data := []byte(""%0\x88\x8a\x97\xb7\xc4\x030"")
	err := d.Read(&m, data)
	if err == nil {
		t.Fatalf(""Parsed invalid message correctly"")
	} else if !strings.Contains(err.Error(), ""Invalid data length"") {
		t.Fatalf(""Failed for reason besides Invalid data length"")
	}
}
func TestInitialAllocationListCompactProtocol(t *testing.T) {
	var m MyTestStruct
	d := NewDeserializer()
	f := NewCompactProtocolFactory()
	d.Protocol = f.GetProtocol(d.Transport)
	// attempts to allocate a list of 950M elements for an 11 byte message
	data := []byte(""%0\x98\xfa\xb7\xb7\xc4\xc4\x03\x01a"")
	err := d.Read(&m, data)
	if err == nil {
		t.Fatalf(""Parsed invalid message correctly"")
	} else if !strings.Contains(err.Error(), ""Invalid data length"") {
		t.Fatalf(""Failed for reason besides Invalid data length"")
	}
}
func TestInitialAllocationSetCompactProtocol(t *testing.T) {
	var m MyTestStruct
	d := NewDeserializer()
	f := NewCompactProtocolFactory()
	d.Protocol = f.GetProtocol(d.Transport)
	// attempts to allocate a list of 950M elements for an 11 byte message
	data := []byte(""%0\xa8\xfa\x97\xb7\xc4\xc4\x03\x01a"")
	err := d.Read(&m, data)
	if err == nil {
		t.Fatalf(""Parsed invalid message correctly"")
	} else if !strings.Contains(err.Error(), ""Invalid data length"") {
		t.Fatalf(""Failed for reason besides Invalid data length"")
	}
}
func TestInitialAllocationMapCompactProtocolLimitedR(t *testing.T) {
	var m MyTestStruct
	// attempts to allocate a map of 930M elements for a 9 byte message
	data := []byte(""%0\x88\x8a\x97\xb7\xc4\x030"")
	p := NewCompactProtocol(
		NewStreamTransportLimitedR(bytes.NewBuffer(data), len(data)),
	)
	err := m.Read(p)
	if err == nil {
		t.Fatalf(""Parsed invalid message correctly"")
	} else if !strings.Contains(err.Error(), ""Invalid data length"") {
		t.Fatalf(""Failed for reason besides Invalid data length"")
	}
}
",CWE-770,119.0,0
"
STUB_SOURCE = \
	tests/stub_CacheDigest.cc \
	tests/stub_CachePeer.cc \
	tests/stub_CollapsedForwarding.cc \
	tests/stub_CommIO.cc \
	tests/stub_DelayId.cc \
	tests/stub_ETag.cc \
	tests/stub_EventLoop.cc \
	tests/stub_HelperChildConfig.cc \
	tests/stub_HttpControlMsg.cc \
	tests/stub_HttpHeader.cc \
	tests/stub_HttpReply.cc \
	tests/stub_HttpRequest.cc \
	tests/stub_HttpUpgradeProtocolAccess.cc \
	tests/stub_IpcIoFile.cc \
	tests/stub_MemBuf.cc \
	tests/stub_MemObject.cc \
	tests/stub_MemStore.cc \
	tests/stub_Port.cc \
	tests/stub_SBuf.cc \
	tests/stub_StatHist.cc \
	tests/stub_UdsOp.cc \
	tests/stub_access_log.cc \
	tests/stub_acl.cc \
	tests/stub_cache_cf.cc \
	tests/stub_cache_manager.cc \
	tests/stub_carp.cc \
	tests/stub_cbdata.cc \
	tests/stub_client_db.cc \
	tests/stub_client_side.cc \
	tests/stub_client_side_request.cc \
	tests/stub_comm.cc \
	tests/stub_debug.cc \
	tests/stub_errorpage.cc \
	tests/stub_event.cc \
	tests/stub_external_acl.cc \
	tests/stub_fatal.cc \
	tests/stub_fd.cc \
	tests/stub_fqdncache.cc \
	tests/stub_helper.cc \
	tests/stub_http.cc \
	tests/stub_icp.cc \
	tests/stub_internal.cc \
	tests/stub_ipc.cc \
	tests/stub_ipc_Forwarder.cc \
	tests/stub_ipc_TypedMsgHdr.cc \
	tests/stub_ipcache.cc \
	tests/stub_libanyp.cc \
	tests/stub_libauth.cc \
	tests/stub_libauth_acls.cc \
	tests/stub_libcomm.cc \
	tests/stub_libdiskio.cc \
	tests/stub_liberror.cc \
	tests/stub_libeui.cc \
	tests/stub_libformat.cc \
	tests/stub_libhttp.cc \
	tests/stub_libicmp.cc \
	tests/stub_libip.cc \
	tests/stub_liblog.cc \
	tests/stub_libmem.cc \
	tests/stub_libmgr.cc \
	tests/stub_libsecurity.cc \
	tests/stub_libsslsquid.cc \
	tests/stub_libstore.cc \
	tests/stub_libtime.cc \
	tests/stub_main_cc.cc \
	tests/stub_mem_node.cc \
	tests/stub_mime.cc \
	tests/stub_neighbors.cc \
	tests/stub_pconn.cc \
	tests/stub_redirect.cc \
	tests/stub_stat.cc \
	tests/stub_stmem.cc \
	tests/stub_store.cc \
	tests/stub_store_client.cc \
	tests/stub_store_digest.cc \
	tests/stub_store_rebuild.cc \
	tests/stub_store_stats.cc \
	tests/stub_tools.cc \
	tests/stub_tunnel.cc \
	tests/stub_wccp2.cc \
	tests/stub_whois.cc \
	tests/stub_wordlist.cc
",CWE-476,94.0,0
"package proxyprotocol
import (
	""bufio""
	""bytes""
	""io""
	""net""
	""testing""
	""github.com/stretchr/testify/assert""
)
func TestHeaderV2(t *testing.T) {
	type section struct {
		name  string
		value []byte
	}
	check := func(name string, h HeaderV2, exp []section) {
		t.Run(name+""_WriteTo"", func(t *testing.T) {
			var buf bytes.Buffer
			_, err := h.WriteTo(&buf)
			assert.NoError(t, err)
			for _, s := range exp {
				cmp := make([]byte, len(s.value))
				_, err := io.ReadFull(&buf, cmp)
				assert.NoError(t, err)
				assert.Equal(t, s.value, cmp, s.name)
			}
		})
		t.Run(name+""_Parse"", func(t *testing.T) {
			var buf bytes.Buffer
			for _, s := range exp {
				buf.Write(s.value)
			}
			hdr, err := Parse(bufio.NewReader(&buf))
			if !assert.NoError(t, err) {
				return
			}
			assert.IsType(t, &HeaderV2{}, hdr, ""Header Type"")
			p := hdr.(*HeaderV2)
			assert.Equal(t, h.Command, p.Command, ""Command"")
			if h.Src != nil {
				assert.NotNil(t, p.Src)
				assert.Equal(t, h.Src.String(), p.Src.String(), ""SrcAddr"")
			} else {
				assert.Nil(t, p.Src)
			}
			if h.Dest != nil {
				assert.NotNil(t, p.Dest)
				assert.Equal(t, h.Dest.String(), p.Dest.String(), ""DestAddr"")
			} else {
				assert.Nil(t, p.Dest)
			}
		})
	}
	check(""local"", HeaderV2{},
		[]section{
			{name: ""Signature"", value: sigV2},
			{name: ""Version"", value: []byte{0x20}},   // v2, Local
			{name: ""Fam/Proto"", value: []byte{0x00}}, // unspec, unspec
			{name: ""Length"", value: []byte{0, 0}},    // zero length
		},
	)
	check(""tcp-ipv4"", HeaderV2{
		Command: CmdProxy,
		Src:     &net.TCPAddr{IP: net.ParseIP(""192.168.0.1""), Port: 80},
		Dest:    &net.TCPAddr{IP: net.ParseIP(""192.168.0.2""), Port: 90},
	},
		[]section{
			{name: ""Signature"", value: sigV2},
			{name: ""Version"", value: []byte{0x21}},   // v2, Proxy
			{name: ""Fam/Proto"", value: []byte{0x11}}, // INET, STREAM
			{name: ""Length"", value: []byte{0, 12}},   // length=12
			{name: ""SrcAddr"", value: []byte{192, 168, 0, 1}},
			{name: ""DestAddr"", value: []byte{192, 168, 0, 2}},
			{name: ""SrcPort"", value: []byte{0, 80}},
			{name: ""DstPort"", value: []byte{0, 90}},
		},
	)
	check(""udp-ipv4"", HeaderV2{
		Command: CmdProxy,
		Src:     &net.UDPAddr{IP: net.ParseIP(""192.168.0.1""), Port: 80},
		Dest:    &net.UDPAddr{IP: net.ParseIP(""192.168.0.2""), Port: 90},
	},
		[]section{
			{name: ""Signature"", value: sigV2},
			{name: ""Version"", value: []byte{0x21}},   // v2, Proxy
			{name: ""Fam/Proto"", value: []byte{0x12}}, // INET, DGRAM
			{name: ""Length"", value: []byte{0, 12}},   // length=12
			{name: ""SrcAddr"", value: []byte{192, 168, 0, 1}},
			{name: ""DestAddr"", value: []byte{192, 168, 0, 2}},
			{name: ""SrcPort"", value: []byte{0, 80}},
			{name: ""DstPort"", value: []byte{0, 90}},
		},
	)
	check(""udp-ipv6"", HeaderV2{
		Command: CmdProxy,
		Src:     &net.UDPAddr{IP: net.ParseIP(""2001::1""), Port: 80},
		Dest:    &net.UDPAddr{IP: net.ParseIP(""2002::2""), Port: 90},
	},
		[]section{
			{name: ""Signature"", value: sigV2},
			{name: ""Version"", value: []byte{0x21}},   // v2, Proxy
			{name: ""Fam/Proto"", value: []byte{0x22}}, // INET6, DGRAM
			{name: ""Length"", value: []byte{0, 36}},   // length=36
			{name: ""SrcAddr"", value: []byte{0x20, 0x01, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x01}},
			{name: ""DestAddr"", value: []byte{0x20, 0x02, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x02}},
			{name: ""SrcPort"", value: []byte{0, 80}},
			{name: ""DstPort"", value: []byte{0, 90}},
		},
	)
	check(""unixstream"", HeaderV2{
		Command: CmdProxy,
		Src:     &net.UnixAddr{Net: ""unix"", Name: ""foo""},
		Dest:    &net.UnixAddr{Net: ""unix"", Name: ""bar""},
	},
		[]section{
			{name: ""Signature"", value: sigV2},
			{name: ""Version"", value: []byte{0x21}},   // v2, Proxy
			{name: ""Fam/Proto"", value: []byte{0x31}}, // UNIX, STREAM
			{name: ""Length"", value: []byte{0, 216}},  // length=216
			{name: ""SrcAddr"", value: append([]byte(""foo""), make([]byte, 105)...)},
			{name: ""DestAddr"", value: append([]byte(""bar""), make([]byte, 105)...)},
		},
	)
	check(""unixgram"", HeaderV2{
		Command: CmdProxy,
		Src:     &net.UnixAddr{Net: ""unixgram"", Name: ""foo""},
		Dest:    &net.UnixAddr{Net: ""unixgram"", Name: ""bar""},
	},
		[]section{
			{name: ""Signature"", value: sigV2},
			{name: ""Version"", value: []byte{0x21}},   // v2, Proxy
			{name: ""Fam/Proto"", value: []byte{0x32}}, // UNIX, DGRAM
			{name: ""Length"", value: []byte{0, 216}},  // length=216
			{name: ""SrcAddr"", value: append([]byte(""foo""), make([]byte, 105)...)},
			{name: ""DestAddr"", value: append([]byte(""bar""), make([]byte, 105)...)},
		},
	)
}
",CWE-20,156.0,0
"package proxyprotocol
import (
	""bufio""
	""bytes""
	""testing""
	""github.com/stretchr/testify/assert""
)
func TestParse_Malformed(t *testing.T) {
	data := []byte{
		// PROXY protocol v2 magic header
		0x0D, 0x0A, 0x0D, 0x0A, 0x00, 0x0D, 0x0A, 0x51, 0x55, 0x49, 0x54, 0x0A,
		// v2 version, PROXY cmd
		0x21,
		// TCP, IPv4 (also works with 0x13,0x21,0x22,0x31,0x32)
		0x12,
		// Length
		0x00, 0x00,
		// src/dest address data _should_ be here but is omitted.
	}
	_, err := Parse(
		bufio.NewReader(
			bytes.NewReader(data)))
	assert.Error(t, err)
}
",CWE-20,29.0,0
"package install
import (
	""errors""
	""fmt""
	""github.com/cnlh/nps/lib/common""
	""io""
	""log""
	""os""
	""path/filepath""
	""strings""
)
func InstallNps() {
	path := common.GetInstallPath()
	if common.FileExists(path) {
		log.Fatalf(""the path %s has exist, does not support install"", path)
	}
	MkidrDirAll(path, ""conf"", ""web/static"", ""web/views"")
	//复制文件到对应目录
	if err := CopyDir(filepath.Join(common.GetAppPath(), ""web"", ""views""), filepath.Join(path, ""web"", ""views"")); err != nil {
		log.Fatalln(err)
	}
	if err := CopyDir(filepath.Join(common.GetAppPath(), ""web"", ""static""), filepath.Join(path, ""web"", ""static"")); err != nil {
		log.Fatalln(err)
	}
	if err := CopyDir(filepath.Join(common.GetAppPath(), ""conf""), filepath.Join(path, ""conf"")); err != nil {
		log.Fatalln(err)
	}
	if !common.IsWindows() {
		if _, err := copyFile(filepath.Join(common.GetAppPath(), ""nps""), ""/usr/bin/nps""); err != nil {
			if _, err := copyFile(filepath.Join(common.GetAppPath(), ""nps""), ""/usr/local/bin/nps""); err != nil {
				log.Fatalln(err)
			} else {
				os.Chmod(""/usr/local/bin/nps"", 0755)
				log.Println(""Executable files have been copied to"", ""/usr/local/bin/nps"")
			}
		} else {
			os.Chmod(""/usr/bin/nps"", 0755)
			log.Println(""Executable files have been copied to"", ""/usr/bin/nps"")
		}
	}
	log.Println(""install ok!"")
	log.Println(""Static files and configuration files in the current directory will be useless"")
	log.Println(""The new configuration file is located in"", path, ""you can edit them"")
	if !common.IsWindows() {
		log.Println(""You can start with nps test|start|stop|restart|status anywhere"")
	} else {
		log.Println(""You can copy executable files to any directory and start working with nps.exe test|start|stop|restart|status"")
	}
}
func MkidrDirAll(path string, v ...string) {
	for _, item := range v {
		if err := os.MkdirAll(filepath.Join(path, item), 0755); err != nil {
			log.Fatalf(""Failed to create directory %s error:%s"", path, err.Error())
		}
	}
}
func CopyDir(srcPath string, destPath string) error {
	//检测目录正确性
	if srcInfo, err := os.Stat(srcPath); err != nil {
		fmt.Println(err.Error())
		return err
	} else {
		if !srcInfo.IsDir() {
			e := errors.New(""SrcPath is not the right directory!"")
			return e
		}
	}
	if destInfo, err := os.Stat(destPath); err != nil {
		return err
	} else {
		if !destInfo.IsDir() {
			e := errors.New(""DestInfo is not the right directory!"")
			return e
		}
	}
	err := filepath.Walk(srcPath, func(path string, f os.FileInfo, err error) error {
		if f == nil {
			return err
		}
		if !f.IsDir() {
			destNewPath := strings.Replace(path, srcPath, destPath, -1)
			log.Println(""copy file ::"" + path + "" to "" + destNewPath)
			copyFile(path, destNewPath)
		}
		return nil
	})
	return err
}
//生成目录并拷贝文件
func copyFile(src, dest string) (w int64, err error) {
	srcFile, err := os.Open(src)
	if err != nil {
		return
	}
	defer srcFile.Close()
	//分割path目录
	destSplitPathDirs := strings.Split(dest, string(filepath.Separator))
	//检测时候存在目录
	destSplitPath := """"
	for index, dir := range destSplitPathDirs {
		if index < len(destSplitPathDirs)-1 {
			destSplitPath = destSplitPath + dir + string(filepath.Separator)
			b, _ := pathExists(destSplitPath)
			if b == false {
				log.Println(""mkdir:"" + destSplitPath)
				//创建目录
				err := os.Mkdir(destSplitPath, os.ModePerm)
				if err != nil {
					log.Fatalln(err)
				}
			}
		}
	}
	dstFile, err := os.Create(dest)
	if err != nil {
		return
	}
	defer dstFile.Close()
	return io.Copy(dstFile, srcFile)
}
//检测文件夹路径时候存在
func pathExists(path string) (bool, error) {
	_, err := os.Stat(path)
	if err == nil {
		return true, nil
	}
	if os.IsNotExist(err) {
		return false, nil
	}
	return false, err
}
",CWE-732,141.0,0
"-----BEGIN CERTIFICATE-----
MIIEoTCCA4mgAwIBAgIUfOq/vQ8mjLRgSYL45lUeRsi92lQwDQYJKoZIhvcNAQEL
BQAwdjELMAkGA1UEBhMCVVMxEzARBgNVBAgMCkNhbGlmb3JuaWExFjAUBgNVBAcM
DVNhbiBGcmFuY2lzY28xDTALBgNVBAoMBEx5ZnQxGTAXBgNVBAsMEEx5ZnQgRW5n
aW5lZXJpbmcxEDAOBgNVBAMMB1Rlc3QgQ0EwHhcNMjMxMTE0MjMxODQwWhcNMjUx
MTEzMjMxODQwWjCBqDELMAkGA1UEBhMCVVMxEzARBgNVBAgMCkNhbGlmb3JuaWEx
FjAUBgNVBAcMDVNhbiBGcmFuY2lzY28xDTALBgNVBAoMBEx5ZnQxGTAXBgNVBAsM
EEx5ZnQgRW5naW5lZXJpbmcxGzAZBgNVBAMMElRlc3QgRnJvbnRlbmQgVGVhbTEl
MCMGCSqGSIb3DQEJARYWZnJvbnRlbmQtdGVhbUBseWZ0LmNvbTCCASIwDQYJKoZI
hvcNAQEBBQADggEPADCCAQoCggEBAL0rleTUkmUs7g/PA9skuWZoa6RoK/NfwwfC
WniKgiX+yRZcBy9//6HlOD3jLezD6tp+smh1UzIu3r69/r0eDjA+PsxQKDFH69LJ
74CaFtx9rjapY3VNwuE3jNclcKzDnjNVHrvND+YAIkLhRbXyBqg3n7T1C2wtVIs5
zOy79iu97vVuX744IDsIuWUWPpFImfgdELeAByRq8IN333jljTf3pN3GfjDf9aKL
M6jTGRitNVPY2mOe6LpkUntHs42weUBCZ2B39c8olXWeEoCJL35ENuJ/JlxpamP+
OlK/eShorsFE+UH8tYRMeNkb8ZEdFHohYQGO8WJ5VBw4d47loRsCAwEAAaOB8zCB
8DAMBgNVHRMBAf8EAjAAMAsGA1UdDwQEAwIF4DAdBgNVHSUEFjAUBggrBgEFBQcD
AgYIKwYBBQUHAwEwdAYDVR0RBG0wa4Yfc3BpZmZlOi8vbHlmdC5jb20vZnJvbnRl
bmQtdGVhbYYYaHR0cDovL2Zyb250ZW5kLmx5ZnQuY29tgghseWZ0LmNvbYIMd3d3
Lmx5ZnQuY29thwQBAgMEhxAAAAABAAIAAwAAAAAAAAAEMB0GA1UdDgQWBBTl8J5P
CF97S4cY6TytejTb3sngmTAfBgNVHSMEGDAWgBQdDTmYdOz7TqwMpoOli3Dmj78y
gjANBgkqhkiG9w0BAQsFAAOCAQEAsMuSPKvSx/uDRIHWNQhUWSHfa4nfonyGBmnV
VvC7Xatq3kZ1MCedzxHbqOOdlO4cSVq+eOHlVzWJUsJSj1J8hcVh3vZp6GFoRZgU
F93g2dlgkmEEqEFB4qI71PwjC6amEV+xY21v/QPEouI1VumUnMnAV81G5uJDzPtn
gmNyM6hnvKGufpaovZFeXsB0ZUnYPz+4QdKwHTErsV8uUdeJUhFHg1NjCmrqQAmm
PG0G9JOi/dY/X5/LfGomAb7E+wuJFKHFP7gE6JvWi5M1Y1IlW1tCgN3dSCdCaUZm
JPKWR3x+gYOFHfKNpdG/zRwOrClgISmDzZiXXFSHCn95tFocXA==
-----END CERTIFICATE-----
",CWE-755,28.0,0
"// Copyright 2016 Documize Inc. <legal@documize.com>. All rights reserved.
//
// This software (Documize Community Edition) is licensed under
// GNU AGPL v3 http://www.gnu.org/licenses/agpl-3.0.en.html
//
// You can operate outside the AGPL restrictions by purchasing
// Documize Enterprise Edition and obtaining a commercial license
// by contacting <sales@documize.com>.
//
// https://documize.com
package markdown
import (
	""net/http""
	""github.com/documize/blackfriday""
	""github.com/documize/community/core/env""
	""github.com/documize/community/domain/section/provider""
	""github.com/documize/community/domain/store""
	""github.com/microcosm-cc/bluemonday""
)
// Provider represents Markdown
type Provider struct {
	Runtime *env.Runtime
	Store   *store.Store
}
// Meta describes us
func (*Provider) Meta() provider.TypeMeta {
	section := provider.TypeMeta{}
	section.ID = ""1470bb4a-36c6-4a98-a443-096f5658378b""
	section.Title = ""Markdown""
	section.Description = ""CommonMark based content""
	section.ContentType = ""markdown""
	section.PageType = ""section""
	section.Order = 9998
	return section
}
// Command stub.
func (*Provider) Command(ctx *provider.Context, w http.ResponseWriter, r *http.Request) {
	provider.WriteEmpty(w)
}
// Render converts markdown data into HTML suitable for browser rendering.
func (*Provider) Render(ctx *provider.Context, config, data string) string {
	unsafe := blackfriday.Run([]byte(data))
	safe := bluemonday.UGCPolicy().SanitizeBytes(unsafe)
	return string(safe)
}
// Refresh just sends back data as-is.
func (*Provider) Refresh(ctx *provider.Context, config, data string) string {
	return data
}
",CWE-79,62.0,0
"module github.com/documize/community
go 1.13
require (
	github.com/BurntSushi/toml v0.3.1
	github.com/andygrunwald/go-jira v1.10.0
	github.com/codegangsta/negroni v0.3.0
	github.com/denisenkom/go-mssqldb v0.0.0-20190806190131-db2462fef53b
	github.com/dgrijalva/jwt-go v3.1.0+incompatible
	github.com/documize/blackfriday v2.0.0+incompatible
	github.com/documize/glick v0.0.0-20160503134043-a8ccbef88237
	github.com/documize/html-diff v0.0.0-20160503140253-f61c192c7796
	github.com/documize/slug v1.1.1
	github.com/elazarl/go-bindata-assetfs v1.0.0
	github.com/go-sql-driver/mysql v1.4.1
	github.com/google/go-github v17.0.0+incompatible
	github.com/google/go-querystring v1.0.0 // indirect
	github.com/gorilla/handlers v1.4.0
	github.com/gorilla/mux v1.6.2
	github.com/jmoiron/sqlx v1.2.0
	github.com/jteeuwen/go-bindata v3.0.7+incompatible // indirect
	github.com/kr/pretty v0.1.0 // indirect
	github.com/lib/pq v1.2.0
	github.com/mb0/diff v0.0.0-20131118162322-d8d9a906c24d // indirect
	github.com/microcosm-cc/bluemonday v1.0.2
	github.com/nu7hatch/gouuid v0.0.0-20131221200532-179d4d0c4d8d
	github.com/pkg/errors v0.8.0
	github.com/rainycape/unidecode v0.0.0-20150907023854-cb7f23ec59be // indirect
	github.com/shurcooL/sanitized_anchor_name v0.0.0-20170918181015-86672fcb3f95 // indirect
	golang.org/x/crypto v0.0.0-20190426145343-a29dc8fdc734
	golang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3
	golang.org/x/oauth2 v0.0.0-20190226205417-e64efc72b421
	gopkg.in/alexcesaro/quotedprintable.v3 v3.0.0-20150716171945-2caba252f4dc
	gopkg.in/asn1-ber.v1 v1.0.0-20170511165959-379148ca0225 // indirect
	gopkg.in/cas.v2 v2.1.0
	gopkg.in/ldap.v3 v3.0.3
)
",CWE-79,39.0,0
"package dtls
import (
	""github.com/pion/dtls/v2/pkg/protocol""
	""github.com/pion/dtls/v2/pkg/protocol/handshake""
	""github.com/pion/dtls/v2/pkg/protocol/recordlayer""
)
type fragment struct {
	recordLayerHeader recordlayer.Header
	handshakeHeader   handshake.Header
	data              []byte
}
type fragmentBuffer struct {
	// map of MessageSequenceNumbers that hold slices of fragments
	cache map[uint16][]*fragment
	currentMessageSequenceNumber uint16
}
func newFragmentBuffer() *fragmentBuffer {
	return &fragmentBuffer{cache: map[uint16][]*fragment{}}
}
// Attempts to push a DTLS packet to the fragmentBuffer
// when it returns true it means the fragmentBuffer has inserted and the buffer shouldn't be handled
// when an error returns it is fatal, and the DTLS connection should be stopped
func (f *fragmentBuffer) push(buf []byte) (bool, error) {
	frag := new(fragment)
	if err := frag.recordLayerHeader.Unmarshal(buf); err != nil {
		return false, err
	}
	// fragment isn't a handshake, we don't need to handle it
	if frag.recordLayerHeader.ContentType != protocol.ContentTypeHandshake {
		return false, nil
	}
	for buf = buf[recordlayer.HeaderSize:]; len(buf) != 0; frag = new(fragment) {
		if err := frag.handshakeHeader.Unmarshal(buf); err != nil {
			return false, err
		}
		if _, ok := f.cache[frag.handshakeHeader.MessageSequence]; !ok {
			f.cache[frag.handshakeHeader.MessageSequence] = []*fragment{}
		}
		// end index should be the length of handshake header but if the handshake
		// was fragmented, we should keep them all
		end := int(handshake.HeaderLength + frag.handshakeHeader.Length)
		if size := len(buf); end > size {
			end = size
		}
		// Discard all headers, when rebuilding the packet we will re-build
		frag.data = append([]byte{}, buf[handshake.HeaderLength:end]...)
		f.cache[frag.handshakeHeader.MessageSequence] = append(f.cache[frag.handshakeHeader.MessageSequence], frag)
		buf = buf[end:]
	}
	return true, nil
}
func (f *fragmentBuffer) pop() (content []byte, epoch uint16) {
	frags, ok := f.cache[f.currentMessageSequenceNumber]
	if !ok {
		return nil, 0
	}
	// Go doesn't support recursive lambdas
	var appendMessage func(targetOffset uint32) bool
	rawMessage := []byte{}
	appendMessage = func(targetOffset uint32) bool {
		for _, f := range frags {
			if f.handshakeHeader.FragmentOffset == targetOffset {
				fragmentEnd := (f.handshakeHeader.FragmentOffset + f.handshakeHeader.FragmentLength)
				if fragmentEnd != f.handshakeHeader.Length && f.handshakeHeader.FragmentLength != 0 {
					if !appendMessage(fragmentEnd) {
						return false
					}
				}
				rawMessage = append(f.data, rawMessage...)
				return true
			}
		}
		return false
	}
	// Recursively collect up
	if !appendMessage(0) {
		return nil, 0
	}
	firstHeader := frags[0].handshakeHeader
	firstHeader.FragmentOffset = 0
	firstHeader.FragmentLength = firstHeader.Length
	rawHeader, err := firstHeader.Marshal()
	if err != nil {
		return nil, 0
	}
	messageEpoch := frags[0].recordLayerHeader.Epoch
	delete(f.cache, f.currentMessageSequenceNumber)
	f.currentMessageSequenceNumber++
	return append(rawHeader, rawMessage...), messageEpoch
}
",CWE-835,112.0,0
"package dtls
import (
	""reflect""
	""testing""
)
func TestFragmentBuffer(t *testing.T) {
	for _, test := range []struct {
		Name     string
		In       [][]byte
		Expected [][]byte
		Epoch    uint16
	}{
		{
			Name: ""Single Fragment"",
			In: [][]byte{
				{0x16, 0xfe, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfe, 0xff, 0x00},
			},
			Expected: [][]byte{
				{0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfe, 0xff, 0x00},
			},
			Epoch: 0,
		},
		{
			Name: ""Single Fragment Epoch 3"",
			In: [][]byte{
				{0x16, 0xfe, 0xff, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfe, 0xff, 0x00},
			},
			Expected: [][]byte{
				{0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfe, 0xff, 0x00},
			},
			Epoch: 3,
		},
		{
			Name: ""Multiple Fragments"",
			In: [][]byte{
				{0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x0b, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x01, 0x02, 0x03, 0x04},
				{0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x0b, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x05, 0x05, 0x06, 0x07, 0x08, 0x09},
				{0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x0b, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x05, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E},
			},
			Expected: [][]byte{
				{0x0b, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e},
			},
			Epoch: 0,
		},
		{
			Name: ""Multiple Unordered Fragments"",
			In: [][]byte{
				{0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x0b, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x01, 0x02, 0x03, 0x04},
				{0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x0b, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x05, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E},
				{0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x81, 0x0b, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x05, 0x05, 0x06, 0x07, 0x08, 0x09},
			},
			Expected: [][]byte{
				{0x0b, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e},
			},
			Epoch: 0,
		},
		{
			Name: ""Multiple Handshakes in Signle Fragment"",
			In: [][]byte{
				{
					0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x30, /* record header */
					0x03, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x01, 0x01, /*handshake msg 1*/
					0x03, 0x00, 0x00, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x01, 0x01, /*handshake msg 2*/
					0x03, 0x00, 0x00, 0x04, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x01, 0x01, /*handshake msg 3*/
				},
			},
			Expected: [][]byte{
				{0x03, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x01, 0x01},
				{0x03, 0x00, 0x00, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x01, 0x01},
				{0x03, 0x00, 0x00, 0x04, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x01, 0x01},
			},
			Epoch: 0,
		},
		// Assert that a zero length fragment doesn't cause the fragmentBuffer to enter an infinite loop
		{
			Name: ""Zero Length Fragment"",
			In: [][]byte{
				{
					0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00,
					0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				},
			},
			Expected: [][]byte{
				{0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00},
			},
			Epoch: 0,
		},
	} {
		fragmentBuffer := newFragmentBuffer()
		for _, frag := range test.In {
			status, err := fragmentBuffer.push(frag)
			if err != nil {
				t.Error(err)
			} else if !status {
				t.Errorf(""fragmentBuffer didn't accept fragments for '%s'"", test.Name)
			}
		}
		for _, expected := range test.Expected {
			out, epoch := fragmentBuffer.pop()
			if !reflect.DeepEqual(out, expected) {
				t.Errorf(""fragmentBuffer '%s' push/pop: got % 02x, want % 02x"", test.Name, out, expected)
			}
			if epoch != test.Epoch {
				t.Errorf(""fragmentBuffer returned wrong epoch: got %d, want %d"", epoch, test.Epoch)
			}
		}
		if frag, _ := fragmentBuffer.pop(); frag != nil {
			t.Errorf(""fragmentBuffer popped single buffer multiple times for '%s'"", test.Name)
		}
	}
}
",CWE-835,116.0,0
"package dtls
import (
	""context""
	""errors""
	""fmt""
	""io""
	""net""
	""os""
	""github.com/pion/dtls/v2/pkg/protocol""
	""github.com/pion/dtls/v2/pkg/protocol/alert""
)
// Typed errors
var (
	ErrConnClosed = &FatalError{Err: errors.New(""conn is closed"")} //nolint:goerr113
	errDeadlineExceeded   = &TimeoutError{Err: fmt.Errorf(""read/write timeout: %w"", context.DeadlineExceeded)}
	errInvalidContentType = &TemporaryError{Err: errors.New(""invalid content type"")} //nolint:goerr113
	errBufferTooSmall               = &TemporaryError{Err: errors.New(""buffer is too small"")}                                        //nolint:goerr113
	errContextUnsupported           = &TemporaryError{Err: errors.New(""context is not supported for ExportKeyingMaterial"")}          //nolint:goerr113
	errHandshakeInProgress          = &TemporaryError{Err: errors.New(""handshake is in progress"")}                                   //nolint:goerr113
	errReservedExportKeyingMaterial = &TemporaryError{Err: errors.New(""ExportKeyingMaterial can not be used with a reserved label"")} //nolint:goerr113
	errApplicationDataEpochZero     = &TemporaryError{Err: errors.New(""ApplicationData with epoch of 0"")}                            //nolint:goerr113
	errUnhandledContextType         = &TemporaryError{Err: errors.New(""unhandled contentType"")}                                      //nolint:goerr113
	errCertificateVerifyNoCertificate    = &FatalError{Err: errors.New(""client sent certificate verify but we have no certificate to verify"")}                      //nolint:goerr113
	errCipherSuiteNoIntersection         = &FatalError{Err: errors.New(""client+server do not support any shared cipher suites"")}                                    //nolint:goerr113
	errClientCertificateNotVerified      = &FatalError{Err: errors.New(""client sent certificate but did not verify it"")}                                            //nolint:goerr113
	errClientCertificateRequired         = &FatalError{Err: errors.New(""server required client verification, but got none"")}                                        //nolint:goerr113
	errClientNoMatchingSRTPProfile       = &FatalError{Err: errors.New(""server responded with SRTP Profile we do not support"")}                                     //nolint:goerr113
	errClientRequiredButNoServerEMS      = &FatalError{Err: errors.New(""client required Extended Master Secret extension, but server does not support it"")}         //nolint:goerr113
	errCookieMismatch                    = &FatalError{Err: errors.New(""client+server cookie does not match"")}                                                      //nolint:goerr113
	errIdentityNoPSK                     = &FatalError{Err: errors.New(""PSK Identity Hint provided but PSK is nil"")}                                                //nolint:goerr113
	errInvalidCertificate                = &FatalError{Err: errors.New(""no certificate provided"")}                                                                  //nolint:goerr113
	errInvalidCipherSuite                = &FatalError{Err: errors.New(""invalid or unknown cipher suite"")}                                                          //nolint:goerr113
	errInvalidECDSASignature             = &FatalError{Err: errors.New(""ECDSA signature contained zero or negative values"")}                                        //nolint:goerr113
	errInvalidPrivateKey                 = &FatalError{Err: errors.New(""invalid private key type"")}                                                                 //nolint:goerr113
	errInvalidSignatureAlgorithm         = &FatalError{Err: errors.New(""invalid signature algorithm"")}                                                              //nolint:goerr113
	errKeySignatureMismatch              = &FatalError{Err: errors.New(""expected and actual key signature do not match"")}                                           //nolint:goerr113
	errNilNextConn                       = &FatalError{Err: errors.New(""Conn can not be created with a nil nextConn"")}                                              //nolint:goerr113
	errNoAvailableCipherSuites           = &FatalError{Err: errors.New(""connection can not be created, no CipherSuites satisfy this Config"")}                       //nolint:goerr113
	errNoAvailablePSKCipherSuite         = &FatalError{Err: errors.New(""connection can not be created, pre-shared key present but no compatible CipherSuite"")}      //nolint:goerr113
	errNoAvailableCertificateCipherSuite = &FatalError{Err: errors.New(""connection can not be created, certificate present but no compatible CipherSuite"")}         //nolint:goerr113
	errNoAvailableSignatureSchemes       = &FatalError{Err: errors.New(""connection can not be created, no SignatureScheme satisfy this Config"")}                    //nolint:goerr113
	errNoCertificates                    = &FatalError{Err: errors.New(""no certificates configured"")}                                                               //nolint:goerr113
	errNoConfigProvided                  = &FatalError{Err: errors.New(""no config provided"")}                                                                       //nolint:goerr113
	errNoSupportedEllipticCurves         = &FatalError{Err: errors.New(""client requested zero or more elliptic curves that are not supported by the server"")}       //nolint:goerr113
	errUnsupportedProtocolVersion        = &FatalError{Err: errors.New(""unsupported protocol version"")}                                                             //nolint:goerr113
	errPSKAndIdentityMustBeSetForClient  = &FatalError{Err: errors.New(""PSK and PSK Identity Hint must both be set for client"")}                                    //nolint:goerr113
	errRequestedButNoSRTPExtension       = &FatalError{Err: errors.New(""SRTP support was requested but server did not respond with use_srtp extension"")}            //nolint:goerr113
	errServerNoMatchingSRTPProfile       = &FatalError{Err: errors.New(""client requested SRTP but we have no matching profiles"")}                                   //nolint:goerr113
	errServerRequiredButNoClientEMS      = &FatalError{Err: errors.New(""server requires the Extended Master Secret extension, but the client does not support it"")} //nolint:goerr113
	errVerifyDataMismatch                = &FatalError{Err: errors.New(""expected and actual verify data does not match"")}                                           //nolint:goerr113
	errInvalidFlight                     = &InternalError{Err: errors.New(""invalid flight number"")}                           //nolint:goerr113
	errKeySignatureGenerateUnimplemented = &InternalError{Err: errors.New(""unable to generate key signature, unimplemented"")} //nolint:goerr113
	errKeySignatureVerifyUnimplemented   = &InternalError{Err: errors.New(""unable to verify key signature, unimplemented"")}   //nolint:goerr113
	errLengthMismatch                    = &InternalError{Err: errors.New(""data length and declared length do not match"")}    //nolint:goerr113
	errSequenceNumberOverflow            = &InternalError{Err: errors.New(""sequence number overflow"")}                        //nolint:goerr113
	errInvalidFSMTransition              = &InternalError{Err: errors.New(""invalid state machine transition"")}                //nolint:goerr113
	errFailedToAccessPoolReadBuffer      = &InternalError{Err: errors.New(""failed to access pool read buffer"")}               //nolint:goerr113
	errFragmentBufferOverflow            = &InternalError{Err: errors.New(""fragment buffer overflow"")}                        //nolint:goerr113
)
// FatalError indicates that the DTLS connection is no longer available.
// It is mainly caused by wrong configuration of server or client.
type FatalError = protocol.FatalError
// InternalError indicates and internal error caused by the implementation, and the DTLS connection is no longer available.
// It is mainly caused by bugs or tried to use unimplemented features.
type InternalError = protocol.InternalError
// TemporaryError indicates that the DTLS connection is still available, but the request was failed temporary.
type TemporaryError = protocol.TemporaryError
// TimeoutError indicates that the request was timed out.
type TimeoutError = protocol.TimeoutError
// HandshakeError indicates that the handshake failed.
type HandshakeError = protocol.HandshakeError
// errInvalidCipherSuite indicates an attempt at using an unsupported cipher suite.
type invalidCipherSuiteError struct {
	id CipherSuiteID
}
func (e *invalidCipherSuiteError) Error() string {
	return fmt.Sprintf(""CipherSuite with id(%d) is not valid"", e.id)
}
func (e *invalidCipherSuiteError) Is(err error) bool {
	var other *invalidCipherSuiteError
	if errors.As(err, &other) {
		return e.id == other.id
	}
	return false
}
// errAlert wraps DTLS alert notification as an error
type alertError struct {
	*alert.Alert
}
func (e *alertError) Error() string {
	return fmt.Sprintf(""alert: %s"", e.Alert.String())
}
func (e *alertError) IsFatalOrCloseNotify() bool {
	return e.Level == alert.Fatal || e.Description == alert.CloseNotify
}
func (e *alertError) Is(err error) bool {
	var other *alertError
	if errors.As(err, &other) {
		return e.Level == other.Level && e.Description == other.Description
	}
	return false
}
// netError translates an error from underlying Conn to corresponding net.Error.
func netError(err error) error {
	switch {
	case errors.Is(err, io.EOF), errors.Is(err, context.Canceled), errors.Is(err, context.DeadlineExceeded):
		// Return io.EOF and context errors as is.
		return err
	}
	var (
		ne      net.Error
		opError *net.OpError
		se      *os.SyscallError
	)
	if errors.As(err, &opError) {
		if errors.As(opError, &se) {
			if se.Timeout() {
				return &TimeoutError{Err: err}
			}
			if isOpErrorTemporary(se) {
				return &TemporaryError{Err: err}
			}
		}
	}
	if errors.As(err, &ne) {
		return err
	}
	return &FatalError{Err: err}
}
",CWE-120,154.0,0
"package dtls
import (
	""github.com/pion/dtls/v2/pkg/protocol""
	""github.com/pion/dtls/v2/pkg/protocol/handshake""
	""github.com/pion/dtls/v2/pkg/protocol/recordlayer""
)
// 2 megabytes
const fragmentBufferMaxSize = 2000000
type fragment struct {
	recordLayerHeader recordlayer.Header
	handshakeHeader   handshake.Header
	data              []byte
}
type fragmentBuffer struct {
	// map of MessageSequenceNumbers that hold slices of fragments
	cache map[uint16][]*fragment
	currentMessageSequenceNumber uint16
}
func newFragmentBuffer() *fragmentBuffer {
	return &fragmentBuffer{cache: map[uint16][]*fragment{}}
}
// current total size of buffer
func (f *fragmentBuffer) size() int {
	size := 0
	for i := range f.cache {
		for j := range f.cache[i] {
			size += len(f.cache[i][j].data)
		}
	}
	return size
}
// Attempts to push a DTLS packet to the fragmentBuffer
// when it returns true it means the fragmentBuffer has inserted and the buffer shouldn't be handled
// when an error returns it is fatal, and the DTLS connection should be stopped
func (f *fragmentBuffer) push(buf []byte) (bool, error) {
	if f.size()+len(buf) >= fragmentBufferMaxSize {
		return false, errFragmentBufferOverflow
	}
	frag := new(fragment)
	if err := frag.recordLayerHeader.Unmarshal(buf); err != nil {
		return false, err
	}
	// fragment isn't a handshake, we don't need to handle it
	if frag.recordLayerHeader.ContentType != protocol.ContentTypeHandshake {
		return false, nil
	}
	for buf = buf[recordlayer.HeaderSize:]; len(buf) != 0; frag = new(fragment) {
		if err := frag.handshakeHeader.Unmarshal(buf); err != nil {
			return false, err
		}
		if _, ok := f.cache[frag.handshakeHeader.MessageSequence]; !ok {
			f.cache[frag.handshakeHeader.MessageSequence] = []*fragment{}
		}
		// end index should be the length of handshake header but if the handshake
		// was fragmented, we should keep them all
		end := int(handshake.HeaderLength + frag.handshakeHeader.Length)
		if size := len(buf); end > size {
			end = size
		}
		// Discard all headers, when rebuilding the packet we will re-build
		frag.data = append([]byte{}, buf[handshake.HeaderLength:end]...)
		f.cache[frag.handshakeHeader.MessageSequence] = append(f.cache[frag.handshakeHeader.MessageSequence], frag)
		buf = buf[end:]
	}
	return true, nil
}
func (f *fragmentBuffer) pop() (content []byte, epoch uint16) {
	frags, ok := f.cache[f.currentMessageSequenceNumber]
	if !ok {
		return nil, 0
	}
	// Go doesn't support recursive lambdas
	var appendMessage func(targetOffset uint32) bool
	rawMessage := []byte{}
	appendMessage = func(targetOffset uint32) bool {
		for _, f := range frags {
			if f.handshakeHeader.FragmentOffset == targetOffset {
				fragmentEnd := (f.handshakeHeader.FragmentOffset + f.handshakeHeader.FragmentLength)
				if fragmentEnd != f.handshakeHeader.Length && f.handshakeHeader.FragmentLength != 0 {
					if !appendMessage(fragmentEnd) {
						return false
					}
				}
				rawMessage = append(f.data, rawMessage...)
				return true
			}
		}
		return false
	}
	// Recursively collect up
	if !appendMessage(0) {
		return nil, 0
	}
	firstHeader := frags[0].handshakeHeader
	firstHeader.FragmentOffset = 0
	firstHeader.FragmentLength = firstHeader.Length
	rawHeader, err := firstHeader.Marshal()
	if err != nil {
		return nil, 0
	}
	messageEpoch := frags[0].recordLayerHeader.Epoch
	delete(f.cache, f.currentMessageSequenceNumber)
	f.currentMessageSequenceNumber++
	return append(rawHeader, rawMessage...), messageEpoch
}
",CWE-120,130.0,0
"package dtls
import (
	""errors""
	""reflect""
	""testing""
)
func TestFragmentBuffer(t *testing.T) {
	for _, test := range []struct {
		Name     string
		In       [][]byte
		Expected [][]byte
		Epoch    uint16
	}{
		{
			Name: ""Single Fragment"",
			In: [][]byte{
				{0x16, 0xfe, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfe, 0xff, 0x00},
			},
			Expected: [][]byte{
				{0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfe, 0xff, 0x00},
			},
			Epoch: 0,
		},
		{
			Name: ""Single Fragment Epoch 3"",
			In: [][]byte{
				{0x16, 0xfe, 0xff, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfe, 0xff, 0x00},
			},
			Expected: [][]byte{
				{0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfe, 0xff, 0x00},
			},
			Epoch: 3,
		},
		{
			Name: ""Multiple Fragments"",
			In: [][]byte{
				{0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x0b, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x01, 0x02, 0x03, 0x04},
				{0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x0b, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x05, 0x05, 0x06, 0x07, 0x08, 0x09},
				{0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x0b, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x05, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E},
			},
			Expected: [][]byte{
				{0x0b, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e},
			},
			Epoch: 0,
		},
		{
			Name: ""Multiple Unordered Fragments"",
			In: [][]byte{
				{0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x0b, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x01, 0x02, 0x03, 0x04},
				{0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x0b, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x05, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E},
				{0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x81, 0x0b, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x05, 0x05, 0x06, 0x07, 0x08, 0x09},
			},
			Expected: [][]byte{
				{0x0b, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e},
			},
			Epoch: 0,
		},
		{
			Name: ""Multiple Handshakes in Single Fragment"",
			In: [][]byte{
				{
					0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x30, /* record header */
					0x03, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x01, 0x01, /*handshake msg 1*/
					0x03, 0x00, 0x00, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x01, 0x01, /*handshake msg 2*/
					0x03, 0x00, 0x00, 0x04, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x01, 0x01, /*handshake msg 3*/
				},
			},
			Expected: [][]byte{
				{0x03, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x01, 0x01},
				{0x03, 0x00, 0x00, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x01, 0x01},
				{0x03, 0x00, 0x00, 0x04, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0xff, 0x01, 0x01},
			},
			Epoch: 0,
		},
		// Assert that a zero length fragment doesn't cause the fragmentBuffer to enter an infinite loop
		{
			Name: ""Zero Length Fragment"",
			In: [][]byte{
				{
					0x16, 0xfe, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00,
					0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				},
			},
			Expected: [][]byte{
				{0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00},
			},
			Epoch: 0,
		},
	} {
		fragmentBuffer := newFragmentBuffer()
		for _, frag := range test.In {
			status, err := fragmentBuffer.push(frag)
			if err != nil {
				t.Error(err)
			} else if !status {
				t.Errorf(""fragmentBuffer didn't accept fragments for '%s'"", test.Name)
			}
		}
		for _, expected := range test.Expected {
			out, epoch := fragmentBuffer.pop()
			if !reflect.DeepEqual(out, expected) {
				t.Errorf(""fragmentBuffer '%s' push/pop: got % 02x, want % 02x"", test.Name, out, expected)
			}
			if epoch != test.Epoch {
				t.Errorf(""fragmentBuffer returned wrong epoch: got %d, want %d"", epoch, test.Epoch)
			}
		}
		if frag, _ := fragmentBuffer.pop(); frag != nil {
			t.Errorf(""fragmentBuffer popped single buffer multiple times for '%s'"", test.Name)
		}
	}
}
func TestFragmentBuffer_Overflow(t *testing.T) {
	fragmentBuffer := newFragmentBuffer()
	// Push a buffer that doesn't exceed size limits
	if _, err := fragmentBuffer.push([]byte{0x16, 0xfe, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfe, 0xff, 0x00}); err != nil {
		t.Fatal(err)
	}
	// Allocate a buffer that exceeds cache size
	largeBuffer := make([]byte, fragmentBufferMaxSize)
	if _, err := fragmentBuffer.push(largeBuffer); !errors.Is(err, errFragmentBufferOverflow) {
		t.Fatalf(""Pushing a large buffer returned (%s) expected(%s)"", err, errFragmentBufferOverflow)
	}
}
",CWE-120,132.0,0
"package dtls
import (
	""context""
	""testing""
	""time""
	""github.com/pion/dtls/v2/internal/ciphersuite""
	""github.com/pion/dtls/v2/pkg/protocol/alert""
	""github.com/pion/dtls/v2/pkg/protocol/handshake""
	""github.com/pion/transport/test""
)
type flight4TestMockFlightConn struct{}
func (f *flight4TestMockFlightConn) notify(ctx context.Context, level alert.Level, desc alert.Description) error {
	return nil
}
func (f *flight4TestMockFlightConn) writePackets(context.Context, []*packet) error { return nil }
func (f *flight4TestMockFlightConn) recvHandshake() <-chan chan struct{}           { return nil }
func (f *flight4TestMockFlightConn) setLocalEpoch(epoch uint16)                    {}
func (f *flight4TestMockFlightConn) handleQueuedPackets(context.Context) error     { return nil }
func (f *flight4TestMockFlightConn) sessionKey() []byte                            { return nil }
type flight4TestMockCipherSuite struct {
	ciphersuite.TLSEcdheEcdsaWithAes128GcmSha256
	t *testing.T
}
func (f *flight4TestMockCipherSuite) IsInitialized() bool {
	f.t.Fatal(""IsInitialized called with Certificate but not CertificateVerify"")
	return true
}
// Assert that if a Client sends a certificate they
// must also send a CertificateVerify message.
// The flight4handler must not interact with the CipherSuite
// if the CertificateVerify is missing
func TestFlight4_Process_CertificateVerify(t *testing.T) {
	// Limit runtime in case of deadlocks
	lim := test.TimeOut(5 * time.Second)
	defer lim.Stop()
	// Check for leaking routines
	report := test.CheckRoutines(t)
	defer report()
	mockConn := &flight4TestMockFlightConn{}
	state := &State{
		cipherSuite: &flight4TestMockCipherSuite{t: t},
	}
	cache := newHandshakeCache()
	cfg := &handshakeConfig{}
	rawCertificate := []byte{
		0x0b, 0x00, 0x01, 0x9b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x01, 0x9b, 0x00, 0x01, 0x98, 0x00, 0x01, 0x95, 0x30, 0x82,
		0x01, 0x91, 0x30, 0x82, 0x01, 0x38, 0xa0, 0x03, 0x02, 0x01,
		0x02, 0x02, 0x11, 0x01, 0x65, 0x03, 0x3f, 0x4d, 0x0b, 0x9a,
		0x62, 0x91, 0xdb, 0x4d, 0x28, 0x2c, 0x1f, 0xd6, 0x73, 0x32,
		0x30, 0x0a, 0x06, 0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x04,
		0x03, 0x02, 0x30, 0x00, 0x30, 0x1e, 0x17, 0x0d, 0x32, 0x32,
		0x30, 0x35, 0x31, 0x35, 0x31, 0x38, 0x34, 0x33, 0x35, 0x35,
		0x5a, 0x17, 0x0d, 0x32, 0x32, 0x30, 0x36, 0x31, 0x35, 0x31,
		0x38, 0x34, 0x33, 0x35, 0x35, 0x5a, 0x30, 0x00, 0x30, 0x59,
		0x30, 0x13, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02,
		0x01, 0x06, 0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x03, 0x01,
		0x07, 0x03, 0x42, 0x00, 0x04, 0xc3, 0xb7, 0x13, 0x1a, 0x0a,
		0xfc, 0xd0, 0x82, 0xf8, 0x94, 0x5e, 0xc0, 0x77, 0x07, 0x81,
		0x28, 0xc9, 0xcb, 0x08, 0x84, 0x50, 0x6b, 0xf0, 0x22, 0xe8,
		0x79, 0xb9, 0x15, 0x33, 0xc4, 0x56, 0xa1, 0xd3, 0x1b, 0x24,
		0xe3, 0x61, 0xbd, 0x4d, 0x65, 0x80, 0x6b, 0x5d, 0x96, 0x48,
		0xa2, 0x44, 0x9e, 0xce, 0xe8, 0x65, 0xd6, 0x3c, 0xe0, 0x9b,
		0x6b, 0xa1, 0x36, 0x34, 0xb2, 0x39, 0xe2, 0x03, 0x00, 0xa3,
		0x81, 0x92, 0x30, 0x81, 0x8f, 0x30, 0x0e, 0x06, 0x03, 0x55,
		0x1d, 0x0f, 0x01, 0x01, 0xff, 0x04, 0x04, 0x03, 0x02, 0x02,
		0xa4, 0x30, 0x1d, 0x06, 0x03, 0x55, 0x1d, 0x25, 0x04, 0x16,
		0x30, 0x14, 0x06, 0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07,
		0x03, 0x02, 0x06, 0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07,
		0x03, 0x01, 0x30, 0x0f, 0x06, 0x03, 0x55, 0x1d, 0x13, 0x01,
		0x01, 0xff, 0x04, 0x05, 0x30, 0x03, 0x01, 0x01, 0xff, 0x30,
		0x1d, 0x06, 0x03, 0x55, 0x1d, 0x0e, 0x04, 0x16, 0x04, 0x14,
		0xb1, 0x1a, 0xe3, 0xeb, 0x6f, 0x7c, 0xc3, 0x8f, 0xba, 0x6f,
		0x1c, 0xe8, 0xf0, 0x23, 0x08, 0x50, 0x8d, 0x3c, 0xea, 0x31,
		0x30, 0x2e, 0x06, 0x03, 0x55, 0x1d, 0x11, 0x01, 0x01, 0xff,
		0x04, 0x24, 0x30, 0x22, 0x82, 0x20, 0x30, 0x30, 0x30, 0x30,
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x0a,
		0x06, 0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x04, 0x03, 0x02,
		0x03, 0x47, 0x00, 0x30, 0x44, 0x02, 0x20, 0x06, 0x31, 0x43,
		0xac, 0x03, 0x45, 0x79, 0x3c, 0xd7, 0x5f, 0x6e, 0x6a, 0xf8,
		0x0e, 0xfd, 0x35, 0x49, 0xee, 0x1b, 0xbc, 0x47, 0xce, 0xe3,
		0x39, 0xec, 0xe4, 0x62, 0xe1, 0x30, 0x1a, 0xa1, 0x89, 0x02,
		0x20, 0x35, 0xcd, 0x7a, 0x15, 0x68, 0x09, 0x50, 0x49, 0x9e,
		0x3e, 0x05, 0xd7, 0xc2, 0x69, 0x3f, 0x9c, 0x0c, 0x98, 0x92,
		0x65, 0xec, 0xae, 0x44, 0xfe, 0xe5, 0x68, 0xb8, 0x09, 0x78,
		0x7f, 0x6b, 0x77,
	}
	rawClientKeyExchange := []byte{
		0x10, 0x00, 0x00, 0x21, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x21, 0x20, 0x96, 0xed, 0x0c, 0xee, 0xf3, 0x11, 0xb1,
		0x9d, 0x8b, 0x1c, 0x02, 0x7f, 0x06, 0x7c, 0x57, 0x7a, 0x14,
		0xa6, 0x41, 0xde, 0x63, 0x57, 0x9e, 0xcd, 0x34, 0x54, 0xba,
		0x37, 0x4d, 0x34, 0x15, 0x18,
	}
	cache.push(rawCertificate, 0, 0, handshake.TypeCertificate, true)
	cache.push(rawClientKeyExchange, 0, 1, handshake.TypeClientKeyExchange, true)
	if _, _, err := flight4Parse(context.TODO(), mockConn, state, cache, cfg); err != nil {
		t.Fatal(err)
	}
}
",CWE-295,117.0,0
"package consensus
import (
	""testing""
	""github.com/tendermint/tendermint/libs/bytes""
	""github.com/tendermint/tendermint/libs/log""
	tmrand ""github.com/tendermint/tendermint/libs/rand""
	""github.com/tendermint/tendermint/p2p""
	tmproto ""github.com/tendermint/tendermint/proto/tendermint/types""
	""github.com/tendermint/tendermint/types""
)
//----------------------------------------------
// byzantine failures
// one byz val sends a precommit for a random block at each height
// Ensure a testnet makes blocks
func TestReactorInvalidPrecommit(t *testing.T) {
	N := 4
	css, cleanup := randConsensusNet(N, ""consensus_reactor_test"", newMockTickerFunc(true), newCounter)
	defer cleanup()
	for i := 0; i < 4; i++ {
		ticker := NewTimeoutTicker()
		ticker.SetLogger(css[i].Logger)
		css[i].SetTimeoutTicker(ticker)
	}
	reactors, blocksSubs, eventBuses := startConsensusNet(t, css, N)
	// this val sends a random precommit at each height
	byzValIdx := 0
	byzVal := css[byzValIdx]
	byzR := reactors[byzValIdx]
	// update the doPrevote function to just send a valid precommit for a random block
	// and otherwise disable the priv validator
	byzVal.mtx.Lock()
	pv := byzVal.privValidator
	byzVal.doPrevote = func(height int64, round int32) {
		invalidDoPrevoteFunc(t, height, round, byzVal, byzR.Switch, pv)
	}
	byzVal.mtx.Unlock()
	defer stopConsensusNet(log.TestingLogger(), reactors, eventBuses)
	// wait for a bunch of blocks
	// TODO: make this tighter by ensuring the halt happens by block 2
	for i := 0; i < 10; i++ {
		timeoutWaitGroup(t, N, func(j int) {
			<-blocksSubs[j].Out()
		}, css)
	}
}
func invalidDoPrevoteFunc(t *testing.T, height int64, round int32, cs *State, sw *p2p.Switch, pv types.PrivValidator) {
	// routine to:
	// - precommit for a random block
	// - send precommit to all peers
	// - disable privValidator (so we don't do normal precommits)
	go func() {
		cs.mtx.Lock()
		cs.privValidator = pv
		pubKey, err := cs.privValidator.GetPubKey()
		if err != nil {
			panic(err)
		}
		addr := pubKey.Address()
		valIndex, _ := cs.Validators.GetByAddress(addr)
		// precommit a random block
		blockHash := bytes.HexBytes(tmrand.Bytes(32))
		precommit := &types.Vote{
			ValidatorAddress: addr,
			ValidatorIndex:   valIndex,
			Height:           cs.Height,
			Round:            cs.Round,
			Timestamp:        cs.voteTime(),
			Type:             tmproto.PrecommitType,
			BlockID: types.BlockID{
				Hash:          blockHash,
				PartSetHeader: types.PartSetHeader{Total: 1, Hash: tmrand.Bytes(32)}},
		}
		p := precommit.ToProto()
		cs.privValidator.SignVote(cs.state.ChainID, p)
		precommit.Signature = p.Signature
		cs.privValidator = nil // disable priv val so we don't do normal votes
		cs.mtx.Unlock()
		peers := sw.Peers().List()
		for _, peer := range peers {
			cs.Logger.Info(""Sending bad vote"", ""block"", blockHash, ""peer"", peer)
			peer.Send(VoteChannel, MustEncode(&VoteMessage{precommit}))
		}
	}()
}
",CWE-347,98.0,0
"package state
import (
	""github.com/tendermint/tendermint/types""
)
//------------------------------------------------------
// blockchain services types
// NOTE: Interfaces used by RPC must be thread safe!
//------------------------------------------------------
//------------------------------------------------------
// blockstore
// BlockStore defines the interface used by the ConsensusState.
type BlockStore interface {
	Base() int64
	Height() int64
	Size() int64
	LoadBaseMeta() *types.BlockMeta
	LoadBlockMeta(height int64) *types.BlockMeta
	LoadBlock(height int64) *types.Block
	SaveBlock(block *types.Block, blockParts *types.PartSet, seenCommit *types.Commit)
	PruneBlocks(height int64) (uint64, error)
	LoadBlockByHash(hash []byte) *types.Block
	LoadBlockPart(height int64, index int) *types.Part
	LoadBlockCommit(height int64) *types.Commit
	LoadSeenCommit(height int64) *types.Commit
}
//-----------------------------------------------------------------------------
// evidence pool
//go:generate mockery --case underscore --name EvidencePool
// EvidencePool defines the EvidencePool interface used by State.
type EvidencePool interface {
	PendingEvidence(maxBytes int64) (ev []types.Evidence, size int64)
	AddEvidence(types.Evidence) error
	Update(State, types.EvidenceList)
	CheckEvidence(types.EvidenceList) error
}
// EmptyEvidencePool is an empty implementation of EvidencePool, useful for testing. It also complies
// to the consensus evidence pool interface
type EmptyEvidencePool struct{}
func (EmptyEvidencePool) PendingEvidence(maxBytes int64) (ev []types.Evidence, size int64) {
	return nil, 0
}
func (EmptyEvidencePool) AddEvidence(types.Evidence) error                { return nil }
func (EmptyEvidencePool) Update(State, types.EvidenceList)                {}
func (EmptyEvidencePool) CheckEvidence(evList types.EvidenceList) error   { return nil }
func (EmptyEvidencePool) ReportConflictingVotes(voteA, voteB *types.Vote) {}
",CWE-400,60.0,0
"module github.com/ory/hydra
require (
	github.com/dgrijalva/jwt-go v3.2.0+incompatible
	github.com/go-sql-driver/mysql v1.4.0
	github.com/gobuffalo/packd v0.0.0-20181029140631-cf76bd87a5a6 // indirect
	github.com/gobwas/glob v0.2.3
	github.com/golang/mock v1.1.1
	github.com/gorilla/context v1.1.1
	github.com/gorilla/securecookie v0.0.0-20160422134519-667fe4e3466a
	github.com/gorilla/sessions v0.0.0-20160922145804-ca9ada445741
	github.com/gtank/cryptopasta v0.0.0-20170601214702-1f550f6f2f69
	github.com/imdario/mergo v0.0.0-20171009183408-7fe0c75c13ab
	github.com/jmoiron/sqlx v0.0.0-20180614180643-0dae4fefe7c0
	github.com/julienschmidt/httprouter v0.0.0-20180715161854-348b672cd90d
	github.com/lib/pq v1.0.0
	github.com/meatballhat/negroni-logrus v0.0.0-20170801195057-31067281800f
	github.com/mendsley/gojwk v0.0.0-20141217222730-4d5ec6e58103
	github.com/mohae/deepcopy v0.0.0-20170929034955-c48cc78d4826
	github.com/oleiade/reflections v1.0.0
	github.com/opentracing/opentracing-go v1.0.2
	github.com/ory/dockertest v3.3.2+incompatible
	github.com/ory/fosite v0.28.0
	github.com/ory/go-convenience v0.1.0
	github.com/ory/graceful v0.1.0
	github.com/ory/herodot v0.4.1
	github.com/ory/sqlcon v0.0.7
	github.com/ory/x v0.0.32
	github.com/pborman/uuid v1.2.0
	github.com/phayes/freeport v0.0.0-20171002181615-b8543db493a5
	github.com/pkg/errors v0.8.0
	github.com/prometheus/client_golang v0.8.0
	github.com/rs/cors v1.6.0
	github.com/rubenv/sql-migrate v0.0.0-20180704111356-ba2c6a7295c59448dbc195cef2f41df5163b3892
	github.com/sirupsen/logrus v1.1.1
	github.com/spf13/cobra v0.0.3
	github.com/spf13/viper v1.2.1
	github.com/stretchr/testify v1.2.2
	github.com/toqueteos/webbrowser v0.0.0-20150720201625-21fc9f95c834
	github.com/uber-go/atomic v1.3.2 // indirect
	github.com/uber/jaeger-client-go v2.15.0+incompatible
	github.com/urfave/negroni v1.0.0
	github.com/ziutek/mymysql v1.5.4 // indirect
	go.uber.org/atomic v1.3.2 // indirect
	golang.org/x/crypto v0.0.0-20181203042331-505ab145d0a9
	golang.org/x/net v0.0.0-20181029044818-c44066c5c816 // indirect
	golang.org/x/oauth2 v0.0.0-20181003184128-c57b0facaced
	gopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127 // indirect
	gopkg.in/resty.v1 v1.9.1
	gopkg.in/square/go-jose.v2 v2.1.9
	gopkg.in/yaml.v1 v1.0.0-20140924161607-9f9df34309c0
)
",CWE-79,53.0,0
"/*
 * Copyright © 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @author		Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @copyright 	2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @license 	Apache-2.0
 */
package oauth2
import (
	""html/template""
	""net/http""
	""github.com/julienschmidt/httprouter""
)
func (h *Handler) DefaultConsentHandler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
	h.L.Warnln(""It looks like no consent/login URL was set. All OAuth2 flows except client credentials will fail."")
	h.L.Warnln(""A client requested the default login & consent URL, environment variable OAUTH2_CONSENT_URL or OAUTH2_LOGIN_URL or both are probably not set."")
	t, err := template.New(""consent"").Parse(`
<html>
<head>
	<title>Misconfigured consent/login URL</title>
</head>
<body>
<p>
	It looks like you forgot to set the consent/login provider url, which can be set using the <code>OAUTH2_CONSENT_URL</code> and <code>OAUTH2_LOGIN_URL</code>
	environment variable.
</p>
<p>
	If you are an administrator, please read <a href=""https://www.ory.sh/docs"">
	the guide</a> to understand what you need to do. If you are a user, please contact the administrator.
</p>
</body>
</html>
`)
	if err != nil {
		h.H.WriteError(w, r, err)
		return
	}
	if err := t.Execute(w, nil); err != nil {
		h.H.WriteError(w, r, err)
		return
	}
}
func (h *Handler) DefaultErrorHandler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
	h.L.Warnln(""A client requested the default error URL, environment variable OAUTH2_ERROR_URL is probably not set."")
	t, err := template.New(""consent"").Parse(`
<html>
<head>
	<title>An OAuth 2.0 Error Occurred</title>
</head>
<body>
<h1>
	The OAuth2 request resulted in an error.
</h1>
<ul>
	<li>Error: {{ .Name }}</li>
	<li>Description: {{ .Description }}</li>
	<li>Hint: {{ .Hint }}</li>
	<li>Debug: {{ .Debug }}</li>
</ul>
<p>
	You are seeing this default error page because the administrator has not set a dedicated error URL (environment variable <code>OAUTH2_ERROR_URL</code> is not set). 
	If you are an administrator, please read <a href=""https://www.ory.sh/docs"">the guide</a> to understand what you
	need to do. If you are a user, please contact the administrator.
</p>
</body>
</html>
`)
	if err != nil {
		h.H.WriteError(w, r, err)
		return
	}
	if err := t.Execute(w, struct {
		Name        string
		Description string
		Hint        string
		Debug       string
	}{
		Name:        r.URL.Query().Get(""error""),
		Description: r.URL.Query().Get(""error_description""),
		Hint:        r.URL.Query().Get(""error_hint""),
		Debug:       r.URL.Query().Get(""error_debug""),
	}); err != nil {
		h.H.WriteError(w, r, err)
		return
	}
}
func (h *Handler) DefaultLogoutHandler(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
	h.L.Warnln(""A client requested the default logout URL, environment variable OAUTH2_LOGOUT_REDIRECT_URL is probably not set."")
	t, err := template.New(""consent"").Parse(`
<html>
<head>
	<title>You logged out successfully</title>
</head>
<body>
<h1>
	You logged out successfully!
</h1>
<p>
	You are seeing this default page because the administrator did not specify a redirect URL (environment variable <code>OAUTH2_LOGOUT_REDIRECT_URL</code> is not set). 
	If you are an administrator, please read <a href=""https://www.ory.sh/docs"">the guide</a> to understand what you
	need to do. If you are a user, please contact the administrator.
</p>
</body>
</html>
`)
	if err != nil {
		h.H.WriteError(w, r, err)
		return
	}
	if err := t.Execute(w, nil); err != nil {
		h.H.WriteError(w, r, err)
		return
	}
}
",CWE-79,138.0,0
"/*
 * Copyright © 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @author		Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @copyright 	2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @license 	Apache-2.0
 */
package client
import (
	""context""
	""github.com/ory/fosite""
)
var _, _ Manager = new(SQLManager), new(MemoryManager)
type Manager interface {
	Storage
	Authenticate(ctx context.Context, id string, secret []byte) (*Client, error)
}
type Storage interface {
	GetClient(ctx context.Context, id string) (fosite.Client, error)
	CreateClient(ctx context.Context, c *Client) error
	UpdateClient(ctx context.Context, c *Client) error
	DeleteClient(ctx context.Context, id string) error
	GetClients(ctx context.Context, limit, offset int) ([]Client, error)
	CountClients(ctx context.Context) (int, error)
	GetConcreteClient(ctx context.Context, id string) (*Client, error)
}
",CWE-294,52.0,0
"package configuration
import (
	""fmt""
	""io/ioutil""
	""net/http""
	""os""
	""strings""
	""testing""
	""github.com/rs/cors""
	""github.com/sirupsen/logrus""
	""github.com/stretchr/testify/assert""
	""github.com/stretchr/testify/require""
	""github.com/ory/hydra/x""
	""github.com/ory/viper""
	""github.com/ory/x/logrusx""
)
func setupEnv(env map[string]string) func(t *testing.T) (func(), func()) {
	return func(t *testing.T) (setup func(), clean func()) {
		setup = func() {
			for k, v := range env {
				require.NoError(t, os.Setenv(k, v))
			}
		}
		clean = func() {
			for k := range env {
				require.NoError(t, os.Unsetenv(k))
			}
		}
		return
	}
}
func TestSubjectTypesSupported(t *testing.T) {
	for k, tc := range []struct {
		d   string
		env func(t *testing.T) (func(), func())
		e   []string
	}{
		{
			d: ""Load legacy environment variable in legacy format"",
			env: setupEnv(map[string]string{
				strings.ToUpper(strings.Replace(ViperKeySubjectTypesSupported, ""."", ""_"", -1)): ""public,pairwise,foobar"",
			}),
			e: []string{""public"", ""pairwise""},
		},
		{
			d: ""Load legacy environment variable in legacy format"",
			env: setupEnv(map[string]string{
				strings.ToUpper(strings.Replace(ViperKeySubjectTypesSupported, ""."", ""_"", -1)): ""public,pairwise,foobar"",
				strings.ToUpper(strings.Replace(ViperKeyAccessTokenStrategy, ""."", ""_"", -1)):   ""jwt"",
			}),
			e: []string{""public""},
		},
	} {
		t.Run(fmt.Sprintf(""case=%d/description=%s"", k, tc.d), func(t *testing.T) {
			setup, clean := tc.env(t)
			setup()
			p := NewViperProvider(logrus.New(), false, nil)
			viper.Set(ViperKeySubjectIdentifierAlgorithmSalt, ""00000000"")
			assert.EqualValues(t, tc.e, p.SubjectTypesSupported())
			clean()
		})
	}
}
func TestWellKnownKeysUnique(t *testing.T) {
	p := NewViperProvider(logrus.New(), false, nil)
	assert.EqualValues(t, []string{x.OAuth2JWTKeyName, x.OpenIDConnectKeyName}, p.WellKnownKeys(x.OAuth2JWTKeyName, x.OpenIDConnectKeyName, x.OpenIDConnectKeyName))
}
func TestCORSOptions(t *testing.T) {
	p := NewViperProvider(logrus.New(), false, nil)
	viper.Set(""serve.public.cors.enabled"", true)
	assert.EqualValues(t, cors.Options{
		AllowedOrigins:     []string{},
		AllowedMethods:     []string{""GET"", ""POST"", ""PUT"", ""PATCH"", ""DELETE""},
		AllowedHeaders:     []string{""Authorization"", ""Content-Type""},
		ExposedHeaders:     []string{""Content-Type""},
		AllowCredentials:   true,
		OptionsPassthrough: false,
		MaxAge:             0,
		Debug:              false,
	}, p.CORSOptions(""public""))
}
func TestViperProvider_AdminDisableHealthAccessLog(t *testing.T) {
	l := logrusx.New()
	l.SetOutput(ioutil.Discard)
	p := NewViperProvider(l, false, nil)
	value := p.AdminDisableHealthAccessLog()
	assert.Equal(t, false, value)
	viper.Set(ViperKeyAdminDisableHealthAccessLog, ""true"")
	value = p.AdminDisableHealthAccessLog()
	assert.Equal(t, true, value)
}
func TestViperProvider_PublicDisableHealthAccessLog(t *testing.T) {
	l := logrusx.New()
	l.SetOutput(ioutil.Discard)
	p := NewViperProvider(l, false, nil)
	value := p.PublicDisableHealthAccessLog()
	assert.Equal(t, false, value)
	viper.Set(ViperKeyPublicDisableHealthAccessLog, ""true"")
	value = p.PublicDisableHealthAccessLog()
	assert.Equal(t, true, value)
}
func TestViperProvider_IssuerURL(t *testing.T) {
	l := logrusx.New()
	l.SetOutput(ioutil.Discard)
	viper.Set(ViperKeyIssuerURL, ""http://hydra.localhost"")
	p := NewViperProvider(l, false, nil)
	assert.Equal(t, ""http://hydra.localhost/"", p.IssuerURL().String())
	viper.Set(ViperKeyIssuerURL, ""http://hydra.localhost/"")
	p2 := NewViperProvider(l, false, nil)
	assert.Equal(t, ""http://hydra.localhost/"", p2.IssuerURL().String())
}
func TestViperProvider_CookieSameSiteMode(t *testing.T) {
	l := logrusx.New()
	l.SetOutput(ioutil.Discard)
	p := NewViperProvider(l, false, nil)
	assert.Equal(t, http.SameSiteDefaultMode, p.CookieSameSiteMode())
	viper.Set(ViperKeyCookieSameSiteMode, ""none"")
	assert.Equal(t, http.SameSiteNoneMode, p.CookieSameSiteMode())
}
",CWE-294,144.0,0
"module github.com/ory/hydra
go 1.14
require (
	github.com/dgrijalva/jwt-go v3.2.0+incompatible
	github.com/go-bindata/go-bindata v3.1.1+incompatible
	github.com/go-openapi/errors v0.19.3
	github.com/go-openapi/runtime v0.19.11
	github.com/go-openapi/strfmt v0.19.4
	github.com/go-openapi/swag v0.19.7
	github.com/go-openapi/validate v0.19.6
	github.com/go-sql-driver/mysql v1.4.1
	github.com/go-swagger/go-swagger v0.22.1-0.20200306221957-4aad3a5f78b8
	github.com/gobuffalo/packr v1.24.0
	github.com/gobwas/glob v0.2.3
	github.com/golang/mock v1.4.3
	github.com/google/uuid v1.1.1
	github.com/gorilla/sessions v1.1.4-0.20181208214519-12bd4761fc66
	github.com/gtank/cryptopasta v0.0.0-20170601214702-1f550f6f2f69
	github.com/jackc/pgx/v4 v4.4.1
	github.com/jmoiron/sqlx v1.2.0
	github.com/julienschmidt/httprouter v1.2.0
	github.com/mattn/go-runewidth v0.0.4 // indirect
	github.com/mohae/deepcopy v0.0.0-20170929034955-c48cc78d4826
	github.com/oleiade/reflections v1.0.0
	github.com/olekukonko/tablewriter v0.0.1
	github.com/opentracing/opentracing-go v1.1.1-0.20190913142402-a7454ce5950e
	github.com/ory/fosite v0.31.0
	github.com/ory/go-acc v0.2.1
	github.com/ory/graceful v0.1.1
	github.com/ory/herodot v0.7.0
	github.com/ory/sdk/swagutil v0.0.0-20200219090358-f796db673877
	github.com/ory/viper v1.7.3
	github.com/ory/x v0.0.108
	github.com/pborman/uuid v1.2.0
	github.com/phayes/freeport v0.0.0-20171002181615-b8543db493a5
	github.com/pkg/errors v0.9.1
	github.com/pkg/profile v1.3.0 // indirect
	github.com/prometheus/client_golang v1.1.0
	github.com/rs/cors v1.6.0
	github.com/rubenv/sql-migrate v0.0.0-20190212093014-1007f53448d7
	github.com/sawadashota/encrypta v0.0.2
	github.com/segmentio/analytics-go v3.1.0+incompatible
	github.com/segmentio/backo-go v0.0.0-20200129164019-23eae7c10bd3 // indirect
	github.com/sirupsen/logrus v1.4.2
	github.com/spf13/cobra v0.0.6
	github.com/sqs/goreturns v0.0.0-20181028201513-538ac6014518
	github.com/stretchr/testify v1.4.0
	github.com/tidwall/gjson v1.6.0
	github.com/tidwall/pretty v1.0.1 // indirect
	github.com/toqueteos/webbrowser v1.2.0
	github.com/uber/jaeger-client-go v2.22.1+incompatible
	github.com/urfave/negroni v1.0.0
	go.opentelemetry.io/otel v0.2.1
	golang.org/x/crypto v0.0.0-20200323165209-0ec3e9974c59
	golang.org/x/lint v0.0.0-20200302205851-738671d3881b // indirect
	golang.org/x/oauth2 v0.0.0-20200107190931-bf48bf16ab8d
	golang.org/x/tools v0.0.0-20200313205530-4303120df7d8
	gopkg.in/square/go-jose.v2 v2.4.1
)
",CWE-294,62.0,0
"package oauth2_test
import (
	""context""
	""fmt""
	""testing""
	""github.com/jmoiron/sqlx""
	""github.com/pkg/errors""
	""github.com/stretchr/testify/require""
	""github.com/ory/fosite""
	""github.com/ory/x/dbal""
	""github.com/ory/x/dbal/migratest""
	""github.com/ory/hydra/client""
	""github.com/ory/hydra/consent""
	""github.com/ory/hydra/internal""
	""github.com/ory/hydra/oauth2""
	""github.com/ory/hydra/x""
)
func TestXXMigrations(t *testing.T) {
	if testing.Short() {
		t.SkipNow()
		return
	}
	migratest.RunPackrMigrationTests(
		t,
		migratest.MigrationSchemas{client.Migrations, consent.Migrations, oauth2.Migrations},
		migratest.MigrationSchemas{nil, nil, dbal.FindMatchingTestMigrations(""migrations/sql/tests/"", oauth2.Migrations, oauth2.AssetNames(), oauth2.Asset)},
		x.CleanSQL,
		x.CleanSQL,
		func(t *testing.T, dbName string, db *sqlx.DB, m, k, steps int) {
			t.Run(fmt.Sprintf(""poll=%d"", k), func(t *testing.T) {
				conf := internal.NewConfigurationWithDefaults()
				reg := internal.NewRegistrySQL(conf, db)
				if m != 2 {
					t.Skip(""Skipping polling unless it's the last migration schema"")
					return
				}
				s := reg.OAuth2Storage().(*oauth2.FositeSQLStore)
				if dbName == ""cockroach"" {
					k += 8
				}
				sig := fmt.Sprintf(""%d-sig"", k+1)
				if k < 8 {
					// With migration 8, all previous test data has been removed because the client is non-existent.
					_, err := s.GetAccessTokenSession(context.Background(), sig, oauth2.NewSession(""""))
					require.Error(t, err)
					return
				}
				_, err := s.GetAccessTokenSession(context.Background(), sig, oauth2.NewSession(""""))
				require.NoError(t, err)
				_, err = s.GetRefreshTokenSession(context.Background(), sig, oauth2.NewSession(""""))
				require.NoError(t, err)
				_, err = s.GetAuthorizeCodeSession(context.Background(), sig, oauth2.NewSession(""""))
				require.NoError(t, err)
				_, err = s.GetOpenIDConnectSession(context.Background(), sig, &fosite.Request{Session: oauth2.NewSession("""")})
				require.NoError(t, err)
				if k > 2 {
					_, err = s.GetPKCERequestSession(context.Background(), sig, oauth2.NewSession(""""))
					require.NoError(t, err)
				}
				if k >= 11 {
					require.True(t, errors.Is(s.ClientAssertionJWTValid(context.Background(), sig), fosite.ErrJTIKnown), ""%+v"", err)
				}
			})
		},
	)
}
",CWE-294,78.0,0
"package x
import (
	""testing""
	""github.com/jmoiron/sqlx""
)
func CleanSQL(t *testing.T, db *sqlx.DB) {
	t.Logf(""Cleaning up database: %s"", db.DriverName())
	for _, tb := range []string{
		""hydra_oauth2_access"",
		""hydra_oauth2_refresh"",
		""hydra_oauth2_code"",
		""hydra_oauth2_oidc"",
		""hydra_oauth2_pkce"",
		""hydra_oauth2_consent_request_handled"",
		""hydra_oauth2_consent_request"",
		""hydra_oauth2_authentication_request_handled"",
		""hydra_oauth2_authentication_request"",
		""hydra_oauth2_authentication_session"",
		""hydra_oauth2_obfuscated_authentication_session"",
		""hydra_oauth2_logout_request"",
		""hydra_oauth2_jti_blacklist"",
		""hydra_jwk"",
		""hydra_client"",
		// Migrations
		""hydra_oauth2_authentication_consent_migration"",
		""hydra_client_migration"",
		""hydra_oauth2_migration"",
		""hydra_jwk_migration"",
	} {
		if _, err := db.Exec(""DROP TABLE IF EXISTS "" + tb); err != nil {
			t.Logf(`Unable to clean up table ""%s"": %s`, tb, err)
		}
	}
	t.Logf(""Successfully cleaned up database: %s"", db.DriverName())
}
",CWE-294,39.0,0
"package project
import (
	""context""
	""github.com/argoproj/argo-cd/v2/pkg/apis/application/v1alpha1""
	""github.com/argoproj/argo-cd/v2/test/e2e/fixture""
	""github.com/stretchr/testify/require""
	v1 ""k8s.io/apimachinery/pkg/apis/meta/v1""
)
// this implements the ""when"" part of given/when/then
//
// none of the func implement error checks, and that is complete intended, you should check for errors
// using the Then()
type Actions struct {
	context      *Context
	lastOutput   string
	lastError    error
	ignoreErrors bool
}
func (a *Actions) IgnoreErrors() *Actions {
	a.ignoreErrors = true
	return a
}
func (a *Actions) DoNotIgnoreErrors() *Actions {
	a.ignoreErrors = false
	return a
}
func (a *Actions) Create(args ...string) *Actions {
	args = a.prepareCreateArgs(args)
	//  are you adding new context values? if you only use them for this func, then use args instead
	a.runCli(args...)
	return a
}
func (a *Actions) AddDestination(cluster string, namespace string) *Actions {
	a.runCli(""proj"", ""add-destination"", a.context.name, cluster, namespace)
	return a
}
func (a *Actions) AddSource(repo string) *Actions {
	a.runCli(""proj"", ""add-source"", a.context.name, repo)
	return a
}
func (a *Actions) UpdateProject(updater func(project *v1alpha1.AppProject)) *Actions {
	proj, err := fixture.AppClientset.ArgoprojV1alpha1().AppProjects(fixture.ArgoCDNamespace).Get(context.TODO(), a.context.name, v1.GetOptions{})
	require.NoError(a.context.t, err)
	updater(proj)
	_, err = fixture.AppClientset.ArgoprojV1alpha1().AppProjects(fixture.ArgoCDNamespace).Update(context.TODO(), proj, v1.UpdateOptions{})
	require.NoError(a.context.t, err)
	return a
}
func (a *Actions) Name(name string) *Actions {
	a.context.name = name
	return a
}
func (a *Actions) prepareCreateArgs(args []string) []string {
	a.context.t.Helper()
	args = append([]string{
		""proj"", ""create"", a.context.name,
	}, args...)
	if a.context.destination != """" {
		args = append(args, ""--dest"", a.context.destination)
	}
	return args
}
func (a *Actions) Delete() *Actions {
	a.context.t.Helper()
	a.runCli(""proj"", ""delete"", a.context.name)
	return a
}
func (a *Actions) And(block func()) *Actions {
	a.context.t.Helper()
	block()
	return a
}
func (a *Actions) Then() *Consequences {
	a.context.t.Helper()
	return &Consequences{a.context, a}
}
func (a *Actions) runCli(args ...string) {
	a.context.t.Helper()
	a.lastOutput, a.lastError = fixture.RunCli(args...)
	if !a.ignoreErrors {
		require.Empty(a.context.t, a.lastError)
	}
}
",CWE-862,103.0,0
"package application
import (
	""encoding/json""
	""fmt""
	""github.com/argoproj/argo-cd/v2/common""
	httputil ""github.com/argoproj/argo-cd/v2/util/http""
	util_session ""github.com/argoproj/argo-cd/v2/util/session""
	""net/http""
	""sync""
	""time""
	""github.com/gorilla/websocket""
	log ""github.com/sirupsen/logrus""
	""k8s.io/client-go/tools/remotecommand""
)
const (
	ReconnectCode    = 1
	ReconnectMessage = ""\nReconnect because the token was refreshed...\n""
)
var upgrader = func() websocket.Upgrader {
	upgrader := websocket.Upgrader{}
	upgrader.HandshakeTimeout = time.Second * 2
	upgrader.CheckOrigin = func(r *http.Request) bool {
		return true
	}
	return upgrader
}()
// terminalSession implements PtyHandler
type terminalSession struct {
	wsConn         *websocket.Conn
	sizeChan       chan remotecommand.TerminalSize
	doneChan       chan struct{}
	tty            bool
	readLock       sync.Mutex
	writeLock      sync.Mutex
	sessionManager util_session.SessionManager
	token          *string
}
// getToken get auth token from web socket request
func getToken(r *http.Request) (string, error) {
	cookies := r.Cookies()
	return httputil.JoinCookies(common.AuthCookieName, cookies)
}
// newTerminalSession create terminalSession
func newTerminalSession(w http.ResponseWriter, r *http.Request, responseHeader http.Header, sessionManager util_session.SessionManager) (*terminalSession, error) {
	token, err := getToken(r)
	if err != nil {
		return nil, err
	}
	conn, err := upgrader.Upgrade(w, r, responseHeader)
	if err != nil {
		return nil, err
	}
	session := &terminalSession{
		wsConn:         conn,
		tty:            true,
		sizeChan:       make(chan remotecommand.TerminalSize),
		doneChan:       make(chan struct{}),
		sessionManager: sessionManager,
		token:          &token,
	}
	return session, nil
}
// Done close the done channel.
func (t *terminalSession) Done() {
	close(t.doneChan)
}
func (t *terminalSession) StartKeepalives(dur time.Duration) {
	ticker := time.NewTicker(dur)
	defer ticker.Stop()
	for {
		select {
		case <-ticker.C:
			err := t.Ping()
			if err != nil {
				log.Errorf(""ping error: %v"", err)
				return
			}
		case <-t.doneChan:
			return
		}
	}
}
// Next called in a loop from remotecommand as long as the process is running
func (t *terminalSession) Next() *remotecommand.TerminalSize {
	select {
	case size := <-t.sizeChan:
		return &size
	case <-t.doneChan:
		return nil
	}
}
// reconnect send reconnect code to client and ask them init new ws session
func (t *terminalSession) reconnect() (int, error) {
	reconnectCommand, _ := json.Marshal(TerminalCommand{
		Code: ReconnectCode,
	})
	reconnectMessage, _ := json.Marshal(TerminalMessage{
		Operation: ""stdout"",
		Data:      ReconnectMessage,
	})
	t.writeLock.Lock()
	err := t.wsConn.WriteMessage(websocket.TextMessage, reconnectMessage)
	if err != nil {
		log.Errorf(""write message err: %v"", err)
		return 0, err
	}
	err = t.wsConn.WriteMessage(websocket.TextMessage, reconnectCommand)
	if err != nil {
		log.Errorf(""write message err: %v"", err)
		return 0, err
	}
	t.writeLock.Unlock()
	return 0, nil
}
// Read called in a loop from remotecommand as long as the process is running
func (t *terminalSession) Read(p []byte) (int, error) {
	// check if token still valid
	_, newToken, err := t.sessionManager.VerifyToken(*t.token)
	// err in case if token is revoked, newToken in case if refresh happened
	if err != nil || newToken != """" {
		// need to send reconnect code in case if token was refreshed
		return t.reconnect()
	}
	t.readLock.Lock()
	_, message, err := t.wsConn.ReadMessage()
	t.readLock.Unlock()
	if err != nil {
		log.Errorf(""read message err: %v"", err)
		return copy(p, EndOfTransmission), err
	}
	var msg TerminalMessage
	if err := json.Unmarshal(message, &msg); err != nil {
		log.Errorf(""read parse message err: %v"", err)
		return copy(p, EndOfTransmission), err
	}
	switch msg.Operation {
	case ""stdin"":
		return copy(p, msg.Data), nil
	case ""resize"":
		t.sizeChan <- remotecommand.TerminalSize{Width: msg.Cols, Height: msg.Rows}
		return 0, nil
	default:
		return copy(p, EndOfTransmission), fmt.Errorf(""unknown message type %s"", msg.Operation)
	}
}
// Ping called periodically to ensure connection stays alive through load balancers
func (t *terminalSession) Ping() error {
	t.writeLock.Lock()
	err := t.wsConn.WriteMessage(websocket.PingMessage, []byte(""ping""))
	t.writeLock.Unlock()
	if err != nil {
		log.Errorf(""ping message err: %v"", err)
	}
	return err
}
// Write called from remotecommand whenever there is any output
func (t *terminalSession) Write(p []byte) (int, error) {
	msg, err := json.Marshal(TerminalMessage{
		Operation: ""stdout"",
		Data:      string(p),
	})
	if err != nil {
		log.Errorf(""write parse message err: %v"", err)
		return 0, err
	}
	t.writeLock.Lock()
	err = t.wsConn.WriteMessage(websocket.TextMessage, msg)
	t.writeLock.Unlock()
	if err != nil {
		log.Errorf(""write message err: %v"", err)
		return 0, err
	}
	return len(p), nil
}
// Close closes websocket connection
func (t *terminalSession) Close() error {
	return t.wsConn.Close()
}
",CWE-613,196.0,0
"package application
import (
	""encoding/json""
	""github.com/gorilla/websocket""
	""github.com/stretchr/testify/assert""
	""net/http""
	""net/http/httptest""
	""strings""
	""testing""
)
func reconnect(w http.ResponseWriter, r *http.Request) {
	var upgrader = websocket.Upgrader{}
	c, err := upgrader.Upgrade(w, r, nil)
	if err != nil {
		return
	}
	ts := terminalSession{wsConn: c}
	_, _ = ts.reconnect()
}
func TestReconnect(t *testing.T) {
	s := httptest.NewServer(http.HandlerFunc(reconnect))
	defer s.Close()
	u := ""ws"" + strings.TrimPrefix(s.URL, ""http"")
	// Connect to the server
	ws, _, err := websocket.DefaultDialer.Dial(u, nil)
	assert.NoError(t, err)
	defer ws.Close()
	_, p, _ := ws.ReadMessage()
	var message TerminalMessage
	err = json.Unmarshal(p, &message)
	assert.NoError(t, err)
	assert.Equal(t, message.Data, ReconnectMessage)
}
",CWE-613,47.0,0
"// Code generated by mockery v1.0.0. DO NOT EDIT.
package mocks
import (
	helm ""github.com/argoproj/argo-cd/v2/util/helm""
	io ""github.com/argoproj/argo-cd/v2/util/io""
	mock ""github.com/stretchr/testify/mock""
)
// Client is an autogenerated mock type for the Client type
type Client struct {
	mock.Mock
}
// CleanChartCache provides a mock function with given fields: chart, version
func (_m *Client) CleanChartCache(chart string, version string) error {
	ret := _m.Called(chart, version)
	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(chart, version)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}
// ExtractChart provides a mock function with given fields: chart, version
func (_m *Client) ExtractChart(chart string, version string, passCredentials bool, manifestMaxExtractedSize int64, disableManifestMaxExtractedSize bool) (string, io.Closer, error) {
	ret := _m.Called(chart, version)
	var r0 string
	if rf, ok := ret.Get(0).(func(string, string) string); ok {
		r0 = rf(chart, version)
	} else {
		r0 = ret.Get(0).(string)
	}
	var r1 io.Closer
	if rf, ok := ret.Get(1).(func(string, string) io.Closer); ok {
		r1 = rf(chart, version)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(io.Closer)
		}
	}
	var r2 error
	if rf, ok := ret.Get(2).(func(string, string) error); ok {
		r2 = rf(chart, version)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}
// GetIndex provides a mock function with given fields: noCache
func (_m *Client) GetIndex(noCache bool) (*helm.Index, error) {
	ret := _m.Called(noCache)
	var r0 *helm.Index
	if rf, ok := ret.Get(0).(func(bool) *helm.Index); ok {
		r0 = rf(noCache)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*helm.Index)
		}
	}
	var r1 error
	if rf, ok := ret.Get(1).(func(bool) error); ok {
		r1 = rf(noCache)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}
// GetTags provides a mock function with given fields: noCache
func (_m *Client) GetTags(chart string, noCache bool) (*helm.TagsList, error) {
	ret := _m.Called(chart, noCache)
	var r0 *helm.TagsList
	if rf, ok := ret.Get(0).(func(string, bool) *helm.TagsList); ok {
		r0 = rf(chart, noCache)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*helm.TagsList)
		}
	}
	var r1 error
	if rf, ok := ret.Get(1).(func(string, bool) error); ok {
		r1 = rf(chart, noCache)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}
// TestHelmOCI provides a mock function with given fields:
func (_m *Client) TestHelmOCI() (bool, error) {
	ret := _m.Called()
	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}
	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}
",CWE-400,127.0,0
"// compares the inventory of package items in the tree
// that is about to be installed (idealTree) with the inventory
// of items stored in the package-lock file (virtualTree)
//
// Returns empty array if no errors found or an array populated
// with an entry for each validation error found.
function validateLockfile (virtualTree, idealTree) {
  const errors = []
  // loops through the inventory of packages resulted by ideal tree,
  // for each package compares the versions with the version stored in the
  // package-lock and adds an error to the list in case of mismatches
  for (const [key, entry] of idealTree.entries()) {
    const lock = virtualTree.get(key)
    if (!lock) {
      errors.push(`Missing: ${entry.name}@${entry.version} from lock file`)
      continue
    }
    if (entry.version !== lock.version) {
      errors.push(`Invalid: lock file's ${lock.name}@${lock.version} does ` +
      `not satisfy ${entry.name}@${entry.version}`)
    }
  }
  return errors
}
module.exports = validateLockfile
",CWE-345,30.0,0
"package api
import (
	""net/http""
	""net/url""
	""github.com/containous/traefik/v2/pkg/log""
	assetfs ""github.com/elazarl/go-bindata-assetfs""
	""github.com/gorilla/mux""
)
// DashboardHandler expose dashboard routes.
type DashboardHandler struct {
	Assets *assetfs.AssetFS
}
// Append add dashboard routes on a router.
func (g DashboardHandler) Append(router *mux.Router) {
	if g.Assets == nil {
		log.WithoutContext().Error(""No assets for dashboard"")
		return
	}
	// Expose dashboard
	router.Methods(http.MethodGet).
		Path(""/"").
		HandlerFunc(func(resp http.ResponseWriter, req *http.Request) {
			http.Redirect(resp, req, safePrefix(req)+""/dashboard/"", http.StatusFound)
		})
	router.Methods(http.MethodGet).
		PathPrefix(""/dashboard/"").
		Handler(http.StripPrefix(""/dashboard/"", http.FileServer(g.Assets)))
}
func safePrefix(req *http.Request) string {
	prefix := req.Header.Get(""X-Forwarded-Prefix"")
	if prefix == """" {
		return """"
	}
	parse, err := url.Parse(prefix)
	if err != nil {
		return """"
	}
	if parse.Host != """" {
		return """"
	}
	return parse.Path
}
",CWE-601,53.0,0
"package api
import (
	""net/http""
	""testing""
	""github.com/stretchr/testify/assert""
	""github.com/stretchr/testify/require""
)
func Test_safePrefix(t *testing.T) {
	testCases := []struct {
		desc     string
		value    string
		expected string
	}{
		{
			desc:     ""host"",
			value:    ""https://example.com"",
			expected: """",
		},
		{
			desc:     ""host with path"",
			value:    ""https://example.com/foo/bar?test"",
			expected: """",
		},
		{
			desc:     ""path"",
			value:    ""/foo/bar"",
			expected: ""/foo/bar"",
		},
		{
			desc:     ""path without leading slash"",
			value:    ""foo/bar"",
			expected: ""foo/bar"",
		},
	}
	for _, test := range testCases {
		test := test
		t.Run(test.desc, func(t *testing.T) {
			t.Parallel()
			req, err := http.NewRequest(http.MethodGet, ""http://localhost"", nil)
			require.NoError(t, err)
			req.Header.Set(""X-Forwarded-Prefix"", test.value)
			prefix := safePrefix(req)
			assert.Equal(t, test.expected, prefix)
		})
	}
}
",CWE-601,55.0,0
"/*
Copyright The Helm Authors.
Licensed under the Apache License, Version 2.0 (the ""License"");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an ""AS IS"" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package main
import (
	""fmt""
	""io""
	""github.com/pkg/errors""
	""github.com/spf13/cobra""
	""helm.sh/helm/v3/cmd/helm/require""
	""helm.sh/helm/v3/pkg/plugin""
	""helm.sh/helm/v3/pkg/plugin/installer""
)
type pluginInstallOptions struct {
	source  string
	version string
}
const pluginInstallDesc = `
This command allows you to install a plugin from a url to a VCS repo or a local path.
`
func newPluginInstallCmd(out io.Writer) *cobra.Command {
	o := &pluginInstallOptions{}
	cmd := &cobra.Command{
		Use:     ""install [options] <path|url>..."",
		Short:   ""install one or more Helm plugins"",
		Long:    pluginInstallDesc,
		Aliases: []string{""add""},
		Args:    require.ExactArgs(1),
		ValidArgsFunction: func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {
			if len(args) == 0 {
				// We do file completion, in case the plugin is local
				return nil, cobra.ShellCompDirectiveDefault
			}
			// No more completion once the plugin path has been specified
			return nil, cobra.ShellCompDirectiveNoFileComp
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return o.complete(args)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return o.run(out)
		},
	}
	cmd.Flags().StringVar(&o.version, ""version"", """", ""specify a version constraint. If this is not specified, the latest version is installed"")
	return cmd
}
func (o *pluginInstallOptions) complete(args []string) error {
	o.source = args[0]
	return nil
}
func (o *pluginInstallOptions) run(out io.Writer) error {
	installer.Debug = settings.Debug
	i, err := installer.NewForSource(o.source, o.version)
	if err != nil {
		return err
	}
	if err := installer.Install(i); err != nil {
		return err
	}
	debug(""loading plugin from %s"", i.Path())
	p, err := plugin.LoadDir(i.Path())
	if err != nil {
		return errors.Wrap(err, ""plugin is installed but unusable"")
	}
	if err := runHook(p, plugin.Install); err != nil {
		return err
	}
	fmt.Fprintf(out, ""Installed plugin: %s\n"", p.Metadata.Name)
	return nil
}
",CWE-74,95.0,0
"/*
 * Copyright © 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @author		Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @copyright 	2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @license 	Apache-2.0
 *
 */
package fosite
import (
	""context""
	""time""
)
// ClientManager defines the (persistent) manager interface for clients.
type ClientManager interface {
	// GetClient loads the client by its ID or returns an error
	// if the client does not exist or another error occurred.
	GetClient(ctx context.Context, id string) (Client, error)
	// ClientAssertionJWTValid returns an error if the JTI is
	// known or the DB check failed and nil if the JTI is not known.
	ClientAssertionJWTValid(ctx context.Context, jti string) error
	// SetClientAssertionJWT marks a JTI as known for the given
	// expiry time. Before inserting the new JTI, it will clean
	// up any existing JTIs that have expired as those tokens can
	// not be replayed due to the expiry.
	SetClientAssertionJWT(ctx context.Context, jti string, exp time.Time) error
}
",CWE-345,43.0,0
"module github.com/ory/fosite
require (
	github.com/asaskevich/govalidator v0.0.0-20180720115003-f9ffefc3facf
	github.com/davecgh/go-spew v1.1.1 // indirect
	github.com/dgrijalva/jwt-go v3.2.0+incompatible
	github.com/elazarl/goproxy v0.0.0-20181003060214-f58a169a71a5 // indirect
	github.com/golang/mock v1.4.3
	github.com/gopherjs/gopherjs v0.0.0-20181004151105-1babbf986f6f // indirect
	github.com/gorilla/context v1.1.1 // indirect
	github.com/gorilla/mux v1.6.2
	github.com/jtolds/gls v4.2.1+incompatible // indirect
	github.com/magiconair/properties v1.8.0
	github.com/mohae/deepcopy v0.0.0-20170929034955-c48cc78d4826
	github.com/moul/http2curl v0.0.0-20170919181001-9ac6cf4d929b // indirect
	github.com/oleiade/reflections v1.0.0
	github.com/ory/go-convenience v0.1.0
	github.com/parnurzeal/gorequest v0.2.15
	github.com/pborman/uuid v1.2.0
	github.com/pkg/errors v0.8.0
	github.com/pmezard/go-difflib v1.0.0 // indirect
	github.com/smartystreets/assertions v0.0.0-20180927180507-b2de0cb4f26d // indirect
	github.com/smartystreets/goconvey v0.0.0-20180222194500-ef6db91d284a // indirect
	github.com/stretchr/testify v1.2.2
	golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2
	golang.org/x/oauth2 v0.0.0-20181003184128-c57b0facaced
	google.golang.org/appengine v1.2.0 // indirect
	gopkg.in/square/go-jose.v2 v2.1.9
)
go 1.13
",CWE-345,32.0,0
"github.com/asaskevich/govalidator v0.0.0-20180720115003-f9ffefc3facf h1:eg0MeVzsP1G42dRafH3vf+al2vQIJU0YHX+1Tw87oco=
github.com/asaskevich/govalidator v0.0.0-20180720115003-f9ffefc3facf/go.mod h1:lB+ZfQJz7igIIfQNfa7Ml4HSf2uFQQRzpGGRXenZAgY=
github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/dgrijalva/jwt-go v3.2.0+incompatible h1:7qlOGliEKZXTDg6OTjfoBKDXWrumCAMpl/TFQ4/5kLM=
github.com/dgrijalva/jwt-go v3.2.0+incompatible/go.mod h1:E3ru+11k8xSBh+hMPgOLZmtrrCbhqsmaPHjLKYnJCaQ=
github.com/elazarl/goproxy v0.0.0-20181003060214-f58a169a71a5 h1:LCoguo7Zd0MByKMbQbTvcZw7HiBcbvew+MOcwsJVwrY=
github.com/elazarl/goproxy v0.0.0-20181003060214-f58a169a71a5/go.mod h1:/Zj4wYkgs4iZTTu3o/KG3Itv/qCCa8VVMlb3i9OVuzc=
github.com/golang/mock v1.1.1 h1:G5FRp8JnTd7RQH5kemVNlMeyXQAztQ3mOWV95KxsXH8=
github.com/golang/mock v1.1.1/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=
github.com/golang/mock v1.4.3 h1:GV+pQPG/EUUbkh47niozDcADz6go/dUwhVzdUQHIVRw=
github.com/golang/mock v1.4.3/go.mod h1:UOMv5ysSaYNkG+OFQykRIcU/QvvxJf3p21QfJ2Bt3cw=
github.com/golang/protobuf v1.2.0 h1:P3YflyNX/ehuJFLhxviNdFxQPkGK5cDcApsge1SqnvM=
github.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=
github.com/google/uuid v1.0.0 h1:b4Gk+7WdP/d3HZH8EJsZpvV7EtDOgaZLtnaNGIu1adA=
github.com/google/uuid v1.0.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
github.com/gopherjs/gopherjs v0.0.0-20181004151105-1babbf986f6f h1:JJ2EP5vV3LAD2U1CxQtD7PTOO15Y96kXmKDz7TjxGHs=
github.com/gopherjs/gopherjs v0.0.0-20181004151105-1babbf986f6f/go.mod h1:wJfORRmW1u3UXTncJ5qlYoELFm8eSnnEO6hX4iZ3EWY=
github.com/gorilla/context v1.1.1 h1:AWwleXJkX/nhcU9bZSnZoi3h/qGYqQAGhq6zZe/aQW8=
github.com/gorilla/context v1.1.1/go.mod h1:kBGZzfjB9CEq2AlWe17Uuf7NDRt0dE0s8S51q0aT7Yg=
github.com/gorilla/mux v1.6.2 h1:Pgr17XVTNXAk3q/r4CpKzC5xBM/qW1uVLV+IhRZpIIk=
github.com/gorilla/mux v1.6.2/go.mod h1:1lud6UwP+6orDFRuTfBEV8e9/aOM/c4fVVCaMa2zaAs=
github.com/jtolds/gls v4.2.1+incompatible h1:fSuqC+Gmlu6l/ZYAoZzx2pyucC8Xza35fpRVWLVmUEE=
github.com/jtolds/gls v4.2.1+incompatible/go.mod h1:QJZ7F/aHp+rZTRtaJ1ow/lLfFfVYBRgL+9YlvaHOwJU=
github.com/magiconair/properties v1.8.0 h1:LLgXmsheXeRoUOBOjtwPQCWIYqM/LU1ayDtDePerRcY=
github.com/magiconair/properties v1.8.0/go.mod h1:PppfXfuXeibc/6YijjN8zIbojt8czPbwD3XqdrwzmxQ=
github.com/mohae/deepcopy v0.0.0-20170929034955-c48cc78d4826 h1:RWengNIwukTxcDr9M+97sNutRR1RKhG96O6jWumTTnw=
github.com/mohae/deepcopy v0.0.0-20170929034955-c48cc78d4826/go.mod h1:TaXosZuwdSHYgviHp1DAtfrULt5eUgsSMsZf+YrPgl8=
github.com/moul/http2curl v0.0.0-20170919181001-9ac6cf4d929b h1:Pip12xNtMvEFUBF4f8/b5yRXj94LLrNdLWELfOr2KcY=
github.com/moul/http2curl v0.0.0-20170919181001-9ac6cf4d929b/go.mod h1:8UbvGypXm98wA/IqH45anm5Y2Z6ep6O31QGOAZ3H0fQ=
github.com/oleiade/reflections v1.0.0 h1:0ir4pc6v8/PJ0yw5AEtMddfXpWBXg9cnG7SgSoJuCgY=
github.com/oleiade/reflections v1.0.0/go.mod h1:RbATFBbKYkVdqmSFtx13Bb/tVhR0lgOBXunWTZKeL4w=
github.com/ory/go-convenience v0.1.0 h1:zouLKfF2GoSGnJwGq+PE/nJAE6dj2Zj5QlTgmMTsTS8=
github.com/ory/go-convenience v0.1.0/go.mod h1:uEY/a60PL5c12nYz4V5cHY03IBmwIAEm8TWB0yn9KNs=
github.com/parnurzeal/gorequest v0.2.15 h1:oPjDCsF5IkD4gUk6vIgsxYNaSgvAnIh1EJeROn3HdJU=
github.com/parnurzeal/gorequest v0.2.15/go.mod h1:3Kh2QUMJoqw3icWAecsyzkpY7UzRfDhbRdTjtNwNiUE=
github.com/pborman/uuid v1.2.0 h1:J7Q5mO4ysT1dv8hyrUGHb9+ooztCXu1D8MY8DZYsu3g=
github.com/pborman/uuid v1.2.0/go.mod h1:X/NO0urCmaxf9VXbdlT7C2Yzkj2IKimNn4k+gtPdI/k=
github.com/pkg/errors v0.8.0 h1:WdK/asTD0HN+q6hsWO3/vpuAkAr+tw6aNJNDFFf0+qw=
github.com/pkg/errors v0.8.0/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=
github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/smartystreets/assertions v0.0.0-20180927180507-b2de0cb4f26d h1:zE9ykElWQ6/NYmHa3jpm/yHnI4xSofP+UP6SpjHcSeM=
github.com/smartystreets/assertions v0.0.0-20180927180507-b2de0cb4f26d/go.mod h1:OnSkiWE9lh6wB0YB77sQom3nweQdgAjqCqsofrRNTgc=
github.com/smartystreets/goconvey v0.0.0-20180222194500-ef6db91d284a h1:JSvGDIbmil4Ui/dDdFBExb7/cmkNjyX5F97oglmvCDo=
github.com/smartystreets/goconvey v0.0.0-20180222194500-ef6db91d284a/go.mod h1:XDJAKZRPZ1CvBcN2aX5YOUTYGHki24fSF0Iv48Ibg0s=
github.com/stretchr/testify v1.2.2 h1:bSDNvY7ZPG5RlJ8otE/7V6gMiyenm9RtJ7IUVIAoJ1w=
github.com/stretchr/testify v1.2.2/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=
golang.org/x/crypto v0.0.0-20181001203147-e3636079e1a4 h1:Vk3wNqEZwyGyei9yq5ekj7frek2u7HUfffJ1/opblzc=
golang.org/x/crypto v0.0.0-20181001203147-e3636079e1a4/go.mod h1:6SG95UA2DQfeDnfUPMdvaQW0Q7yPrPDi9nlGo2tz2b4=
golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2 h1:VklqNMn3ovrHsnt90PveolxSbWFaJdECFbxSq0Mqo2M=
golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=
golang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20181005035420-146acd28ed58 h1:otZG8yDCO4LVps5+9bxOeNiCvgmOyt96J3roHTYs7oE=
golang.org/x/net v0.0.0-20181005035420-146acd28ed58/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20190311183353-d8887717615a h1:oWX7TPOiFAMXLq8o0ikBYfCJVlRHBcsciT5bXOrH628=
golang.org/x/net v0.0.0-20190311183353-d8887717615a/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
golang.org/x/oauth2 v0.0.0-20181003184128-c57b0facaced h1:4oqSq7eft7MdPKBGQK11X9WYUxmj6ZLgGTqYIbY1kyw=
golang.org/x/oauth2 v0.0.0-20181003184128-c57b0facaced/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=
golang.org/x/sync v0.0.0-20180314180146-1d60e4601c6f h1:wMNYb4v58l5UBM7MYRLPG6ZhfOqbKu7X5eyFl8ZhKvA=
golang.org/x/sync v0.0.0-20180314180146-1d60e4601c6f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
golang.org/x/tools v0.0.0-20190425150028-36563e24a262 h1:qsl9y/CJx34tuA7QCPNp86JNJe4spst6Ff8MjvPUdPg=
golang.org/x/tools v0.0.0-20190425150028-36563e24a262/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=
google.golang.org/appengine v1.2.0 h1:S0iUepdCWODXRvtE+gcRDd15L+k+k1AiHlMiMjefH24=
google.golang.org/appengine v1.2.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=
gopkg.in/square/go-jose.v2 v2.1.9 h1:YCFbL5T2gbmC2sMG12s1x2PAlTK5TZNte3hjZEIcCAg=
gopkg.in/square/go-jose.v2 v2.1.9/go.mod h1:M9dMgbHiYLoDGQrXy7OpJDJWiKiU//h+vD76mk0e1AI=
rsc.io/quote/v3 v3.1.0/go.mod h1:yEA65RcK8LyAZtP9Kv3t0HmxON59tX3rD+tICJqUlj0=
rsc.io/sampler v1.3.0/go.mod h1:T1hPZKmBbMNahiBKFy5HrXp6adAjACjK9JXDnKaTXpA=
",CWE-345,74.0,0
"/*
 * Copyright © 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @author		Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @copyright 	2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @license 	Apache-2.0
 *
 */
package oauth2
import (
	""context""
	""fmt""
	""strings""
	""time""
	""github.com/pkg/errors""
	""github.com/ory/fosite""
	""github.com/ory/fosite/storage""
)
type RefreshTokenGrantHandler struct {
	AccessTokenStrategy    AccessTokenStrategy
	RefreshTokenStrategy   RefreshTokenStrategy
	TokenRevocationStorage TokenRevocationStorage
	// AccessTokenLifespan defines the lifetime of an access token.
	AccessTokenLifespan time.Duration
	// RefreshTokenLifespan defines the lifetime of a refresh token.
	RefreshTokenLifespan time.Duration
	ScopeStrategy            fosite.ScopeStrategy
	AudienceMatchingStrategy fosite.AudienceMatchingStrategy
	RefreshTokenScopes       []string
}
// HandleTokenEndpointRequest implements https://tools.ietf.org/html/rfc6749
func (c *RefreshTokenGrantHandler) HandleTokenEndpointRequest(ctx context.Context, request fosite.AccessRequester) error {
	// grant_type REQUIRED.
	// Value MUST be set to ""refresh_token"".
	if !request.GetGrantTypes().ExactOne(""refresh_token"") {
		return errors.WithStack(fosite.ErrUnknownRequest)
	}
	if !request.GetClient().GetGrantTypes().Has(""refresh_token"") {
		return errors.WithStack(fosite.ErrInvalidGrant.WithHint(""The OAuth 2.0 Client is not allowed to use authorization grant \""refresh_token\"".""))
	}
	refresh := request.GetRequestForm().Get(""refresh_token"")
	signature := c.RefreshTokenStrategy.RefreshTokenSignature(refresh)
	originalRequest, err := c.TokenRevocationStorage.GetRefreshTokenSession(ctx, signature, request.GetSession())
	if errors.Cause(err) == fosite.ErrNotFound {
		return errors.WithStack(fosite.ErrInvalidRequest.WithDebug(err.Error()))
	} else if err != nil {
		return errors.WithStack(fosite.ErrServerError.WithDebug(err.Error()))
	} else if err := c.RefreshTokenStrategy.ValidateRefreshToken(ctx, originalRequest, refresh); err != nil {
		// The authorization server MUST ... validate the refresh token.
		// This needs to happen after store retrieval for the session to be hydrated properly
		return errors.WithStack(fosite.ErrInvalidRequest.WithDebug(err.Error()))
	}
	if !(len(c.RefreshTokenScopes) == 0 || originalRequest.GetGrantedScopes().HasOneOf(c.RefreshTokenScopes...)) {
		scopeNames := strings.Join(c.RefreshTokenScopes, "" or "")
		hint := fmt.Sprintf(""The OAuth 2.0 Client was not granted scope %s and may thus not perform the \""refresh_token\"" authorization grant."", scopeNames)
		return errors.WithStack(fosite.ErrScopeNotGranted.WithHint(hint))
	}
	// The authorization server MUST ... and ensure that the refresh token was issued to the authenticated client
	if originalRequest.GetClient().GetID() != request.GetClient().GetID() {
		return errors.WithStack(fosite.ErrInvalidRequest.WithHint(""The OAuth 2.0 Client ID from this request does not match the ID during the initial token issuance.""))
	}
	request.SetSession(originalRequest.GetSession().Clone())
	request.SetRequestedScopes(originalRequest.GetRequestedScopes())
	request.SetRequestedAudience(originalRequest.GetRequestedAudience())
	for _, scope := range originalRequest.GetGrantedScopes() {
		if !c.ScopeStrategy(request.GetClient().GetScopes(), scope) {
			return errors.WithStack(fosite.ErrInvalidScope.WithHintf(""The OAuth 2.0 Client is not allowed to request scope \""%s\""."", scope))
		}
		request.GrantScope(scope)
	}
	if err := c.AudienceMatchingStrategy(request.GetClient().GetAudience(), originalRequest.GetGrantedAudience()); err != nil {
		return err
	}
	for _, audience := range originalRequest.GetGrantedAudience() {
		request.GrantAudience(audience)
	}
	request.GetSession().SetExpiresAt(fosite.AccessToken, time.Now().UTC().Add(c.AccessTokenLifespan).Round(time.Second))
	if c.RefreshTokenLifespan > -1 {
		request.GetSession().SetExpiresAt(fosite.RefreshToken, time.Now().UTC().Add(c.RefreshTokenLifespan).Round(time.Second))
	}
	return nil
}
// PopulateTokenEndpointResponse implements https://tools.ietf.org/html/rfc6749
func (c *RefreshTokenGrantHandler) PopulateTokenEndpointResponse(ctx context.Context, requester fosite.AccessRequester, responder fosite.AccessResponder) error {
	if !requester.GetGrantTypes().ExactOne(""refresh_token"") {
		return errors.WithStack(fosite.ErrUnknownRequest)
	}
	accessToken, accessSignature, err := c.AccessTokenStrategy.GenerateAccessToken(ctx, requester)
	if err != nil {
		return errors.WithStack(fosite.ErrServerError.WithDebug(err.Error()))
	}
	refreshToken, refreshSignature, err := c.RefreshTokenStrategy.GenerateRefreshToken(ctx, requester)
	if err != nil {
		return errors.WithStack(fosite.ErrServerError.WithDebug(err.Error()))
	}
	signature := c.RefreshTokenStrategy.RefreshTokenSignature(requester.GetRequestForm().Get(""refresh_token""))
	ctx, err = storage.MaybeBeginTx(ctx, c.TokenRevocationStorage)
	if err != nil {
		return errors.WithStack(fosite.ErrServerError.WithDebug(err.Error()))
	}
	ts, err := c.TokenRevocationStorage.GetRefreshTokenSession(ctx, signature, nil)
	if err != nil {
		return handleRefreshTokenEndpointResponseStorageError(ctx, true, c.TokenRevocationStorage, err)
	} else if err := c.TokenRevocationStorage.RevokeAccessToken(ctx, ts.GetID()); err != nil {
		return handleRefreshTokenEndpointResponseStorageError(ctx, true, c.TokenRevocationStorage, err)
	} else if err := c.TokenRevocationStorage.RevokeRefreshToken(ctx, ts.GetID()); err != nil {
		return handleRefreshTokenEndpointResponseStorageError(ctx, true, c.TokenRevocationStorage, err)
	}
	storeReq := requester.Sanitize([]string{})
	storeReq.SetID(ts.GetID())
	if err := c.TokenRevocationStorage.CreateAccessTokenSession(ctx, accessSignature, storeReq); err != nil {
		return handleRefreshTokenEndpointResponseStorageError(ctx, true, c.TokenRevocationStorage, err)
	}
	if err := c.TokenRevocationStorage.CreateRefreshTokenSession(ctx, refreshSignature, storeReq); err != nil {
		return handleRefreshTokenEndpointResponseStorageError(ctx, true, c.TokenRevocationStorage, err)
	}
	responder.SetAccessToken(accessToken)
	responder.SetTokenType(""bearer"")
	responder.SetExpiresIn(getExpiresIn(requester, fosite.AccessToken, c.AccessTokenLifespan, time.Now().UTC()))
	responder.SetScopes(requester.GetGrantedScopes())
	responder.SetExtra(""refresh_token"", refreshToken)
	if err := storage.MaybeCommitTx(ctx, c.TokenRevocationStorage); err != nil {
		return handleRefreshTokenEndpointResponseStorageError(ctx, false, c.TokenRevocationStorage, err)
	}
	return nil
}
func handleRefreshTokenEndpointResponseStorageError(ctx context.Context, rollback bool, store TokenRevocationStorage, storageErr error) (err error) {
	defer func() {
		if rollback {
			if rbErr := storage.MaybeRollbackTx(ctx, store); rbErr != nil {
				err = errors.WithStack(fosite.ErrServerError.WithDebug(rbErr.Error()))
			}
		}
	}()
	if errors.Cause(storageErr) == fosite.ErrSerializationFailure {
		return errors.WithStack(fosite.ErrInvalidRequest.
			WithDebugf(storageErr.Error()).
			WithHint(""Failed to refresh token because of multiple concurrent requests using the same token which is not allowed.""))
	}
	if errors.Cause(storageErr) == fosite.ErrNotFound {
		return errors.WithStack(fosite.ErrInvalidRequest.
			WithDebugf(storageErr.Error()).
			WithHint(""Failed to refresh token because of multiple concurrent requests using the same token which is not allowed.""))
	}
	return errors.WithStack(fosite.ErrServerError.WithDebug(storageErr.Error()))
}
",CWE-345,195.0,0
"// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ory/fosite (interfaces: AccessResponder)
// Package internal is a generated GoMock package.
package internal
import (
	reflect ""reflect""
	time ""time""
	gomock ""github.com/golang/mock/gomock""
	fosite ""github.com/ory/fosite""
)
// MockAccessResponder is a mock of AccessResponder interface
type MockAccessResponder struct {
	ctrl     *gomock.Controller
	recorder *MockAccessResponderMockRecorder
}
// MockAccessResponderMockRecorder is the mock recorder for MockAccessResponder
type MockAccessResponderMockRecorder struct {
	mock *MockAccessResponder
}
// NewMockAccessResponder creates a new mock instance
func NewMockAccessResponder(ctrl *gomock.Controller) *MockAccessResponder {
	mock := &MockAccessResponder{ctrl: ctrl}
	mock.recorder = &MockAccessResponderMockRecorder{mock}
	return mock
}
// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockAccessResponder) EXPECT() *MockAccessResponderMockRecorder {
	return m.recorder
}
// GetAccessToken mocks base method
func (m *MockAccessResponder) GetAccessToken() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""GetAccessToken"")
	ret0, _ := ret[0].(string)
	return ret0
}
// GetAccessToken indicates an expected call of GetAccessToken
func (mr *MockAccessResponderMockRecorder) GetAccessToken() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetAccessToken"", reflect.TypeOf((*MockAccessResponder)(nil).GetAccessToken))
}
// GetExtra mocks base method
func (m *MockAccessResponder) GetExtra(arg0 string) interface{} {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""GetExtra"", arg0)
	ret0, _ := ret[0].(interface{})
	return ret0
}
// GetExtra indicates an expected call of GetExtra
func (mr *MockAccessResponderMockRecorder) GetExtra(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetExtra"", reflect.TypeOf((*MockAccessResponder)(nil).GetExtra), arg0)
}
// GetTokenType mocks base method
func (m *MockAccessResponder) GetTokenType() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""GetTokenType"")
	ret0, _ := ret[0].(string)
	return ret0
}
// GetTokenType indicates an expected call of GetTokenType
func (mr *MockAccessResponderMockRecorder) GetTokenType() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetTokenType"", reflect.TypeOf((*MockAccessResponder)(nil).GetTokenType))
}
// SetAccessToken mocks base method
func (m *MockAccessResponder) SetAccessToken(arg0 string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, ""SetAccessToken"", arg0)
}
// SetAccessToken indicates an expected call of SetAccessToken
func (mr *MockAccessResponderMockRecorder) SetAccessToken(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""SetAccessToken"", reflect.TypeOf((*MockAccessResponder)(nil).SetAccessToken), arg0)
}
// SetExpiresIn mocks base method
func (m *MockAccessResponder) SetExpiresIn(arg0 time.Duration) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, ""SetExpiresIn"", arg0)
}
// SetExpiresIn indicates an expected call of SetExpiresIn
func (mr *MockAccessResponderMockRecorder) SetExpiresIn(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""SetExpiresIn"", reflect.TypeOf((*MockAccessResponder)(nil).SetExpiresIn), arg0)
}
// SetExtra mocks base method
func (m *MockAccessResponder) SetExtra(arg0 string, arg1 interface{}) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, ""SetExtra"", arg0, arg1)
}
// SetExtra indicates an expected call of SetExtra
func (mr *MockAccessResponderMockRecorder) SetExtra(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""SetExtra"", reflect.TypeOf((*MockAccessResponder)(nil).SetExtra), arg0, arg1)
}
// SetScopes mocks base method
func (m *MockAccessResponder) SetScopes(arg0 fosite.Arguments) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, ""SetScopes"", arg0)
}
// SetScopes indicates an expected call of SetScopes
func (mr *MockAccessResponderMockRecorder) SetScopes(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""SetScopes"", reflect.TypeOf((*MockAccessResponder)(nil).SetScopes), arg0)
}
// SetTokenType mocks base method
func (m *MockAccessResponder) SetTokenType(arg0 string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, ""SetTokenType"", arg0)
}
// SetTokenType indicates an expected call of SetTokenType
func (mr *MockAccessResponderMockRecorder) SetTokenType(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""SetTokenType"", reflect.TypeOf((*MockAccessResponder)(nil).SetTokenType), arg0)
}
// ToMap mocks base method
func (m *MockAccessResponder) ToMap() map[string]interface{} {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""ToMap"")
	ret0, _ := ret[0].(map[string]interface{})
	return ret0
}
// ToMap indicates an expected call of ToMap
func (mr *MockAccessResponderMockRecorder) ToMap() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""ToMap"", reflect.TypeOf((*MockAccessResponder)(nil).ToMap))
}
",CWE-345,154.0,0
"// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ory/fosite/handler/oauth2 (interfaces: AccessTokenStorage)
// Package internal is a generated GoMock package.
package internal
import (
	context ""context""
	reflect ""reflect""
	gomock ""github.com/golang/mock/gomock""
	fosite ""github.com/ory/fosite""
)
// MockAccessTokenStorage is a mock of AccessTokenStorage interface
type MockAccessTokenStorage struct {
	ctrl     *gomock.Controller
	recorder *MockAccessTokenStorageMockRecorder
}
// MockAccessTokenStorageMockRecorder is the mock recorder for MockAccessTokenStorage
type MockAccessTokenStorageMockRecorder struct {
	mock *MockAccessTokenStorage
}
// NewMockAccessTokenStorage creates a new mock instance
func NewMockAccessTokenStorage(ctrl *gomock.Controller) *MockAccessTokenStorage {
	mock := &MockAccessTokenStorage{ctrl: ctrl}
	mock.recorder = &MockAccessTokenStorageMockRecorder{mock}
	return mock
}
// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockAccessTokenStorage) EXPECT() *MockAccessTokenStorageMockRecorder {
	return m.recorder
}
// CreateAccessTokenSession mocks base method
func (m *MockAccessTokenStorage) CreateAccessTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""CreateAccessTokenSession"", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}
// CreateAccessTokenSession indicates an expected call of CreateAccessTokenSession
func (mr *MockAccessTokenStorageMockRecorder) CreateAccessTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""CreateAccessTokenSession"", reflect.TypeOf((*MockAccessTokenStorage)(nil).CreateAccessTokenSession), arg0, arg1, arg2)
}
// DeleteAccessTokenSession mocks base method
func (m *MockAccessTokenStorage) DeleteAccessTokenSession(arg0 context.Context, arg1 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""DeleteAccessTokenSession"", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}
// DeleteAccessTokenSession indicates an expected call of DeleteAccessTokenSession
func (mr *MockAccessTokenStorageMockRecorder) DeleteAccessTokenSession(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""DeleteAccessTokenSession"", reflect.TypeOf((*MockAccessTokenStorage)(nil).DeleteAccessTokenSession), arg0, arg1)
}
// GetAccessTokenSession mocks base method
func (m *MockAccessTokenStorage) GetAccessTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Session) (fosite.Requester, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""GetAccessTokenSession"", arg0, arg1, arg2)
	ret0, _ := ret[0].(fosite.Requester)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}
// GetAccessTokenSession indicates an expected call of GetAccessTokenSession
func (mr *MockAccessTokenStorageMockRecorder) GetAccessTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetAccessTokenSession"", reflect.TypeOf((*MockAccessTokenStorage)(nil).GetAccessTokenSession), arg0, arg1, arg2)
}
",CWE-345,81.0,0
"// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ory/fosite/handler/oauth2 (interfaces: AccessTokenStrategy)
// Package internal is a generated GoMock package.
package internal
import (
	context ""context""
	reflect ""reflect""
	gomock ""github.com/golang/mock/gomock""
	fosite ""github.com/ory/fosite""
)
// MockAccessTokenStrategy is a mock of AccessTokenStrategy interface
type MockAccessTokenStrategy struct {
	ctrl     *gomock.Controller
	recorder *MockAccessTokenStrategyMockRecorder
}
// MockAccessTokenStrategyMockRecorder is the mock recorder for MockAccessTokenStrategy
type MockAccessTokenStrategyMockRecorder struct {
	mock *MockAccessTokenStrategy
}
// NewMockAccessTokenStrategy creates a new mock instance
func NewMockAccessTokenStrategy(ctrl *gomock.Controller) *MockAccessTokenStrategy {
	mock := &MockAccessTokenStrategy{ctrl: ctrl}
	mock.recorder = &MockAccessTokenStrategyMockRecorder{mock}
	return mock
}
// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockAccessTokenStrategy) EXPECT() *MockAccessTokenStrategyMockRecorder {
	return m.recorder
}
// AccessTokenSignature mocks base method
func (m *MockAccessTokenStrategy) AccessTokenSignature(arg0 string) string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""AccessTokenSignature"", arg0)
	ret0, _ := ret[0].(string)
	return ret0
}
// AccessTokenSignature indicates an expected call of AccessTokenSignature
func (mr *MockAccessTokenStrategyMockRecorder) AccessTokenSignature(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""AccessTokenSignature"", reflect.TypeOf((*MockAccessTokenStrategy)(nil).AccessTokenSignature), arg0)
}
// GenerateAccessToken mocks base method
func (m *MockAccessTokenStrategy) GenerateAccessToken(arg0 context.Context, arg1 fosite.Requester) (string, string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""GenerateAccessToken"", arg0, arg1)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(string)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}
// GenerateAccessToken indicates an expected call of GenerateAccessToken
func (mr *MockAccessTokenStrategyMockRecorder) GenerateAccessToken(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GenerateAccessToken"", reflect.TypeOf((*MockAccessTokenStrategy)(nil).GenerateAccessToken), arg0, arg1)
}
// ValidateAccessToken mocks base method
func (m *MockAccessTokenStrategy) ValidateAccessToken(arg0 context.Context, arg1 fosite.Requester, arg2 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""ValidateAccessToken"", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}
// ValidateAccessToken indicates an expected call of ValidateAccessToken
func (mr *MockAccessTokenStrategyMockRecorder) ValidateAccessToken(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""ValidateAccessToken"", reflect.TypeOf((*MockAccessTokenStrategy)(nil).ValidateAccessToken), arg0, arg1, arg2)
}
",CWE-345,82.0,0
"// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ory/fosite/handler/oauth2 (interfaces: AuthorizeCodeStorage)
// Package internal is a generated GoMock package.
package internal
import (
	context ""context""
	reflect ""reflect""
	gomock ""github.com/golang/mock/gomock""
	fosite ""github.com/ory/fosite""
)
// MockAuthorizeCodeStorage is a mock of AuthorizeCodeStorage interface
type MockAuthorizeCodeStorage struct {
	ctrl     *gomock.Controller
	recorder *MockAuthorizeCodeStorageMockRecorder
}
// MockAuthorizeCodeStorageMockRecorder is the mock recorder for MockAuthorizeCodeStorage
type MockAuthorizeCodeStorageMockRecorder struct {
	mock *MockAuthorizeCodeStorage
}
// NewMockAuthorizeCodeStorage creates a new mock instance
func NewMockAuthorizeCodeStorage(ctrl *gomock.Controller) *MockAuthorizeCodeStorage {
	mock := &MockAuthorizeCodeStorage{ctrl: ctrl}
	mock.recorder = &MockAuthorizeCodeStorageMockRecorder{mock}
	return mock
}
// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockAuthorizeCodeStorage) EXPECT() *MockAuthorizeCodeStorageMockRecorder {
	return m.recorder
}
// CreateAuthorizeCodeSession mocks base method
func (m *MockAuthorizeCodeStorage) CreateAuthorizeCodeSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""CreateAuthorizeCodeSession"", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}
// CreateAuthorizeCodeSession indicates an expected call of CreateAuthorizeCodeSession
func (mr *MockAuthorizeCodeStorageMockRecorder) CreateAuthorizeCodeSession(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""CreateAuthorizeCodeSession"", reflect.TypeOf((*MockAuthorizeCodeStorage)(nil).CreateAuthorizeCodeSession), arg0, arg1, arg2)
}
// GetAuthorizeCodeSession mocks base method
func (m *MockAuthorizeCodeStorage) GetAuthorizeCodeSession(arg0 context.Context, arg1 string, arg2 fosite.Session) (fosite.Requester, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""GetAuthorizeCodeSession"", arg0, arg1, arg2)
	ret0, _ := ret[0].(fosite.Requester)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}
// GetAuthorizeCodeSession indicates an expected call of GetAuthorizeCodeSession
func (mr *MockAuthorizeCodeStorageMockRecorder) GetAuthorizeCodeSession(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetAuthorizeCodeSession"", reflect.TypeOf((*MockAuthorizeCodeStorage)(nil).GetAuthorizeCodeSession), arg0, arg1, arg2)
}
// InvalidateAuthorizeCodeSession mocks base method
func (m *MockAuthorizeCodeStorage) InvalidateAuthorizeCodeSession(arg0 context.Context, arg1 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""InvalidateAuthorizeCodeSession"", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}
// InvalidateAuthorizeCodeSession indicates an expected call of InvalidateAuthorizeCodeSession
func (mr *MockAuthorizeCodeStorageMockRecorder) InvalidateAuthorizeCodeSession(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""InvalidateAuthorizeCodeSession"", reflect.TypeOf((*MockAuthorizeCodeStorage)(nil).InvalidateAuthorizeCodeSession), arg0, arg1)
}
",CWE-345,81.0,0
"// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ory/fosite/handler/oauth2 (interfaces: AuthorizeCodeStrategy)
// Package internal is a generated GoMock package.
package internal
import (
	context ""context""
	reflect ""reflect""
	gomock ""github.com/golang/mock/gomock""
	fosite ""github.com/ory/fosite""
)
// MockAuthorizeCodeStrategy is a mock of AuthorizeCodeStrategy interface
type MockAuthorizeCodeStrategy struct {
	ctrl     *gomock.Controller
	recorder *MockAuthorizeCodeStrategyMockRecorder
}
// MockAuthorizeCodeStrategyMockRecorder is the mock recorder for MockAuthorizeCodeStrategy
type MockAuthorizeCodeStrategyMockRecorder struct {
	mock *MockAuthorizeCodeStrategy
}
// NewMockAuthorizeCodeStrategy creates a new mock instance
func NewMockAuthorizeCodeStrategy(ctrl *gomock.Controller) *MockAuthorizeCodeStrategy {
	mock := &MockAuthorizeCodeStrategy{ctrl: ctrl}
	mock.recorder = &MockAuthorizeCodeStrategyMockRecorder{mock}
	return mock
}
// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockAuthorizeCodeStrategy) EXPECT() *MockAuthorizeCodeStrategyMockRecorder {
	return m.recorder
}
// AuthorizeCodeSignature mocks base method
func (m *MockAuthorizeCodeStrategy) AuthorizeCodeSignature(arg0 string) string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""AuthorizeCodeSignature"", arg0)
	ret0, _ := ret[0].(string)
	return ret0
}
// AuthorizeCodeSignature indicates an expected call of AuthorizeCodeSignature
func (mr *MockAuthorizeCodeStrategyMockRecorder) AuthorizeCodeSignature(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""AuthorizeCodeSignature"", reflect.TypeOf((*MockAuthorizeCodeStrategy)(nil).AuthorizeCodeSignature), arg0)
}
// GenerateAuthorizeCode mocks base method
func (m *MockAuthorizeCodeStrategy) GenerateAuthorizeCode(arg0 context.Context, arg1 fosite.Requester) (string, string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""GenerateAuthorizeCode"", arg0, arg1)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(string)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}
// GenerateAuthorizeCode indicates an expected call of GenerateAuthorizeCode
func (mr *MockAuthorizeCodeStrategyMockRecorder) GenerateAuthorizeCode(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GenerateAuthorizeCode"", reflect.TypeOf((*MockAuthorizeCodeStrategy)(nil).GenerateAuthorizeCode), arg0, arg1)
}
// ValidateAuthorizeCode mocks base method
func (m *MockAuthorizeCodeStrategy) ValidateAuthorizeCode(arg0 context.Context, arg1 fosite.Requester, arg2 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""ValidateAuthorizeCode"", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}
// ValidateAuthorizeCode indicates an expected call of ValidateAuthorizeCode
func (mr *MockAuthorizeCodeStrategyMockRecorder) ValidateAuthorizeCode(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""ValidateAuthorizeCode"", reflect.TypeOf((*MockAuthorizeCodeStrategy)(nil).ValidateAuthorizeCode), arg0, arg1, arg2)
}
",CWE-345,82.0,0
"// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ory/fosite (interfaces: AuthorizeEndpointHandler)
// Package internal is a generated GoMock package.
package internal
import (
	context ""context""
	reflect ""reflect""
	gomock ""github.com/golang/mock/gomock""
	fosite ""github.com/ory/fosite""
)
// MockAuthorizeEndpointHandler is a mock of AuthorizeEndpointHandler interface
type MockAuthorizeEndpointHandler struct {
	ctrl     *gomock.Controller
	recorder *MockAuthorizeEndpointHandlerMockRecorder
}
// MockAuthorizeEndpointHandlerMockRecorder is the mock recorder for MockAuthorizeEndpointHandler
type MockAuthorizeEndpointHandlerMockRecorder struct {
	mock *MockAuthorizeEndpointHandler
}
// NewMockAuthorizeEndpointHandler creates a new mock instance
func NewMockAuthorizeEndpointHandler(ctrl *gomock.Controller) *MockAuthorizeEndpointHandler {
	mock := &MockAuthorizeEndpointHandler{ctrl: ctrl}
	mock.recorder = &MockAuthorizeEndpointHandlerMockRecorder{mock}
	return mock
}
// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockAuthorizeEndpointHandler) EXPECT() *MockAuthorizeEndpointHandlerMockRecorder {
	return m.recorder
}
// HandleAuthorizeEndpointRequest mocks base method
func (m *MockAuthorizeEndpointHandler) HandleAuthorizeEndpointRequest(arg0 context.Context, arg1 fosite.AuthorizeRequester, arg2 fosite.AuthorizeResponder) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""HandleAuthorizeEndpointRequest"", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}
// HandleAuthorizeEndpointRequest indicates an expected call of HandleAuthorizeEndpointRequest
func (mr *MockAuthorizeEndpointHandlerMockRecorder) HandleAuthorizeEndpointRequest(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""HandleAuthorizeEndpointRequest"", reflect.TypeOf((*MockAuthorizeEndpointHandler)(nil).HandleAuthorizeEndpointRequest), arg0, arg1, arg2)
}
",CWE-345,52.0,0
"// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ory/fosite (interfaces: AuthorizeResponder)
// Package internal is a generated GoMock package.
package internal
import (
	http ""net/http""
	url ""net/url""
	reflect ""reflect""
	gomock ""github.com/golang/mock/gomock""
)
// MockAuthorizeResponder is a mock of AuthorizeResponder interface
type MockAuthorizeResponder struct {
	ctrl     *gomock.Controller
	recorder *MockAuthorizeResponderMockRecorder
}
// MockAuthorizeResponderMockRecorder is the mock recorder for MockAuthorizeResponder
type MockAuthorizeResponderMockRecorder struct {
	mock *MockAuthorizeResponder
}
// NewMockAuthorizeResponder creates a new mock instance
func NewMockAuthorizeResponder(ctrl *gomock.Controller) *MockAuthorizeResponder {
	mock := &MockAuthorizeResponder{ctrl: ctrl}
	mock.recorder = &MockAuthorizeResponderMockRecorder{mock}
	return mock
}
// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockAuthorizeResponder) EXPECT() *MockAuthorizeResponderMockRecorder {
	return m.recorder
}
// AddFragment mocks base method
func (m *MockAuthorizeResponder) AddFragment(arg0, arg1 string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, ""AddFragment"", arg0, arg1)
}
// AddFragment indicates an expected call of AddFragment
func (mr *MockAuthorizeResponderMockRecorder) AddFragment(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""AddFragment"", reflect.TypeOf((*MockAuthorizeResponder)(nil).AddFragment), arg0, arg1)
}
// AddHeader mocks base method
func (m *MockAuthorizeResponder) AddHeader(arg0, arg1 string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, ""AddHeader"", arg0, arg1)
}
// AddHeader indicates an expected call of AddHeader
func (mr *MockAuthorizeResponderMockRecorder) AddHeader(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""AddHeader"", reflect.TypeOf((*MockAuthorizeResponder)(nil).AddHeader), arg0, arg1)
}
// AddQuery mocks base method
func (m *MockAuthorizeResponder) AddQuery(arg0, arg1 string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, ""AddQuery"", arg0, arg1)
}
// AddQuery indicates an expected call of AddQuery
func (mr *MockAuthorizeResponderMockRecorder) AddQuery(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""AddQuery"", reflect.TypeOf((*MockAuthorizeResponder)(nil).AddQuery), arg0, arg1)
}
// GetCode mocks base method
func (m *MockAuthorizeResponder) GetCode() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""GetCode"")
	ret0, _ := ret[0].(string)
	return ret0
}
// GetCode indicates an expected call of GetCode
func (mr *MockAuthorizeResponderMockRecorder) GetCode() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetCode"", reflect.TypeOf((*MockAuthorizeResponder)(nil).GetCode))
}
// GetFragment mocks base method
func (m *MockAuthorizeResponder) GetFragment() url.Values {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""GetFragment"")
	ret0, _ := ret[0].(url.Values)
	return ret0
}
// GetFragment indicates an expected call of GetFragment
func (mr *MockAuthorizeResponderMockRecorder) GetFragment() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetFragment"", reflect.TypeOf((*MockAuthorizeResponder)(nil).GetFragment))
}
// GetHeader mocks base method
func (m *MockAuthorizeResponder) GetHeader() http.Header {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""GetHeader"")
	ret0, _ := ret[0].(http.Header)
	return ret0
}
// GetHeader indicates an expected call of GetHeader
func (mr *MockAuthorizeResponderMockRecorder) GetHeader() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetHeader"", reflect.TypeOf((*MockAuthorizeResponder)(nil).GetHeader))
}
// GetQuery mocks base method
func (m *MockAuthorizeResponder) GetQuery() url.Values {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""GetQuery"")
	ret0, _ := ret[0].(url.Values)
	return ret0
}
// GetQuery indicates an expected call of GetQuery
func (mr *MockAuthorizeResponderMockRecorder) GetQuery() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetQuery"", reflect.TypeOf((*MockAuthorizeResponder)(nil).GetQuery))
}
",CWE-345,129.0,0
"// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ory/fosite (interfaces: Client)
// Package internal is a generated GoMock package.
package internal
import (
	reflect ""reflect""
	gomock ""github.com/golang/mock/gomock""
	fosite ""github.com/ory/fosite""
)
// MockClient is a mock of Client interface
type MockClient struct {
	ctrl     *gomock.Controller
	recorder *MockClientMockRecorder
}
// MockClientMockRecorder is the mock recorder for MockClient
type MockClientMockRecorder struct {
	mock *MockClient
}
// NewMockClient creates a new mock instance
func NewMockClient(ctrl *gomock.Controller) *MockClient {
	mock := &MockClient{ctrl: ctrl}
	mock.recorder = &MockClientMockRecorder{mock}
	return mock
}
// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockClient) EXPECT() *MockClientMockRecorder {
	return m.recorder
}
// GetAudience mocks base method
func (m *MockClient) GetAudience() fosite.Arguments {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""GetAudience"")
	ret0, _ := ret[0].(fosite.Arguments)
	return ret0
}
// GetAudience indicates an expected call of GetAudience
func (mr *MockClientMockRecorder) GetAudience() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetAudience"", reflect.TypeOf((*MockClient)(nil).GetAudience))
}
// GetGrantTypes mocks base method
func (m *MockClient) GetGrantTypes() fosite.Arguments {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""GetGrantTypes"")
	ret0, _ := ret[0].(fosite.Arguments)
	return ret0
}
// GetGrantTypes indicates an expected call of GetGrantTypes
func (mr *MockClientMockRecorder) GetGrantTypes() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetGrantTypes"", reflect.TypeOf((*MockClient)(nil).GetGrantTypes))
}
// GetHashedSecret mocks base method
func (m *MockClient) GetHashedSecret() []byte {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""GetHashedSecret"")
	ret0, _ := ret[0].([]byte)
	return ret0
}
// GetHashedSecret indicates an expected call of GetHashedSecret
func (mr *MockClientMockRecorder) GetHashedSecret() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetHashedSecret"", reflect.TypeOf((*MockClient)(nil).GetHashedSecret))
}
// GetID mocks base method
func (m *MockClient) GetID() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""GetID"")
	ret0, _ := ret[0].(string)
	return ret0
}
// GetID indicates an expected call of GetID
func (mr *MockClientMockRecorder) GetID() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetID"", reflect.TypeOf((*MockClient)(nil).GetID))
}
// GetRedirectURIs mocks base method
func (m *MockClient) GetRedirectURIs() []string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""GetRedirectURIs"")
	ret0, _ := ret[0].([]string)
	return ret0
}
// GetRedirectURIs indicates an expected call of GetRedirectURIs
func (mr *MockClientMockRecorder) GetRedirectURIs() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetRedirectURIs"", reflect.TypeOf((*MockClient)(nil).GetRedirectURIs))
}
// GetResponseTypes mocks base method
func (m *MockClient) GetResponseTypes() fosite.Arguments {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""GetResponseTypes"")
	ret0, _ := ret[0].(fosite.Arguments)
	return ret0
}
// GetResponseTypes indicates an expected call of GetResponseTypes
func (mr *MockClientMockRecorder) GetResponseTypes() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetResponseTypes"", reflect.TypeOf((*MockClient)(nil).GetResponseTypes))
}
// GetScopes mocks base method
func (m *MockClient) GetScopes() fosite.Arguments {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""GetScopes"")
	ret0, _ := ret[0].(fosite.Arguments)
	return ret0
}
// GetScopes indicates an expected call of GetScopes
func (mr *MockClientMockRecorder) GetScopes() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetScopes"", reflect.TypeOf((*MockClient)(nil).GetScopes))
}
// IsPublic mocks base method
func (m *MockClient) IsPublic() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""IsPublic"")
	ret0, _ := ret[0].(bool)
	return ret0
}
// IsPublic indicates an expected call of IsPublic
func (mr *MockClientMockRecorder) IsPublic() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""IsPublic"", reflect.TypeOf((*MockClient)(nil).IsPublic))
}
",CWE-345,149.0,0
"// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ory/fosite (interfaces: Hasher)
// Package internal is a generated GoMock package.
package internal
import (
	context ""context""
	reflect ""reflect""
	gomock ""github.com/golang/mock/gomock""
)
// MockHasher is a mock of Hasher interface
type MockHasher struct {
	ctrl     *gomock.Controller
	recorder *MockHasherMockRecorder
}
// MockHasherMockRecorder is the mock recorder for MockHasher
type MockHasherMockRecorder struct {
	mock *MockHasher
}
// NewMockHasher creates a new mock instance
func NewMockHasher(ctrl *gomock.Controller) *MockHasher {
	mock := &MockHasher{ctrl: ctrl}
	mock.recorder = &MockHasherMockRecorder{mock}
	return mock
}
// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockHasher) EXPECT() *MockHasherMockRecorder {
	return m.recorder
}
// Compare mocks base method
func (m *MockHasher) Compare(arg0 context.Context, arg1, arg2 []byte) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""Compare"", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}
// Compare indicates an expected call of Compare
func (mr *MockHasherMockRecorder) Compare(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""Compare"", reflect.TypeOf((*MockHasher)(nil).Compare), arg0, arg1, arg2)
}
// Hash mocks base method
func (m *MockHasher) Hash(arg0 context.Context, arg1 []byte) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""Hash"", arg0, arg1)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}
// Hash indicates an expected call of Hash
func (mr *MockHasherMockRecorder) Hash(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""Hash"", reflect.TypeOf((*MockHasher)(nil).Hash), arg0, arg1)
}
",CWE-345,65.0,0
"// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ory/fosite/handler/openid (interfaces: OpenIDConnectTokenStrategy)
// Package internal is a generated GoMock package.
package internal
import (
	context ""context""
	reflect ""reflect""
	gomock ""github.com/golang/mock/gomock""
	fosite ""github.com/ory/fosite""
)
// MockOpenIDConnectTokenStrategy is a mock of OpenIDConnectTokenStrategy interface
type MockOpenIDConnectTokenStrategy struct {
	ctrl     *gomock.Controller
	recorder *MockOpenIDConnectTokenStrategyMockRecorder
}
// MockOpenIDConnectTokenStrategyMockRecorder is the mock recorder for MockOpenIDConnectTokenStrategy
type MockOpenIDConnectTokenStrategyMockRecorder struct {
	mock *MockOpenIDConnectTokenStrategy
}
// NewMockOpenIDConnectTokenStrategy creates a new mock instance
func NewMockOpenIDConnectTokenStrategy(ctrl *gomock.Controller) *MockOpenIDConnectTokenStrategy {
	mock := &MockOpenIDConnectTokenStrategy{ctrl: ctrl}
	mock.recorder = &MockOpenIDConnectTokenStrategyMockRecorder{mock}
	return mock
}
// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockOpenIDConnectTokenStrategy) EXPECT() *MockOpenIDConnectTokenStrategyMockRecorder {
	return m.recorder
}
// GenerateIDToken mocks base method
func (m *MockOpenIDConnectTokenStrategy) GenerateIDToken(arg0 context.Context, arg1 fosite.Requester) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""GenerateIDToken"", arg0, arg1)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}
// GenerateIDToken indicates an expected call of GenerateIDToken
func (mr *MockOpenIDConnectTokenStrategyMockRecorder) GenerateIDToken(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GenerateIDToken"", reflect.TypeOf((*MockOpenIDConnectTokenStrategy)(nil).GenerateIDToken), arg0, arg1)
}
",CWE-345,53.0,0
"// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ory/fosite (interfaces: TokenIntrospector)
// Package internal is a generated GoMock package.
package internal
import (
	context ""context""
	reflect ""reflect""
	gomock ""github.com/golang/mock/gomock""
	fosite ""github.com/ory/fosite""
)
// MockTokenIntrospector is a mock of TokenIntrospector interface
type MockTokenIntrospector struct {
	ctrl     *gomock.Controller
	recorder *MockTokenIntrospectorMockRecorder
}
// MockTokenIntrospectorMockRecorder is the mock recorder for MockTokenIntrospector
type MockTokenIntrospectorMockRecorder struct {
	mock *MockTokenIntrospector
}
// NewMockTokenIntrospector creates a new mock instance
func NewMockTokenIntrospector(ctrl *gomock.Controller) *MockTokenIntrospector {
	mock := &MockTokenIntrospector{ctrl: ctrl}
	mock.recorder = &MockTokenIntrospectorMockRecorder{mock}
	return mock
}
// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockTokenIntrospector) EXPECT() *MockTokenIntrospectorMockRecorder {
	return m.recorder
}
// IntrospectToken mocks base method
func (m *MockTokenIntrospector) IntrospectToken(arg0 context.Context, arg1 string, arg2 fosite.TokenType, arg3 fosite.AccessRequester, arg4 []string) (fosite.TokenType, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""IntrospectToken"", arg0, arg1, arg2, arg3, arg4)
	ret0, _ := ret[0].(fosite.TokenType)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}
// IntrospectToken indicates an expected call of IntrospectToken
func (mr *MockTokenIntrospectorMockRecorder) IntrospectToken(arg0, arg1, arg2, arg3, arg4 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""IntrospectToken"", reflect.TypeOf((*MockTokenIntrospector)(nil).IntrospectToken), arg0, arg1, arg2, arg3, arg4)
}
",CWE-345,53.0,0
"// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ory/fosite/handler/oauth2 (interfaces: ClientCredentialsGrantStorage)
// Package internal is a generated GoMock package.
package internal
import (
	context ""context""
	reflect ""reflect""
	gomock ""github.com/golang/mock/gomock""
	fosite ""github.com/ory/fosite""
)
// MockClientCredentialsGrantStorage is a mock of ClientCredentialsGrantStorage interface
type MockClientCredentialsGrantStorage struct {
	ctrl     *gomock.Controller
	recorder *MockClientCredentialsGrantStorageMockRecorder
}
// MockClientCredentialsGrantStorageMockRecorder is the mock recorder for MockClientCredentialsGrantStorage
type MockClientCredentialsGrantStorageMockRecorder struct {
	mock *MockClientCredentialsGrantStorage
}
// NewMockClientCredentialsGrantStorage creates a new mock instance
func NewMockClientCredentialsGrantStorage(ctrl *gomock.Controller) *MockClientCredentialsGrantStorage {
	mock := &MockClientCredentialsGrantStorage{ctrl: ctrl}
	mock.recorder = &MockClientCredentialsGrantStorageMockRecorder{mock}
	return mock
}
// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockClientCredentialsGrantStorage) EXPECT() *MockClientCredentialsGrantStorageMockRecorder {
	return m.recorder
}
// CreateAccessTokenSession mocks base method
func (m *MockClientCredentialsGrantStorage) CreateAccessTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""CreateAccessTokenSession"", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}
// CreateAccessTokenSession indicates an expected call of CreateAccessTokenSession
func (mr *MockClientCredentialsGrantStorageMockRecorder) CreateAccessTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""CreateAccessTokenSession"", reflect.TypeOf((*MockClientCredentialsGrantStorage)(nil).CreateAccessTokenSession), arg0, arg1, arg2)
}
// DeleteAccessTokenSession mocks base method
func (m *MockClientCredentialsGrantStorage) DeleteAccessTokenSession(arg0 context.Context, arg1 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""DeleteAccessTokenSession"", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}
// DeleteAccessTokenSession indicates an expected call of DeleteAccessTokenSession
func (mr *MockClientCredentialsGrantStorageMockRecorder) DeleteAccessTokenSession(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""DeleteAccessTokenSession"", reflect.TypeOf((*MockClientCredentialsGrantStorage)(nil).DeleteAccessTokenSession), arg0, arg1)
}
// GetAccessTokenSession mocks base method
func (m *MockClientCredentialsGrantStorage) GetAccessTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Session) (fosite.Requester, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""GetAccessTokenSession"", arg0, arg1, arg2)
	ret0, _ := ret[0].(fosite.Requester)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}
// GetAccessTokenSession indicates an expected call of GetAccessTokenSession
func (mr *MockClientCredentialsGrantStorageMockRecorder) GetAccessTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetAccessTokenSession"", reflect.TypeOf((*MockClientCredentialsGrantStorage)(nil).GetAccessTokenSession), arg0, arg1, arg2)
}
",CWE-345,81.0,0
"// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ory/fosite/handler/oauth2 (interfaces: ResourceOwnerPasswordCredentialsGrantStorage)
// Package internal is a generated GoMock package.
package internal
import (
	context ""context""
	reflect ""reflect""
	gomock ""github.com/golang/mock/gomock""
	fosite ""github.com/ory/fosite""
)
// MockResourceOwnerPasswordCredentialsGrantStorage is a mock of ResourceOwnerPasswordCredentialsGrantStorage interface
type MockResourceOwnerPasswordCredentialsGrantStorage struct {
	ctrl     *gomock.Controller
	recorder *MockResourceOwnerPasswordCredentialsGrantStorageMockRecorder
}
// MockResourceOwnerPasswordCredentialsGrantStorageMockRecorder is the mock recorder for MockResourceOwnerPasswordCredentialsGrantStorage
type MockResourceOwnerPasswordCredentialsGrantStorageMockRecorder struct {
	mock *MockResourceOwnerPasswordCredentialsGrantStorage
}
// NewMockResourceOwnerPasswordCredentialsGrantStorage creates a new mock instance
func NewMockResourceOwnerPasswordCredentialsGrantStorage(ctrl *gomock.Controller) *MockResourceOwnerPasswordCredentialsGrantStorage {
	mock := &MockResourceOwnerPasswordCredentialsGrantStorage{ctrl: ctrl}
	mock.recorder = &MockResourceOwnerPasswordCredentialsGrantStorageMockRecorder{mock}
	return mock
}
// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockResourceOwnerPasswordCredentialsGrantStorage) EXPECT() *MockResourceOwnerPasswordCredentialsGrantStorageMockRecorder {
	return m.recorder
}
// Authenticate mocks base method
func (m *MockResourceOwnerPasswordCredentialsGrantStorage) Authenticate(arg0 context.Context, arg1, arg2 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""Authenticate"", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}
// Authenticate indicates an expected call of Authenticate
func (mr *MockResourceOwnerPasswordCredentialsGrantStorageMockRecorder) Authenticate(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""Authenticate"", reflect.TypeOf((*MockResourceOwnerPasswordCredentialsGrantStorage)(nil).Authenticate), arg0, arg1, arg2)
}
// CreateAccessTokenSession mocks base method
func (m *MockResourceOwnerPasswordCredentialsGrantStorage) CreateAccessTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""CreateAccessTokenSession"", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}
// CreateAccessTokenSession indicates an expected call of CreateAccessTokenSession
func (mr *MockResourceOwnerPasswordCredentialsGrantStorageMockRecorder) CreateAccessTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""CreateAccessTokenSession"", reflect.TypeOf((*MockResourceOwnerPasswordCredentialsGrantStorage)(nil).CreateAccessTokenSession), arg0, arg1, arg2)
}
// CreateRefreshTokenSession mocks base method
func (m *MockResourceOwnerPasswordCredentialsGrantStorage) CreateRefreshTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""CreateRefreshTokenSession"", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}
// CreateRefreshTokenSession indicates an expected call of CreateRefreshTokenSession
func (mr *MockResourceOwnerPasswordCredentialsGrantStorageMockRecorder) CreateRefreshTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""CreateRefreshTokenSession"", reflect.TypeOf((*MockResourceOwnerPasswordCredentialsGrantStorage)(nil).CreateRefreshTokenSession), arg0, arg1, arg2)
}
// DeleteAccessTokenSession mocks base method
func (m *MockResourceOwnerPasswordCredentialsGrantStorage) DeleteAccessTokenSession(arg0 context.Context, arg1 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""DeleteAccessTokenSession"", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}
// DeleteAccessTokenSession indicates an expected call of DeleteAccessTokenSession
func (mr *MockResourceOwnerPasswordCredentialsGrantStorageMockRecorder) DeleteAccessTokenSession(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""DeleteAccessTokenSession"", reflect.TypeOf((*MockResourceOwnerPasswordCredentialsGrantStorage)(nil).DeleteAccessTokenSession), arg0, arg1)
}
// DeleteRefreshTokenSession mocks base method
func (m *MockResourceOwnerPasswordCredentialsGrantStorage) DeleteRefreshTokenSession(arg0 context.Context, arg1 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""DeleteRefreshTokenSession"", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}
// DeleteRefreshTokenSession indicates an expected call of DeleteRefreshTokenSession
func (mr *MockResourceOwnerPasswordCredentialsGrantStorageMockRecorder) DeleteRefreshTokenSession(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""DeleteRefreshTokenSession"", reflect.TypeOf((*MockResourceOwnerPasswordCredentialsGrantStorage)(nil).DeleteRefreshTokenSession), arg0, arg1)
}
// GetAccessTokenSession mocks base method
func (m *MockResourceOwnerPasswordCredentialsGrantStorage) GetAccessTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Session) (fosite.Requester, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""GetAccessTokenSession"", arg0, arg1, arg2)
	ret0, _ := ret[0].(fosite.Requester)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}
// GetAccessTokenSession indicates an expected call of GetAccessTokenSession
func (mr *MockResourceOwnerPasswordCredentialsGrantStorageMockRecorder) GetAccessTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetAccessTokenSession"", reflect.TypeOf((*MockResourceOwnerPasswordCredentialsGrantStorage)(nil).GetAccessTokenSession), arg0, arg1, arg2)
}
// GetRefreshTokenSession mocks base method
func (m *MockResourceOwnerPasswordCredentialsGrantStorage) GetRefreshTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Session) (fosite.Requester, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""GetRefreshTokenSession"", arg0, arg1, arg2)
	ret0, _ := ret[0].(fosite.Requester)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}
// GetRefreshTokenSession indicates an expected call of GetRefreshTokenSession
func (mr *MockResourceOwnerPasswordCredentialsGrantStorageMockRecorder) GetRefreshTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetRefreshTokenSession"", reflect.TypeOf((*MockResourceOwnerPasswordCredentialsGrantStorage)(nil).GetRefreshTokenSession), arg0, arg1, arg2)
}
",CWE-345,138.0,0
"// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ory/fosite/handler/oauth2 (interfaces: TokenRevocationStorage)
// Package internal is a generated GoMock package.
package internal
import (
	context ""context""
	reflect ""reflect""
	gomock ""github.com/golang/mock/gomock""
	fosite ""github.com/ory/fosite""
)
// MockTokenRevocationStorage is a mock of TokenRevocationStorage interface
type MockTokenRevocationStorage struct {
	ctrl     *gomock.Controller
	recorder *MockTokenRevocationStorageMockRecorder
}
// MockTokenRevocationStorageMockRecorder is the mock recorder for MockTokenRevocationStorage
type MockTokenRevocationStorageMockRecorder struct {
	mock *MockTokenRevocationStorage
}
// NewMockTokenRevocationStorage creates a new mock instance
func NewMockTokenRevocationStorage(ctrl *gomock.Controller) *MockTokenRevocationStorage {
	mock := &MockTokenRevocationStorage{ctrl: ctrl}
	mock.recorder = &MockTokenRevocationStorageMockRecorder{mock}
	return mock
}
// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockTokenRevocationStorage) EXPECT() *MockTokenRevocationStorageMockRecorder {
	return m.recorder
}
// CreateAccessTokenSession mocks base method
func (m *MockTokenRevocationStorage) CreateAccessTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""CreateAccessTokenSession"", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}
// CreateAccessTokenSession indicates an expected call of CreateAccessTokenSession
func (mr *MockTokenRevocationStorageMockRecorder) CreateAccessTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""CreateAccessTokenSession"", reflect.TypeOf((*MockTokenRevocationStorage)(nil).CreateAccessTokenSession), arg0, arg1, arg2)
}
// CreateRefreshTokenSession mocks base method
func (m *MockTokenRevocationStorage) CreateRefreshTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""CreateRefreshTokenSession"", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}
// CreateRefreshTokenSession indicates an expected call of CreateRefreshTokenSession
func (mr *MockTokenRevocationStorageMockRecorder) CreateRefreshTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""CreateRefreshTokenSession"", reflect.TypeOf((*MockTokenRevocationStorage)(nil).CreateRefreshTokenSession), arg0, arg1, arg2)
}
// DeleteAccessTokenSession mocks base method
func (m *MockTokenRevocationStorage) DeleteAccessTokenSession(arg0 context.Context, arg1 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""DeleteAccessTokenSession"", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}
// DeleteAccessTokenSession indicates an expected call of DeleteAccessTokenSession
func (mr *MockTokenRevocationStorageMockRecorder) DeleteAccessTokenSession(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""DeleteAccessTokenSession"", reflect.TypeOf((*MockTokenRevocationStorage)(nil).DeleteAccessTokenSession), arg0, arg1)
}
// DeleteRefreshTokenSession mocks base method
func (m *MockTokenRevocationStorage) DeleteRefreshTokenSession(arg0 context.Context, arg1 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""DeleteRefreshTokenSession"", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}
// DeleteRefreshTokenSession indicates an expected call of DeleteRefreshTokenSession
func (mr *MockTokenRevocationStorageMockRecorder) DeleteRefreshTokenSession(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""DeleteRefreshTokenSession"", reflect.TypeOf((*MockTokenRevocationStorage)(nil).DeleteRefreshTokenSession), arg0, arg1)
}
// GetAccessTokenSession mocks base method
func (m *MockTokenRevocationStorage) GetAccessTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Session) (fosite.Requester, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""GetAccessTokenSession"", arg0, arg1, arg2)
	ret0, _ := ret[0].(fosite.Requester)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}
// GetAccessTokenSession indicates an expected call of GetAccessTokenSession
func (mr *MockTokenRevocationStorageMockRecorder) GetAccessTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetAccessTokenSession"", reflect.TypeOf((*MockTokenRevocationStorage)(nil).GetAccessTokenSession), arg0, arg1, arg2)
}
// GetRefreshTokenSession mocks base method
func (m *MockTokenRevocationStorage) GetRefreshTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Session) (fosite.Requester, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""GetRefreshTokenSession"", arg0, arg1, arg2)
	ret0, _ := ret[0].(fosite.Requester)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}
// GetRefreshTokenSession indicates an expected call of GetRefreshTokenSession
func (mr *MockTokenRevocationStorageMockRecorder) GetRefreshTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetRefreshTokenSession"", reflect.TypeOf((*MockTokenRevocationStorage)(nil).GetRefreshTokenSession), arg0, arg1, arg2)
}
// RevokeAccessToken mocks base method
func (m *MockTokenRevocationStorage) RevokeAccessToken(arg0 context.Context, arg1 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""RevokeAccessToken"", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}
// RevokeAccessToken indicates an expected call of RevokeAccessToken
func (mr *MockTokenRevocationStorageMockRecorder) RevokeAccessToken(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""RevokeAccessToken"", reflect.TypeOf((*MockTokenRevocationStorage)(nil).RevokeAccessToken), arg0, arg1)
}
// RevokeRefreshToken mocks base method
func (m *MockTokenRevocationStorage) RevokeRefreshToken(arg0 context.Context, arg1 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""RevokeRefreshToken"", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}
// RevokeRefreshToken indicates an expected call of RevokeRefreshToken
func (mr *MockTokenRevocationStorageMockRecorder) RevokeRefreshToken(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""RevokeRefreshToken"", reflect.TypeOf((*MockTokenRevocationStorage)(nil).RevokeRefreshToken), arg0, arg1)
}
",CWE-345,152.0,0
"// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ory/fosite/handler/oauth2 (interfaces: CoreStorage)
// Package internal is a generated GoMock package.
package internal
import (
	context ""context""
	reflect ""reflect""
	gomock ""github.com/golang/mock/gomock""
	fosite ""github.com/ory/fosite""
)
// MockCoreStorage is a mock of CoreStorage interface
type MockCoreStorage struct {
	ctrl     *gomock.Controller
	recorder *MockCoreStorageMockRecorder
}
// MockCoreStorageMockRecorder is the mock recorder for MockCoreStorage
type MockCoreStorageMockRecorder struct {
	mock *MockCoreStorage
}
// NewMockCoreStorage creates a new mock instance
func NewMockCoreStorage(ctrl *gomock.Controller) *MockCoreStorage {
	mock := &MockCoreStorage{ctrl: ctrl}
	mock.recorder = &MockCoreStorageMockRecorder{mock}
	return mock
}
// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockCoreStorage) EXPECT() *MockCoreStorageMockRecorder {
	return m.recorder
}
// CreateAccessTokenSession mocks base method
func (m *MockCoreStorage) CreateAccessTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""CreateAccessTokenSession"", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}
// CreateAccessTokenSession indicates an expected call of CreateAccessTokenSession
func (mr *MockCoreStorageMockRecorder) CreateAccessTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""CreateAccessTokenSession"", reflect.TypeOf((*MockCoreStorage)(nil).CreateAccessTokenSession), arg0, arg1, arg2)
}
// CreateAuthorizeCodeSession mocks base method
func (m *MockCoreStorage) CreateAuthorizeCodeSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""CreateAuthorizeCodeSession"", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}
// CreateAuthorizeCodeSession indicates an expected call of CreateAuthorizeCodeSession
func (mr *MockCoreStorageMockRecorder) CreateAuthorizeCodeSession(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""CreateAuthorizeCodeSession"", reflect.TypeOf((*MockCoreStorage)(nil).CreateAuthorizeCodeSession), arg0, arg1, arg2)
}
// CreateRefreshTokenSession mocks base method
func (m *MockCoreStorage) CreateRefreshTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""CreateRefreshTokenSession"", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}
// CreateRefreshTokenSession indicates an expected call of CreateRefreshTokenSession
func (mr *MockCoreStorageMockRecorder) CreateRefreshTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""CreateRefreshTokenSession"", reflect.TypeOf((*MockCoreStorage)(nil).CreateRefreshTokenSession), arg0, arg1, arg2)
}
// DeleteAccessTokenSession mocks base method
func (m *MockCoreStorage) DeleteAccessTokenSession(arg0 context.Context, arg1 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""DeleteAccessTokenSession"", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}
// DeleteAccessTokenSession indicates an expected call of DeleteAccessTokenSession
func (mr *MockCoreStorageMockRecorder) DeleteAccessTokenSession(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""DeleteAccessTokenSession"", reflect.TypeOf((*MockCoreStorage)(nil).DeleteAccessTokenSession), arg0, arg1)
}
// DeleteRefreshTokenSession mocks base method
func (m *MockCoreStorage) DeleteRefreshTokenSession(arg0 context.Context, arg1 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""DeleteRefreshTokenSession"", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}
// DeleteRefreshTokenSession indicates an expected call of DeleteRefreshTokenSession
func (mr *MockCoreStorageMockRecorder) DeleteRefreshTokenSession(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""DeleteRefreshTokenSession"", reflect.TypeOf((*MockCoreStorage)(nil).DeleteRefreshTokenSession), arg0, arg1)
}
// GetAccessTokenSession mocks base method
func (m *MockCoreStorage) GetAccessTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Session) (fosite.Requester, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""GetAccessTokenSession"", arg0, arg1, arg2)
	ret0, _ := ret[0].(fosite.Requester)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}
// GetAccessTokenSession indicates an expected call of GetAccessTokenSession
func (mr *MockCoreStorageMockRecorder) GetAccessTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetAccessTokenSession"", reflect.TypeOf((*MockCoreStorage)(nil).GetAccessTokenSession), arg0, arg1, arg2)
}
// GetAuthorizeCodeSession mocks base method
func (m *MockCoreStorage) GetAuthorizeCodeSession(arg0 context.Context, arg1 string, arg2 fosite.Session) (fosite.Requester, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""GetAuthorizeCodeSession"", arg0, arg1, arg2)
	ret0, _ := ret[0].(fosite.Requester)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}
// GetAuthorizeCodeSession indicates an expected call of GetAuthorizeCodeSession
func (mr *MockCoreStorageMockRecorder) GetAuthorizeCodeSession(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetAuthorizeCodeSession"", reflect.TypeOf((*MockCoreStorage)(nil).GetAuthorizeCodeSession), arg0, arg1, arg2)
}
// GetRefreshTokenSession mocks base method
func (m *MockCoreStorage) GetRefreshTokenSession(arg0 context.Context, arg1 string, arg2 fosite.Session) (fosite.Requester, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""GetRefreshTokenSession"", arg0, arg1, arg2)
	ret0, _ := ret[0].(fosite.Requester)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}
// GetRefreshTokenSession indicates an expected call of GetRefreshTokenSession
func (mr *MockCoreStorageMockRecorder) GetRefreshTokenSession(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetRefreshTokenSession"", reflect.TypeOf((*MockCoreStorage)(nil).GetRefreshTokenSession), arg0, arg1, arg2)
}
// InvalidateAuthorizeCodeSession mocks base method
func (m *MockCoreStorage) InvalidateAuthorizeCodeSession(arg0 context.Context, arg1 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""InvalidateAuthorizeCodeSession"", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}
// InvalidateAuthorizeCodeSession indicates an expected call of InvalidateAuthorizeCodeSession
func (mr *MockCoreStorageMockRecorder) InvalidateAuthorizeCodeSession(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""InvalidateAuthorizeCodeSession"", reflect.TypeOf((*MockCoreStorage)(nil).InvalidateAuthorizeCodeSession), arg0, arg1)
}
",CWE-345,167.0,0
"// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ory/fosite/handler/oauth2 (interfaces: CoreStrategy)
// Package internal is a generated GoMock package.
package internal
import (
	context ""context""
	reflect ""reflect""
	gomock ""github.com/golang/mock/gomock""
	fosite ""github.com/ory/fosite""
)
// MockCoreStrategy is a mock of CoreStrategy interface
type MockCoreStrategy struct {
	ctrl     *gomock.Controller
	recorder *MockCoreStrategyMockRecorder
}
// MockCoreStrategyMockRecorder is the mock recorder for MockCoreStrategy
type MockCoreStrategyMockRecorder struct {
	mock *MockCoreStrategy
}
// NewMockCoreStrategy creates a new mock instance
func NewMockCoreStrategy(ctrl *gomock.Controller) *MockCoreStrategy {
	mock := &MockCoreStrategy{ctrl: ctrl}
	mock.recorder = &MockCoreStrategyMockRecorder{mock}
	return mock
}
// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockCoreStrategy) EXPECT() *MockCoreStrategyMockRecorder {
	return m.recorder
}
// AccessTokenSignature mocks base method
func (m *MockCoreStrategy) AccessTokenSignature(arg0 string) string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""AccessTokenSignature"", arg0)
	ret0, _ := ret[0].(string)
	return ret0
}
// AccessTokenSignature indicates an expected call of AccessTokenSignature
func (mr *MockCoreStrategyMockRecorder) AccessTokenSignature(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""AccessTokenSignature"", reflect.TypeOf((*MockCoreStrategy)(nil).AccessTokenSignature), arg0)
}
// AuthorizeCodeSignature mocks base method
func (m *MockCoreStrategy) AuthorizeCodeSignature(arg0 string) string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""AuthorizeCodeSignature"", arg0)
	ret0, _ := ret[0].(string)
	return ret0
}
// AuthorizeCodeSignature indicates an expected call of AuthorizeCodeSignature
func (mr *MockCoreStrategyMockRecorder) AuthorizeCodeSignature(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""AuthorizeCodeSignature"", reflect.TypeOf((*MockCoreStrategy)(nil).AuthorizeCodeSignature), arg0)
}
// GenerateAccessToken mocks base method
func (m *MockCoreStrategy) GenerateAccessToken(arg0 context.Context, arg1 fosite.Requester) (string, string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""GenerateAccessToken"", arg0, arg1)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(string)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}
// GenerateAccessToken indicates an expected call of GenerateAccessToken
func (mr *MockCoreStrategyMockRecorder) GenerateAccessToken(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GenerateAccessToken"", reflect.TypeOf((*MockCoreStrategy)(nil).GenerateAccessToken), arg0, arg1)
}
// GenerateAuthorizeCode mocks base method
func (m *MockCoreStrategy) GenerateAuthorizeCode(arg0 context.Context, arg1 fosite.Requester) (string, string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""GenerateAuthorizeCode"", arg0, arg1)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(string)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}
// GenerateAuthorizeCode indicates an expected call of GenerateAuthorizeCode
func (mr *MockCoreStrategyMockRecorder) GenerateAuthorizeCode(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GenerateAuthorizeCode"", reflect.TypeOf((*MockCoreStrategy)(nil).GenerateAuthorizeCode), arg0, arg1)
}
// GenerateRefreshToken mocks base method
func (m *MockCoreStrategy) GenerateRefreshToken(arg0 context.Context, arg1 fosite.Requester) (string, string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""GenerateRefreshToken"", arg0, arg1)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(string)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}
// GenerateRefreshToken indicates an expected call of GenerateRefreshToken
func (mr *MockCoreStrategyMockRecorder) GenerateRefreshToken(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GenerateRefreshToken"", reflect.TypeOf((*MockCoreStrategy)(nil).GenerateRefreshToken), arg0, arg1)
}
// RefreshTokenSignature mocks base method
func (m *MockCoreStrategy) RefreshTokenSignature(arg0 string) string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""RefreshTokenSignature"", arg0)
	ret0, _ := ret[0].(string)
	return ret0
}
// RefreshTokenSignature indicates an expected call of RefreshTokenSignature
func (mr *MockCoreStrategyMockRecorder) RefreshTokenSignature(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""RefreshTokenSignature"", reflect.TypeOf((*MockCoreStrategy)(nil).RefreshTokenSignature), arg0)
}
// ValidateAccessToken mocks base method
func (m *MockCoreStrategy) ValidateAccessToken(arg0 context.Context, arg1 fosite.Requester, arg2 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""ValidateAccessToken"", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}
// ValidateAccessToken indicates an expected call of ValidateAccessToken
func (mr *MockCoreStrategyMockRecorder) ValidateAccessToken(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""ValidateAccessToken"", reflect.TypeOf((*MockCoreStrategy)(nil).ValidateAccessToken), arg0, arg1, arg2)
}
// ValidateAuthorizeCode mocks base method
func (m *MockCoreStrategy) ValidateAuthorizeCode(arg0 context.Context, arg1 fosite.Requester, arg2 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""ValidateAuthorizeCode"", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}
// ValidateAuthorizeCode indicates an expected call of ValidateAuthorizeCode
func (mr *MockCoreStrategyMockRecorder) ValidateAuthorizeCode(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""ValidateAuthorizeCode"", reflect.TypeOf((*MockCoreStrategy)(nil).ValidateAuthorizeCode), arg0, arg1, arg2)
}
// ValidateRefreshToken mocks base method
func (m *MockCoreStrategy) ValidateRefreshToken(arg0 context.Context, arg1 fosite.Requester, arg2 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""ValidateRefreshToken"", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}
// ValidateRefreshToken indicates an expected call of ValidateRefreshToken
func (mr *MockCoreStrategyMockRecorder) ValidateRefreshToken(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""ValidateRefreshToken"", reflect.TypeOf((*MockCoreStrategy)(nil).ValidateRefreshToken), arg0, arg1, arg2)
}
",CWE-345,170.0,0
"// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ory/fosite/handler/openid (interfaces: OpenIDConnectRequestStorage)
// Package internal is a generated GoMock package.
package internal
import (
	context ""context""
	reflect ""reflect""
	gomock ""github.com/golang/mock/gomock""
	fosite ""github.com/ory/fosite""
)
// MockOpenIDConnectRequestStorage is a mock of OpenIDConnectRequestStorage interface
type MockOpenIDConnectRequestStorage struct {
	ctrl     *gomock.Controller
	recorder *MockOpenIDConnectRequestStorageMockRecorder
}
// MockOpenIDConnectRequestStorageMockRecorder is the mock recorder for MockOpenIDConnectRequestStorage
type MockOpenIDConnectRequestStorageMockRecorder struct {
	mock *MockOpenIDConnectRequestStorage
}
// NewMockOpenIDConnectRequestStorage creates a new mock instance
func NewMockOpenIDConnectRequestStorage(ctrl *gomock.Controller) *MockOpenIDConnectRequestStorage {
	mock := &MockOpenIDConnectRequestStorage{ctrl: ctrl}
	mock.recorder = &MockOpenIDConnectRequestStorageMockRecorder{mock}
	return mock
}
// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockOpenIDConnectRequestStorage) EXPECT() *MockOpenIDConnectRequestStorageMockRecorder {
	return m.recorder
}
// CreateOpenIDConnectSession mocks base method
func (m *MockOpenIDConnectRequestStorage) CreateOpenIDConnectSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""CreateOpenIDConnectSession"", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}
// CreateOpenIDConnectSession indicates an expected call of CreateOpenIDConnectSession
func (mr *MockOpenIDConnectRequestStorageMockRecorder) CreateOpenIDConnectSession(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""CreateOpenIDConnectSession"", reflect.TypeOf((*MockOpenIDConnectRequestStorage)(nil).CreateOpenIDConnectSession), arg0, arg1, arg2)
}
// DeleteOpenIDConnectSession mocks base method
func (m *MockOpenIDConnectRequestStorage) DeleteOpenIDConnectSession(arg0 context.Context, arg1 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""DeleteOpenIDConnectSession"", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}
// DeleteOpenIDConnectSession indicates an expected call of DeleteOpenIDConnectSession
func (mr *MockOpenIDConnectRequestStorageMockRecorder) DeleteOpenIDConnectSession(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""DeleteOpenIDConnectSession"", reflect.TypeOf((*MockOpenIDConnectRequestStorage)(nil).DeleteOpenIDConnectSession), arg0, arg1)
}
// GetOpenIDConnectSession mocks base method
func (m *MockOpenIDConnectRequestStorage) GetOpenIDConnectSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) (fosite.Requester, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""GetOpenIDConnectSession"", arg0, arg1, arg2)
	ret0, _ := ret[0].(fosite.Requester)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}
// GetOpenIDConnectSession indicates an expected call of GetOpenIDConnectSession
func (mr *MockOpenIDConnectRequestStorageMockRecorder) GetOpenIDConnectSession(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetOpenIDConnectSession"", reflect.TypeOf((*MockOpenIDConnectRequestStorage)(nil).GetOpenIDConnectSession), arg0, arg1, arg2)
}
",CWE-345,81.0,0
"// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ory/fosite/handler/pkce (interfaces: PKCERequestStorage)
// Package internal is a generated GoMock package.
package internal
import (
	context ""context""
	reflect ""reflect""
	gomock ""github.com/golang/mock/gomock""
	fosite ""github.com/ory/fosite""
)
// MockPKCERequestStorage is a mock of PKCERequestStorage interface
type MockPKCERequestStorage struct {
	ctrl     *gomock.Controller
	recorder *MockPKCERequestStorageMockRecorder
}
// MockPKCERequestStorageMockRecorder is the mock recorder for MockPKCERequestStorage
type MockPKCERequestStorageMockRecorder struct {
	mock *MockPKCERequestStorage
}
// NewMockPKCERequestStorage creates a new mock instance
func NewMockPKCERequestStorage(ctrl *gomock.Controller) *MockPKCERequestStorage {
	mock := &MockPKCERequestStorage{ctrl: ctrl}
	mock.recorder = &MockPKCERequestStorageMockRecorder{mock}
	return mock
}
// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockPKCERequestStorage) EXPECT() *MockPKCERequestStorageMockRecorder {
	return m.recorder
}
// CreatePKCERequestSession mocks base method
func (m *MockPKCERequestStorage) CreatePKCERequestSession(arg0 context.Context, arg1 string, arg2 fosite.Requester) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""CreatePKCERequestSession"", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}
// CreatePKCERequestSession indicates an expected call of CreatePKCERequestSession
func (mr *MockPKCERequestStorageMockRecorder) CreatePKCERequestSession(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""CreatePKCERequestSession"", reflect.TypeOf((*MockPKCERequestStorage)(nil).CreatePKCERequestSession), arg0, arg1, arg2)
}
// DeletePKCERequestSession mocks base method
func (m *MockPKCERequestStorage) DeletePKCERequestSession(arg0 context.Context, arg1 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""DeletePKCERequestSession"", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}
// DeletePKCERequestSession indicates an expected call of DeletePKCERequestSession
func (mr *MockPKCERequestStorageMockRecorder) DeletePKCERequestSession(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""DeletePKCERequestSession"", reflect.TypeOf((*MockPKCERequestStorage)(nil).DeletePKCERequestSession), arg0, arg1)
}
// GetPKCERequestSession mocks base method
func (m *MockPKCERequestStorage) GetPKCERequestSession(arg0 context.Context, arg1 string, arg2 fosite.Session) (fosite.Requester, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""GetPKCERequestSession"", arg0, arg1, arg2)
	ret0, _ := ret[0].(fosite.Requester)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}
// GetPKCERequestSession indicates an expected call of GetPKCERequestSession
func (mr *MockPKCERequestStorageMockRecorder) GetPKCERequestSession(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetPKCERequestSession"", reflect.TypeOf((*MockPKCERequestStorage)(nil).GetPKCERequestSession), arg0, arg1, arg2)
}
",CWE-345,81.0,0
"// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ory/fosite/handler/oauth2 (interfaces: RefreshTokenStrategy)
// Package internal is a generated GoMock package.
package internal
import (
	context ""context""
	reflect ""reflect""
	gomock ""github.com/golang/mock/gomock""
	fosite ""github.com/ory/fosite""
)
// MockRefreshTokenStrategy is a mock of RefreshTokenStrategy interface
type MockRefreshTokenStrategy struct {
	ctrl     *gomock.Controller
	recorder *MockRefreshTokenStrategyMockRecorder
}
// MockRefreshTokenStrategyMockRecorder is the mock recorder for MockRefreshTokenStrategy
type MockRefreshTokenStrategyMockRecorder struct {
	mock *MockRefreshTokenStrategy
}
// NewMockRefreshTokenStrategy creates a new mock instance
func NewMockRefreshTokenStrategy(ctrl *gomock.Controller) *MockRefreshTokenStrategy {
	mock := &MockRefreshTokenStrategy{ctrl: ctrl}
	mock.recorder = &MockRefreshTokenStrategyMockRecorder{mock}
	return mock
}
// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockRefreshTokenStrategy) EXPECT() *MockRefreshTokenStrategyMockRecorder {
	return m.recorder
}
// GenerateRefreshToken mocks base method
func (m *MockRefreshTokenStrategy) GenerateRefreshToken(arg0 context.Context, arg1 fosite.Requester) (string, string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""GenerateRefreshToken"", arg0, arg1)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(string)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}
// GenerateRefreshToken indicates an expected call of GenerateRefreshToken
func (mr *MockRefreshTokenStrategyMockRecorder) GenerateRefreshToken(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GenerateRefreshToken"", reflect.TypeOf((*MockRefreshTokenStrategy)(nil).GenerateRefreshToken), arg0, arg1)
}
// RefreshTokenSignature mocks base method
func (m *MockRefreshTokenStrategy) RefreshTokenSignature(arg0 string) string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""RefreshTokenSignature"", arg0)
	ret0, _ := ret[0].(string)
	return ret0
}
// RefreshTokenSignature indicates an expected call of RefreshTokenSignature
func (mr *MockRefreshTokenStrategyMockRecorder) RefreshTokenSignature(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""RefreshTokenSignature"", reflect.TypeOf((*MockRefreshTokenStrategy)(nil).RefreshTokenSignature), arg0)
}
// ValidateRefreshToken mocks base method
func (m *MockRefreshTokenStrategy) ValidateRefreshToken(arg0 context.Context, arg1 fosite.Requester, arg2 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""ValidateRefreshToken"", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}
// ValidateRefreshToken indicates an expected call of ValidateRefreshToken
func (mr *MockRefreshTokenStrategyMockRecorder) ValidateRefreshToken(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""ValidateRefreshToken"", reflect.TypeOf((*MockRefreshTokenStrategy)(nil).ValidateRefreshToken), arg0, arg1, arg2)
}
",CWE-345,82.0,0
"// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ory/fosite (interfaces: RevocationHandler)
// Package internal is a generated GoMock package.
package internal
import (
	context ""context""
	reflect ""reflect""
	gomock ""github.com/golang/mock/gomock""
	fosite ""github.com/ory/fosite""
)
// MockRevocationHandler is a mock of RevocationHandler interface
type MockRevocationHandler struct {
	ctrl     *gomock.Controller
	recorder *MockRevocationHandlerMockRecorder
}
// MockRevocationHandlerMockRecorder is the mock recorder for MockRevocationHandler
type MockRevocationHandlerMockRecorder struct {
	mock *MockRevocationHandler
}
// NewMockRevocationHandler creates a new mock instance
func NewMockRevocationHandler(ctrl *gomock.Controller) *MockRevocationHandler {
	mock := &MockRevocationHandler{ctrl: ctrl}
	mock.recorder = &MockRevocationHandlerMockRecorder{mock}
	return mock
}
// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockRevocationHandler) EXPECT() *MockRevocationHandlerMockRecorder {
	return m.recorder
}
// RevokeToken mocks base method
func (m *MockRevocationHandler) RevokeToken(arg0 context.Context, arg1 string, arg2 fosite.TokenType, arg3 fosite.Client) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""RevokeToken"", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(error)
	return ret0
}
// RevokeToken indicates an expected call of RevokeToken
func (mr *MockRevocationHandlerMockRecorder) RevokeToken(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""RevokeToken"", reflect.TypeOf((*MockRevocationHandler)(nil).RevokeToken), arg0, arg1, arg2, arg3)
}
",CWE-345,52.0,0
"// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ory/fosite (interfaces: Storage)
// Package internal is a generated GoMock package.
package internal
import (
	context ""context""
	reflect ""reflect""
	time ""time""
	gomock ""github.com/golang/mock/gomock""
	fosite ""github.com/ory/fosite""
)
// MockStorage is a mock of Storage interface
type MockStorage struct {
	ctrl     *gomock.Controller
	recorder *MockStorageMockRecorder
}
// MockStorageMockRecorder is the mock recorder for MockStorage
type MockStorageMockRecorder struct {
	mock *MockStorage
}
// NewMockStorage creates a new mock instance
func NewMockStorage(ctrl *gomock.Controller) *MockStorage {
	mock := &MockStorage{ctrl: ctrl}
	mock.recorder = &MockStorageMockRecorder{mock}
	return mock
}
// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockStorage) EXPECT() *MockStorageMockRecorder {
	return m.recorder
}
// ClientAssertionJWTValid mocks base method
func (m *MockStorage) ClientAssertionJWTValid(arg0 context.Context, arg1 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""ClientAssertionJWTValid"", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}
// ClientAssertionJWTValid indicates an expected call of ClientAssertionJWTValid
func (mr *MockStorageMockRecorder) ClientAssertionJWTValid(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""ClientAssertionJWTValid"", reflect.TypeOf((*MockStorage)(nil).ClientAssertionJWTValid), arg0, arg1)
}
// GetClient mocks base method
func (m *MockStorage) GetClient(arg0 context.Context, arg1 string) (fosite.Client, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""GetClient"", arg0, arg1)
	ret0, _ := ret[0].(fosite.Client)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}
// GetClient indicates an expected call of GetClient
func (mr *MockStorageMockRecorder) GetClient(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""GetClient"", reflect.TypeOf((*MockStorage)(nil).GetClient), arg0, arg1)
}
// SetClientAssertionJWT mocks base method
func (m *MockStorage) SetClientAssertionJWT(arg0 context.Context, arg1 string, arg2 time.Time) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""SetClientAssertionJWT"", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}
// SetClientAssertionJWT indicates an expected call of SetClientAssertionJWT
func (mr *MockStorageMockRecorder) SetClientAssertionJWT(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""SetClientAssertionJWT"", reflect.TypeOf((*MockStorage)(nil).SetClientAssertionJWT), arg0, arg1, arg2)
}
",CWE-345,82.0,0
"// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ory/fosite (interfaces: TokenEndpointHandler)
// Package internal is a generated GoMock package.
package internal
import (
	context ""context""
	reflect ""reflect""
	gomock ""github.com/golang/mock/gomock""
	fosite ""github.com/ory/fosite""
)
// MockTokenEndpointHandler is a mock of TokenEndpointHandler interface
type MockTokenEndpointHandler struct {
	ctrl     *gomock.Controller
	recorder *MockTokenEndpointHandlerMockRecorder
}
// MockTokenEndpointHandlerMockRecorder is the mock recorder for MockTokenEndpointHandler
type MockTokenEndpointHandlerMockRecorder struct {
	mock *MockTokenEndpointHandler
}
// NewMockTokenEndpointHandler creates a new mock instance
func NewMockTokenEndpointHandler(ctrl *gomock.Controller) *MockTokenEndpointHandler {
	mock := &MockTokenEndpointHandler{ctrl: ctrl}
	mock.recorder = &MockTokenEndpointHandlerMockRecorder{mock}
	return mock
}
// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockTokenEndpointHandler) EXPECT() *MockTokenEndpointHandlerMockRecorder {
	return m.recorder
}
// HandleTokenEndpointRequest mocks base method
func (m *MockTokenEndpointHandler) HandleTokenEndpointRequest(arg0 context.Context, arg1 fosite.AccessRequester) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""HandleTokenEndpointRequest"", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}
// HandleTokenEndpointRequest indicates an expected call of HandleTokenEndpointRequest
func (mr *MockTokenEndpointHandlerMockRecorder) HandleTokenEndpointRequest(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""HandleTokenEndpointRequest"", reflect.TypeOf((*MockTokenEndpointHandler)(nil).HandleTokenEndpointRequest), arg0, arg1)
}
// PopulateTokenEndpointResponse mocks base method
func (m *MockTokenEndpointHandler) PopulateTokenEndpointResponse(arg0 context.Context, arg1 fosite.AccessRequester, arg2 fosite.AccessResponder) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""PopulateTokenEndpointResponse"", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}
// PopulateTokenEndpointResponse indicates an expected call of PopulateTokenEndpointResponse
func (mr *MockTokenEndpointHandlerMockRecorder) PopulateTokenEndpointResponse(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""PopulateTokenEndpointResponse"", reflect.TypeOf((*MockTokenEndpointHandler)(nil).PopulateTokenEndpointResponse), arg0, arg1, arg2)
}
",CWE-345,66.0,0
"// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ory/fosite/storage (interfaces: Transactional)
// Package internal is a generated GoMock package.
package internal
import (
	context ""context""
	reflect ""reflect""
	gomock ""github.com/golang/mock/gomock""
)
// MockTransactional is a mock of Transactional interface
type MockTransactional struct {
	ctrl     *gomock.Controller
	recorder *MockTransactionalMockRecorder
}
// MockTransactionalMockRecorder is the mock recorder for MockTransactional
type MockTransactionalMockRecorder struct {
	mock *MockTransactional
}
// NewMockTransactional creates a new mock instance
func NewMockTransactional(ctrl *gomock.Controller) *MockTransactional {
	mock := &MockTransactional{ctrl: ctrl}
	mock.recorder = &MockTransactionalMockRecorder{mock}
	return mock
}
// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockTransactional) EXPECT() *MockTransactionalMockRecorder {
	return m.recorder
}
// BeginTX mocks base method
func (m *MockTransactional) BeginTX(arg0 context.Context) (context.Context, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""BeginTX"", arg0)
	ret0, _ := ret[0].(context.Context)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}
// BeginTX indicates an expected call of BeginTX
func (mr *MockTransactionalMockRecorder) BeginTX(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""BeginTX"", reflect.TypeOf((*MockTransactional)(nil).BeginTX), arg0)
}
// Commit mocks base method
func (m *MockTransactional) Commit(arg0 context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""Commit"", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}
// Commit indicates an expected call of Commit
func (mr *MockTransactionalMockRecorder) Commit(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""Commit"", reflect.TypeOf((*MockTransactional)(nil).Commit), arg0)
}
// Rollback mocks base method
func (m *MockTransactional) Rollback(arg0 context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, ""Rollback"", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}
// Rollback indicates an expected call of Rollback
func (mr *MockTransactionalMockRecorder) Rollback(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, ""Rollback"", reflect.TypeOf((*MockTransactional)(nil).Rollback), arg0)
}
",CWE-345,79.0,0
"/*
 * Copyright © 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @author		Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @copyright 	2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @license 	Apache-2.0
 *
 */
package fosite
import (
	""encoding/json""
	""fmt""
	""net/http""
)
func (f *Fosite) WriteAccessError(rw http.ResponseWriter, _ AccessRequester, err error) {
	f.writeJsonError(rw, err)
}
func (f *Fosite) writeJsonError(rw http.ResponseWriter, err error) {
	rw.Header().Set(""Content-Type"", ""application/json;charset=UTF-8"")
	rw.Header().Set(""Cache-Control"", ""no-store"")
	rw.Header().Set(""Pragma"", ""no-cache"")
	rfcerr := ErrorToRFC6749Error(err)
	if !f.SendDebugMessagesToClients {
		rfcerr = rfcerr.Sanitize()
	}
	js, err := json.Marshal(rfcerr)
	if err != nil {
		if f.SendDebugMessagesToClients {
			errorMessage := EscapeJSONString(err.Error())
			http.Error(rw, fmt.Sprintf(`{""error"":""server_error"",""error_description"":""%s""}`, errorMessage), http.StatusInternalServerError)
		} else {
			http.Error(rw, `{""error"":""server_error""}`, http.StatusInternalServerError)
		}
		return
	}
	rw.WriteHeader(rfcerr.Code)
	// ignoring the error because the connection is broken when it happens
	_, _ = rw.Write(js)
}
",CWE-754,59.0,0
"/*
 * Copyright © 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @author		Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @copyright 	2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @license 	Apache-2.0
 *
 */
package fosite
import (
	""encoding/json""
	""net/http""
)
func (f *Fosite) WriteAccessResponse(rw http.ResponseWriter, requester AccessRequester, responder AccessResponder) {
	rw.Header().Set(""Cache-Control"", ""no-store"")
	rw.Header().Set(""Pragma"", ""no-cache"")
	js, err := json.Marshal(responder.ToMap())
	if err != nil {
		http.Error(rw, err.Error(), http.StatusInternalServerError)
		return
	}
	rw.Header().Set(""Content-Type"", ""application/json;charset=UTF-8"")
	rw.WriteHeader(http.StatusOK)
	_, _ = rw.Write(js)
}
",CWE-754,44.0,0
"/*
 * Copyright © 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @author		Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @copyright 	2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @license 	Apache-2.0
 *
 */
package fosite
import (
	""encoding/json""
	""fmt""
	""net/http""
	""github.com/pkg/errors""
)
func (f *Fosite) WriteAuthorizeError(rw http.ResponseWriter, ar AuthorizeRequester, err error) {
	rw.Header().Set(""Cache-Control"", ""no-store"")
	rw.Header().Set(""Pragma"", ""no-cache"")
	rfcerr := ErrorToRFC6749Error(err)
	if !f.SendDebugMessagesToClients {
		rfcerr = rfcerr.Sanitize()
	}
	if !ar.IsRedirectURIValid() {
		rw.Header().Set(""Content-Type"", ""application/json;charset=UTF-8"")
		js, err := json.Marshal(rfcerr)
		if err != nil {
			if f.SendDebugMessagesToClients {
				errorMessage := EscapeJSONString(err.Error())
				http.Error(rw, fmt.Sprintf(`{""error"":""server_error"",""error_description"":""%s""}`, errorMessage), http.StatusInternalServerError)
			} else {
				http.Error(rw, `{""error"":""server_error""}`, http.StatusInternalServerError)
			}
			return
		}
		rw.WriteHeader(rfcerr.Code)
		_, _ = rw.Write(js)
		return
	}
	redirectURI := ar.GetRedirectURI()
	// The endpoint URI MUST NOT include a fragment component.
	redirectURI.Fragment = """"
	query := rfcerr.ToValues()
	query.Add(""state"", ar.GetState())
	var redirectURIString string
	if !(len(ar.GetResponseTypes()) == 0 || ar.GetResponseTypes().ExactOne(""code"")) && !errors.Is(err, ErrUnsupportedResponseType) {
		redirectURIString = redirectURI.String() + ""
	} else {
		for key, values := range redirectURI.Query() {
			for _, value := range values {
				query.Add(key, value)
			}
		}
		redirectURI.RawQuery = query.Encode()
		redirectURIString = redirectURI.String()
	}
	rw.Header().Add(""Location"", redirectURIString)
	rw.WriteHeader(http.StatusFound)
}
",CWE-754,84.0,0
"/*
 * Copyright © 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @author		Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @copyright 	2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @license 	Apache-2.0
 *
 */
package fosite
import (
	""testing""
	""github.com/pkg/errors""
	""github.com/stretchr/testify/assert""
)
func TestIs(t *testing.T) {
	assert.True(t, errors.Is(ErrUnknownRequest, ErrUnknownRequest))
	assert.True(t, errors.Is(ErrUnknownRequest, &RFC6749Error{
		Name: errUnknownErrorName,
	}))
	assert.True(t, errors.Is(&RFC6749Error{
		Name: errUnknownErrorName,
	}, ErrUnknownRequest))
}
",CWE-754,40.0,0
"// +build tools
package fosite
import (
	_ ""github.com/gorilla/websocket""
	_ ""github.com/mattn/goveralls""
	_ ""github.com/ory/go-acc""
)
",CWE-754,11.0,0
"/*
 * Copyright © 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @author		Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @copyright 	2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @license 	Apache-2.0
 *
 */
package oauth2
import (
	""context""
	""github.com/pkg/errors""
	""github.com/ory/fosite""
)
type TokenRevocationHandler struct {
	TokenRevocationStorage TokenRevocationStorage
	RefreshTokenStrategy   RefreshTokenStrategy
	AccessTokenStrategy    AccessTokenStrategy
}
// RevokeToken implements https://tools.ietf.org/html/rfc7009
// The token type hint indicates which token type check should be performed first.
func (r *TokenRevocationHandler) RevokeToken(ctx context.Context, token string, tokenType fosite.TokenType, client fosite.Client) error {
	discoveryFuncs := []func() (request fosite.Requester, err error){
		func() (request fosite.Requester, err error) {
			// Refresh token
			signature := r.RefreshTokenStrategy.RefreshTokenSignature(token)
			return r.TokenRevocationStorage.GetRefreshTokenSession(ctx, signature, nil)
		},
		func() (request fosite.Requester, err error) {
			// Access token
			signature := r.AccessTokenStrategy.AccessTokenSignature(token)
			return r.TokenRevocationStorage.GetAccessTokenSession(ctx, signature, nil)
		},
	}
	// Token type hinting
	if tokenType == fosite.AccessToken {
		discoveryFuncs[0], discoveryFuncs[1] = discoveryFuncs[1], discoveryFuncs[0]
	}
	var ar fosite.Requester
	var err1, err2 error
	if ar, err1 = discoveryFuncs[0](); err1 != nil {
		ar, err2 = discoveryFuncs[1]()
	}
	// err2 can only be not nil if first err1 was not nil
	if err2 != nil {
		return storeErrorsToRevocationError(err1, err2)
	}
	if ar.GetClient().GetID() != client.GetID() {
		return errors.WithStack(fosite.ErrUnauthorizedClient)
	}
	requestID := ar.GetID()
	err1 = r.TokenRevocationStorage.RevokeRefreshToken(ctx, requestID)
	err2 = r.TokenRevocationStorage.RevokeAccessToken(ctx, requestID)
	return storeErrorsToRevocationError(err1, err2)
}
func storeErrorsToRevocationError(err1, err2 error) error {
	// both errors are 404 or nil <=> the token is revoked
	if (errors.Is(err1, fosite.ErrNotFound) || err1 == nil) && (errors.Is(err2, fosite.ErrNotFound) || err2 == nil) {
		return nil
	}
	// there was an unexpected error => the token may still exist and the client should retry later
	return errors.WithStack(fosite.ErrTemporarilyUnavailable)
}
",CWE-754,89.0,0
"/*
 * Copyright © 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @author		Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @copyright 	2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @license 	Apache-2.0
 *
 */
package openid
import (
	""bytes""
	""context""
	""crypto/sha256""
	""encoding/base64""
	""github.com/ory/fosite""
)
type IDTokenHandleHelper struct {
	IDTokenStrategy OpenIDConnectTokenStrategy
}
func (i *IDTokenHandleHelper) GetAccessTokenHash(ctx context.Context, requester fosite.AccessRequester, responder fosite.AccessResponder) string {
	token := responder.GetAccessToken()
	buffer := bytes.NewBufferString(token)
	hash := sha256.New()
	// sha256.digest.Write() always returns nil for err, the panic should never happen
	_, err := hash.Write(buffer.Bytes())
	if err != nil {
		panic(err)
	}
	hashBuf := bytes.NewBuffer(hash.Sum([]byte{}))
	len := hashBuf.Len()
	return base64.RawURLEncoding.EncodeToString(hashBuf.Bytes()[:len/2])
}
func (i *IDTokenHandleHelper) generateIDToken(ctx context.Context, fosr fosite.Requester) (token string, err error) {
	token, err = i.IDTokenStrategy.GenerateIDToken(ctx, fosr)
	if err != nil {
		return """", err
	}
	return token, nil
}
func (i *IDTokenHandleHelper) IssueImplicitIDToken(ctx context.Context, ar fosite.Requester, resp fosite.AuthorizeResponder) error {
	token, err := i.generateIDToken(ctx, ar)
	if err != nil {
		return err
	}
	resp.AddFragment(""id_token"", token)
	return nil
}
func (i *IDTokenHandleHelper) IssueExplicitIDToken(ctx context.Context, ar fosite.Requester, resp fosite.AccessResponder) error {
	token, err := i.generateIDToken(ctx, ar)
	if err != nil {
		return err
	}
	resp.SetExtra(""id_token"", token)
	return nil
}
",CWE-754,81.0,0
"/*
 * Copyright © 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @author		Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @copyright 	2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @license 	Apache-2.0
 *
 */
package fosite
import (
	""context""
	""encoding/json""
	""fmt""
	""net/http""
	""github.com/pkg/errors""
)
// NewRevocationRequest handles incoming token revocation requests and
// validates various parameters as specified in:
// https://tools.ietf.org/html/rfc7009
//
// The authorization server first validates the client credentials (in
// case of a confidential client) and then verifies whether the token
// was issued to the client making the revocation request.  If this
// validation fails, the request is refused and the client is informed
// of the error by the authorization server as described below.
//
// In the next step, the authorization server invalidates the token.
// The invalidation takes place immediately, and the token cannot be
// used again after the revocation.
//
// * https://tools.ietf.org/html/rfc7009
// An invalid token type hint value is ignored by the authorization
// server and does not influence the revocation response.
func (f *Fosite) NewRevocationRequest(ctx context.Context, r *http.Request) error {
	if r.Method != ""POST"" {
		return errors.WithStack(ErrInvalidRequest.WithHintf(""HTTP method is \""%s\"", expected \""POST\""."", r.Method))
	} else if err := r.ParseMultipartForm(1 << 20); err != nil && err != http.ErrNotMultipart {
		return errors.WithStack(ErrInvalidRequest.WithHint(""Unable to parse HTTP body, make sure to send a properly formatted form request body."").WithCause(err).WithDebug(err.Error()))
	} else if len(r.PostForm) == 0 {
		return errors.WithStack(ErrInvalidRequest.WithHint(""The POST body can not be empty.""))
	}
	client, err := f.AuthenticateClient(ctx, r, r.PostForm)
	if err != nil {
		return err
	}
	token := r.PostForm.Get(""token"")
	tokenTypeHint := TokenType(r.PostForm.Get(""token_type_hint""))
	var found = false
	for _, loader := range f.RevocationHandlers {
		if err := loader.RevokeToken(ctx, token, tokenTypeHint, client); err == nil {
			found = true
		} else if errors.Is(err, ErrUnknownRequest) {
			// do nothing
		} else if err != nil {
			return err
		}
	}
	if !found {
		return errors.WithStack(ErrInvalidRequest)
	}
	return nil
}
// WriteRevocationResponse writes a token revocation response as specified in:
// https://tools.ietf.org/html/rfc7009
//
// The authorization server responds with HTTP status code 200 if the
// token has been revoked successfully or if the client submitted an
// invalid token.
//
// Note: invalid tokens do not cause an error response since the client
// cannot handle such an error in a reasonable way.  Moreover, the
// purpose of the revocation request, invalidating the particular token,
// is already achieved.
func (f *Fosite) WriteRevocationResponse(rw http.ResponseWriter, err error) {
	rw.Header().Set(""Cache-Control"", ""no-store"")
	rw.Header().Set(""Pragma"", ""no-cache"")
	if err == nil {
		rw.WriteHeader(http.StatusOK)
		return
	}
	if errors.Is(err, ErrInvalidRequest) {
		rw.Header().Set(""Content-Type"", ""application/json;charset=UTF-8"")
		js, err := json.Marshal(ErrInvalidRequest)
		if err != nil {
			http.Error(rw, fmt.Sprintf(`{""error"": ""%s""}`, err.Error()), http.StatusInternalServerError)
			return
		}
		rw.WriteHeader(ErrInvalidRequest.Code)
		_, _ = rw.Write(js)
	} else if errors.Is(err, ErrInvalidClient) {
		rw.Header().Set(""Content-Type"", ""application/json;charset=UTF-8"")
		js, err := json.Marshal(ErrInvalidClient)
		if err != nil {
			http.Error(rw, fmt.Sprintf(`{""error"": ""%s""}`, err.Error()), http.StatusInternalServerError)
			return
		}
		rw.WriteHeader(ErrInvalidClient.Code)
		_, _ = rw.Write(js)
	} else {
		// 200 OK
		rw.WriteHeader(http.StatusOK)
	}
}
",CWE-754,132.0,0
"/*
 * Copyright © 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @author		Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @copyright 	2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @license 	Apache-2.0
 *
 */
// Package hmac is the default implementation for generating and validating challenges. It uses HMAC-SHA256 to
// generate and validate challenges.
package hmac
import (
	""crypto/hmac""
	""crypto/sha512""
	""encoding/base64""
	""fmt""
	""strings""
	""sync""
	""github.com/pkg/errors""
	""github.com/ory/fosite""
)
// HMACStrategy is responsible for generating and validating challenges.
type HMACStrategy struct {
	TokenEntropy         int
	GlobalSecret         []byte
	RotatedGlobalSecrets [][]byte
	sync.Mutex
}
const (
	// key should be at least 256 bit long, making it
	minimumEntropy = 32
	// the secrets (client and global) should each have at least 16 characters making it harder to guess them
	minimumSecretLength = 32
)
var b64 = base64.URLEncoding.WithPadding(base64.NoPadding)
// Generate generates a token and a matching signature or returns an error.
// This method implements rfc6819 Section 5.1.4.2.2: Use High Entropy for Secrets.
func (c *HMACStrategy) Generate() (string, string, error) {
	c.Lock()
	defer c.Unlock()
	if len(c.GlobalSecret) < minimumSecretLength {
		return """", """", errors.Errorf(""secret for signing HMAC-SHA256 is expected to be 32 byte long, got %d byte"", len(c.GlobalSecret))
	}
	var signingKey [32]byte
	copy(signingKey[:], c.GlobalSecret)
	if c.TokenEntropy < minimumEntropy {
		c.TokenEntropy = minimumEntropy
	}
	// When creating secrets not intended for usage by human users (e.g.,
	// client secrets or token handles), the authorization server should
	// include a reasonable level of entropy in order to mitigate the risk
	// of guessing attacks.  The token value should be >=128 bits long and
	// constructed from a cryptographically strong random or pseudo-random
	// number sequence (see [RFC4086] for best current practice) generated
	// by the authorization server.
	tokenKey, err := RandomBytes(c.TokenEntropy)
	if err != nil {
		return """", """", errors.WithStack(err)
	}
	signature := generateHMAC(tokenKey, &signingKey)
	encodedSignature := b64.EncodeToString(signature)
	encodedToken := fmt.Sprintf(""%s.%s"", b64.EncodeToString(tokenKey), encodedSignature)
	return encodedToken, encodedSignature, nil
}
// Validate validates a token and returns its signature or an error if the token is not valid.
func (c *HMACStrategy) Validate(token string) (err error) {
	var keys [][]byte
	if len(c.GlobalSecret) > 0 {
		keys = append(keys, c.GlobalSecret)
	}
	if len(c.RotatedGlobalSecrets) > 0 {
		keys = append(keys, c.RotatedGlobalSecrets...)
	}
	for _, key := range keys {
		if err = c.validate(key, token); err == nil {
			return nil
		} else if errors.Is(err, fosite.ErrTokenSignatureMismatch) {
		} else {
			return err
		}
	}
	if err == nil {
		return errors.New(""a secret for signing HMAC-SHA256 is expected to be defined, but none were"")
	}
	return err
}
func (c *HMACStrategy) validate(secret []byte, token string) error {
	if len(secret) < minimumSecretLength {
		return errors.Errorf(""secret for signing HMAC-SHA256 is expected to be 32 byte long, got %d byte"", len(secret))
	}
	var signingKey [32]byte
	copy(signingKey[:], secret)
	split := strings.Split(token, ""."")
	if len(split) != 2 {
		return errors.WithStack(fosite.ErrInvalidTokenFormat)
	}
	tokenKey := split[0]
	tokenSignature := split[1]
	if tokenKey == """" || tokenSignature == """" {
		return errors.WithStack(fosite.ErrInvalidTokenFormat)
	}
	decodedTokenSignature, err := b64.DecodeString(tokenSignature)
	if err != nil {
		return errors.WithStack(err)
	}
	decodedTokenKey, err := b64.DecodeString(tokenKey)
	if err != nil {
		return errors.WithStack(err)
	}
	expectedMAC := generateHMAC(decodedTokenKey, &signingKey)
	if !hmac.Equal(expectedMAC, decodedTokenSignature) {
		// Hash is invalid
		return errors.WithStack(fosite.ErrTokenSignatureMismatch)
	}
	return nil
}
func (c *HMACStrategy) Signature(token string) string {
	split := strings.Split(token, ""."")
	if len(split) != 2 {
		return """"
	}
	return split[1]
}
func generateHMAC(data []byte, key *[32]byte) []byte {
	h := hmac.New(sha512.New512_256, key[:])
	// sha512.digest.Write() always returns nil for err, the panic should never happen
	_, err := h.Write(data)
	if err != nil {
		panic(err)
	}
	return h.Sum(nil)
}
",CWE-754,179.0,0
"/*
 * Copyright © 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @author		Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @copyright 	2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @license 	Apache-2.0
 *
 */
package fosite
import (
	""net/url""
	""regexp""
	""strings""
	""github.com/asaskevich/govalidator""
	""github.com/pkg/errors""
)
// GetRedirectURIFromRequestValues extracts the redirect_uri from values but does not do any sort of validation.
//
// Considered specifications
// * https://tools.ietf.org/html/rfc6749
//   The endpoint URI MAY include an
//   ""application/x-www-form-urlencoded"" formatted (per Appendix B) query
//   component ([RFC3986] Section 3.4), which MUST be retained when adding
//   additional query parameters.
func GetRedirectURIFromRequestValues(values url.Values) (string, error) {
	// rfc6749 3.1.   Authorization Endpoint
	// The endpoint URI MAY include an ""application/x-www-form-urlencoded"" formatted (per Appendix B) query component
	redirectURI, err := url.QueryUnescape(values.Get(""redirect_uri""))
	if err != nil {
		return """", errors.WithStack(ErrInvalidRequest.WithHint(`The ""redirect_uri"" parameter is malformed or missing.`).WithCause(err).WithDebug(err.Error()))
	}
	return redirectURI, nil
}
// MatchRedirectURIWithClientRedirectURIs if the given uri is a registered redirect uri. Does not perform
// uri validation.
//
// Considered specifications
// * https://tools.ietf.org/html/rfc6749
//   If multiple redirection URIs have been registered, if only part of
//   the redirection URI has been registered, or if no redirection URI has
//   been registered, the client MUST include a redirection URI with the
//   authorization request using the ""redirect_uri"" request parameter.
//
//   When a redirection URI is included in an authorization request, the
//   authorization server MUST compare and match the value received
//   against at least one of the registered redirection URIs (or URI
//   components) as defined in [RFC3986] Section 6, if any redirection
//   URIs were registered.  If the client registration included the full
//   redirection URI, the authorization server MUST compare the two URIs
//   using simple string comparison as defined in [RFC3986] Section 6.2.1.
//
// * https://tools.ietf.org/html/rfc6819
//   * The authorization server may also enforce the usage and validation
//     of pre-registered redirect URIs (see Section 5.2.3.5).  This will
//     allow for early recognition of authorization ""code"" disclosure to
//     counterfeit clients.
//   * The attacker will need to use another redirect URI for its
//     authorization process rather than the target web site because it
//     needs to intercept the flow.  So, if the authorization server
//     associates the authorization ""code"" with the redirect URI of a
//     particular end-user authorization and validates this redirect URI
//     with the redirect URI passed to the token's endpoint, such an
//     attack is detected (see Section 5.2.4.5).
func MatchRedirectURIWithClientRedirectURIs(rawurl string, client Client) (*url.URL, error) {
	if rawurl == """" && len(client.GetRedirectURIs()) == 1 {
		if redirectURIFromClient, err := url.Parse(client.GetRedirectURIs()[0]); err == nil && IsValidRedirectURI(redirectURIFromClient) {
			// If no redirect_uri was given and the client has exactly one valid redirect_uri registered, use that instead
			return redirectURIFromClient, nil
		}
	} else if rawurl != """" && isMatchingRedirectURI(rawurl, client.GetRedirectURIs()) {
		// If a redirect_uri was given and the clients knows it (simple string comparison!)
		// return it.
		if parsed, err := url.Parse(rawurl); err == nil && IsValidRedirectURI(parsed) {
			// If no redirect_uri was given and the client has exactly one valid redirect_uri registered, use that instead
			return parsed, nil
		}
	}
	return nil, errors.WithStack(ErrInvalidRequest.WithHint(`The ""redirect_uri"" parameter does not match any of the OAuth 2.0 Client's pre-registered redirect urls.`))
}
// Match a requested  redirect URI against a pool of registered client URIs
//
// Test a given redirect URI against a pool of URIs provided by a registered client.
// If the OAuth 2.0 Client has loopback URIs registered either an IPv4 URI http://127.0.0.1 or
// an IPv6 URI http://[::1] a client is allowed to request a dynamic port and the server MUST accept
// it as a valid redirection uri.
//
// https://tools.ietf.org/html/rfc8252
// Native apps that are able to open a port on the loopback network
// interface without needing special permissions (typically, those on
// desktop operating systems) can use the loopback interface to receive
// the OAuth redirect.
//
// Loopback redirect URIs use the ""http"" scheme and are constructed with
// the loopback IP literal and whatever port the client is listening on.
func isMatchingRedirectURI(uri string, haystack []string) bool {
	requested, err := url.Parse(uri)
	if err != nil {
		return false
	}
	for _, b := range haystack {
		if b == uri || isMatchingAsLoopback(requested, b) {
			return true
		}
	}
	return false
}
func isMatchingAsLoopback(requested *url.URL, registeredURI string) bool {
	registered, err := url.Parse(registeredURI)
	if err != nil {
		return false
	}
	// Native apps that are able to open a port on the loopback network
	// interface without needing special permissions (typically, those on
	// desktop operating systems) can use the loopback interface to receive
	// the OAuth redirect.
	//
	// Loopback redirect URIs use the ""http"" scheme and are constructed with
	// the loopback IP literal and whatever port the client is listening on.
	//
	// Source: https://tools.ietf.org/html/rfc8252
	if requested.Scheme == ""http"" &&
		isLoopbackAddress(requested.Host) &&
		registered.Hostname() == requested.Hostname() &&
		// The port is skipped here - see codedoc above!
		registered.Path == requested.Path &&
		registered.RawQuery == requested.RawQuery {
		return true
	}
	return false
}
// Check if address is either an IPv4 loopback or an IPv6 loopback-
// An optional port is ignored
func isLoopbackAddress(address string) bool {
	match, _ := regexp.MatchString(""^(127.0.0.1|\\[::1\\])(:?)(\\d*)$"", address)
	return match
}
// IsValidRedirectURI validates a redirect_uri as specified in:
//
// * https://tools.ietf.org/html/rfc6749
//   * The redirection endpoint URI MUST be an absolute URI as defined by [RFC3986] Section 4.3.
//   * The endpoint URI MUST NOT include a fragment component.
// * https://tools.ietf.org/html/rfc3986
//   absolute-URI  = scheme "":"" hier-part [ ""?"" query ]
// * https://tools.ietf.org/html/rfc6819
func IsValidRedirectURI(redirectURI *url.URL) bool {
	// We need to explicitly check for a scheme
	if !govalidator.IsRequestURL(redirectURI.String()) {
		return false
	}
	if redirectURI.Fragment != """" {
		// ""The endpoint URI MUST NOT include a fragment component.""
		return false
	}
	return true
}
func IsRedirectURISecure(redirectURI *url.URL) bool {
	return !(redirectURI.Scheme == ""http"" && !IsLocalhost(redirectURI))
}
func IsLocalhost(redirectURI *url.URL) bool {
	hn := redirectURI.Hostname()
	return strings.HasSuffix(hn, "".localhost"") || hn == ""127.0.0.1"" || hn == ""localhost""
}
",CWE-601,192.0,0
"/*
 * Copyright © 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @author		Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @copyright 	2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @license 	Apache-2.0
 *
 */
package fosite
import (
	""net/url""
	""regexp""
	""strings""
	""github.com/asaskevich/govalidator""
	""github.com/pkg/errors""
)
// GetRedirectURIFromRequestValues extracts the redirect_uri from values but does not do any sort of validation.
//
// Considered specifications
// * https://tools.ietf.org/html/rfc6749
//   The endpoint URI MAY include an
//   ""application/x-www-form-urlencoded"" formatted (per Appendix B) query
//   component ([RFC3986] Section 3.4), which MUST be retained when adding
//   additional query parameters.
func GetRedirectURIFromRequestValues(values url.Values) (string, error) {
	// rfc6749 3.1.   Authorization Endpoint
	// The endpoint URI MAY include an ""application/x-www-form-urlencoded"" formatted (per Appendix B) query component
	redirectURI, err := url.QueryUnescape(values.Get(""redirect_uri""))
	if err != nil {
		return """", errors.WithStack(ErrInvalidRequest.WithHint(`The ""redirect_uri"" parameter is malformed or missing.`).WithCause(err).WithDebug(err.Error()))
	}
	return redirectURI, nil
}
// MatchRedirectURIWithClientRedirectURIs if the given uri is a registered redirect uri. Does not perform
// uri validation.
//
// Considered specifications
// * https://tools.ietf.org/html/rfc6749
//   If multiple redirection URIs have been registered, if only part of
//   the redirection URI has been registered, or if no redirection URI has
//   been registered, the client MUST include a redirection URI with the
//   authorization request using the ""redirect_uri"" request parameter.
//
//   When a redirection URI is included in an authorization request, the
//   authorization server MUST compare and match the value received
//   against at least one of the registered redirection URIs (or URI
//   components) as defined in [RFC3986] Section 6, if any redirection
//   URIs were registered.  If the client registration included the full
//   redirection URI, the authorization server MUST compare the two URIs
//   using simple string comparison as defined in [RFC3986] Section 6.2.1.
//
// * https://tools.ietf.org/html/rfc6819
//   * The authorization server may also enforce the usage and validation
//     of pre-registered redirect URIs (see Section 5.2.3.5).  This will
//     allow for early recognition of authorization ""code"" disclosure to
//     counterfeit clients.
//   * The attacker will need to use another redirect URI for its
//     authorization process rather than the target web site because it
//     needs to intercept the flow.  So, if the authorization server
//     associates the authorization ""code"" with the redirect URI of a
//     particular end-user authorization and validates this redirect URI
//     with the redirect URI passed to the token's endpoint, such an
//     attack is detected (see Section 5.2.4.5).
func MatchRedirectURIWithClientRedirectURIs(rawurl string, client Client) (*url.URL, error) {
	if rawurl == """" && len(client.GetRedirectURIs()) == 1 {
		if redirectURIFromClient, err := url.Parse(client.GetRedirectURIs()[0]); err == nil && IsValidRedirectURI(redirectURIFromClient) {
			// If no redirect_uri was given and the client has exactly one valid redirect_uri registered, use that instead
			return redirectURIFromClient, nil
		}
	} else if rawurl != """" && isMatchingRedirectURI(rawurl, client.GetRedirectURIs()) {
		// If a redirect_uri was given and the clients knows it (simple string comparison!)
		// return it.
		if parsed, err := url.Parse(rawurl); err == nil && IsValidRedirectURI(parsed) {
			// If no redirect_uri was given and the client has exactly one valid redirect_uri registered, use that instead
			return parsed, nil
		}
	}
	return nil, errors.WithStack(ErrInvalidRequest.WithHint(`The ""redirect_uri"" parameter does not match any of the OAuth 2.0 Client's pre-registered redirect urls.`))
}
// Match a requested  redirect URI against a pool of registered client URIs
//
// Test a given redirect URI against a pool of URIs provided by a registered client.
// If the OAuth 2.0 Client has loopback URIs registered either an IPv4 URI http://127.0.0.1 or
// an IPv6 URI http://[::1] a client is allowed to request a dynamic port and the server MUST accept
// it as a valid redirection uri.
//
// https://tools.ietf.org/html/rfc8252
// Native apps that are able to open a port on the loopback network
// interface without needing special permissions (typically, those on
// desktop operating systems) can use the loopback interface to receive
// the OAuth redirect.
//
// Loopback redirect URIs use the ""http"" scheme and are constructed with
// the loopback IP literal and whatever port the client is listening on.
func isMatchingRedirectURI(uri string, haystack []string) bool {
	requested, err := url.Parse(uri)
	if err != nil {
		return false
	}
	for _, b := range haystack {
		if b == uri || isMatchingAsLoopback(requested, b) {
			return true
		}
	}
	return false
}
func isMatchingAsLoopback(requested *url.URL, registeredURI string) bool {
	registered, err := url.Parse(registeredURI)
	if err != nil {
		return false
	}
	// Native apps that are able to open a port on the loopback network
	// interface without needing special permissions (typically, those on
	// desktop operating systems) can use the loopback interface to receive
	// the OAuth redirect.
	//
	// Loopback redirect URIs use the ""http"" scheme and are constructed with
	// the loopback IP literal and whatever port the client is listening on.
	//
	// Source: https://tools.ietf.org/html/rfc8252
	if requested.Scheme == ""http"" &&
		isLoopbackAddress(requested.Host) &&
		registered.Hostname() == requested.Hostname() &&
		// The port is skipped here - see codedoc above!
		registered.Path == requested.Path &&
		registered.RawQuery == requested.RawQuery {
		return true
	}
	return false
}
// Check if address is either an IPv4 loopback or an IPv6 loopback-
// An optional port is ignored
func isLoopbackAddress(address string) bool {
	match, _ := regexp.MatchString(""^(127.0.0.1|\\[::1\\])(:?)(\\d*)$"", address)
	return match
}
// IsValidRedirectURI validates a redirect_uri as specified in:
//
// * https://tools.ietf.org/html/rfc6749
//   * The redirection endpoint URI MUST be an absolute URI as defined by [RFC3986] Section 4.3.
//   * The endpoint URI MUST NOT include a fragment component.
// * https://tools.ietf.org/html/rfc3986
//   absolute-URI  = scheme "":"" hier-part [ ""?"" query ]
// * https://tools.ietf.org/html/rfc6819
func IsValidRedirectURI(redirectURI *url.URL) bool {
	// We need to explicitly check for a scheme
	if !govalidator.IsRequestURL(redirectURI.String()) {
		return false
	}
	if redirectURI.Fragment != """" {
		// ""The endpoint URI MUST NOT include a fragment component.""
		return false
	}
	return true
}
func IsRedirectURISecure(redirectURI *url.URL) bool {
	return !(redirectURI.Scheme == ""http"" && !IsLocalhost(redirectURI))
}
func IsLocalhost(redirectURI *url.URL) bool {
	hn := redirectURI.Hostname()
	return strings.HasSuffix(hn, "".localhost"") || hn == ""127.0.0.1"" || hn == ""localhost""
}
",CWE-178,192.0,0
"/*
 * Copyright © 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @author		Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @copyright 	2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @license 	Apache-2.0
 *
 */
package fosite
import (
	""encoding/json""
	""testing""
	""github.com/stretchr/testify/assert""
	""github.com/stretchr/testify/require""
)
func TestStringInSlice(t *testing.T) {
	for k, c := range []struct {
		needle   string
		haystack []string
		ok       bool
	}{
		{needle: ""foo"", haystack: []string{""foo"", ""bar""}, ok: true},
		{needle: ""bar"", haystack: []string{""foo"", ""bar""}, ok: true},
		{needle: ""baz"", haystack: []string{""foo"", ""bar""}, ok: false},
		{needle: ""foo"", haystack: []string{""bar""}, ok: false},
		{needle: ""bar"", haystack: []string{""bar""}, ok: true},
		{needle: ""foo"", haystack: []string{}, ok: false},
	} {
		assert.Equal(t, c.ok, StringInSlice(c.needle, c.haystack), ""%d"", k)
		t.Logf(""Passed test case %d"", k)
	}
}
func TestEscapeJSONString(t *testing.T) {
	for _, str := range []string{"""", ""foobar"", `foo""bar`, `foo\bar`, ""foo\n\tbar""} {
		escaped := EscapeJSONString(str)
		var unmarshaled string
		err := json.Unmarshal([]byte(`""`+escaped+`""`), &unmarshaled)
		require.NoError(t, err, str)
		assert.Equal(t, str, unmarshaled, str)
	}
}
",CWE-601,59.0,0
"/*
 * Copyright © 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @author		Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @copyright 	2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @license 	Apache-2.0
 *
 */
package fosite
import (
	""encoding/json""
	""testing""
	""github.com/stretchr/testify/assert""
	""github.com/stretchr/testify/require""
)
func TestStringInSlice(t *testing.T) {
	for k, c := range []struct {
		needle   string
		haystack []string
		ok       bool
	}{
		{needle: ""foo"", haystack: []string{""foo"", ""bar""}, ok: true},
		{needle: ""bar"", haystack: []string{""foo"", ""bar""}, ok: true},
		{needle: ""baz"", haystack: []string{""foo"", ""bar""}, ok: false},
		{needle: ""foo"", haystack: []string{""bar""}, ok: false},
		{needle: ""bar"", haystack: []string{""bar""}, ok: true},
		{needle: ""foo"", haystack: []string{}, ok: false},
	} {
		assert.Equal(t, c.ok, StringInSlice(c.needle, c.haystack), ""%d"", k)
		t.Logf(""Passed test case %d"", k)
	}
}
func TestEscapeJSONString(t *testing.T) {
	for _, str := range []string{"""", ""foobar"", `foo""bar`, `foo\bar`, ""foo\n\tbar""} {
		escaped := EscapeJSONString(str)
		var unmarshaled string
		err := json.Unmarshal([]byte(`""`+escaped+`""`), &unmarshaled)
		require.NoError(t, err, str)
		assert.Equal(t, str, unmarshaled, str)
	}
}
",CWE-178,59.0,0
"/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
// RUN: %hermes -g --lazy --Xhermes-internal-test-methods -O %s | %FileCheck %s
// RUN: %hermes -g --lazy --Xhermes-internal-test-methods -O0 %s | %FileCheck %s
""use strict"";
// isLazy should be able to handle native functions.
print(HermesInternal.isLazy(print));
// CHECK: false
// isLazy should be able to handle non-callables.
print(HermesInternal.isLazy(10));
// CHECK: false
function lazyFunc() {}
print(HermesInternal.isLazy(lazyFunc));
// CHECK: true
print(JSON.stringify(HermesInternal.getFunctionLocation(lazyFunc)));
// CHECK: {""isNative"":false,""lineNumber"":21,""columnNumber"":1}
lazyFunc();
print(HermesInternal.isLazy(lazyFunc));
// CHECK: false
print(JSON.stringify(HermesInternal.getFunctionLocation(lazyFunc)));
// CHECK: {""isNative"":false,""lineNumber"":21,""columnNumber"":1,""fileName"":""{{.*}}regress-hermes-internal-get-lazy-function-location.js""}
",CWE-476,36.0,0
"package config
import (
	""encoding/json""
	""io/ioutil""
	log ""github.com/gophish/gophish/logger""
)
// AdminServer represents the Admin server configuration details
type AdminServer struct {
	ListenURL            string   `json:""listen_url""`
	UseTLS               bool     `json:""use_tls""`
	CertPath             string   `json:""cert_path""`
	KeyPath              string   `json:""key_path""`
	CSRFKey              string   `json:""csrf_key""`
	AllowedInternalHosts []string `json:""allowed_internal_hosts""`
}
// PhishServer represents the Phish server configuration details
type PhishServer struct {
	ListenURL string `json:""listen_url""`
	UseTLS    bool   `json:""use_tls""`
	CertPath  string `json:""cert_path""`
	KeyPath   string `json:""key_path""`
}
// Config represents the configuration information.
type Config struct {
	AdminConf      AdminServer `json:""admin_server""`
	PhishConf      PhishServer `json:""phish_server""`
	DBName         string      `json:""db_name""`
	DBPath         string      `json:""db_path""`
	DBSSLCaPath    string      `json:""db_sslca_path""`
	MigrationsPath string      `json:""migrations_prefix""`
	TestFlag       bool        `json:""test_flag""`
	ContactAddress string      `json:""contact_address""`
	Logging        *log.Config `json:""logging""`
}
// Version contains the current gophish version
var Version = """"
// ServerName is the server type that is returned in the transparency response.
const ServerName = ""gophish""
// LoadConfig loads the configuration from the specified filepath
func LoadConfig(filepath string) (*Config, error) {
	// Get the config file
	configFile, err := ioutil.ReadFile(filepath)
	if err != nil {
		return nil, err
	}
	config := &Config{}
	err = json.Unmarshal(configFile, config)
	if err != nil {
		return nil, err
	}
	if config.Logging == nil {
		config.Logging = &log.Config{}
	}
	// Choosing the migrations directory based on the database used.
	config.MigrationsPath = config.MigrationsPath + config.DBName
	// Explicitly set the TestFlag to false to prevent config.json overrides
	config.TestFlag = false
	return config, nil
}
",CWE-918,68.0,0
"package api
import (
	""bytes""
	""crypto/tls""
	""encoding/json""
	""errors""
	""fmt""
	""net/http""
	""strings""
	""github.com/PuerkitoBio/goquery""
	""github.com/gophish/gophish/dialer""
	log ""github.com/gophish/gophish/logger""
	""github.com/gophish/gophish/models""
	""github.com/gophish/gophish/util""
	""github.com/jordan-wright/email""
)
type cloneRequest struct {
	URL              string `json:""url""`
	IncludeResources bool   `json:""include_resources""`
}
func (cr *cloneRequest) validate() error {
	if cr.URL == """" {
		return errors.New(""No URL Specified"")
	}
	return nil
}
type cloneResponse struct {
	HTML string `json:""html""`
}
type emailResponse struct {
	Text    string `json:""text""`
	HTML    string `json:""html""`
	Subject string `json:""subject""`
}
// ImportGroup imports a CSV of group members
func (as *Server) ImportGroup(w http.ResponseWriter, r *http.Request) {
	ts, err := util.ParseCSV(r)
	if err != nil {
		JSONResponse(w, models.Response{Success: false, Message: ""Error parsing CSV""}, http.StatusInternalServerError)
		return
	}
	JSONResponse(w, ts, http.StatusOK)
}
// ImportEmail allows for the importing of email.
// Returns a Message object
func (as *Server) ImportEmail(w http.ResponseWriter, r *http.Request) {
	if r.Method != ""POST"" {
		JSONResponse(w, models.Response{Success: false, Message: ""Method not allowed""}, http.StatusBadRequest)
		return
	}
	ir := struct {
		Content      string `json:""content""`
		ConvertLinks bool   `json:""convert_links""`
	}{}
	err := json.NewDecoder(r.Body).Decode(&ir)
	if err != nil {
		JSONResponse(w, models.Response{Success: false, Message: ""Error decoding JSON Request""}, http.StatusBadRequest)
		return
	}
	e, err := email.NewEmailFromReader(strings.NewReader(ir.Content))
	if err != nil {
		log.Error(err)
	}
	// If the user wants to convert links to point to
	// the landing page, let's make it happen by changing up
	// e.HTML
	if ir.ConvertLinks {
		d, err := goquery.NewDocumentFromReader(bytes.NewReader(e.HTML))
		if err != nil {
			JSONResponse(w, models.Response{Success: false, Message: err.Error()}, http.StatusBadRequest)
			return
		}
		d.Find(""a"").Each(func(i int, a *goquery.Selection) {
			a.SetAttr(""href"", ""{{.URL}}"")
		})
		h, err := d.Html()
		if err != nil {
			JSONResponse(w, models.Response{Success: false, Message: err.Error()}, http.StatusInternalServerError)
			return
		}
		e.HTML = []byte(h)
	}
	er := emailResponse{
		Subject: e.Subject,
		Text:    string(e.Text),
		HTML:    string(e.HTML),
	}
	JSONResponse(w, er, http.StatusOK)
}
// ImportSite allows for the importing of HTML from a website
// Without ""include_resources"" set, it will merely place a ""base"" tag
// so that all resources can be loaded relative to the given URL.
func (as *Server) ImportSite(w http.ResponseWriter, r *http.Request) {
	cr := cloneRequest{}
	if r.Method != ""POST"" {
		JSONResponse(w, models.Response{Success: false, Message: ""Method not allowed""}, http.StatusBadRequest)
		return
	}
	err := json.NewDecoder(r.Body).Decode(&cr)
	if err != nil {
		JSONResponse(w, models.Response{Success: false, Message: ""Error decoding JSON Request""}, http.StatusBadRequest)
		return
	}
	if err = cr.validate(); err != nil {
		JSONResponse(w, models.Response{Success: false, Message: err.Error()}, http.StatusBadRequest)
		return
	}
	restrictedDialer := dialer.Dialer()
	tr := &http.Transport{
		DialContext: restrictedDialer.DialContext,
		TLSClientConfig: &tls.Config{
			InsecureSkipVerify: true,
		},
	}
	client := &http.Client{Transport: tr}
	resp, err := client.Get(cr.URL)
	if err != nil {
		JSONResponse(w, models.Response{Success: false, Message: err.Error()}, http.StatusBadRequest)
		return
	}
	// Insert the base href tag to better handle relative resources
	d, err := goquery.NewDocumentFromResponse(resp)
	if err != nil {
		JSONResponse(w, models.Response{Success: false, Message: err.Error()}, http.StatusBadRequest)
		return
	}
	// Assuming we don't want to include resources, we'll need a base href
	if d.Find(""head base"").Length() == 0 {
		d.Find(""head"").PrependHtml(fmt.Sprintf(""<base href=\""%s\"">"", cr.URL))
	}
	forms := d.Find(""form"")
	forms.Each(func(i int, f *goquery.Selection) {
		// We'll want to store where we got the form from
		// (the current URL)
		url := f.AttrOr(""action"", cr.URL)
		if !strings.HasPrefix(url, ""http"") {
			url = fmt.Sprintf(""%s%s"", cr.URL, url)
		}
		f.PrependHtml(fmt.Sprintf(""<input type=\""hidden\"" name=\""__original_url\"" value=\""%s\""/>"", url))
	})
	h, err := d.Html()
	if err != nil {
		JSONResponse(w, models.Response{Success: false, Message: err.Error()}, http.StatusInternalServerError)
		return
	}
	cs := cloneResponse{HTML: h}
	JSONResponse(w, cs, http.StatusOK)
}
",CWE-918,158.0,0
"package api
import (
	""bytes""
	""encoding/json""
	""fmt""
	""net/http""
	""net/http/httptest""
	""strings""
	""testing""
	""github.com/gophish/gophish/dialer""
	""github.com/gophish/gophish/models""
)
func makeImportRequest(ctx *testContext, allowedHosts []string, url string) *httptest.ResponseRecorder {
	orig := dialer.DefaultDialer.AllowedHosts()
	dialer.SetAllowedHosts(allowedHosts)
	req := httptest.NewRequest(http.MethodPost, ""/api/import/site"",
		bytes.NewBuffer([]byte(fmt.Sprintf(`
			{
				""url"" : ""%s""
			}
		`, url))))
	req.Header.Set(""Content-Type"", ""application/json"")
	response := httptest.NewRecorder()
	ctx.apiServer.ImportSite(response, req)
	dialer.SetAllowedHosts(orig)
	return response
}
func TestDefaultDeniedImport(t *testing.T) {
	ctx := setupTest(t)
	metadataURL := ""http://169.254.169.254/latest/meta-data/""
	response := makeImportRequest(ctx, []string{}, metadataURL)
	expectedCode := http.StatusBadRequest
	if response.Code != expectedCode {
		t.Fatalf(""incorrect status code received. expected %d got %d"", expectedCode, response.Code)
	}
	got := &models.Response{}
	err := json.NewDecoder(response.Body).Decode(got)
	if err != nil {
		t.Fatalf(""error decoding body: %v"", err)
	}
	if !strings.Contains(got.Message, ""upstream connection denied"") {
		t.Fatalf(""incorrect response error provided: %s"", got.Message)
	}
}
func TestDefaultAllowedImport(t *testing.T) {
	ctx := setupTest(t)
	h := ""<html><head></head><body><img src=\""/test.png\""/></body></html>""
	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintln(w, h)
	}))
	defer ts.Close()
	response := makeImportRequest(ctx, []string{}, ts.URL)
	expectedCode := http.StatusOK
	if response.Code != expectedCode {
		t.Fatalf(""incorrect status code received. expected %d got %d"", expectedCode, response.Code)
	}
}
func TestCustomDeniedImport(t *testing.T) {
	ctx := setupTest(t)
	h := ""<html><head></head><body><img src=\""/test.png\""/></body></html>""
	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintln(w, h)
	}))
	defer ts.Close()
	response := makeImportRequest(ctx, []string{""192.168.1.1""}, ts.URL)
	expectedCode := http.StatusBadRequest
	if response.Code != expectedCode {
		t.Fatalf(""incorrect status code received. expected %d got %d"", expectedCode, response.Code)
	}
	got := &models.Response{}
	err := json.NewDecoder(response.Body).Decode(got)
	if err != nil {
		t.Fatalf(""error decoding body: %v"", err)
	}
	if !strings.Contains(got.Message, ""upstream connection denied"") {
		t.Fatalf(""incorrect response error provided: %s"", got.Message)
	}
}
",CWE-918,85.0,0
"package dialer
import (
	""fmt""
	""net""
	""syscall""
	""time""
)
// RestrictedDialer is used to create a net.Dialer which restricts outbound
// connections to only allowlisted IP ranges.
type RestrictedDialer struct {
	allowedHosts []*net.IPNet
}
// DefaultDialer is a global instance of a RestrictedDialer
var DefaultDialer = &RestrictedDialer{}
// SetAllowedHosts sets the list of allowed hosts or IP ranges for the default
// dialer.
func SetAllowedHosts(allowed []string) {
	DefaultDialer.SetAllowedHosts(allowed)
}
// AllowedHosts returns the configured hosts that are allowed for the dialer.
func (d *RestrictedDialer) AllowedHosts() []string {
	ranges := []string{}
	for _, ipRange := range d.allowedHosts {
		ranges = append(ranges, ipRange.String())
	}
	return ranges
}
// SetAllowedHosts sets the list of allowed hosts or IP ranges for the dialer.
func (d *RestrictedDialer) SetAllowedHosts(allowed []string) error {
	for _, ipRange := range allowed {
		// For flexibility, try to parse as an IP first since this will
		// undoubtedly cause issues. If it works, then just append the
		// appropriate subnet mask, then parse as CIDR
		if singleIP := net.ParseIP(ipRange); singleIP != nil {
			if singleIP.To4() != nil {
				ipRange += ""/32""
			} else {
				ipRange += ""/128""
			}
		}
		_, parsed, err := net.ParseCIDR(ipRange)
		if err != nil {
			return fmt.Errorf(""provided ip range is not valid CIDR notation: %v"", err)
		}
		d.allowedHosts = append(d.allowedHosts, parsed)
	}
	return nil
}
// Dialer returns a net.Dialer that restricts outbound connections to only the
// addresses allowed by the DefaultDialer.
func Dialer() *net.Dialer {
	return DefaultDialer.Dialer()
}
// Dialer returns a net.Dialer that restricts outbound connections to only the
// allowed addresses over TCP.
//
// By default, since Gophish anticipates connections originating to hosts on
// the local network, we only deny access to the link-local addresses at
// 169.254.0.0/16.
//
// If hosts are provided, then Gophish blocks access to all local addresses
// except the ones provided.
//
// This implementation is based on the blog post by Andrew Ayer at
// https://www.agwa.name/blog/post/preventing_server_side_request_forgery_in_golang
func (d *RestrictedDialer) Dialer() *net.Dialer {
	return &net.Dialer{
		Timeout:   30 * time.Second,
		KeepAlive: 30 * time.Second,
		Control:   restrictedControl(d.allowedHosts),
	}
}
// defaultDeny represents the list of IP ranges that we want to block unless
// explicitly overriden.
var defaultDeny = []string{
	""169.254.0.0/16"", // Link-local (used for VPS instance metadata)
}
// allInternal represents all internal hosts such that the only connections
// allowed are external ones.
var allInternal = []string{
	""0.0.0.0/8"",
	""127.0.0.0/8"",        // IPv4 loopback
	""10.0.0.0/8"",         // RFC1918
	""100.64.0.0/10"",      // CGNAT
	""172.16.0.0/12"",      // RFC1918
	""169.254.0.0/16"",     // RFC3927 link-local
	""192.88.99.0/24"",     // IPv6 to IPv4 Relay
	""192.168.0.0/16"",     // RFC1918
	""198.51.100.0/24"",    // TEST-NET-2
	""203.0.113.0/24"",     // TEST-NET-3
	""224.0.0.0/4"",        // Multicast
	""240.0.0.0/4"",        // Reserved
	""255.255.255.255/32"", // Broadcast
	""::/0"",               // Default route
	""::/128"",             // Unspecified address
	""::1/128"",            // IPv6 loopback
	""::ffff:0:0/96"",      // IPv4 mapped addresses.
	""::ffff:0:0:0/96"",    // IPv4 translated addresses.
	""fe80::/10"",          // IPv6 link-local
	""fc00::/7"",           // IPv6 unique local addr
}
type dialControl = func(network, address string, c syscall.RawConn) error
type restrictedDialer struct {
	*net.Dialer
	allowed []string
}
func restrictedControl(allowed []*net.IPNet) dialControl {
	return func(network string, address string, conn syscall.RawConn) error {
		if !(network == ""tcp4"" || network == ""tcp6"") {
			return fmt.Errorf(""%s is not a safe network type"", network)
		}
		host, _, err := net.SplitHostPort(address)
		if err != nil {
			return fmt.Errorf(""%s is not a valid host/port pair: %s"", address, err)
		}
		ip := net.ParseIP(host)
		if ip == nil {
			return fmt.Errorf(""%s is not a valid IP address"", host)
		}
		denyList := defaultDeny
		if len(allowed) > 0 {
			denyList = allInternal
		}
		for _, ipRange := range allowed {
			if ipRange.Contains(ip) {
				return nil
			}
		}
		for _, ipRange := range denyList {
			_, parsed, err := net.ParseCIDR(ipRange)
			if err != nil {
				return fmt.Errorf(""error parsing denied range: %v"", err)
			}
			if parsed.Contains(ip) {
				return fmt.Errorf(""upstream connection denied to internal host"")
			}
		}
		return nil
	}
}
",CWE-918,159.0,0
"package dialer
import (
	""fmt""
	""net""
	""strings""
	""syscall""
	""testing""
)
func TestDefaultDeny(t *testing.T) {
	control := restrictedControl([]*net.IPNet{})
	host := ""169.254.169.254""
	expected := fmt.Errorf(""upstream connection denied to internal host at %s"", host)
	conn := new(syscall.RawConn)
	got := control(""tcp4"", fmt.Sprintf(""%s:80"", host), *conn)
	if !strings.Contains(got.Error(), ""upstream connection denied"") {
		t.Fatalf(""unexpected error dialing denylisted host. expected %v got %v"", expected, got)
	}
}
func TestDefaultAllow(t *testing.T) {
	control := restrictedControl([]*net.IPNet{})
	host := ""1.1.1.1""
	conn := new(syscall.RawConn)
	got := control(""tcp4"", fmt.Sprintf(""%s:80"", host), *conn)
	if got != nil {
		t.Fatalf(""error dialing allowed host. got %v"", got)
	}
}
func TestCustomAllow(t *testing.T) {
	host := ""127.0.0.1""
	_, ipRange, _ := net.ParseCIDR(fmt.Sprintf(""%s/32"", host))
	allowed := []*net.IPNet{ipRange}
	control := restrictedControl(allowed)
	conn := new(syscall.RawConn)
	got := control(""tcp4"", fmt.Sprintf(""%s:80"", host), *conn)
	if got != nil {
		t.Fatalf(""error dialing allowed host. got %v"", got)
	}
}
func TestCustomDeny(t *testing.T) {
	host := ""127.0.0.1""
	_, ipRange, _ := net.ParseCIDR(fmt.Sprintf(""%s/32"", host))
	allowed := []*net.IPNet{ipRange}
	control := restrictedControl(allowed)
	conn := new(syscall.RawConn)
	expected := fmt.Errorf(""upstream connection denied to internal host at %s"", host)
	got := control(""tcp4"", ""192.168.1.2:80"", *conn)
	if !strings.Contains(got.Error(), ""upstream connection denied"") {
		t.Fatalf(""unexpected error dialing denylisted host. expected %v got %v"", expected, got)
	}
}
func TestSingleIP(t *testing.T) {
	orig := DefaultDialer.AllowedHosts()
	host := ""127.0.0.1""
	DefaultDialer.SetAllowedHosts([]string{host})
	control := DefaultDialer.Dialer().Control
	conn := new(syscall.RawConn)
	expected := fmt.Errorf(""upstream connection denied to internal host at %s"", host)
	got := control(""tcp4"", ""192.168.1.2:80"", *conn)
	if !strings.Contains(got.Error(), ""upstream connection denied"") {
		t.Fatalf(""unexpected error dialing denylisted host. expected %v got %v"", expected, got)
	}
	host = ""::1""
	DefaultDialer.SetAllowedHosts([]string{host})
	control = DefaultDialer.Dialer().Control
	conn = new(syscall.RawConn)
	expected = fmt.Errorf(""upstream connection denied to internal host at %s"", host)
	got = control(""tcp4"", ""192.168.1.2:80"", *conn)
	if !strings.Contains(got.Error(), ""upstream connection denied"") {
		t.Fatalf(""unexpected error dialing denylisted host. expected %v got %v"", expected, got)
	}
	// Test an allowed connection
	got = control(""tcp4"", fmt.Sprintf(""[%s]:80"", host), *conn)
	if got != nil {
		t.Fatalf(""error dialing allowed host. got %v"", got)
	}
	DefaultDialer.SetAllowedHosts(orig)
}
",CWE-918,86.0,0
"module github.com/gophish/gophish
go 1.13
require (
	bitbucket.org/liamstask/goose v0.0.0-20150115234039-8488cc47d90c
	github.com/NYTimes/gziphandler v1.1.1
	github.com/PuerkitoBio/goquery v1.5.0
	github.com/alecthomas/template v0.0.0-20190718012654-fb15b899a751 // indirect
	github.com/alecthomas/units v0.0.0-20190924025748-f65c72e2690d // indirect
	github.com/emersion/go-imap v1.0.4
	github.com/emersion/go-message v0.12.0
	github.com/go-sql-driver/mysql v1.5.0
	github.com/gophish/gomail v0.0.0-20200818021916-1f6d0dfd512e
	github.com/gorilla/context v1.1.1
	github.com/gorilla/csrf v1.6.2
	github.com/gorilla/handlers v1.4.2
	github.com/gorilla/mux v1.7.3
	github.com/gorilla/securecookie v1.1.1
	github.com/gorilla/sessions v1.2.0
	github.com/jinzhu/gorm v1.9.12
	github.com/jordan-wright/email v0.0.0-20200602115436-fd8a7622303e
	github.com/jordan-wright/unindexed v0.0.0-20181209214434-78fa79113c0f
	github.com/kylelemons/go-gypsy v0.0.0-20160905020020-08cad365cd28 // indirect
	github.com/mattn/go-sqlite3 v2.0.3+incompatible
	github.com/oschwald/maxminddb-golang v1.6.0
	github.com/sirupsen/logrus v1.4.2
	github.com/ziutek/mymysql v1.5.4 // indirect
	golang.org/x/crypto v0.0.0-20200128174031-69ecbb4d6d5d
	golang.org/x/time v0.0.0-20200416051211-89c76fbcd5d1
	gopkg.in/alecthomas/kingpin.v2 v2.2.6
	gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405
)
",CWE-918,34.0,0
"bitbucket.org/liamstask/goose v0.0.0-20150115234039-8488cc47d90c h1:bkb2NMGo3/Du52wvYj9Whth5KZfMV6d3O0Vbr3nz/UE=
bitbucket.org/liamstask/goose v0.0.0-20150115234039-8488cc47d90c/go.mod h1:hSVuE3qU7grINVSwrmzHfpg9k87ALBk+XaualNyUzI4=
github.com/NYTimes/gziphandler v1.1.1 h1:ZUDjpQae29j0ryrS0u/B8HZfJBtBQHjqw2rQ2cqUQ3I=
github.com/NYTimes/gziphandler v1.1.1/go.mod h1:n/CVRwUEOgIxrgPvAQhUUr9oeUtvrhMomdKFjzJNB0c=
github.com/PuerkitoBio/goquery v1.5.0 h1:uGvmFXOA73IKluu/F84Xd1tt/z07GYm8X49XKHP7EJk=
github.com/PuerkitoBio/goquery v1.5.0/go.mod h1:qD2PgZ9lccMbQlc7eEOjaeRlFQON7xY8kdmcsrnKqMg=
github.com/alecthomas/template v0.0.0-20190718012654-fb15b899a751 h1:JYp7IbQjafoB+tBA3gMyHYHrpOtNuDiK/uB5uXxq5wM=
github.com/alecthomas/template v0.0.0-20190718012654-fb15b899a751/go.mod h1:LOuyumcjzFXgccqObfd/Ljyb9UuFJ6TxHnclSeseNhc=
github.com/alecthomas/units v0.0.0-20190924025748-f65c72e2690d h1:UQZhZ2O0vMHr2cI+DC1Mbh0TJxzA3RcLoMsFw+aXw7E=
github.com/alecthomas/units v0.0.0-20190924025748-f65c72e2690d/go.mod h1:rBZYJk541a8SKzHPHnH3zbiI+7dagKZ0cgpgrD7Fyho=
github.com/andybalholm/cascadia v1.0.0 h1:hOCXnnZ5A+3eVDX8pvgl4kofXv2ELss0bKcqRySc45o=
github.com/andybalholm/cascadia v1.0.0/go.mod h1:GsXiBklL0woXo1j/WYWtSYYC4ouU9PqHO0sqidkEA4Y=
github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/denisenkom/go-mssqldb v0.0.0-20191124224453-732737034ffd h1:83Wprp6ROGeiHFAP8WJdI2RoxALQYgdllERc3N5N2DM=
github.com/denisenkom/go-mssqldb v0.0.0-20191124224453-732737034ffd/go.mod h1:xbL0rPBG9cCiLr28tMa8zpbdarY27NDyej4t/EjAShU=
github.com/emersion/go-imap v1.0.4 h1:uiCAIHM6Z5Jwkma1zdNDWWXxSCqb+/xHBkHflD7XBro=
github.com/emersion/go-imap v1.0.4/go.mod h1:yKASt+C3ZiDAiCSssxg9caIckWF/JG7ZQTO7GAmvicU=
github.com/emersion/go-message v0.11.1/go.mod h1:C4jnca5HOTo4bGN9YdqNQM9sITuT3Y0K6bSUw9RklvY=
github.com/emersion/go-message v0.12.0 h1:mZnv35eZ6lB6EftTQBgYXspOH0FQdhpFhSUhA9i6/Zg=
github.com/emersion/go-message v0.12.0/go.mod h1:C4jnca5HOTo4bGN9YdqNQM9sITuT3Y0K6bSUw9RklvY=
github.com/emersion/go-sasl v0.0.0-20191210011802-430746ea8b9b h1:uhWtEWBHgop1rqEk2klKaxPAkVDCXexai6hSuRQ7Nvs=
github.com/emersion/go-sasl v0.0.0-20191210011802-430746ea8b9b/go.mod h1:G/dpzLu16WtQpBfQ/z3LYiYJn3ZhKSGWn83fyoyQe/k=
github.com/emersion/go-textwrapper v0.0.0-20160606182133-d0e65e56babe h1:40SWqY0zE3qCi6ZrtTf5OUdNm5lDnGnjRSq9GgmeTrg=
github.com/emersion/go-textwrapper v0.0.0-20160606182133-d0e65e56babe/go.mod h1:aqO8z8wPrjkscevZJFVE1wXJrLpC5LtJG7fqLOsPb2U=
github.com/erikstmartin/go-testdb v0.0.0-20160219214506-8d10e4a1bae5 h1:Yzb9+7DPaBjB8zlTR87/ElzFsnQfuHnVUVqpZZIcV5Y=
github.com/erikstmartin/go-testdb v0.0.0-20160219214506-8d10e4a1bae5/go.mod h1:a2zkGnVExMxdzMo3M0Hi/3sEU+cWnZpSni0O6/Yb/P0=
github.com/go-sql-driver/mysql v1.4.1/go.mod h1:zAC/RDZ24gD3HViQzih4MyKcchzm+sOG5ZlKdlhCg5w=
github.com/go-sql-driver/mysql v1.5.0 h1:ozyZYNQW3x3HtqT1jira07DN2PArx2v7/mN66gGcHOs=
github.com/go-sql-driver/mysql v1.5.0/go.mod h1:DCzpHaOWr8IXmIStZouvnhqoel9Qv2LBy8hT2VhHyBg=
github.com/golang-sql/civil v0.0.0-20190719163853-cb61b32ac6fe h1:lXe2qZdvpiX5WZkZR4hgp4KJVfY3nMkvmwbVkpv1rVY=
github.com/golang-sql/civil v0.0.0-20190719163853-cb61b32ac6fe/go.mod h1:8vg3r2VgvsThLBIFL93Qb5yWzgyZWhEmBwUJWevAkK0=
github.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=
github.com/gophish/gomail v0.0.0-20200818021916-1f6d0dfd512e h1:URNpXdOxXAfuZ8wsr/DY27KTffVenKDjtNVAEwcR2Oo=
github.com/gophish/gomail v0.0.0-20200818021916-1f6d0dfd512e/go.mod h1:JGlHttcLdDp3F4g8bPHqqQnUUDuB3poB4zLXozQ0xCY=
github.com/gorilla/context v1.1.1 h1:AWwleXJkX/nhcU9bZSnZoi3h/qGYqQAGhq6zZe/aQW8=
github.com/gorilla/context v1.1.1/go.mod h1:kBGZzfjB9CEq2AlWe17Uuf7NDRt0dE0s8S51q0aT7Yg=
github.com/gorilla/csrf v1.6.2 h1:QqQ/OWwuFp4jMKgBFAzJVW3FMULdyUW7JoM4pEWuqKg=
github.com/gorilla/csrf v1.6.2/go.mod h1:7tSf8kmjNYr7IWDCYhd3U8Ck34iQ/Yw5CJu7bAkHEGI=
github.com/gorilla/handlers v1.4.2 h1:0QniY0USkHQ1RGCLfKxeNHK9bkDHGRYGNDFBCS+YARg=
github.com/gorilla/handlers v1.4.2/go.mod h1:Qkdc/uu4tH4g6mTK6auzZ766c4CA0Ng8+o/OAirnOIQ=
github.com/gorilla/mux v1.7.3 h1:gnP5JzjVOuiZD07fKKToCAOjS0yOpj/qPETTXCCS6hw=
github.com/gorilla/mux v1.7.3/go.mod h1:1lud6UwP+6orDFRuTfBEV8e9/aOM/c4fVVCaMa2zaAs=
github.com/gorilla/securecookie v1.1.1 h1:miw7JPhV+b/lAHSXz4qd/nN9jRiAFV5FwjeKyCS8BvQ=
github.com/gorilla/securecookie v1.1.1/go.mod h1:ra0sb63/xPlUeL+yeDciTfxMRAA+MP+HVt/4epWDjd4=
github.com/gorilla/sessions v1.2.0 h1:S7P+1Hm5V/AT9cjEcUD5uDaQSX0OE577aCXgoaKpYbQ=
github.com/gorilla/sessions v1.2.0/go.mod h1:dk2InVEVJ0sfLlnXv9EAgkf6ecYs/i80K/zI+bUmuGM=
github.com/jinzhu/gorm v1.9.12 h1:Drgk1clyWT9t9ERbzHza6Mj/8FY/CqMyVzOiHviMo6Q=
github.com/jinzhu/gorm v1.9.12/go.mod h1:vhTjlKSJUTWNtcbQtrMBFCxy7eXTzeCAzfL5fBZT/Qs=
github.com/jinzhu/inflection v1.0.0 h1:K317FqzuhWc8YvSVlFMCCUb36O/S9MCKRDI7QkRKD/E=
github.com/jinzhu/inflection v1.0.0/go.mod h1:h+uFLlag+Qp1Va5pdKtLDYj+kHp5pxUVkryuEj+Srlc=
github.com/jinzhu/now v1.0.1 h1:HjfetcXq097iXP0uoPCdnM4Efp5/9MsM0/M+XOTeR3M=
github.com/jinzhu/now v1.0.1/go.mod h1:d3SSVoowX0Lcu0IBviAWJpolVfI5UJVZZ7cO71lE/z8=
github.com/jordan-wright/email v0.0.0-20200602115436-fd8a7622303e h1:OGunVjqY7y4U4laftpEHv+mvZBlr7UGimJXKEGQtg48=
github.com/jordan-wright/email v0.0.0-20200602115436-fd8a7622303e/go.mod h1:Fy2gCFfZhay8jplf/Csj6cyH/oshQTkLQYZbKkcV+SY=
github.com/jordan-wright/unindexed v0.0.0-20181209214434-78fa79113c0f h1:bYVTBvVHcAYDkH8hyVMRUW7J2mYQNNSmQPXGadYd1nY=
github.com/jordan-wright/unindexed v0.0.0-20181209214434-78fa79113c0f/go.mod h1:eRt05O5haIXGKGodWjpQ2xdgBHTE7hg/pzsukNi9IRA=
github.com/konsorten/go-windows-terminal-sequences v1.0.1 h1:mweAR1A6xJ3oS2pRaGiHgQ4OO8tzTaLawm8vnODuwDk=
github.com/konsorten/go-windows-terminal-sequences v1.0.1/go.mod h1:T0+1ngSBFLxvqU3pZ+m/2kptfBszLMUkC4ZK/EgS/cQ=
github.com/kylelemons/go-gypsy v0.0.0-20160905020020-08cad365cd28 h1:mkl3tvPHIuPaWsLtmHTybJeoVEW7cbePK73Ir8VtruA=
github.com/kylelemons/go-gypsy v0.0.0-20160905020020-08cad365cd28/go.mod h1:T/T7jsxVqf9k/zYOqbgNAsANsjxTd1Yq3htjDhQ1H0c=
github.com/lib/pq v1.1.1 h1:sJZmqHoEaY7f+NPP8pgLB/WxulyR3fewgCM2qaSlBb4=
github.com/lib/pq v1.1.1/go.mod h1:5WUZQaWbwv1U+lTReE5YruASi9Al49XbQIvNi/34Woo=
github.com/martinlindhe/base36 v1.0.0/go.mod h1:+AtEs8xrBpCeYgSLoY/aJ6Wf37jtBuR0s35750M27+8=
github.com/mattn/go-sqlite3 v2.0.1+incompatible/go.mod h1:FPy6KqzDD04eiIsT53CuJW3U88zkxoIYsOqkbpncsNc=
github.com/mattn/go-sqlite3 v2.0.3+incompatible h1:gXHsfypPkaMZrKbD5209QV9jbUTJKjyR5WD3HYQSd+U=
github.com/mattn/go-sqlite3 v2.0.3+incompatible/go.mod h1:FPy6KqzDD04eiIsT53CuJW3U88zkxoIYsOqkbpncsNc=
github.com/oschwald/maxminddb-golang v1.6.0 h1:KAJSjdHQ8Kv45nFIbtoLGrGWqHFajOIm7skTyz/+Dls=
github.com/oschwald/maxminddb-golang v1.6.0/go.mod h1:DUJFucBg2cvqx42YmDa/+xHvb0elJtOm3o4aFQ/nb/w=
github.com/pkg/errors v0.8.0 h1:WdK/asTD0HN+q6hsWO3/vpuAkAr+tw6aNJNDFFf0+qw=
github.com/pkg/errors v0.8.0/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=
github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/sirupsen/logrus v1.4.2 h1:SPIRibHv4MatM3XXNO2BJeFLZwZ2LvZgfQ5+UNI2im4=
github.com/sirupsen/logrus v1.4.2/go.mod h1:tLMulIdttU9McNUspp0xgXVQah82FyeX6MwdIuYE2rE=
github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
github.com/stretchr/objx v0.1.1/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
github.com/stretchr/testify v1.2.2/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=
github.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=
github.com/stretchr/testify v1.4.0 h1:2E4SXV/wtOkTonXsotYi4li6zVWxYlZuYNCXe9XRJyk=
github.com/stretchr/testify v1.4.0/go.mod h1:j7eGeouHqKxXV5pUuKE4zz7dFj8WfuZ+81PSLYec5m4=
github.com/ziutek/mymysql v1.5.4 h1:GB0qdRGsTwQSBVYuVShFBKaXSnSnYYC2d9knnE1LHFs=
github.com/ziutek/mymysql v1.5.4/go.mod h1:LMSpPZ6DbqWFxNCHW77HeMg9I646SAhApZ/wKdgO/C0=
golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=
golang.org/x/crypto v0.0.0-20190325154230-a5d413f7728c/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=
golang.org/x/crypto v0.0.0-20191205180655-e7c4368fe9dd/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=
golang.org/x/crypto v0.0.0-20200128174031-69ecbb4d6d5d h1:9FCpayM9Egr1baVnV1SX0H87m+XB0B8S0hAMi99X/3U=
golang.org/x/crypto v0.0.0-20200128174031-69ecbb4d6d5d/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=
golang.org/x/net v0.0.0-20180218175443-cbe0f9307d01/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20181114220301-adae6a3d119a/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3 h1:0GoQqolDA55aaLxZyTzK/Y2ePZzZTUrRacwib7cNsYQ=
golang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20190422165155-953cdadca894/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20191224085550-c709ea063b76 h1:Dho5nD6R3PcW2SH1or8vS0dszDaXRxIw55lBX7XiE5g=
golang.org/x/sys v0.0.0-20191224085550-c709ea063b76/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
golang.org/x/text v0.3.2 h1:tW2bmiBqwgJj/UpqtC8EpXEZVYOwU0yG4iWbprSVAcs=
golang.org/x/text v0.3.2/go.mod h1:bEr9sfX3Q8Zfm5fL9x+3itogRgK3+ptLWKqgva+5dAk=
golang.org/x/time v0.0.0-20200416051211-89c76fbcd5d1 h1:NusfzzA6yGQ+ua51ck7E3omNUX/JuqbFSaRGqU8CcLI=
golang.org/x/time v0.0.0-20200416051211-89c76fbcd5d1/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=
golang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
google.golang.org/appengine v1.4.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=
gopkg.in/alecthomas/kingpin.v2 v2.2.6 h1:jMFz6MfLP0/4fUyZle81rXUoxOBFi19VUFKVDOQfozc=
gopkg.in/alecthomas/kingpin.v2 v2.2.6/go.mod h1:FMv+mEhP44yOT+4EoQTLFTRgOQ1FBLkstjWtayDeSgw=
gopkg.in/alexcesaro/quotedprintable.v3 v3.0.0-20150716171945-2caba252f4dc h1:2gGKlE2+asNV9m7xrywl36YYNnBG5ZQ0r/BOOxqPpmk=
gopkg.in/alexcesaro/quotedprintable.v3 v3.0.0-20150716171945-2caba252f4dc/go.mod h1:m7x9LTH6d71AHyAX77c9yqWCCa3UKHcVEj9y7hAtKDk=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/yaml.v2 v2.2.2 h1:ZCJp+EgiOT7lHqUV2J862kp8Qj64Jo6az82+3Td9dZw=
gopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
",CWE-918,115.0,0
"package main
/*
gophish - Open-Source Phishing Framework
The MIT License (MIT)
Copyright (c) 2013 Jordan Wright
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the ""Software""), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/
import (
	""fmt""
	""io/ioutil""
	""net/http""
	""os""
	""os/signal""
	""gopkg.in/alecthomas/kingpin.v2""
	""github.com/gophish/gophish/config""
	""github.com/gophish/gophish/controllers""
	""github.com/gophish/gophish/dialer""
	""github.com/gophish/gophish/imap""
	log ""github.com/gophish/gophish/logger""
	""github.com/gophish/gophish/middleware""
	""github.com/gophish/gophish/models""
	""github.com/gophish/gophish/webhook""
)
const (
	modeAll   string = ""all""
	modeAdmin string = ""admin""
	modePhish string = ""phish""
)
var (
	configPath    = kingpin.Flag(""config"", ""Location of config.json."").Default(""./config.json"").String()
	disableMailer = kingpin.Flag(""disable-mailer"", ""Disable the mailer (for use with multi-system deployments)"").Bool()
	mode          = kingpin.Flag(""mode"", fmt.Sprintf(""Run the binary in one of the modes (%s, %s or %s)"", modeAll, modeAdmin, modePhish)).
			Default(""all"").Enum(modeAll, modeAdmin, modePhish)
)
func main() {
	// Load the version
	version, err := ioutil.ReadFile(""./VERSION"")
	if err != nil {
		log.Fatal(err)
	}
	kingpin.Version(string(version))
	// Parse the CLI flags and load the config
	kingpin.CommandLine.HelpFlag.Short('h')
	kingpin.Parse()
	// Load the config
	conf, err := config.LoadConfig(*configPath)
	// Just warn if a contact address hasn't been configured
	if err != nil {
		log.Fatal(err)
	}
	if conf.ContactAddress == """" {
		log.Warnf(""No contact address has been configured."")
		log.Warnf(""Please consider adding a contact_address entry in your config.json"")
	}
	config.Version = string(version)
	// Configure our various upstream clients to make sure that we restrict
	// outbound connections as needed.
	dialer.SetAllowedHosts(conf.AdminConf.AllowedInternalHosts)
	webhook.SetTransport(&http.Transport{
		DialContext: dialer.Dialer().DialContext,
	})
	err = log.Setup(conf.Logging)
	if err != nil {
		log.Fatal(err)
	}
	// Provide the option to disable the built-in mailer
	// Setup the global variables and settings
	err = models.Setup(conf)
	if err != nil {
		log.Fatal(err)
	}
	// Unlock any maillogs that may have been locked for processing
	// when Gophish was last shutdown.
	err = models.UnlockAllMailLogs()
	if err != nil {
		log.Fatal(err)
	}
	// Create our servers
	adminOptions := []controllers.AdminServerOption{}
	if *disableMailer {
		adminOptions = append(adminOptions, controllers.WithWorker(nil))
	}
	adminConfig := conf.AdminConf
	adminServer := controllers.NewAdminServer(adminConfig, adminOptions...)
	middleware.Store.Options.Secure = adminConfig.UseTLS
	phishConfig := conf.PhishConf
	phishServer := controllers.NewPhishingServer(phishConfig)
	imapMonitor := imap.NewMonitor()
	if *mode == ""admin"" || *mode == ""all"" {
		go adminServer.Start()
		go imapMonitor.Start()
	}
	if *mode == ""phish"" || *mode == ""all"" {
		go phishServer.Start()
	}
	// Handle graceful shutdown
	c := make(chan os.Signal, 1)
	signal.Notify(c, os.Interrupt)
	<-c
	log.Info(""CTRL+C Received... Gracefully shutting down servers"")
	if *mode == modeAdmin || *mode == modeAll {
		adminServer.Shutdown()
		imapMonitor.Shutdown()
	}
	if *mode == modePhish || *mode == modeAll {
		phishServer.Shutdown()
	}
}
",CWE-918,146.0,0
"package models
import (
	""fmt""
	""github.com/jinzhu/gorm""
	check ""gopkg.in/check.v1""
)
func (s *ModelsSuite) TestPostSMTP(c *check.C) {
	smtp := SMTP{
		Name:        ""Test SMTP"",
		Host:        ""1.1.1.1:25"",
		FromAddress: ""Foo Bar <foo@example.com>"",
		UserId:      1,
	}
	err := PostSMTP(&smtp)
	c.Assert(err, check.Equals, nil)
	ss, err := GetSMTPs(1)
	c.Assert(err, check.Equals, nil)
	c.Assert(len(ss), check.Equals, 1)
}
func (s *ModelsSuite) TestPostSMTPNoHost(c *check.C) {
	smtp := SMTP{
		Name:        ""Test SMTP"",
		FromAddress: ""Foo Bar <foo@example.com>"",
		UserId:      1,
	}
	err := PostSMTP(&smtp)
	c.Assert(err, check.Equals, ErrHostNotSpecified)
}
func (s *ModelsSuite) TestPostSMTPNoFrom(c *check.C) {
	smtp := SMTP{
		Name:   ""Test SMTP"",
		UserId: 1,
		Host:   ""1.1.1.1:25"",
	}
	err := PostSMTP(&smtp)
	c.Assert(err, check.Equals, ErrFromAddressNotSpecified)
}
func (s *ModelsSuite) TestPostSMTPValidHeader(c *check.C) {
	smtp := SMTP{
		Name:        ""Test SMTP"",
		Host:        ""1.1.1.1:25"",
		FromAddress: ""Foo Bar <foo@example.com>"",
		UserId:      1,
		Headers: []Header{
			Header{Key: ""Reply-To"", Value: ""test@example.com""},
			Header{Key: ""X-Mailer"", Value: ""gophish""},
		},
	}
	err := PostSMTP(&smtp)
	c.Assert(err, check.Equals, nil)
	ss, err := GetSMTPs(1)
	c.Assert(err, check.Equals, nil)
	c.Assert(len(ss), check.Equals, 1)
}
func (s *ModelsSuite) TestSMTPGetDialer(ch *check.C) {
	host := ""localhost""
	port := 25
	smtp := SMTP{
		Host:             fmt.Sprintf(""%s:%d"", host, port),
		IgnoreCertErrors: false,
	}
	d, err := smtp.GetDialer()
	ch.Assert(err, check.Equals, nil)
	dialer := d.(*Dialer).Dialer
	ch.Assert(dialer.Host, check.Equals, host)
	ch.Assert(dialer.Port, check.Equals, port)
	ch.Assert(dialer.TLSConfig.ServerName, check.Equals, host)
	ch.Assert(dialer.TLSConfig.InsecureSkipVerify, check.Equals, smtp.IgnoreCertErrors)
}
func (s *ModelsSuite) TestGetInvalidSMTP(ch *check.C) {
	_, err := GetSMTP(-1, 1)
	ch.Assert(err, check.Equals, gorm.ErrRecordNotFound)
}
func (s *ModelsSuite) TestDefaultDeniedDial(ch *check.C) {
	host := ""169.254.169.254""
	port := 25
	smtp := SMTP{
		Host: fmt.Sprintf(""%s:%d"", host, port),
	}
	d, err := smtp.GetDialer()
	ch.Assert(err, check.Equals, nil)
	_, err = d.Dial()
	ch.Assert(err, check.ErrorMatches, "".*upstream connection denied.*"")
}
",CWE-918,96.0,0
"package webhook
import (
	""bytes""
	""crypto/hmac""
	""crypto/sha256""
	""encoding/hex""
	""encoding/json""
	""errors""
	""fmt""
	""net/http""
	""time""
	log ""github.com/gophish/gophish/logger""
)
const (
	// DefaultTimeoutSeconds is the number of seconds before a timeout occurs
	// when sending a webhook
	DefaultTimeoutSeconds = 10
	// MinHTTPStatusErrorCode is the lower bound of HTTP status codes which
	// indicate an error occurred
	MinHTTPStatusErrorCode = 400
	// SignatureHeader is the name of the HTTP header which contains the
	// webhook signature
	SignatureHeader = ""X-Gophish-Signature""
	// Sha256Prefix is the prefix that specifies the hashing algorithm used
	// for the signature
	Sha256Prefix = ""sha256""
)
// Sender represents a type which can send webhooks to an EndPoint
type Sender interface {
	Send(endPoint EndPoint, data interface{}) error
}
type defaultSender struct {
	client *http.Client
}
var senderInstance = &defaultSender{
	client: &http.Client{
		Timeout: time.Second * DefaultTimeoutSeconds,
		CheckRedirect: func(req *http.Request, via []*http.Request) error {
			return http.ErrUseLastResponse
		},
	},
}
// SetTransport sets the underlying transport for the default webhook client.
func SetTransport(tr *http.Transport) {
	senderInstance.client.Transport = tr
}
// EndPoint represents a URL to send the webhook to, as well as a secret used
// to sign the event
type EndPoint struct {
	URL    string
	Secret string
}
// Send sends data to a single EndPoint
func Send(endPoint EndPoint, data interface{}) error {
	return senderInstance.Send(endPoint, data)
}
// SendAll sends data to multiple EndPoints
func SendAll(endPoints []EndPoint, data interface{}) {
	for _, e := range endPoints {
		go func(e EndPoint) {
			senderInstance.Send(e, data)
		}(e)
	}
}
// Send contains the implementation of sending webhook to an EndPoint
func (ds defaultSender) Send(endPoint EndPoint, data interface{}) error {
	jsonData, err := json.Marshal(data)
	if err != nil {
		log.Error(err)
		return err
	}
	req, err := http.NewRequest(""POST"", endPoint.URL, bytes.NewBuffer(jsonData))
	if err != nil {
		log.Error(err)
		return err
	}
	signat, err := sign(endPoint.Secret, jsonData)
	if err != nil {
		log.Error(err)
		return err
	}
	req.Header.Set(SignatureHeader, fmt.Sprintf(""%s=%s"", Sha256Prefix, signat))
	req.Header.Set(""Content-Type"", ""application/json"")
	resp, err := ds.client.Do(req)
	if err != nil {
		log.Error(err)
		return err
	}
	defer resp.Body.Close()
	if resp.StatusCode >= MinHTTPStatusErrorCode {
		errMsg := fmt.Sprintf(""http status of response: %s"", resp.Status)
		log.Error(errMsg)
		return errors.New(errMsg)
	}
	return nil
}
func sign(secret string, data []byte) (string, error) {
	hash1 := hmac.New(sha256.New, []byte(secret))
	_, err := hash1.Write(data)
	if err != nil {
		return """", err
	}
	hexStr := hex.EncodeToString(hash1.Sum(nil))
	return hexStr, nil
}
",CWE-918,124.0,0
"package middleware
import (
	""encoding/json""
	""fmt""
	""net/http""
	""strings""
	ctx ""github.com/gophish/gophish/context""
	""github.com/gophish/gophish/models""
	""github.com/gorilla/csrf""
)
// CSRFExemptPrefixes are a list of routes that are exempt from CSRF protection
var CSRFExemptPrefixes = []string{
	""/api"",
}
// CSRFExceptions is a middleware that prevents CSRF checks on routes listed in
// CSRFExemptPrefixes.
func CSRFExceptions(handler http.Handler) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		for _, prefix := range CSRFExemptPrefixes {
			if strings.HasPrefix(r.URL.Path, prefix) {
				r = csrf.UnsafeSkipCheck(r)
				break
			}
		}
		handler.ServeHTTP(w, r)
	}
}
// Use allows us to stack middleware to process the request
// Example taken from https://github.com/gorilla/mux/pull/36
func Use(handler http.HandlerFunc, mid ...func(http.Handler) http.HandlerFunc) http.HandlerFunc {
	for _, m := range mid {
		handler = m(handler)
	}
	return handler
}
// GetContext wraps each request in a function which fills in the context for a given request.
// This includes setting the User and Session keys and values as necessary for use in later functions.
func GetContext(handler http.Handler) http.HandlerFunc {
	// Set the context here
	return func(w http.ResponseWriter, r *http.Request) {
		// Parse the request form
		err := r.ParseForm()
		if err != nil {
			http.Error(w, ""Error parsing request"", http.StatusInternalServerError)
		}
		// Set the context appropriately here.
		// Set the session
		session, _ := Store.Get(r, ""gophish"")
		// Put the session in the context so that we can
		// reuse the values in different handlers
		r = ctx.Set(r, ""session"", session)
		if id, ok := session.Values[""id""]; ok {
			u, err := models.GetUser(id.(int64))
			if err != nil {
				r = ctx.Set(r, ""user"", nil)
			} else {
				r = ctx.Set(r, ""user"", u)
			}
		} else {
			r = ctx.Set(r, ""user"", nil)
		}
		handler.ServeHTTP(w, r)
		// Remove context contents
		ctx.Clear(r)
	}
}
// RequireAPIKey ensures that a valid API key is set as either the api_key GET
// parameter, or a Bearer token.
func RequireAPIKey(handler http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set(""Access-Control-Allow-Origin"", ""*"")
		if r.Method == ""OPTIONS"" {
			w.Header().Set(""Access-Control-Allow-Methods"", ""POST, GET, OPTIONS"")
			w.Header().Set(""Access-Control-Max-Age"", ""1000"")
			w.Header().Set(""Access-Control-Allow-Headers"", ""Origin, X-Requested-With, Content-Type, Accept"")
			return
		}
		r.ParseForm()
		ak := r.Form.Get(""api_key"")
		// If we can't get the API key, we'll also check for the
		// Authorization Bearer token
		if ak == """" {
			tokens, ok := r.Header[""Authorization""]
			if ok && len(tokens) >= 1 {
				ak = tokens[0]
				ak = strings.TrimPrefix(ak, ""Bearer "")
			}
		}
		if ak == """" {
			JSONError(w, http.StatusUnauthorized, ""API Key not set"")
			return
		}
		u, err := models.GetUserByAPIKey(ak)
		if err != nil {
			JSONError(w, http.StatusUnauthorized, ""Invalid API Key"")
			return
		}
		r = ctx.Set(r, ""user"", u)
		r = ctx.Set(r, ""user_id"", u.Id)
		r = ctx.Set(r, ""api_key"", ak)
		handler.ServeHTTP(w, r)
	})
}
// RequireLogin checks to see if the user is currently logged in.
// If not, the function returns a 302 redirect to the login page.
func RequireLogin(handler http.Handler) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		if u := ctx.Get(r, ""user""); u != nil {
			// If a password change is required for the user, then redirect them
			// to the login page
			currentUser := u.(models.User)
			if currentUser.PasswordChangeRequired && r.URL.Path != ""/reset_password"" {
				q := r.URL.Query()
				q.Set(""next"", r.URL.Path)
				http.Redirect(w, r, fmt.Sprintf(""/reset_password?%s"", q.Encode()), http.StatusTemporaryRedirect)
				return
			}
			handler.ServeHTTP(w, r)
			return
		}
		q := r.URL.Query()
		q.Set(""next"", r.URL.Path)
		http.Redirect(w, r, fmt.Sprintf(""/login?%s"", q.Encode()), http.StatusTemporaryRedirect)
	}
}
// EnforceViewOnly is a global middleware that limits the ability to edit
// objects to accounts with the PermissionModifyObjects permission.
func EnforceViewOnly(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// If the request is for any non-GET HTTP method, e.g. POST, PUT,
		// or DELETE, we need to ensure the user has the appropriate
		// permission.
		if r.Method != http.MethodGet && r.Method != http.MethodHead && r.Method != http.MethodOptions {
			user := ctx.Get(r, ""user"").(models.User)
			access, err := user.HasPermission(models.PermissionModifyObjects)
			if err != nil {
				http.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
				return
			}
			if !access {
				http.Error(w, http.StatusText(http.StatusForbidden), http.StatusForbidden)
				return
			}
		}
		next.ServeHTTP(w, r)
	})
}
// RequirePermission checks to see if the user has the requested permission
// before executing the handler. If the request is unauthorized, a JSONError
// is returned.
func RequirePermission(perm string) func(http.Handler) http.HandlerFunc {
	return func(next http.Handler) http.HandlerFunc {
		return func(w http.ResponseWriter, r *http.Request) {
			user := ctx.Get(r, ""user"").(models.User)
			access, err := user.HasPermission(perm)
			if err != nil {
				JSONError(w, http.StatusInternalServerError, err.Error())
				return
			}
			if !access {
				JSONError(w, http.StatusForbidden, http.StatusText(http.StatusForbidden))
				return
			}
			next.ServeHTTP(w, r)
		}
	}
}
// ApplySecurityHeaders applies various security headers according to best-
// practices.
func ApplySecurityHeaders(next http.Handler) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		csp := ""frame-ancestors 'none';""
		w.Header().Set(""Content-Security-Policy"", csp)
		w.Header().Set(""X-Frame-Options"", ""DENY"")
		next.ServeHTTP(w, r)
	}
}
// JSONError returns an error in JSON format with the given
// status code and message
func JSONError(w http.ResponseWriter, c int, m string) {
	cj, _ := json.MarshalIndent(models.Response{Success: false, Message: m}, """", ""  "")
	w.Header().Set(""Content-Type"", ""application/json"")
	w.WriteHeader(c)
	fmt.Fprintf(w, ""%s"", cj)
}
",CWE-1021,198.0,0
"package platform
import (
	""os""
	""github.com/dropbox/godropbox/errors""
	""github.com/hectane/go-acl""
	""github.com/pritunl/pritunl-client-electron/service/errortypes""
	""golang.org/x/sys/windows""
)
func MkdirSecure(pth string) (err error) {
	err = os.MkdirAll(pth, 0755)
	if err != nil {
		err = &errortypes.WriteError{
			errors.Wrap(err, ""utils: Failed to create directory""),
		}
		return
	}
	err = acl.Apply(
		pth,
		true,
		false,
		acl.GrantName(windows.GENERIC_ALL, ""SYSTEM""),
		acl.GrantName(windows.GENERIC_ALL, ""Administrators""),
	)
	if err != nil {
		err = &errortypes.WriteError{
			errors.Wrap(err, ""utils: Failed to acl directory""),
		}
		return
	}
	return
}
",CWE-269,37.0,0
"// +build !windows
package errors
import (
	""os""
	""syscall""
)
// Abort will terminate & sends SIGTERM to process
func Abort(i ...int) {
	if _, err := os.Stat(""/.dockerenv""); err == nil {
		os.Exit(i[0])
	}
	pgid, err := syscall.Getpgid(syscall.Getpid())
	if err != nil {
		Exit(err.Error())
	}
	// nolint:errcheck
	syscall.Kill(-pgid, syscall.SIGTERM)
}
",CWE-476,24.0,0
"module github.com/fleetdm/fleet
go 1.12
require (
	cloud.google.com/go v0.37.4
	github.com/AbGuthrie/goquery/v2 v2.0.1
	github.com/VividCortex/gohistogram v1.0.0 // indirect
	github.com/VividCortex/mysqlerr v0.0.0-20170204212430-6c6b55f8796f
	github.com/WatchBeam/clock v0.0.0-20170901150240-b08e6b4da7ea
	github.com/aws/aws-sdk-go v1.26.8
	github.com/beevik/etree v1.1.0
	github.com/bmizerany/assert v0.0.0-20160611221934-b7ed37b82869
	github.com/briandowns/spinner v0.0.0-20170614154858-48dbb65d7bd5
	github.com/cenkalti/backoff/v4 v4.0.0
	github.com/cpuguy83/go-md2man/v2 v2.0.0 // indirect
	github.com/davecgh/go-spew v1.1.1
	github.com/dgrijalva/jwt-go v3.2.0+incompatible
	github.com/e-dard/netbug v0.0.0-20151029172837-e64d308a0b20
	github.com/elazarl/go-bindata-assetfs v1.0.0
	github.com/fatih/color v1.7.0 // indirect
	github.com/ghodss/yaml v1.0.0
	github.com/go-kit/kit v0.8.0
	github.com/go-sql-driver/mysql v1.5.0
	github.com/gomodule/redigo v2.0.0+incompatible
	github.com/google/uuid v0.0.0-20161128191214-064e2069ce9c
	github.com/gorilla/mux v1.6.2
	github.com/gorilla/websocket v1.4.2
	github.com/gosuri/uilive v0.0.4
	github.com/hashicorp/golang-lru v0.5.1 // indirect
	github.com/hashicorp/hcl v0.0.0-20180404174102-ef8a98b0bbce // indirect
	github.com/igm/sockjs-go v3.0.0+incompatible
	github.com/igm/sockjs-go/v3 v3.0.0
	github.com/inconshreveable/mousetrap v1.0.0 // indirect
	github.com/jmoiron/sqlx v0.0.0-20180406164412-2aeb6a910c2b
	github.com/jonboulle/clockwork v0.2.2 // indirect
	github.com/kolide/goose v0.0.0-20181015214854-7aebd1deb5ab
	github.com/kolide/kit v0.0.0-20180421083548-36eb8dc43916
	github.com/kolide/launcher v0.0.0-20180427153757-cb412b945cf7
	github.com/kolide/osquery-go v0.0.0-20190904034940-a74aa860032d
	github.com/lib/pq v1.2.0 // indirect
	github.com/magiconair/properties v1.7.6 // indirect
	github.com/mattermost/xml-roundtrip-validator v0.0.0-20201213122252-bcd7e1b9601e
	github.com/mattn/go-isatty v0.0.12 // indirect
	github.com/mattn/go-runewidth v0.0.8 // indirect
	github.com/mattn/go-sqlite3 v1.11.0 // indirect
	github.com/mitchellh/mapstructure v0.0.0-20180220230111-00c29f56e238 // indirect
	github.com/mixer/clock v0.0.0-20200713181918-dd2ce6ac2af6
	github.com/olekukonko/tablewriter v0.0.0-20180506121414-d4647c9c7a84
	github.com/patrickmn/sortutil v0.0.0-20120526081524-abeda66eb583
	github.com/pelletier/go-toml v1.1.0 // indirect
	github.com/pkg/errors v0.8.1
	github.com/pressly/goose v2.6.0+incompatible
	github.com/prometheus/client_golang v0.9.3-0.20190127221311-3c4408c8b829
	github.com/russellhaering/gosaml2 v0.3.1
	github.com/russellhaering/goxmldsig v1.1.0
	github.com/spf13/afero v1.1.0 // indirect
	github.com/spf13/cast v1.2.0
	github.com/spf13/cobra v0.0.2
	github.com/spf13/jwalterweatherman v0.0.0-20180109140146-7c0cea34c8ec // indirect
	github.com/spf13/pflag v1.0.1 // indirect
	github.com/spf13/viper v1.0.2
	github.com/stretchr/testify v1.6.1
	github.com/urfave/cli v1.22.4
	go.opencensus.io v0.20.2 // indirect
	golang.org/x/crypto v0.0.0-20200622213623-75b288015ac9
	golang.org/x/oauth2 v0.0.0-20190402181905-9f3314589c9a // indirect
	golang.org/x/tools v0.0.0-20201102212025-f46e4245211d // indirect
	google.golang.org/api v0.3.2 // indirect
	google.golang.org/grpc v1.19.0
	gopkg.in/guregu/null.v3 v3.4.0
	gopkg.in/natefinch/lumberjack.v2 v2.0.0-20170531160350-a96e63847dc3
	gopkg.in/yaml.v2 v2.2.2
)
",CWE-290,75.0,0
"package fleet
const (
	// ActionRead refers to reading an entity.
	ActionRead = ""read""
	// ActionList refers to listing an entity.
	ActionList = ""list""
	// ActionWrite refers to writing (CRUD operations) an entity.
	ActionWrite = ""write""
	//
	// User specific actions
	//
	// ActionWriteRole is a write to a user's global roles and teams.
	//
	// While the Write action allows setting the role on creation of a user, the
	// ActionWriteRole action is required to modify an existing user's password.
	ActionWriteRole = ""write_role""
	// ActionChangePassword is the permission to change a user's password.
	//
	// While the Write action allows setting the password on creation of a user, the
	// ActionChangePassword action is required to modify an existing user's password.
	ActionChangePassword = ""change_password""
	//
	// Query specific actions
	//
	// ActionRun is the action for running a live query.
	ActionRun = ""run""
	// ActionRunNew is the action for running a new live query.
	ActionRunNew = ""run_new""
)
",CWE-863,35.0,0
"package fleet
import (
	""errors""
	""strconv""
	""strings""
	""github.com/fleetdm/fleet/v4/server/ptr""
)
type PackListOptions struct {
	ListOptions
	// IncludeSystemPacks will include Global & Team Packs while listing packs
	IncludeSystemPacks bool
}
// Pack is the structure which represents an osquery query pack.
//
// NOTE: A ""team pack"" is a special type of pack with Pack.Type=""team-$TEAM_ID"".
// Such team packs hold the scheduled queries for a team. This is different from a
// pack that has a team as target (Pack.Teams and Pack.TeamIDs fields).
type Pack struct {
	UpdateCreateTimestamps
	ID          uint   `json:""id""`
	Name        string `json:""name""`
	Description string `json:""description,omitempty""`
	Platform    string `json:""platform,omitempty""`
	Disabled    bool   `json:""disabled""`
	// Type indicates the type of the pack:
	//	- ""global"" is the type of the global pack.
	//	- ""team-$ID"" is the type for team packs.
	//	- nil is the type for a user created pack.
	Type     *string  `json:""type"" db:""pack_type""`
	Labels   []Target `json:""labels""`
	LabelIDs []uint   `json:""label_ids""`
	Hosts    []Target `json:""hosts""`
	HostIDs  []uint   `json:""host_ids""`
	Teams    []Target `json:""teams""`
	// TeamIDs holds the ID of the teams this pack should target.
	TeamIDs []uint `json:""team_ids""`
}
// isTeamPack returns true if the pack is a pack specifically made for a team.
func (p *Pack) isTeamPack() bool {
	return p.Type != nil && strings.HasPrefix(*p.Type, ""team-"")
}
// isGlobalPack returns true if the pack is the global pack.
func (p *Pack) isGlobalPack() bool {
	return p.Type != nil && *p.Type == ""global""
}
// TeamPack returns the team ID for a team's pack.
// Returns (nil, nil) if the pack is not a team pack.
func (p *Pack) teamPack() (*uint, error) {
	if !p.isTeamPack() {
		return nil, nil
	}
	t := strings.TrimPrefix(*p.Type, ""team-"")
	teamID, err := strconv.ParseUint(t, 10, 64)
	if err != nil {
		return nil, err
	}
	return ptr.Uint(uint(teamID)), nil
}
// ExtraAuthz implements authz.ExtraAuthzer.
func (p *Pack) ExtraAuthz() (map[string]interface{}, error) {
	packTeamID, err := p.teamPack()
	if err != nil {
		return nil, err
	}
	return map[string]interface{}{
		""pack_team_id"":   packTeamID,
		""is_global_pack"": p.isGlobalPack(),
	}, nil
}
// Verify verifies the pack's fields are valid.
func (p *Pack) Verify() error {
	if emptyString(p.Name) {
		return errPackEmptyName
	}
	return nil
}
// EditablePackType only returns true when the pack doesn't have a specific Type set, only nil & empty string Pack.Type
// is editable https://github.com/fleetdm/fleet/issues/1485
func (p *Pack) EditablePackType() bool {
	return p != nil && (p.Type == nil || (p.Type != nil && *p.Type == """"))
}
func (p Pack) AuthzType() string {
	return ""pack""
}
const (
	PackKind = ""pack""
)
// PackPayload is the struct which is used to create/update packs.
type PackPayload struct {
	Name        *string `json:""name""`
	Description *string `json:""description""`
	Platform    *string `json:""platform""`
	Disabled    *bool   `json:""disabled""`
	HostIDs     *[]uint `json:""host_ids""`
	LabelIDs    *[]uint `json:""label_ids""`
	TeamIDs     *[]uint `json:""team_ids""`
}
var errPackEmptyName = errors.New(""pack name cannot be empty"")
// Verify verifies the pack's payload fields are valid.
func (p *PackPayload) Verify() error {
	if p.Name != nil {
		if emptyString(*p.Name) {
			return errPackEmptyName
		}
	}
	return nil
}
type PackSpec struct {
	ID          uint            `json:""id,omitempty""`
	Name        string          `json:""name""`
	Description string          `json:""description,omitempty""`
	Platform    string          `json:""platform,omitempty""`
	Disabled    bool            `json:""disabled""`
	Targets     PackSpecTargets `json:""targets,omitempty""`
	Queries     []PackSpecQuery `json:""queries,omitempty""`
}
// Verify verifies the pack's spec fields are valid.
func (p *PackSpec) Verify() error {
	if emptyString(p.Name) {
		return errPackEmptyName
	}
	return nil
}
type PackSpecTargets struct {
	Labels []string `json:""labels""`
	Teams  []string `json:""teams""`
}
type PackSpecQuery struct {
	QueryName   string  `json:""query"" db:""query_name""`
	Name        string  `json:""name""`
	Description string  `json:""description""`
	Interval    uint    `json:""interval""`
	Snapshot    *bool   `json:""snapshot,omitempty""`
	Removed     *bool   `json:""removed,omitempty""`
	Shard       *uint   `json:""shard,omitempty""`
	Platform    *string `json:""platform,omitempty""`
	Version     *string `json:""version,omitempty""`
	Denylist    *bool   `json:""denylist,omitempty""`
}
// PackTarget targets a pack to a host, label, or team.
type PackTarget struct {
	ID     uint `db:""id"" json:""-""`
	PackID uint `db:""pack_id"" json:""-""`
	Target
}
type PackStats struct {
	PackID   uint   `json:""pack_id""`
	PackName string `json:""pack_name""`
	// Type indicates the type of the pack:
	//	- ""global"" is the type of the global pack.
	//	- ""team-$ID"" is returned for team packs.
	//	- ""pack"" means it is a user created pack.
	Type       string                `json:""type""`
	QueryStats []ScheduledQueryStats `json:""query_stats""`
}
",CWE-863,178.0,0
"package fleet
import ""time""
type SoftwareCVE struct {
	CVE         string `json:""cve"" db:""cve""`
	DetailsLink string `json:""details_link"" db:""details_link""`
}
// Software is a named and versioned piece of software installed on a device.
type Software struct {
	ID uint `json:""id"" db:""id""`
	// Name is the reported name.
	Name string `json:""name"" db:""name""`
	// Version is reported version.
	Version string `json:""version"" db:""version""`
	// BundleIdentifier is the CFBundleIdentifier label from the info properties
	BundleIdentifier string `json:""bundle_identifier,omitempty"" db:""bundle_identifier""`
	// Source is the source of the data (osquery table name).
	Source string `json:""source"" db:""source""`
	// Release is the version of the OS this software was released on
	// (e.g. ""30.el7"" for a CentOS package).
	Release string `json:""release,omitempty"" db:""release""`
	// Vendor is the supplier of the software (e.g. ""CentOS"").
	Vendor string `json:""vendor,omitempty"" db:""vendor""`
	// Arch is the architecture of the software (e.g. ""x86_64"").
	Arch string `json:""arch,omitempty"" db:""arch""`
	// GenerateCPE is the CPE23 string that corresponds to the current software
	GenerateCPE string `json:""generated_cpe"" db:""generated_cpe""`
	// Vulnerabilities lists all the found CVEs for the CPE
	Vulnerabilities VulnerabilitiesSlice `json:""vulnerabilities""`
	// HostsCount indicates the number of hosts with that software, filled only
	// if explicitly requested.
	HostsCount int `json:""hosts_count,omitempty"" db:""hosts_count""`
	// CountsUpdatedAt is the timestamp when the hosts count was last updated
	// for that software, filled only if hosts count is requested.
	CountsUpdatedAt time.Time `json:""-"" db:""counts_updated_at""`
}
func (Software) AuthzType() string {
	return ""software""
}
// AuthzSoftwareInventory is used for access controls on software inventory.
type AuthzSoftwareInventory struct {
	// TeamID is the ID of the team. A value of nil means global scope.
	TeamID *uint `json:""team_id""`
}
// AuthzType implements authz.AuthzTyper.
func (s *AuthzSoftwareInventory) AuthzType() string {
	return ""software_inventory""
}
type VulnerabilitiesSlice []SoftwareCVE
// HostSoftware is the set of software installed on a specific host
type HostSoftware struct {
	// Software is the software information.
	Software []Software `json:""software,omitempty"" csv:""-""`
	// Modified is a boolean indicating whether this has been modified since
	// loading. If Modified is true, datastore implementations should save the
	// data. We track this here because saving the software set is likely to be
	// an expensive operation.
	Modified bool `json:""-"" csv:""-""`
}
type SoftwareIterator interface {
	Next() bool
	Value() (*Software, error)
	Err() error
	Close() error
}
type SoftwareListOptions struct {
	ListOptions
	TeamID         *uint `query:""team_id,optional""`
	VulnerableOnly bool  `query:""vulnerable,optional""`
	SkipLoadingCVEs bool
	// WithHostCounts indicates that the list of software should include the
	// counts of hosts per software, and include only those software that have
	// a count of hosts > 0.
	WithHostCounts bool
}
",CWE-863,90.0,0
"package service
import (
	""context""
	""testing""
	""github.com/fleetdm/fleet/v4/server/authz""
	""github.com/fleetdm/fleet/v4/server/fleet""
	""github.com/fleetdm/fleet/v4/server/mock""
	""github.com/fleetdm/fleet/v4/server/test""
	""github.com/stretchr/testify/require""
)
func TestListActivities(t *testing.T) {
	ds := new(mock.Store)
	svc := newTestService(t, ds, nil, nil)
	globalUsers := []*fleet.User{test.UserAdmin, test.UserMaintainer, test.UserObserver}
	teamUsers := []*fleet.User{test.UserTeamAdminTeam1, test.UserTeamMaintainerTeam1, test.UserTeamObserverTeam1}
	ds.ListActivitiesFunc = func(ctx context.Context, opts fleet.ListOptions) ([]*fleet.Activity, error) {
		return []*fleet.Activity{
			{ID: 1},
			{ID: 2},
		}, nil
	}
	// any global user can read activities
	for _, u := range globalUsers {
		activities, err := svc.ListActivities(test.UserContext(u), fleet.ListOptions{})
		require.NoError(t, err)
		require.Len(t, activities, 2)
	}
	// team users cannot read activities
	for _, u := range teamUsers {
		_, err := svc.ListActivities(test.UserContext(u), fleet.ListOptions{})
		require.Error(t, err)
		require.Contains(t, err.Error(), authz.ForbiddenErrorMessage)
	}
	// user with no roles cannot read activities
	_, err := svc.ListActivities(test.UserContext(test.UserNoRoles), fleet.ListOptions{})
	require.Error(t, err)
	require.Contains(t, err.Error(), authz.ForbiddenErrorMessage)
	// no user in context
	_, err = svc.ListActivities(context.Background(), fleet.ListOptions{})
	require.Error(t, err)
	require.Contains(t, err.Error(), authz.ForbiddenErrorMessage)
}
",CWE-863,52.0,0
"package service
import (
	""context""
	""testing""
	""github.com/fleetdm/fleet/v4/server/contexts/viewer""
	""github.com/fleetdm/fleet/v4/server/fleet""
	""github.com/fleetdm/fleet/v4/server/mock""
	""github.com/fleetdm/fleet/v4/server/ptr""
)
func TestGlobalScheduleAuth(t *testing.T) {
	ds := new(mock.Store)
	svc := newTestService(t, ds, nil, nil)
	ds.ListScheduledQueriesInPackWithStatsFunc = func(ctx context.Context, id uint, opts fleet.ListOptions) ([]*fleet.ScheduledQuery, error) {
		return nil, nil
	}
	ds.EnsureGlobalPackFunc = func(ctx context.Context) (*fleet.Pack, error) {
		return &fleet.Pack{}, nil
	}
	ds.NewScheduledQueryFunc = func(ctx context.Context, sq *fleet.ScheduledQuery, opts ...fleet.OptionalArg) (*fleet.ScheduledQuery, error) {
		return sq, nil
	}
	ds.ScheduledQueryFunc = func(ctx context.Context, id uint) (*fleet.ScheduledQuery, error) {
		return &fleet.ScheduledQuery{}, nil
	}
	ds.SaveScheduledQueryFunc = func(ctx context.Context, sq *fleet.ScheduledQuery) (*fleet.ScheduledQuery, error) {
		return sq, nil
	}
	ds.DeleteScheduledQueryFunc = func(ctx context.Context, id uint) error {
		return nil
	}
	testCases := []struct {
		name            string
		user            *fleet.User
		shouldFailWrite bool
		shouldFailRead  bool
	}{
		{
			name:            ""global admin"",
			user:            &fleet.User{GlobalRole: ptr.String(fleet.RoleAdmin)},
			shouldFailWrite: false,
			shouldFailRead:  false,
		},
		{
			name:            ""global maintainer"",
			user:            &fleet.User{GlobalRole: ptr.String(fleet.RoleMaintainer)},
			shouldFailWrite: false,
			shouldFailRead:  false,
		},
		{
			name:            ""global observer"",
			user:            &fleet.User{GlobalRole: ptr.String(fleet.RoleObserver)},
			shouldFailWrite: true,
			shouldFailRead:  false,
		},
		{
			name:            ""team admin"",
			user:            &fleet.User{Teams: []fleet.UserTeam{{Team: fleet.Team{ID: 1}, Role: fleet.RoleAdmin}}},
			shouldFailWrite: true,
			shouldFailRead:  false,
		},
		{
			name:            ""team maintainer"",
			user:            &fleet.User{Teams: []fleet.UserTeam{{Team: fleet.Team{ID: 1}, Role: fleet.RoleMaintainer}}},
			shouldFailWrite: true,
			shouldFailRead:  false,
		},
		{
			name:            ""team observer"",
			user:            &fleet.User{Teams: []fleet.UserTeam{{Team: fleet.Team{ID: 1}, Role: fleet.RoleObserver}}},
			shouldFailWrite: true,
			shouldFailRead:  false,
		},
	}
	for _, tt := range testCases {
		t.Run(tt.name, func(t *testing.T) {
			ctx := viewer.NewContext(context.Background(), viewer.Viewer{User: tt.user})
			_, err := svc.GetGlobalScheduledQueries(ctx, fleet.ListOptions{})
			checkAuthErr(t, tt.shouldFailRead, err)
			_, err = svc.GlobalScheduleQuery(ctx, &fleet.ScheduledQuery{Name: ""query"", QueryName: ""query""})
			checkAuthErr(t, tt.shouldFailWrite, err)
			_, err = svc.ModifyGlobalScheduledQueries(ctx, 1, fleet.ScheduledQueryPayload{})
			checkAuthErr(t, tt.shouldFailWrite, err)
			err = svc.DeleteGlobalScheduledQueries(ctx, 1)
			checkAuthErr(t, tt.shouldFailWrite, err)
		})
	}
}
",CWE-863,97.0,0
"package service
import (
	""context""
	""time""
	""github.com/fleetdm/fleet/v4/server/fleet""
)
/////////////////////////////////////////////////////////////////////////////////
// List
/////////////////////////////////////////////////////////////////////////////////
type listSoftwareRequest struct {
	fleet.SoftwareListOptions
}
type listSoftwareResponse struct {
	CountsUpdatedAt *time.Time       `json:""counts_updated_at""`
	Software        []fleet.Software `json:""software,omitempty""`
	Err             error            `json:""error,omitempty""`
}
func (r listSoftwareResponse) error() error { return r.Err }
func listSoftwareEndpoint(ctx context.Context, request interface{}, svc fleet.Service) (interface{}, error) {
	req := request.(*listSoftwareRequest)
	resp, err := svc.ListSoftware(ctx, req.SoftwareListOptions)
	if err != nil {
		return listSoftwareResponse{Err: err}, nil
	}
	var latest time.Time
	for _, sw := range resp {
		if !sw.CountsUpdatedAt.IsZero() && sw.CountsUpdatedAt.After(latest) {
			latest = sw.CountsUpdatedAt
		}
	}
	listResp := listSoftwareResponse{Software: resp}
	if !latest.IsZero() {
		listResp.CountsUpdatedAt = &latest
	}
	return listResp, nil
}
func (svc Service) ListSoftware(ctx context.Context, opt fleet.SoftwareListOptions) ([]fleet.Software, error) {
	if err := svc.authz.Authorize(ctx, &fleet.AuthzSoftwareInventory{
		TeamID: opt.TeamID,
	}, fleet.ActionRead); err != nil {
		return nil, err
	}
	// default sort order to hosts_count descending
	if opt.OrderKey == """" {
		opt.OrderKey = ""hosts_count""
		opt.OrderDirection = fleet.OrderDescending
	}
	opt.WithHostCounts = true
	return svc.ds.ListSoftware(ctx, opt)
}
/////////////////////////////////////////////////////////////////////////////////
// Count
/////////////////////////////////////////////////////////////////////////////////
type countSoftwareRequest struct {
	fleet.SoftwareListOptions
}
type countSoftwareResponse struct {
	Count int   `json:""count""`
	Err   error `json:""error,omitempty""`
}
func (r countSoftwareResponse) error() error { return r.Err }
func countSoftwareEndpoint(ctx context.Context, request interface{}, svc fleet.Service) (interface{}, error) {
	req := request.(*countSoftwareRequest)
	count, err := svc.CountSoftware(ctx, req.SoftwareListOptions)
	if err != nil {
		return countSoftwareResponse{Err: err}, nil
	}
	return countSoftwareResponse{Count: count}, nil
}
func (svc Service) CountSoftware(ctx context.Context, opt fleet.SoftwareListOptions) (int, error) {
	if err := svc.authz.Authorize(ctx, &fleet.AuthzSoftwareInventory{
		TeamID: opt.TeamID,
	}, fleet.ActionRead); err != nil {
		return 0, err
	}
	return svc.ds.CountSoftware(ctx, opt)
}
",CWE-863,95.0,0
"package service
import (
	""context""
	""testing""
	""github.com/fleetdm/fleet/v4/server/contexts/viewer""
	""github.com/fleetdm/fleet/v4/server/fleet""
	""github.com/fleetdm/fleet/v4/server/mock""
	""github.com/fleetdm/fleet/v4/server/ptr""
	""github.com/stretchr/testify/assert""
	""github.com/stretchr/testify/require""
)
func TestService_ListSoftware(t *testing.T) {
	ds := new(mock.Store)
	var calledWithTeamID *uint
	var calledWithOpt fleet.SoftwareListOptions
	ds.ListSoftwareFunc = func(ctx context.Context, opt fleet.SoftwareListOptions) ([]fleet.Software, error) {
		calledWithTeamID = opt.TeamID
		calledWithOpt = opt
		return []fleet.Software{}, nil
	}
	user := &fleet.User{
		ID:         3,
		Email:      ""foo@bar.com"",
		GlobalRole: ptr.String(fleet.RoleAdmin),
	}
	svc := newTestService(t, ds, nil, nil)
	ctx := context.Background()
	ctx = viewer.NewContext(ctx, viewer.Viewer{User: user})
	_, err := svc.ListSoftware(ctx, fleet.SoftwareListOptions{TeamID: ptr.Uint(42), ListOptions: fleet.ListOptions{PerPage: 77, Page: 4}})
	require.NoError(t, err)
	assert.True(t, ds.ListSoftwareFuncInvoked)
	assert.Equal(t, ptr.Uint(42), calledWithTeamID)
	// sort order defaults to hosts_count descending, automatically, if not explicitly provided
	assert.Equal(t, fleet.ListOptions{PerPage: 77, Page: 4, OrderKey: ""hosts_count"", OrderDirection: fleet.OrderDescending}, calledWithOpt.ListOptions)
	assert.True(t, calledWithOpt.WithHostCounts)
	// call again, this time with an explicit sort
	ds.ListSoftwareFuncInvoked = false
	_, err = svc.ListSoftware(ctx, fleet.SoftwareListOptions{TeamID: nil, ListOptions: fleet.ListOptions{PerPage: 11, Page: 2, OrderKey: ""id"", OrderDirection: fleet.OrderAscending}})
	require.NoError(t, err)
	assert.True(t, ds.ListSoftwareFuncInvoked)
	assert.Nil(t, calledWithTeamID)
	assert.Equal(t, fleet.ListOptions{PerPage: 11, Page: 2, OrderKey: ""id"", OrderDirection: fleet.OrderAscending}, calledWithOpt.ListOptions)
	assert.True(t, calledWithOpt.WithHostCounts)
}
func TestServiceSoftwareInventoryAuth(t *testing.T) {
	ds := new(mock.Store)
	ds.ListSoftwareFunc = func(ctx context.Context, opt fleet.SoftwareListOptions) ([]fleet.Software, error) {
		return []fleet.Software{}, nil
	}
	ds.CountSoftwareFunc = func(ctx context.Context, opt fleet.SoftwareListOptions) (int, error) {
		return 0, nil
	}
	svc := newTestService(t, ds, nil, nil)
	for _, tc := range []struct {
		name                 string
		user                 *fleet.User
		shouldFailGlobalRead bool
		shouldFailTeamRead   bool
	}{
		{
			name: ""global-admin"",
			user: &fleet.User{
				ID:         1,
				GlobalRole: ptr.String(fleet.RoleAdmin),
			},
			shouldFailGlobalRead: false,
			shouldFailTeamRead:   false,
		},
		{
			name: ""global-maintainer"",
			user: &fleet.User{
				ID:         1,
				GlobalRole: ptr.String(fleet.RoleMaintainer),
			},
			shouldFailGlobalRead: false,
			shouldFailTeamRead:   false,
		},
		{
			name: ""global-observer"",
			user: &fleet.User{
				ID:         1,
				GlobalRole: ptr.String(fleet.RoleObserver),
			},
			shouldFailGlobalRead: false,
			shouldFailTeamRead:   false,
		},
		{
			name: ""team-admin-belongs-to-team"",
			user: &fleet.User{
				ID: 1,
				Teams: []fleet.UserTeam{{
					Team: fleet.Team{ID: 1},
					Role: fleet.RoleAdmin,
				}},
			},
			shouldFailGlobalRead: true,
			shouldFailTeamRead:   false,
		},
		{
			name: ""team-maintainer-belongs-to-team"",
			user: &fleet.User{
				ID: 1,
				Teams: []fleet.UserTeam{{
					Team: fleet.Team{ID: 1},
					Role: fleet.RoleMaintainer,
				}},
			},
			shouldFailGlobalRead: true,
			shouldFailTeamRead:   false,
		},
		{
			name: ""team-observer-belongs-to-team"",
			user: &fleet.User{
				ID: 1,
				Teams: []fleet.UserTeam{{
					Team: fleet.Team{ID: 1},
					Role: fleet.RoleObserver,
				}},
			},
			shouldFailGlobalRead: true,
			shouldFailTeamRead:   false,
		},
		{
			name: ""team-admin-does-not-belong-to-team"",
			user: &fleet.User{
				ID: 1,
				Teams: []fleet.UserTeam{{
					Team: fleet.Team{ID: 2},
					Role: fleet.RoleAdmin,
				}},
			},
			shouldFailGlobalRead: true,
			shouldFailTeamRead:   true,
		},
		{
			name: ""team-maintainer-does-not-belong-to-team"",
			user: &fleet.User{
				ID: 1,
				Teams: []fleet.UserTeam{{
					Team: fleet.Team{ID: 2},
					Role: fleet.RoleMaintainer,
				}},
			},
			shouldFailGlobalRead: true,
			shouldFailTeamRead:   true,
		},
		{
			name: ""team-observer-does-not-belong-to-team"",
			user: &fleet.User{
				ID: 1,
				Teams: []fleet.UserTeam{{
					Team: fleet.Team{ID: 2},
					Role: fleet.RoleObserver,
				}},
			},
			shouldFailGlobalRead: true,
			shouldFailTeamRead:   true,
		},
	} {
		t.Run(tc.name, func(t *testing.T) {
			ctx := viewer.NewContext(context.Background(), viewer.Viewer{User: tc.user})
			// List all software.
			_, err := svc.ListSoftware(ctx, fleet.SoftwareListOptions{})
			checkAuthErr(t, tc.shouldFailGlobalRead, err)
			// Count all software.
			_, err = svc.CountSoftware(ctx, fleet.SoftwareListOptions{})
			checkAuthErr(t, tc.shouldFailGlobalRead, err)
			// List software for a team.
			_, err = svc.ListSoftware(ctx, fleet.SoftwareListOptions{
				TeamID: ptr.Uint(1),
			})
			checkAuthErr(t, tc.shouldFailTeamRead, err)
			// Count software for a team.
			_, err = svc.CountSoftware(ctx, fleet.SoftwareListOptions{
				TeamID: ptr.Uint(1),
			})
			checkAuthErr(t, tc.shouldFailTeamRead, err)
		})
	}
}
",CWE-863,198.0,0
"package service
import (
	""context""
	""fmt""
	""github.com/fleetdm/fleet/v4/server/fleet""
	""github.com/fleetdm/fleet/v4/server/ptr""
	""gopkg.in/guregu/null.v3""
)
type getTeamScheduleRequest struct {
	TeamID      uint              `url:""team_id""`
	ListOptions fleet.ListOptions `url:""list_options""`
}
type getTeamScheduleResponse struct {
	Scheduled []scheduledQueryResponse `json:""scheduled""`
	Err       error                    `json:""error,omitempty""`
}
func (r getTeamScheduleResponse) error() error { return r.Err }
func getTeamScheduleEndpoint(ctx context.Context, request interface{}, svc fleet.Service) (interface{}, error) {
	req := request.(*getTeamScheduleRequest)
	resp := getTeamScheduleResponse{Scheduled: []scheduledQueryResponse{}}
	queries, err := svc.GetTeamScheduledQueries(ctx, req.TeamID, req.ListOptions)
	if err != nil {
		return getTeamScheduleResponse{Err: err}, nil
	}
	for _, q := range queries {
		resp.Scheduled = append(resp.Scheduled, scheduledQueryResponse{
			ScheduledQuery: *q,
		})
	}
	return resp, nil
}
func (svc Service) GetTeamScheduledQueries(ctx context.Context, teamID uint, opts fleet.ListOptions) ([]*fleet.ScheduledQuery, error) {
	if err := svc.authz.Authorize(ctx, &fleet.Pack{
		Type: ptr.String(fmt.Sprintf(""team-%d"", teamID)),
	}, fleet.ActionRead); err != nil {
		return nil, err
	}
	gp, err := svc.ds.EnsureTeamPack(ctx, teamID)
	if err != nil {
		return nil, err
	}
	return svc.ds.ListScheduledQueriesInPackWithStats(ctx, gp.ID, opts)
}
/////////////////////////////////////////////////////////////////////////////////
// Add
/////////////////////////////////////////////////////////////////////////////////
type teamScheduleQueryRequest struct {
	TeamID uint `url:""team_id""`
	fleet.ScheduledQueryPayload
}
type teamScheduleQueryResponse struct {
	Scheduled *fleet.ScheduledQuery `json:""scheduled,omitempty""`
	Err       error                 `json:""error,omitempty""`
}
func (r teamScheduleQueryResponse) error() error { return r.Err }
func uintValueOrZero(v *uint) uint {
	if v == nil {
		return 0
	}
	return *v
}
func nullIntToPtrUint(v *null.Int) *uint {
	if v == nil {
		return nil
	}
	return ptr.Uint(uint(v.ValueOrZero()))
}
func teamScheduleQueryEndpoint(ctx context.Context, request interface{}, svc fleet.Service) (interface{}, error) {
	req := request.(*teamScheduleQueryRequest)
	resp, err := svc.TeamScheduleQuery(ctx, req.TeamID, &fleet.ScheduledQuery{
		QueryID:  uintValueOrZero(req.QueryID),
		Interval: uintValueOrZero(req.Interval),
		Snapshot: req.Snapshot,
		Removed:  req.Removed,
		Platform: req.Platform,
		Version:  req.Version,
		Shard:    nullIntToPtrUint(req.Shard),
	})
	if err != nil {
		return teamScheduleQueryResponse{Err: err}, nil
	}
	return teamScheduleQueryResponse{
		Scheduled: resp,
	}, nil
}
func (svc Service) TeamScheduleQuery(ctx context.Context, teamID uint, q *fleet.ScheduledQuery) (*fleet.ScheduledQuery, error) {
	if err := svc.authz.Authorize(ctx, &fleet.Pack{
		Type: ptr.String(fmt.Sprintf(""team-%d"", teamID)),
	}, fleet.ActionWrite); err != nil {
		return nil, err
	}
	gp, err := svc.ds.EnsureTeamPack(ctx, teamID)
	if err != nil {
		return nil, err
	}
	q.PackID = gp.ID
	return svc.unauthorizedScheduleQuery(ctx, q)
}
/////////////////////////////////////////////////////////////////////////////////
// Modify
/////////////////////////////////////////////////////////////////////////////////
type modifyTeamScheduleRequest struct {
	TeamID           uint `url:""team_id""`
	ScheduledQueryID uint `url:""scheduled_query_id""`
	fleet.ScheduledQueryPayload
}
type modifyTeamScheduleResponse struct {
	Scheduled *fleet.ScheduledQuery `json:""scheduled,omitempty""`
	Err       error                 `json:""error,omitempty""`
}
func (r modifyTeamScheduleResponse) error() error { return r.Err }
func modifyTeamScheduleEndpoint(ctx context.Context, request interface{}, svc fleet.Service) (interface{}, error) {
	req := request.(*modifyTeamScheduleRequest)
	resp, err := svc.ModifyTeamScheduledQueries(ctx, req.TeamID, req.ScheduledQueryID, req.ScheduledQueryPayload)
	if err != nil {
		return modifyTeamScheduleResponse{Err: err}, nil
	}
	_ = resp
	return modifyTeamScheduleResponse{}, nil
}
func (svc Service) ModifyTeamScheduledQueries(ctx context.Context, teamID uint, scheduledQueryID uint, query fleet.ScheduledQueryPayload) (*fleet.ScheduledQuery, error) {
	if err := svc.authz.Authorize(ctx, &fleet.Pack{
		Type: ptr.String(fmt.Sprintf(""team-%d"", teamID)),
	}, fleet.ActionWrite); err != nil {
		return nil, err
	}
	gp, err := svc.ds.EnsureTeamPack(ctx, teamID)
	if err != nil {
		return nil, err
	}
	query.PackID = ptr.Uint(gp.ID)
	return svc.unauthorizedModifyScheduledQuery(ctx, scheduledQueryID, query)
}
/////////////////////////////////////////////////////////////////////////////////
// Delete
/////////////////////////////////////////////////////////////////////////////////
type deleteTeamScheduleRequest struct {
	TeamID           uint `url:""team_id""`
	ScheduledQueryID uint `url:""scheduled_query_id""`
}
type deleteTeamScheduleResponse struct {
	Scheduled *fleet.ScheduledQuery `json:""scheduled,omitempty""`
	Err       error                 `json:""error,omitempty""`
}
func (r deleteTeamScheduleResponse) error() error { return r.Err }
func deleteTeamScheduleEndpoint(ctx context.Context, request interface{}, svc fleet.Service) (interface{}, error) {
	req := request.(*deleteTeamScheduleRequest)
	err := svc.DeleteTeamScheduledQueries(ctx, req.TeamID, req.ScheduledQueryID)
	if err != nil {
		return deleteTeamScheduleResponse{Err: err}, nil
	}
	return deleteTeamScheduleResponse{}, nil
}
func (svc Service) DeleteTeamScheduledQueries(ctx context.Context, teamID uint, scheduledQueryID uint) error {
	if err := svc.authz.Authorize(ctx, &fleet.Pack{
		Type: ptr.String(fmt.Sprintf(""team-%d"", teamID)),
	}, fleet.ActionWrite); err != nil {
		return err
	}
	return svc.ds.DeleteScheduledQuery(ctx, scheduledQueryID)
}
",CWE-863,196.0,0
"package service
import (
	""context""
	""fmt""
	""testing""
	""github.com/fleetdm/fleet/v4/server/contexts/viewer""
	""github.com/fleetdm/fleet/v4/server/fleet""
	""github.com/fleetdm/fleet/v4/server/mock""
	""github.com/fleetdm/fleet/v4/server/ptr""
)
func TestTeamScheduleAuth(t *testing.T) {
	ds := new(mock.Store)
	svc := newTestService(t, ds, nil, nil)
	ds.EnsureTeamPackFunc = func(ctx context.Context, teamID uint) (*fleet.Pack, error) {
		return &fleet.Pack{
			ID:   999,
			Type: ptr.String(fmt.Sprintf(""team-%d"", teamID)),
		}, nil
	}
	ds.ListScheduledQueriesInPackWithStatsFunc = func(ctx context.Context, id uint, opts fleet.ListOptions) ([]*fleet.ScheduledQuery, error) {
		return nil, nil
	}
	ds.QueryFunc = func(ctx context.Context, id uint) (*fleet.Query, error) {
		return &fleet.Query{}, nil
	}
	ds.ScheduledQueryFunc = func(ctx context.Context, id uint) (*fleet.ScheduledQuery, error) {
		return &fleet.ScheduledQuery{}, nil
	}
	ds.NewScheduledQueryFunc = func(ctx context.Context, sq *fleet.ScheduledQuery, opts ...fleet.OptionalArg) (*fleet.ScheduledQuery, error) {
		return sq, nil
	}
	ds.SaveScheduledQueryFunc = func(ctx context.Context, sq *fleet.ScheduledQuery) (*fleet.ScheduledQuery, error) {
		return sq, nil
	}
	ds.DeleteScheduledQueryFunc = func(ctx context.Context, id uint) error {
		return nil
	}
	testCases := []struct {
		name            string
		user            *fleet.User
		shouldFailWrite bool
		shouldFailRead  bool
	}{
		{
			""global admin"",
			&fleet.User{GlobalRole: ptr.String(fleet.RoleAdmin)},
			false,
			false,
		},
		{
			""global maintainer"",
			&fleet.User{GlobalRole: ptr.String(fleet.RoleMaintainer)},
			false,
			false,
		},
		{
			""global observer"",
			&fleet.User{GlobalRole: ptr.String(fleet.RoleObserver)},
			true,
			true,
		},
		{
			""team admin, belongs to team"",
			&fleet.User{Teams: []fleet.UserTeam{{Team: fleet.Team{ID: 1}, Role: fleet.RoleAdmin}}},
			false,
			false,
		},
		{
			""team maintainer, belongs to team"",
			&fleet.User{Teams: []fleet.UserTeam{{Team: fleet.Team{ID: 1}, Role: fleet.RoleMaintainer}}},
			false,
			false,
		},
		{
			""team observer, belongs to team"",
			&fleet.User{Teams: []fleet.UserTeam{{Team: fleet.Team{ID: 1}, Role: fleet.RoleObserver}}},
			true,
			false,
		},
		{
			""team maintainer, DOES NOT belong to team"",
			&fleet.User{Teams: []fleet.UserTeam{{Team: fleet.Team{ID: 2}, Role: fleet.RoleMaintainer}}},
			true,
			true,
		},
		{
			""team admin, DOES NOT belong to team"",
			&fleet.User{Teams: []fleet.UserTeam{{Team: fleet.Team{ID: 2}, Role: fleet.RoleAdmin}}},
			true,
			true,
		},
		{
			""team observer, DOES NOT belong to team"",
			&fleet.User{Teams: []fleet.UserTeam{{Team: fleet.Team{ID: 2}, Role: fleet.RoleObserver}}},
			true,
			true,
		},
	}
	for _, tt := range testCases {
		t.Run(tt.name, func(t *testing.T) {
			ctx := viewer.NewContext(context.Background(), viewer.Viewer{User: tt.user})
			_, err := svc.GetTeamScheduledQueries(ctx, 1, fleet.ListOptions{})
			checkAuthErr(t, tt.shouldFailRead, err)
			_, err = svc.TeamScheduleQuery(ctx, 1, &fleet.ScheduledQuery{})
			checkAuthErr(t, tt.shouldFailWrite, err)
			_, err = svc.ModifyTeamScheduledQueries(ctx, 1, 99, fleet.ScheduledQueryPayload{})
			checkAuthErr(t, tt.shouldFailWrite, err)
			err = svc.DeleteTeamScheduledQueries(ctx, 1, 1)
			checkAuthErr(t, tt.shouldFailWrite, err)
		})
	}
}
",CWE-863,122.0,0
"// DBDeployer - The MySQL Sandbox
// Copyright © 2006-2020 Giuseppe Maxia
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package common
// This file was generated during build. Do not edit.
// Build time: 2020-12-15 10:49
var VersionDef string = ""1.58.2"" // 2020-12-15
// Compatible version is the version used to mark compatible archives (templates, configuration).
// It is usually major.minor.0, except when we are at version 0.x, when
// every revision may bring incompatibility
var CompatibleVersion string = ""1.58.0"" // 2020-12-11
",CWE-59,27.0,0
"module github.com/datacharmer/dbdeployer
go 1.12
require (
	github.com/alexeyco/simpletable v0.0.0-20180729223640-1fa9009f1080
	github.com/araddon/dateparse v0.0.0-20190622164848-0fb0a474d195
	github.com/dustin/go-humanize v1.0.0
	github.com/go-sql-driver/mysql v1.4.1
	github.com/nightlyone/lockfile v0.0.0-20180618180623-0ad87eef1443
	github.com/pkg/errors v0.9.1
	github.com/spf13/cobra v1.1.1
	github.com/spf13/pflag v1.0.5
	github.com/stretchr/testify v1.4.0 // indirect
	github.com/xi2/xz v0.0.0-20171230120015-48954b6210f8
	golang.org/x/crypto v0.0.0-20200622213623-75b288015ac9
	golang.org/x/sys v0.0.0-20201119102817-f84b799fce68 // indirect
)
",CWE-59,19.0,0
"package native
import (
	""bytes""
	""fmt""
	""text/template""
	types ""github.com/go-vela/types/yaml""
	""github.com/Masterminds/sprig""
	yaml ""gopkg.in/yaml.v2""
)
// Render combines the template with the step in the yaml pipeline.
func Render(tmpl string, s *types.Step) (types.StepSlice, error) {
	buffer := new(bytes.Buffer)
	config := new(types.Build)
	velaFuncs := funcHandler{envs: convertPlatformVars(s.Environment)}
	templateFuncMap := map[string]interface{}{
		""vela"": velaFuncs.returnPlatformVar,
	}
	// modify Masterminds/sprig functions
	// to remove OS functions
	//
	// https://masterminds.github.io/sprig/os.html
	sf := sprig.TxtFuncMap()
	delete(sf, ""env"")
	delete(sf, ""expandenv"")
	// parse the template with Masterminds/sprig functions
	//
	// https://pkg.go.dev/github.com/Masterminds/sprig?tab=doc
	t, err := template.New(s.Name).Funcs(sf).Funcs(templateFuncMap).Parse(tmpl)
	if err != nil {
		return types.StepSlice{}, fmt.Errorf(""unable to parse template %s: %v"", s.Template.Name, err)
	}
	// apply the variables to the parsed template
	err = t.Execute(buffer, s.Template.Variables)
	if err != nil {
		return types.StepSlice{}, fmt.Errorf(""unable to execute template %s: %v"", s.Template.Name, err)
	}
	// unmarshal the template to the pipeline
	err = yaml.Unmarshal(buffer.Bytes(), config)
	if err != nil {
		return types.StepSlice{}, fmt.Errorf(""unable to unmarshal yaml: %v"", err)
	}
	// ensure all templated steps have template prefix
	for index, newStep := range config.Steps {
		config.Steps[index].Name = fmt.Sprintf(""%s_%s"", s.Name, newStep.Name)
	}
	return config.Steps, nil
}
",CWE-78,59.0,0
"// Copyright (c) 2020 Target Brands, Inc. All rights reserved.
//
// Use of this source code is governed by the LICENSE file in this repository.
package native
import (
	""io/ioutil""
	""reflect""
	""testing""
	""github.com/go-vela/types/raw""
	""github.com/google/go-cmp/cmp""
	goyaml ""gopkg.in/yaml.v2""
	""github.com/go-vela/types/yaml""
)
func TestNative_Render(t *testing.T) {
	type args struct {
		velaFile     string
		templateFile string
	}
	tests := []struct {
		name     string
		args     args
		wantFile string
		wantErr  bool
	}{
		{""basic"", args{velaFile: ""testdata/basic/step.yml"", templateFile: ""testdata/basic/tmpl.yml""}, ""testdata/basic/want.yml"", false},
		{""multiline"", args{velaFile: ""testdata/multiline/step.yml"", templateFile: ""testdata/multiline/tmpl.yml""}, ""testdata/multiline/want.yml"", false},
		{""conditional match"", args{velaFile: ""testdata/conditional/step.yml"", templateFile: ""testdata/conditional/tmpl.yml""}, ""testdata/conditional/want.yml"", false},
		{""loop map"", args{velaFile: ""testdata/loop_map/step.yml"", templateFile: ""testdata/loop_map/tmpl.yml""}, ""testdata/loop_map/want.yml"", false},
		{""loop slice"", args{velaFile: ""testdata/loop_slice/step.yml"", templateFile: ""testdata/loop_slice/tmpl.yml""}, ""testdata/loop_slice/want.yml"", false},
		{""platform vars"", args{velaFile: ""testdata/with_vars_plat/step.yml"", templateFile: ""testdata/with_vars_plat/tmpl.yml""}, ""testdata/with_vars_plat/want.yml"", false},
		{""invalid template"", args{velaFile: ""testdata/basic/step.yml"", templateFile: ""testdata/invalid_template.yml""}, """", true},
		{""invalid variable"", args{velaFile: ""testdata/basic/step.yml"", templateFile: ""testdata/invalid_variables.yml""}, """", true},
		{""invalid yml"", args{velaFile: ""testdata/basic/step.yml"", templateFile: ""testdata/invalid.yml""}, """", true},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			sFile, err := ioutil.ReadFile(tt.args.velaFile)
			if err != nil {
				t.Error(err)
			}
			b := &yaml.Build{}
			err = goyaml.Unmarshal(sFile, b)
			if err != nil {
				t.Error(err)
			}
			b.Steps[0].Environment = raw.StringSliceMap{
				""VELA_REPO_FULL_NAME"": ""octocat/hello-world"",
			}
			tmpl, err := ioutil.ReadFile(tt.args.templateFile)
			if err != nil {
				t.Error(err)
			}
			got, err := Render(string(tmpl), b.Steps[0])
			if (err != nil) != tt.wantErr {
				t.Errorf(""Render() error = %v, wantErr %v"", err, tt.wantErr)
				return
			}
			if tt.wantErr != true {
				wFile, err := ioutil.ReadFile(tt.wantFile)
				if err != nil {
					t.Error(err)
				}
				w := &yaml.Build{}
				err = goyaml.Unmarshal(wFile, w)
				if err != nil {
					t.Error(err)
				}
				want := w.Steps
				if diff := cmp.Diff(want, got); diff != """" {
					t.Errorf(""Render() mismatch (-want +got):\n%s"", diff)
				}
			}
		})
	}
}
func TestNative_Render_DisallowedFunc_Env(t *testing.T) {
	// setup types
	want := yaml.StepSlice{}
	// run test
	tmpl, err := ioutil.ReadFile(""testdata/disallowed/tmpl_env.yml"")
	if err != nil {
		t.Errorf(""Reading file returned err: %v"", err)
	}
	got, err := Render(string(tmpl), &yaml.Step{})
	if err == nil {
		t.Errorf(""Render should have returned err"")
	}
	if !reflect.DeepEqual(got, want) {
		t.Errorf(""Render is %v, want %v"", got, want)
	}
}
func TestNative_Render_DisallowedFunc_ExpandEnv(t *testing.T) {
	// setup types
	want := yaml.StepSlice{}
	// run test
	tmpl, err := ioutil.ReadFile(""testdata/disallowed/tmpl_expandenv.yml"")
	if err != nil {
		t.Errorf(""Reading file returned err: %v"", err)
	}
	got, err := Render(string(tmpl), &yaml.Step{})
	if err == nil {
		t.Errorf(""Render should have returned err"")
	}
	if !reflect.DeepEqual(got, want) {
		t.Errorf(""Render is %v, want %v"", got, want)
	}
}
",CWE-78,126.0,0
"package gateway
import (
	""context""
	""crypto/aes""
	""encoding/binary""
	""fmt""
	""time""
	""github.com/golang/protobuf/ptypes""
	""github.com/jmoiron/sqlx""
	""github.com/pkg/errors""
	log ""github.com/sirupsen/logrus""
	""github.com/brocaar/chirpstack-api/go/v3/common""
	""github.com/brocaar/chirpstack-api/go/v3/gw""
	""github.com/brocaar/chirpstack-network-server/internal/helpers""
	""github.com/brocaar/chirpstack-network-server/internal/logging""
	""github.com/brocaar/chirpstack-network-server/internal/storage""
	""github.com/brocaar/lorawan""
)
// UpdateMetaDataInRxInfoSet updates the gateway meta-data in the
// given rx-info set. It will:
//   - add the gateway location
//   - set the FPGA id if available
//   - decrypt the fine-timestamp (if available and AES key is set)
func UpdateMetaDataInRxInfoSet(ctx context.Context, db sqlx.Queryer, rxInfoSet []*gw.UplinkRXInfo) []*gw.UplinkRXInfo {
	var out []*gw.UplinkRXInfo
	for i := range rxInfoSet {
		rxInfo := rxInfoSet[i]
		id := helpers.GetGatewayID(rxInfo)
		g, err := storage.GetAndCacheGateway(ctx, db, id)
		if err != nil {
			if errors.Cause(err) == storage.ErrDoesNotExist {
				log.WithFields(log.Fields{
					""ctx_id"":     ctx.Value(logging.ContextIDKey),
					""gateway_id"": id,
				}).Warning(""uplink received by unknown gateway"")
			} else {
				log.WithFields(log.Fields{
					""ctx_id"":     ctx.Value(logging.ContextIDKey),
					""gateway_id"": id,
				}).WithError(err).Error(""get gateway error"")
			}
			continue
		}
		// set gateway location
		rxInfo.Location = &common.Location{
			Latitude:  g.Location.Latitude,
			Longitude: g.Location.Longitude,
			Altitude:  g.Altitude,
		}
		var board storage.GatewayBoard
		if int(rxInfo.Board) < len(g.Boards) {
			board = g.Boards[int(rxInfo.Board)]
		}
		// set FPGA ID
		// this is useful when the AES decryption key is not set as it
		// indicates which key to use for decryption
		if tsInfo := rxInfo.GetEncryptedFineTimestamp(); tsInfo != nil && board.FPGAID != nil {
			if len(tsInfo.FpgaId) == 0 {
				tsInfo.FpgaId = board.FPGAID[:]
			}
		}
		// decrypt fine-timestamp when the AES key is known
		if tsInfo := rxInfo.GetEncryptedFineTimestamp(); tsInfo != nil && board.FineTimestampKey != nil {
			rxTime, err := ptypes.Timestamp(rxInfo.GetTime())
			if err != nil {
				log.WithFields(log.Fields{
					""ctx_id"":     ctx.Value(logging.ContextIDKey),
					""gateway_id"": id,
				}).WithError(err).Error(""get timestamp error"")
			}
			plainTS, err := decryptFineTimestamp(*board.FineTimestampKey, rxTime, *tsInfo)
			if err != nil {
				log.WithFields(log.Fields{
					""ctx_id"":     ctx.Value(logging.ContextIDKey),
					""gateway_id"": id,
				}).WithError(err).Error(""decrypt fine-timestamp error"")
				continue
			}
			rxInfo.FineTimestampType = gw.FineTimestampType_PLAIN
			rxInfo.FineTimestamp = &gw.UplinkRXInfo_PlainFineTimestamp{
				PlainFineTimestamp: &plainTS,
			}
		}
		out = append(out, rxInfo)
	}
	return out
}
func decryptFineTimestamp(key lorawan.AES128Key, rxTime time.Time, ts gw.EncryptedFineTimestamp) (gw.PlainFineTimestamp, error) {
	var plainTS gw.PlainFineTimestamp
	block, err := aes.NewCipher(key[:])
	if err != nil {
		return plainTS, errors.Wrap(err, ""new cipher error"")
	}
	if len(ts.EncryptedNs) != block.BlockSize() {
		return plainTS, fmt.Errorf(""invalid block-size (%d) or ciphertext length (%d)"", block.BlockSize(), len(ts.EncryptedNs))
	}
	ct := make([]byte, block.BlockSize())
	block.Decrypt(ct, ts.EncryptedNs)
	nanoSec := binary.BigEndian.Uint64(ct[len(ct)-8:])
	nanoSec = nanoSec / 32
	if time.Duration(nanoSec) >= time.Second {
		return plainTS, errors.New(""expected fine-timestamp nanosecond remainder must be < 1 second, did you set the correct decryption key?"")
	}
	rxTime = rxTime.Add(time.Duration(nanoSec) * time.Nanosecond)
	plainTS.Time, err = ptypes.TimestampProto(rxTime)
	if err != nil {
		return plainTS, errors.Wrap(err, ""timestamp proto error"")
	}
	return plainTS, nil
}
",CWE-20,134.0,0
"package uplink
import (
	""encoding/hex""
	""fmt""
	""time""
	""github.com/golang/protobuf/proto""
	""github.com/pkg/errors""
	log ""github.com/sirupsen/logrus""
	""github.com/brocaar/chirpstack-api/go/v3/gw""
	""github.com/brocaar/chirpstack-network-server/internal/band""
	""github.com/brocaar/chirpstack-network-server/internal/helpers""
	""github.com/brocaar/chirpstack-network-server/internal/models""
	""github.com/brocaar/chirpstack-network-server/internal/storage""
	""github.com/brocaar/lorawan""
)
// Templates used for generating Redis keys
const (
	CollectKeyTempl     = ""lora:ns:rx:collect:%s:%s""
	CollectLockKeyTempl = ""lora:ns:rx:collect:%s:%s:lock""
)
// collectAndCallOnce collects the package, sleeps the configured duraction and
// calls the callback only once with a slice of packets, sorted by signal
// strength (strongest at index 0). This method exists since multiple gateways
// are able to receive the same packet, but the packet needs to processed
// only once.
// It is safe to collect the same packet received by the same gateway twice.
// Since the underlying storage type is a set, the result will always be a
// unique set per gateway MAC and packet MIC.
func collectAndCallOnce(rxPacket gw.UplinkFrame, callback func(packet models.RXPacket) error) error {
	phyKey := hex.EncodeToString(rxPacket.PhyPayload)
	txInfoB, err := proto.Marshal(rxPacket.TxInfo)
	if err != nil {
		return errors.Wrap(err, ""marshal protobuf error"")
	}
	txInfoHEX := hex.EncodeToString(txInfoB)
	key := fmt.Sprintf(CollectKeyTempl, txInfoHEX, phyKey)
	lockKey := fmt.Sprintf(CollectLockKeyTempl, txInfoHEX, phyKey)
	// this way we can set a really low DeduplicationDelay for testing, without
	// the risk that the set already expired in redis on read
	deduplicationTTL := deduplicationDelay * 2
	if deduplicationTTL < time.Millisecond*200 {
		deduplicationTTL = time.Millisecond * 200
	}
	if err := collectAndCallOncePut(key, deduplicationTTL, rxPacket); err != nil {
		return err
	}
	if locked, err := collectAndCallOnceLocked(lockKey, deduplicationTTL); err != nil || locked {
		// when locked == true, err == nil
		return err
	}
	// wait the configured amount of time, more packets might be received
	// from other gateways
	time.Sleep(deduplicationDelay)
	// collect all packets from the set
	payloads, err := collectAndCallOnceCollect(key)
	if err != nil {
		return errors.Wrap(err, ""get deduplication set members error"")
	}
	if len(payloads) == 0 {
		return errors.New(""zero items in collect set"")
	}
	var out models.RXPacket
	for i, b := range payloads {
		var uplinkFrame gw.UplinkFrame
		if err := proto.Unmarshal(b, &uplinkFrame); err != nil {
			return errors.Wrap(err, ""unmarshal uplink frame error"")
		}
		if uplinkFrame.TxInfo == nil {
			log.Warning(""tx-info of uplink frame is empty, skipping"")
			continue
		}
		if uplinkFrame.RxInfo == nil {
			log.Warning(""rx-info of uplink frame is empty, skipping"")
			continue
		}
		if i == 0 {
			var phy lorawan.PHYPayload
			if err := phy.UnmarshalBinary(uplinkFrame.PhyPayload); err != nil {
				return errors.Wrap(err, ""unmarshal phypayload error"")
			}
			out.PHYPayload = phy
			dr, err := helpers.GetDataRateIndex(true, uplinkFrame.TxInfo, band.Band())
			if err != nil {
				return errors.Wrap(err, ""get data-rate index error"")
			}
			out.DR = dr
		}
		out.TXInfo = uplinkFrame.TxInfo
		out.RXInfoSet = append(out.RXInfoSet, uplinkFrame.RxInfo)
	}
	return callback(out)
}
func collectAndCallOncePut(key string, ttl time.Duration, rxPacket gw.UplinkFrame) error {
	b, err := proto.Marshal(&rxPacket)
	if err != nil {
		return errors.Wrap(err, ""marshal uplink frame error"")
	}
	pipe := storage.RedisClient().TxPipeline()
	pipe.SAdd(key, b)
	pipe.PExpire(key, ttl)
	_, err = pipe.Exec()
	if err != nil {
		return errors.Wrap(err, ""add uplink frame to set error"")
	}
	return nil
}
func collectAndCallOnceLocked(key string, ttl time.Duration) (bool, error) {
	// this way we can set a really low DeduplicationDelay for testing, without
	// the risk that the set already expired in redis on read
	deduplicationTTL := deduplicationDelay * 2
	if deduplicationTTL < time.Millisecond*200 {
		deduplicationTTL = time.Millisecond * 200
	}
	set, err := storage.RedisClient().SetNX(key, ""lock"", ttl).Result()
	if err != nil {
		return false, errors.Wrap(err, ""acquire deduplication lock error"")
	}
	// Set is true when we were able to set the lock, we return true if it
	// was already locked.
	return !set, nil
}
func collectAndCallOnceCollect(key string) ([][]byte, error) {
	pipe := storage.RedisClient().Pipeline()
	val := pipe.SMembers(key)
	pipe.Del(key)
	if _, err := pipe.Exec(); err != nil {
		return nil, errors.Wrap(err, ""get set members error"")
	}
	var out [][]byte
	vals := val.Val()
	for i := range vals {
		out = append(out, []byte(vals[i]))
	}
	return out, nil
}
",CWE-20,167.0,0
"// Copyright (c) Jeevanandam M. (https://github.com/jeevatkm)
// Source code and usage is governed by a MIT style
// license that can be found in the LICENSE file.
package aah
import (
	""bytes""
	""io/ioutil""
	""net/http""
	""net/http/httptest""
	""os""
	""path/filepath""
	""strings""
	""testing""
	""aahframe.work/ahttp""
	""aahframe.work/internal/util""
	""github.com/stretchr/testify/assert""
)
func TestStaticFilesDelivery(t *testing.T) {
	importPath := filepath.Join(testdataBaseDir(), ""webapp1"")
	ts := newTestServer(t, importPath)
	defer ts.Close()
	t.Logf(""Test Server URL [Static Files Delivery]: %s"", ts.URL)
	httpClient := new(http.Client)
	// Static File - /robots.txt
	t.Log(""Static File - /robots.txt"")
	resp, err := httpClient.Get(ts.URL + ""/robots.txt"")
	assert.Nil(t, err)
	assert.Equal(t, 200, resp.StatusCode)
	assert.True(t, strings.Contains(responseBody(resp), ""User-agent: *""))
	assert.Equal(t, ""no-cache, no-store, must-revalidate"", resp.Header.Get(ahttp.HeaderCacheControl))
	// Static File - /assets/css/aah.css
	t.Log(""Static File - /assets/css/aah.css"")
	resp, err = httpClient.Get(ts.URL + ""/assets/css/aah.css"")
	assert.Nil(t, err)
	assert.Equal(t, 200, resp.StatusCode)
	assert.True(t, strings.Contains(responseBody(resp), ""Minimal aah framework application template CSS.""))
	assert.Equal(t, ""no-cache, no-store, must-revalidate"", resp.Header.Get(ahttp.HeaderCacheControl))
	// Directory Listing - /assets
	// t.Log(""Directory Listing - /assets"")
	// resp, err = httpClient.Get(ts.URL + ""/assets"")
	// fmt.Println(""err"", err.Error())
	// assert.Nil(t, err)
	// assert.Equal(t, 200, resp.StatusCode)
	// body := responseBody(resp)
	// fmt.Println(""body"", body)
	// assert.True(t, strings.Contains(body, ""<title>Listing of /assets/</title>""))
	// assert.True(t, strings.Contains(body, ""<h1>Listing of /assets/</h1><hr>""))
	// assert.True(t, strings.Contains(body, `<a href=""robots.txt"">robots.txt</a>`))
	// assert.Equal(t, """", resp.Header.Get(ahttp.HeaderCacheControl))
	// Static File - /assets/img/aah-framework-logo.png
	t.Log(""Static File - /assets/img/aah-framework-logo.png"")
	resp, err = httpClient.Get(ts.URL + ""/assets/img/aah-framework-logo.png"")
	assert.Nil(t, err)
	assert.Equal(t, 200, resp.StatusCode)
	assert.Equal(t, ""image/png"", resp.Header.Get(ahttp.HeaderContentType))
	assert.Equal(t, ""6990"", resp.Header.Get(ahttp.HeaderContentLength))
	assert.Equal(t, ""no-cache, no-store, must-revalidate"", resp.Header.Get(ahttp.HeaderCacheControl))
	// Static File - /assets/img/notfound/file.txt
	t.Log(""Static File - /assets/img/notfound/file.txt"")
	resp, err = httpClient.Get(ts.URL + ""/assets/img/notfound/file.txt"")
	assert.Nil(t, err)
	assert.Equal(t, 200, resp.StatusCode)
	assert.Equal(t, ""0"", resp.Header.Get(ahttp.HeaderContentLength))
}
func TestStaticDetectContentType(t *testing.T) {
	testcases := []struct {
		label    string
		filename string
		result   string
	}{
		{
			label:    ""svg"",
			filename: ""image1.svg"",
			result:   ""image/svg+xml"",
		},
		{
			label:    ""png"",
			filename: ""image2.png"",
			result:   ""image/png"",
		},
		{
			label:    ""jpg"",
			filename: ""image3.jpg"",
			result:   ""image/jpeg"",
		},
		{
			label:    ""jpeg"",
			filename: ""image4.jpeg"",
			result:   ""image/jpeg"",
		},
		{
			label:    ""pdf"",
			filename: ""file.pdf"",
			result:   ""application/pdf"",
		},
		{
			label:    ""javascript"",
			filename: ""file.js"",
			result:   ""application/javascript; charset=utf-8"",
		},
		{
			label:    ""txt"",
			filename: ""file.txt"",
			result:   ""text/plain; charset=utf-8"",
		},
		{
			label:    ""xml"",
			filename: ""file.xml"",
			result:   ""application/xml; charset=utf-8"",
		},
		{
			label:    ""css"",
			filename: ""file.css"",
			result:   ""text/css; charset=utf-8"",
		},
		{
			label:    ""html"",
			filename: ""file.html"",
			result:   ""text/html; charset=utf-8"",
		},
	}
	for _, tc := range testcases {
		t.Run(tc.label, func(t *testing.T) {
			v, _ := util.DetectFileContentType(tc.filename, nil)
			assert.Equal(t, tc.result, v)
		})
	}
	content, _ := ioutil.ReadFile(filepath.Join(testdataBaseDir(), ""test-image.noext""))
	v, _ := util.DetectFileContentType(""test-image.noext"", bytes.NewReader(content))
	assert.Equal(t, ""image/png"", v)
}
func TestStaticCacheHeader(t *testing.T) {
	sm := staticManager{
		mimeCacheHdrMap: map[string]string{
			""text/css"":               ""public, max-age=604800, proxy-revalidate"",
			""application/javascript"": ""public, max-age=604800, proxy-revalidate"",
			""image/png"":              ""public, max-age=604800, proxy-revalidate"",
		},
		defaultCacheHdr: ""public, max-age=31536000"",
	}
	str := sm.cacheHeader(""application/json"")
	assert.Equal(t, ""public, max-age=31536000"", str)
	str = sm.cacheHeader(""image/png"")
	assert.Equal(t, ""public, max-age=604800, proxy-revalidate"", str)
	str = sm.cacheHeader(""application/json; charset=utf-8"")
	assert.Equal(t, ""public, max-age=31536000"", str)
	str = sm.cacheHeader(""text/css"")
	assert.Equal(t, ""public, max-age=604800, proxy-revalidate"", str)
}
func TestStaticWriteFileError(t *testing.T) {
	importPath := filepath.Join(testdataBaseDir(), ""webapp1"")
	ts := newTestServer(t, importPath)
	defer ts.Close()
	t.Logf(""Test Server URL [Static Write File Error]: %s"", ts.URL)
	sm := ts.app.staticMgr
	req := httptest.NewRequest(ahttp.MethodGet, ""http://localhost:8080/assets/js/myfile.js"", nil)
	w1 := httptest.NewRecorder()
	sm.writeError(ahttp.AcquireResponseWriter(w1), ahttp.AcquireRequest(req), os.ErrPermission)
	assert.Equal(t, ""403 Forbidden"", responseBody(w1.Result()))
	w2 := httptest.NewRecorder()
	sm.writeError(ahttp.AcquireResponseWriter(w2), ahttp.AcquireRequest(req), nil)
	assert.Equal(t, ""500 Internal Server Error"", responseBody(w2.Result()))
}
",CWE-22,188.0,0
"// Copyright (c) Jeevanandam M. (https://github.com/jeevatkm)
// Source code and usage is governed by a MIT style
// license that can be found in the LICENSE file.
package aah
// Version no. of aah framework
const Version = ""0.12.4""
",CWE-22,9.0,0
"github.com/davecgh/go-spew v1.1.0 h1:ZDRjVQ15GmhC3fiQ8ni8+OwkZQO4DARzQgrnXU1Liz8=
github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/go-macaron/inject v0.0.0-20160627170012-d8a0b8677191 h1:NjHlg70DuOkcAMqgt0+XA+NHwtu66MkTVVgR4fFWbcI=
github.com/go-macaron/inject v0.0.0-20160627170012-d8a0b8677191/go.mod h1:VFI2o2q9kYsC4o7VP1HrEVosiZZTd+MVT3YZx4gqvJw=
github.com/gopherjs/gopherjs v0.0.0-20181017120253-0766667cb4d1/go.mod h1:wJfORRmW1u3UXTncJ5qlYoELFm8eSnnEO6hX4iZ3EWY=
github.com/gopherjs/gopherjs v0.0.0-20181103185306-d547d1d9531e/go.mod h1:wJfORRmW1u3UXTncJ5qlYoELFm8eSnnEO6hX4iZ3EWY=
github.com/gopherjs/gopherjs v0.0.0-20190430165422-3e4dfb77656c h1:7lF+Vz0LqiRidnzC1Oq86fpX1q/iEv2KJdrCtttYjT4=
github.com/gopherjs/gopherjs v0.0.0-20190430165422-3e4dfb77656c/go.mod h1:wJfORRmW1u3UXTncJ5qlYoELFm8eSnnEO6hX4iZ3EWY=
github.com/jtolds/gls v4.2.1+incompatible/go.mod h1:QJZ7F/aHp+rZTRtaJ1ow/lLfFfVYBRgL+9YlvaHOwJU=
github.com/jtolds/gls v4.20.0+incompatible h1:xdiiI2gbIgH/gLH7ADydsJ1uDOEzR8yvV7C0MuV77Wo=
github.com/jtolds/gls v4.20.0+incompatible/go.mod h1:QJZ7F/aHp+rZTRtaJ1ow/lLfFfVYBRgL+9YlvaHOwJU=
github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/smartystreets/assertions v0.0.0-20180927180507-b2de0cb4f26d/go.mod h1:OnSkiWE9lh6wB0YB77sQom3nweQdgAjqCqsofrRNTgc=
github.com/smartystreets/assertions v0.0.0-20190116191733-b6c0e53d7304/go.mod h1:OnSkiWE9lh6wB0YB77sQom3nweQdgAjqCqsofrRNTgc=
github.com/smartystreets/assertions v1.0.1 h1:voD4ITNjPL5jjBfgR/r8fPIIBrliWrWHeiJApdr3r4w=
github.com/smartystreets/assertions v1.0.1/go.mod h1:kHHU4qYBaI3q23Pp3VPrmWhuIUrLW/7eUrw0BU5VaoM=
github.com/smartystreets/goconvey v0.0.0-20181108003508-044398e4856c/go.mod h1:XDJAKZRPZ1CvBcN2aX5YOUTYGHki24fSF0Iv48Ibg0s=
github.com/smartystreets/goconvey v0.0.0-20190731233626-505e41936337 h1:WN9BUFbdyOsSH/XohnWpXOlq9NBD5sGAB2FciQMUEe8=
github.com/smartystreets/goconvey v0.0.0-20190731233626-505e41936337/go.mod h1:syvi0/a8iFYH4r/RixwvyeAJjdLS9QV7WQ/tjFTllLA=
github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
github.com/stretchr/testify v1.4.0 h1:2E4SXV/wtOkTonXsotYi4li6zVWxYlZuYNCXe9XRJyk=
github.com/stretchr/testify v1.4.0/go.mod h1:j7eGeouHqKxXV5pUuKE4zz7dFj8WfuZ+81PSLYec5m4=
github.com/unknwon/com v0.0.0-20190804042917-757f69c95f3e h1:GSGeB9EAKY2spCABz6xOX5DbxZEXolK+nBSvmsQwRjM=
github.com/unknwon/com v0.0.0-20190804042917-757f69c95f3e/go.mod h1:tOOxU81rwgoCLoOVVPHb6T/wt8HZygqH5id+GNnlCXM=
github.com/unknwon/i18n v0.0.0-20190805065654-5c6446a380b6 h1:sRrkJEHtNoaSvyXMbRgofEOX4/3gMiraevQKJdIBhYE=
github.com/unknwon/i18n v0.0.0-20190805065654-5c6446a380b6/go.mod h1:+5rDk6sDGpl3azws3O+f+GpFSyN9GVr0K8cvQLQM2ZQ=
golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=
golang.org/x/crypto v0.0.0-20190701094942-4def268fd1a4 h1:HuIa8hRrWRSrqYzx1qI49NNxhdi2PrY7gxVSq1JjLDc=
golang.org/x/crypto v0.0.0-20190701094942-4def268fd1a4/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=
golang.org/x/net v0.0.0-20190311183353-d8887717615a/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
golang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
golang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20190724013045-ca1201d0de80/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20190804053845-51ab0e2deafa/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
golang.org/x/text v0.3.2 h1:tW2bmiBqwgJj/UpqtC8EpXEZVYOwU0yG4iWbprSVAcs=
golang.org/x/text v0.3.2/go.mod h1:bEr9sfX3Q8Zfm5fL9x+3itogRgK3+ptLWKqgva+5dAk=
golang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
golang.org/x/tools v0.0.0-20190328211700-ab21143f2384/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=
golang.org/x/tools v0.0.0-20190802220118-1d1727260058/go.mod h1:jcCCGcm9btYwXyDqrUWc6MKQKKGJCWEQ3AfLSRIbEuI=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/ini.v1 v1.46.0 h1:VeDZbLYGaupuvIrsYCEOe/L/2Pcs5n7hdO1ZTjporag=
gopkg.in/ini.v1 v1.46.0/go.mod h1:pNLf8WUiyNEtQjuu5G5vTm06TEv9tsIgeAvK8hOrP4k=
gopkg.in/macaron.v1 v1.3.4 h1:HvIscOwxhFhx3swWM/979wh2QMYyuXrNmrF9l+j3HZs=
gopkg.in/macaron.v1 v1.3.4/go.mod h1:/RoHTdC8ALpyJ3+QR36mKjwnT1F1dyYtsGM9Ate6ZFI=
gopkg.in/yaml.v2 v2.2.2 h1:ZCJp+EgiOT7lHqUV2J862kp8Qj64Jo6az82+3Td9dZw=
gopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
",CWE-601,53.0,0
"// Copyright 2014 The Macaron Authors
//
// Licensed under the Apache License, Version 2.0 (the ""License""): you may
// not use this file except in compliance with the License. You may obtain
// a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations
// under the License.
package i18n
import (
	""errors""
	""net/http""
	""net/http/httptest""
	""testing""
	""github.com/stretchr/testify/assert""
	""gopkg.in/macaron.v1""
)
func TestI18n(t *testing.T) {
	t.Run(""no language"", func(t *testing.T) {
		defer func() {
			assert.Equal(t, ""no language is specified"", recover())
		}()
		m := macaron.New()
		m.Use(I18n(Options{}))
	})
	t.Run(""languages and names not match"", func(t *testing.T) {
		defer func() {
			assert.Equal(t, ""length of langs is not same as length of names"", recover())
		}()
		m := macaron.New()
		m.Use(I18n(Options{
			Langs: []string{""en-US""},
		}))
	})
	t.Run(""invalid directory"", func(t *testing.T) {
		defer func() {
			assert.Equal(t, errors.New(""fail to set message file(en-US): open 404/locale_en-US.ini: no such file or directory""), recover())
		}()
		m := macaron.New()
		m.Use(I18n(Options{
			Directory: ""404"",
			Langs:     []string{""en-US""},
			Names:     []string{""English""},
		}))
	})
	t.Run(""with correct options"", func(t *testing.T) {
		m := macaron.New()
		m.Use(I18n(Options{
			Files: map[string][]byte{""locale_en-US.ini"": []byte("""")},
			Langs: []string{""en-US""},
			Names: []string{""English""},
		}))
		m.Get(""/"", func() {})
		resp := httptest.NewRecorder()
		req, err := http.NewRequest(""GET"", ""/"", nil)
		if err != nil {
			t.Fatal(err)
		}
		m.ServeHTTP(resp, req)
	})
	t.Run(""set by Accept-Language"", func(t *testing.T) {
		m := macaron.New()
		m.Use(I18n(Options{
			Langs: []string{""en-US"", ""zh-CN"", ""it-IT""},
			Names: []string{""English"", ""简体中文"", ""Italiano""},
		}))
		m.Get(""/"", func(l Locale) {
			assert.Equal(t, ""it-IT"", l.Language())
		})
		resp := httptest.NewRecorder()
		req, err := http.NewRequest(""GET"", ""/"", nil)
		if err != nil {
			t.Fatal(err)
		}
		req.Header.Set(""Accept-Language"", ""it"")
		m.ServeHTTP(resp, req)
	})
	t.Run(""set to default language"", func(t *testing.T) {
		m := macaron.New()
		m.Use(I18n(Options{
			Langs: []string{""en-US"", ""zh-CN"", ""it-IT""},
			Names: []string{""English"", ""简体中文"", ""Italiano""},
		}))
		m.Get(""/"", func(l Locale) {
			assert.Equal(t, ""en-US"", l.Language())
		})
		resp := httptest.NewRecorder()
		req, err := http.NewRequest(""GET"", ""/"", nil)
		if err != nil {
			t.Fatal(err)
		}
		req.Header.Set(""Accept-Language"", ""ru"")
		m.ServeHTTP(resp, req)
	})
}
func TestRedirect(t *testing.T) {
	m := macaron.New()
	m.Use(I18n(Options{
		Langs:    []string{""en-US""},
		Names:    []string{""English""},
		Redirect: true,
	}))
	m.Get(""/"", func() {})
	tests := []struct {
		url    string
		expURL string
	}{
		{
			url:    ""/?lang=en-US"",
			expURL: ""/"",
		}, {
			url:    ""//example.com?lang=en-US"",
			expURL: ""/example.com"",
		}, {
			url:    ""/abc/../../../example.com?lang=en-US"",
			expURL: ""/example.com"",
		}, {
			url:    ""/../abc/../example.com?lang=en-US"",
			expURL: ""/example.com"",
		},
	}
	for _, test := range tests {
		t.Run("""", func(t *testing.T) {
			resp := httptest.NewRecorder()
			req, err := http.NewRequest(""GET"", test.url, nil)
			if err != nil {
				t.Fatal(err)
			}
			req.RequestURI = test.url
			m.ServeHTTP(resp, req)
			assert.Equal(t, http.StatusFound, resp.Code)
			assert.Equal(t, ""<a href=\""""+test.expURL+""\"">Found</a>.\n\n"", resp.Body.String())
		})
	}
}
",CWE-601,159.0,0
"{
	""name"": ""pixl-class"",
	""version"": ""1.0.3"",
	""description"": ""A simple module for creating classes, with inheritance and mixins."",
	""author"": ""Joseph Huckaby <jhuckaby@gmail.com>"",
	""homepage"": ""https://github.com/jhuckaby/pixl-class"",
	""license"": ""MIT"",
	""main"": ""class.js"",
	""repository"": {
		""type"": ""git"",
		""url"": ""https://github.com/jhuckaby/pixl-class""
	},
	""bugs"": {
		""url"": ""https://github.com/jhuckaby/pixl-class/issues""
	},
	""keywords"": [
		""oop"",
		""class""
	],
	""dependencies"": {},
	""devDependencies"": {}
}
",CWE-78,23.0,0
"/*
 * Copyright (c) SAS Institute, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package cpio
import (
	""fmt""
	""io""
	""os""
	""path""
	""path/filepath""
	""strings""
	""github.com/sassoftware/go-rpmutils/fileutil""
)
// Standard set of permission bit masks.
const (
	S_ISUID  = 04000   // Set uid
	S_ISGID  = 02000   // Set gid
	S_ISVTX  = 01000   // Save text (sticky bit)
	S_ISDIR  = 040000  // Directory
	S_ISFIFO = 010000  // FIFO
	S_ISREG  = 0100000 // Regular file
	S_ISLNK  = 0120000 // Symbolic link
	S_ISBLK  = 060000  // Block special file
	S_ISCHR  = 020000  // Character special file
	S_ISSOCK = 0140000 // Socket
)
// Extract the contents of a cpio stream from r to the destination directory dest
func Extract(rs io.Reader, dest string) error {
	dest = filepath.Clean(filepath.FromSlash(dest))
	linkMap := make(map[int][]string)
	stream := NewCpioStream(rs)
	for {
		entry, err := stream.ReadNextEntry()
		if err != nil {
			return err
		}
		if entry.Header.filename == TRAILER {
			break
		}
		// sanitize path
		target := path.Clean(entry.Header.filename)
		for strings.HasPrefix(target, ""../"") {
			target = target[3:]
		}
		target = filepath.Join(dest, filepath.FromSlash(target))
		if !strings.HasPrefix(target, dest+string(filepath.Separator)) && dest != target {
			// this shouldn't happen due to the sanitization above but always check
			return fmt.Errorf(""invalid cpio path %q"", entry.Header.filename)
		}
		// Create the parent directory if it doesn't exist.
		parent := filepath.Dir(target)
		if err := os.MkdirAll(parent, 0755); err != nil {
			return err
		}
		// FIXME: Need a makedev implementation in go.
		switch entry.Header.Mode() &^ 07777 {
		case S_ISCHR:
			logger.Debug(""unpacking char device"")
			// FIXME: skipping due to lack of makedev.
			continue
		case S_ISBLK:
			logger.Debug(""unpacking block device"")
			// FIXME: skipping due to lack of makedev.
			continue
		case S_ISDIR:
			logger.Debug(""unpacking dir"")
			m := os.FileMode(entry.Header.Mode()).Perm()
			if err := os.Mkdir(target, m); err != nil && !os.IsExist(err) {
				return err
			}
		case S_ISFIFO:
			logger.Debug(""unpacking named pipe"")
			if err := fileutil.Mkfifo(target, uint32(entry.Header.Mode())); err != nil {
				return err
			}
		case S_ISLNK:
			logger.Debug(""unpacking symlink"")
			buf := make([]byte, entry.Header.c_filesize)
			if _, err := entry.payload.Read(buf); err != nil {
				return err
			}
			if err := os.Symlink(string(buf), target); err != nil {
				return err
			}
		case S_ISREG:
			logger.Debug(""unpacking regular file"")
			// save hardlinks until after the taget is written
			if entry.Header.c_nlink > 1 && entry.Header.c_filesize == 0 {
				logger.Debug(""regular file is a hard link"")
				l, ok := linkMap[entry.Header.c_ino]
				if !ok {
					l = make([]string, 0)
				}
				l = append(l, target)
				linkMap[entry.Header.c_ino] = l
				continue
			}
			// FIXME: Set permissions on files when creating.
			f, err := os.Create(target)
			if err != nil {
				return err
			}
			written, err := io.Copy(f, entry.payload)
			if err != nil {
				return err
			}
			if written != int64(entry.Header.c_filesize) {
				logger.Debugf(""written: %d, filesize: %d"", written, entry.Header.c_filesize)
				return fmt.Errorf(""short write"")
			}
			if err := f.Close(); err != nil {
				return err
			}
			// Create hardlinks after the file content is written.
			if entry.Header.c_nlink > 1 && entry.Header.c_filesize > 0 {
				l, ok := linkMap[entry.Header.c_ino]
				if !ok {
					return fmt.Errorf(""hardlinks missing"")
				}
				for _, t := range l {
					if err := os.Link(target, t); err != nil {
						return err
					}
				}
			}
		default:
			return fmt.Errorf(""unknown file mode 0%o for %s"",
				entry.Header.c_mode, entry.Header.filename)
		}
	}
	return nil
}
",CWE-22,159.0,0
"/*
 * Copyright (c) SAS Institute, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package cpio
import (
	""io/ioutil""
	""os""
	""path/filepath""
	""testing""
	""testing/iotest""
	""github.com/op/go-logging""
)
func TestExtract(t *testing.T) {
	setupLogging()
	f, err := os.Open(""../testdata/foo.cpio"")
	if err != nil {
		t.Fatal(err)
	}
	defer f.Close()
	tmpdir, err := ioutil.TempDir("""", ""cpio"")
	if err != nil {
		t.Fatal(err)
	}
	defer os.RemoveAll(tmpdir)
	logger.Debugf(""using destdir: %s"", tmpdir)
	hf := iotest.HalfReader(f)
	if err := Extract(hf, tmpdir); err != nil {
		t.Fatal(err)
	}
	logger.Debugf(""Test second extract on existing directory using destdir: %s"", tmpdir)
	if f, err = os.Open(""../testdata/foo.cpio""); err != nil {
		t.Fatal(err)
	}
	hf = iotest.HalfReader(f)
	if err := Extract(hf, tmpdir); err != nil {
		t.Fatal(err)
	}
}
func TestExtractDotdot(t *testing.T) {
	setupLogging()
	f, err := os.Open(""../testdata/dotdot.cpio"")
	if err != nil {
		t.Fatal(err)
	}
	defer f.Close()
	tmpdir, err := ioutil.TempDir("""", ""cpio"")
	if err != nil {
		t.Fatal(err)
	}
	defer os.RemoveAll(tmpdir)
	err = Extract(f, tmpdir)
	if err != nil {
		t.Fatal(err)
	}
	if _, err := os.Stat(filepath.Join(tmpdir, ""aaaaaaaaa"")); err != nil {
		t.Error(""expected file with ../ to extract into top of destdir:"", err)
	}
}
var _format = logging.MustStringFormatter(
	`%{color}%{time:15:04:05.000} %{shortfunc} ▶ %{level:.4s} %{id:03x}%{color:reset} %{message}`,
)
func setupLogging() {
	cmdBackend := logging.NewLogBackend(os.Stderr, """", 0)
	cmdLevel := logging.AddModuleLevel(cmdBackend)
	cmdLevel.SetLevel(logging.DEBUG, """")
	logging.SetBackend(cmdLevel)
}
",CWE-22,93.0,0
"/*
 * Copyright (c) SAS Institute, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package rpmutils
import (
	""io/ioutil""
	""os""
	""testing""
	""testing/iotest""
)
func TestReadHeader(t *testing.T) {
	f, err := os.Open(""./testdata/simple-1.0.1-1.i386.rpm"")
	if err != nil {
		t.Fatal(err)
	}
	defer f.Close()
	hdr, err := ReadHeader(iotest.HalfReader(f))
	if err != nil {
		t.Fatal(err)
	}
	if hdr == nil {
		t.Fatal(""no header found"")
	}
	nevra, err := hdr.GetNEVRA()
	if err != nil {
		t.Fatal(err)
	}
	if nevra.Epoch != ""0"" || nevra.Name != ""simple"" || nevra.Version != ""1.0.1"" || nevra.Release != ""1"" || nevra.Arch != ""i386"" {
		t.Fatalf(""incorrect nevra: %s-%s:%s-%s.%s"", nevra.Name, nevra.Epoch, nevra.Version, nevra.Release, nevra.Arch)
	}
	files, err := hdr.GetFiles()
	if err != nil {
		t.Fatal(err)
	}
	if len(files) != 3 {
		t.Fatalf(""incorrect number of files %d"", len(files))
	}
}
func TestPayloadReader(t *testing.T) {
	f, err := os.Open(""./testdata/simple-1.0.1-1.i386.rpm"")
	if err != nil {
		t.Fatal(err)
	}
	defer f.Close()
	rpm, err := ReadRpm(iotest.HalfReader(f))
	if err != nil {
		t.Fatal(err)
	}
	pldr, err := rpm.PayloadReader()
	if err != nil {
		t.Fatal(err)
	}
	hdr, err := pldr.Next()
	if err != nil {
		t.Fatal(err)
	}
	if hdr.Filesize() != 7 {
		t.Fatalf(""wrong file size %d"", hdr.Filesize())
	}
	if hdr.Filename() != ""./config"" {
		t.Fatalf(""wrong file name %s"", hdr.Filename())
	}
}
func TestExpandPayload(t *testing.T) {
	f, err := os.Open(""./testdata/simple-1.0.1-1.i386.rpm"")
	if err != nil {
		t.Fatal(err)
	}
	defer f.Close()
	rpm, err := ReadRpm(iotest.HalfReader(f))
	if err != nil {
		t.Fatal(err)
	}
	tmpdir, err := ioutil.TempDir("""", ""rpmutil"")
	if err != nil {
		t.Fatal(err)
	}
	defer os.RemoveAll(tmpdir)
	if err := rpm.ExpandPayload(tmpdir); err != nil {
		t.Fatal(err)
	}
}
",CWE-22,114.0,0
"// Copyright Istio Authors
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package xds
import (
	""context""
	""errors""
	""fmt""
	""google.golang.org/grpc/codes""
	""google.golang.org/grpc/credentials""
	""google.golang.org/grpc/peer""
	""google.golang.org/grpc/status""
	""istio.io/istio/pilot/pkg/features""
	""istio.io/istio/pilot/pkg/model""
	""istio.io/istio/pkg/security""
	""istio.io/istio/pkg/spiffe""
	""istio.io/pkg/env""
)
var AuthPlaintext = env.RegisterBoolVar(""XDS_AUTH_PLAINTEXT"", false,
	""Authenticate plain text requests - used if Istiod is running on a secure/trusted network"").Get()
// authenticate authenticates the ADS request using the configured authenticators.
// Returns the validated principals or an error.
// If no authenticators are configured, or if the request is on a non-secure
// stream ( 15010 ) - returns an empty list of principals and no errors.
func (s *DiscoveryServer) authenticate(ctx context.Context) ([]string, error) {
	if !features.XDSAuth {
		return nil, nil
	}
	// Authenticate - currently just checks that request has a certificate signed with the our key.
	// Protected by flag to avoid breaking upgrades - should be enabled in multi-cluster/meshexpansion where
	// XDS is exposed.
	peerInfo, ok := peer.FromContext(ctx)
	if !ok {
		return nil, errors.New(""invalid context"")
	}
	// Not a TLS connection, we will not perform authentication
	// TODO: add a flag to prevent unauthenticated requests ( 15010 )
	// request not over TLS on the insecure port
	if _, ok := peerInfo.AuthInfo.(credentials.TLSInfo); !ok && !AuthPlaintext {
		return nil, nil
	}
	am := security.AuthenticationManager{
		Authenticators: s.Authenticators,
	}
	if u := am.Authenticate(ctx); u != nil {
		return u.Identities, nil
	}
	log.Errorf(""Failed to authenticate client from %s: %s"", peerInfo.Addr.String(), am.FailedMessages())
	return nil, errors.New(""authentication failure"")
}
func (s *DiscoveryServer) authorize(con *Connection, identities []string) error {
	if con == nil || con.proxy == nil {
		return nil
	}
	if features.EnableXDSIdentityCheck && identities != nil {
		// TODO: allow locking down, rejecting unauthenticated requests.
		id, err := checkConnectionIdentity(con.proxy, identities)
		if err != nil {
			log.Warnf(""Unauthorized XDS: %v with identity %v: %v"", con.peerAddr, identities, err)
			return status.Newf(codes.PermissionDenied, ""authorization failed: %v"", err).Err()
		}
		con.proxy.VerifiedIdentity = id
	}
	return nil
}
func checkConnectionIdentity(proxy *model.Proxy, identities []string) (*spiffe.Identity, error) {
	for _, rawID := range identities {
		spiffeID, err := spiffe.ParseIdentity(rawID)
		if err != nil {
			continue
		}
		if proxy.ConfigNamespace != """" && spiffeID.Namespace != proxy.ConfigNamespace {
			continue
		}
		if proxy.Metadata.ServiceAccount != """" && spiffeID.ServiceAccount != proxy.Metadata.ServiceAccount {
			continue
		}
		return &spiffeID, nil
	}
	return nil, fmt.Errorf(""no identities (%v) matched %v/%v"", identities, proxy.ConfigNamespace, proxy.Metadata.ServiceAccount)
}
",CWE-863,103.0,0
"// Copyright Istio Authors
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package authenticate
import (
	""context""
	""fmt""
	""net/http""
	""google.golang.org/grpc/credentials""
	""google.golang.org/grpc/peer""
	""istio.io/istio/pkg/security""
	""istio.io/istio/security/pkg/pki/util""
)
const (
	ClientCertAuthenticatorType = ""ClientCertAuthenticator""
)
// ClientCertAuthenticator extracts identities from client certificate.
type ClientCertAuthenticator struct{}
var _ security.Authenticator = &ClientCertAuthenticator{}
func (cca *ClientCertAuthenticator) AuthenticatorType() string {
	return ClientCertAuthenticatorType
}
// Authenticate extracts identities from presented client certificates. This
// method assumes that certificate chain has been properly validated before
// this method is called. In other words, this method does not do certificate
// chain validation itself.
func (cca *ClientCertAuthenticator) Authenticate(ctx context.Context) (*security.Caller, error) {
	peer, ok := peer.FromContext(ctx)
	if !ok || peer.AuthInfo == nil {
		return nil, fmt.Errorf(""no client certificate is presented"")
	}
	if authType := peer.AuthInfo.AuthType(); authType != ""tls"" {
		return nil, fmt.Errorf(""unsupported auth type: %q"", authType)
	}
	tlsInfo := peer.AuthInfo.(credentials.TLSInfo)
	chains := tlsInfo.State.VerifiedChains
	if len(chains) == 0 || len(chains[0]) == 0 {
		return nil, fmt.Errorf(""no verified chain is found"")
	}
	ids, err := util.ExtractIDs(chains[0][0].Extensions)
	if err != nil {
		return nil, err
	}
	return &security.Caller{
		AuthSource: security.AuthSourceClientCertificate,
		Identities: ids,
	}, nil
}
// AuthenticateRequest performs mTLS authentication for http requests. Requires having the endpoints on a listener
// with proper TLS configuration.
func (cca *ClientCertAuthenticator) AuthenticateRequest(req *http.Request) (*security.Caller, error) {
	if req.TLS == nil || req.TLS.VerifiedChains == nil {
		return nil, fmt.Errorf(""no client certificate is presented"")
	}
	chains := req.TLS.VerifiedChains
	if len(chains) == 0 || len(chains[0]) == 0 {
		return nil, fmt.Errorf(""no verified chain is found"")
	}
	ids, err := util.ExtractIDs(chains[0][0].Extensions)
	if err != nil {
		return nil, err
	}
	return &security.Caller{
		AuthSource: security.AuthSourceClientCertificate,
		Identities: ids,
	}, nil
}
",CWE-863,95.0,0
"// Copyright Istio Authors
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package authenticate
import (
	""context""
	""fmt""
	""net""
	""net/http""
	""strings""
	""github.com/alecholmes/xfccparser""
	""google.golang.org/grpc/metadata""
	""google.golang.org/grpc/peer""
	""istio.io/istio/pilot/pkg/features""
	""istio.io/istio/pkg/security""
)
const (
	XfccAuthenticatorType = ""XfccAuthenticator""
)
// XfccAuthenticator extracts identities from Xfcc header.
type XfccAuthenticator struct{}
var _ security.Authenticator = &XfccAuthenticator{}
func (xff XfccAuthenticator) AuthenticatorType() string {
	return XfccAuthenticatorType
}
// Authenticate extracts identities from Xfcc Header.
func (xff XfccAuthenticator) Authenticate(ctx context.Context) (*security.Caller, error) {
	peerInfo, _ := peer.FromContext(ctx)
	// First check if client is trusted client so that we can ""trust"" the Xfcc Header.
	if !isTrustedAddress(peerInfo.Addr.String(), features.TrustedGatewayCIDR) {
		return nil, fmt.Errorf(""caller from %s is not in the trusted network. XfccAuthenticator can not be used"", peerInfo.Addr.String())
	}
	meta, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(meta.Get(xfccparser.ForwardedClientCertHeader)) == 0 {
		return nil, nil
	}
	xfccHeader := meta.Get(xfccparser.ForwardedClientCertHeader)[0]
	return buildSecurityCaller(xfccHeader)
}
// AuthenticateRequest validates Xfcc Header.
func (xff XfccAuthenticator) AuthenticateRequest(req *http.Request) (*security.Caller, error) {
	xfccHeader := req.Header.Get(xfccparser.ForwardedClientCertHeader)
	if len(xfccHeader) == 0 {
		return nil, nil
	}
	return buildSecurityCaller(xfccHeader)
}
func buildSecurityCaller(xfccHeader string) (*security.Caller, error) {
	clientCerts, err := xfccparser.ParseXFCCHeader(xfccHeader)
	if err != nil {
		message := fmt.Sprintf(""error in parsing xfcc header: %v"", err)
		return nil, fmt.Errorf(message)
	}
	if len(clientCerts) == 0 {
		message := ""xfcc header does not have atleast one client certs""
		return nil, fmt.Errorf(message)
	}
	ids := []string{}
	for _, cc := range clientCerts {
		ids = append(ids, cc.URI)
		ids = append(ids, cc.DNS...)
		if cc.Subject != nil {
			ids = append(ids, cc.Subject.CommonName)
		}
	}
	return &security.Caller{
		AuthSource: security.AuthSourceClientCertificate,
		Identities: ids,
	}, nil
}
func isTrustedAddress(addr string, trustedCidrs []string) bool {
	for _, cidr := range trustedCidrs {
		if isInRange(addr, cidr) {
			return true
		}
	}
	// Always trust local host addresses.
	return net.ParseIP(addr).IsLoopback()
}
func isInRange(addr, cidr string) bool {
	if strings.Contains(cidr, ""/"") {
		ip, ipnet, err := net.ParseCIDR(cidr)
		if err != nil {
			return false
		}
		if ip.To4() == nil && ip.To16() == nil {
			return false
		}
		return ipnet.Contains(net.ParseIP(addr))
	}
	return false
}
",CWE-863,118.0,0
"// Copyright Istio Authors
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package authenticate
import (
	""net""
	""reflect""
	""strings""
	""testing""
	""github.com/alecholmes/xfccparser""
	""golang.org/x/net/context""
	""google.golang.org/grpc/metadata""
	""google.golang.org/grpc/peer""
	""istio.io/istio/pkg/security""
)
func TestIsTrustedAddress(t *testing.T) {
	cases := []struct {
		name    string
		cidr    string
		peer    string
		trusted bool
	}{
		{
			name:    ""localhost client"",
			cidr:    """",
			peer:    ""127.0.0.1"",
			trusted: true,
		},
		{
			name:    ""external client without trusted cidr"",
			cidr:    """",
			peer:    ""172.0.0.1"",
			trusted: false,
		},
		{
			name:    ""cidr in range"",
			cidr:    ""172.17.0.0/16,192.17.0.0/16"",
			peer:    ""172.17.0.2"",
			trusted: true,
		},
		{
			name:    ""cidr in range with both ipv6 and ipv4"",
			cidr:    ""172.17.0.0/16,2001:db8:1234:1a00::/56"",
			peer:    ""2001:0db8:1234:1aff:ffff:ffff:ffff:ffff"",
			trusted: true,
		},
		{
			name:    ""cidr outside range"",
			cidr:    ""172.17.0.0/16,172.17.0.0/16"",
			peer:    ""110.17.0.2"",
			trusted: false,
		},
	}
	for _, tt := range cases {
		t.Run(tt.name, func(t *testing.T) {
			if result := isTrustedAddress(tt.peer, strings.Split(tt.cidr, "","")); result != tt.trusted {
				t.Errorf(""Unexpected authentication result: want %v but got %v"",
					tt.trusted, result)
			}
		})
	}
}
func TestXfccAuthenticator(t *testing.T) {
	cases := []struct {
		name               string
		xfccHeader         string
		caller             *security.Caller
		authenticateErrMsg string
	}{
		{
			name:       ""No xfcc header"",
			xfccHeader: """",
			caller:     nil,
		},
		{
			name:               ""junk xfcc header"",
			xfccHeader:         `junk xfcc header`,
			authenticateErrMsg: `error in parsing xfcc header: invalid header format: unexpected token ""junk xfcc header""`,
		},
		{
			name: ""Xfcc Header single hop"",
			// nolint lll
			xfccHeader: `Hash=meshclient;Subject="""";URI=spiffe://mesh.example.com/ns/otherns/sa/othersa`,
			caller: &security.Caller{
				AuthSource: security.AuthSourceClientCertificate,
				Identities: []string{
					""spiffe://mesh.example.com/ns/otherns/sa/othersa"",
				},
			},
		},
		{
			name: ""Xfcc Header multiple hops"",
			// nolint lll
			xfccHeader: `Hash=hash;Cert=""-----BEGIN%20CERTIFICATE-----%0cert%0A-----END%20CERTIFICATE-----%0A"";Subject=""CN=hello,OU=hello,O=Acme\, Inc."";URI=spiffe://mesh.example.com/ns/firstns/sa/firstsa;DNS=hello.west.example.com;DNS=hello.east.example.com,By=spiffe://mesh.example.com/ns/hellons/sa/hellosa;Hash=again;Subject="""";URI=spiffe://mesh.example.com/ns/otherns/sa/othersa`,
			caller: &security.Caller{
				AuthSource: security.AuthSourceClientCertificate,
				Identities: []string{
					""spiffe://mesh.example.com/ns/firstns/sa/firstsa"",
					""hello.west.example.com"",
					""hello.east.example.com"",
					""hello"",
					""spiffe://mesh.example.com/ns/otherns/sa/othersa"",
				},
			},
		},
	}
	auth := &XfccAuthenticator{}
	for _, tt := range cases {
		t.Run(tt.name, func(t *testing.T) {
			md := metadata.MD{}
			if len(tt.xfccHeader) > 0 {
				md.Append(xfccparser.ForwardedClientCertHeader, tt.xfccHeader)
			}
			ctx := peer.NewContext(context.Background(), &peer.Peer{Addr: &net.IPAddr{IP: net.ParseIP(""127.0.0.1"").To4()}})
			ctx = metadata.NewIncomingContext(ctx, md)
			result, err := auth.Authenticate(ctx)
			if len(tt.authenticateErrMsg) > 0 {
				if err == nil {
					t.Errorf(""Succeeded. Error expected: %v"", err)
				} else if err.Error() != tt.authenticateErrMsg {
					t.Errorf(""Incorrect error message: want %s but got %s"",
						tt.authenticateErrMsg, err.Error())
				}
			} else if err != nil {
				t.Fatalf(""Unexpected Error: %v"", err)
			}
			if !reflect.DeepEqual(tt.caller, result) {
				t.Errorf(""Unexpected authentication result: want %v but got %v"",
					tt.caller, result)
			}
		})
	}
}
",CWE-863,154.0,0
"// Copyright Istio Authors
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package ca
import (
	""time""
	""golang.org/x/net/context""
	""google.golang.org/grpc""
	""google.golang.org/grpc/codes""
	""google.golang.org/grpc/status""
	pb ""istio.io/api/security/v1alpha1""
	""istio.io/istio/pkg/security""
	""istio.io/istio/security/pkg/pki/ca""
	caerror ""istio.io/istio/security/pkg/pki/error""
	""istio.io/istio/security/pkg/pki/util""
	""istio.io/pkg/log""
)
var serverCaLog = log.RegisterScope(""serverca"", ""Citadel server log"", 0)
// CertificateAuthority contains methods to be supported by a CA.
type CertificateAuthority interface {
	// Sign generates a certificate for a workload or CA, from the given CSR and cert opts.
	Sign(csrPEM []byte, opts ca.CertOpts) ([]byte, error)
	// SignWithCertChain is similar to Sign but returns the leaf cert and the entire cert chain.
	SignWithCertChain(csrPEM []byte, opts ca.CertOpts) ([]string, error)
	// GetCAKeyCertBundle returns the KeyCertBundle used by CA.
	GetCAKeyCertBundle() *util.KeyCertBundle
}
// Server implements IstioCAService and IstioCertificateService and provides the services on the
// specified port.
type Server struct {
	pb.UnimplementedIstioCertificateServiceServer
	monitoring     monitoringMetrics
	Authenticators []security.Authenticator
	ca             CertificateAuthority
	serverCertTTL  time.Duration
}
// CreateCertificate handles an incoming certificate signing request (CSR). It does
// authentication and authorization. Upon validated, signs a certificate that:
// the SAN is the identity of the caller in authentication result.
// the subject public key is the public key in the CSR.
// the validity duration is the ValidityDuration in request, or default value if the given duration is invalid.
// it is signed by the CA signing key.
func (s *Server) CreateCertificate(ctx context.Context, request *pb.IstioCertificateRequest) (
	*pb.IstioCertificateResponse, error,
) {
	s.monitoring.CSR.Increment()
	am := security.AuthenticationManager{Authenticators: s.Authenticators}
	caller := am.Authenticate(ctx)
	if caller == nil {
		s.monitoring.AuthnError.Increment()
		return nil, status.Error(codes.Unauthenticated, ""request authenticate failure"")
	}
	// TODO: Call authorizer.
	crMetadata := request.Metadata.GetFields()
	certSigner := crMetadata[security.CertSigner].GetStringValue()
	log.Debugf(""cert signer from workload %s"", certSigner)
	_, _, certChainBytes, rootCertBytes := s.ca.GetCAKeyCertBundle().GetAll()
	certOpts := ca.CertOpts{
		SubjectIDs: caller.Identities,
		TTL:        time.Duration(request.ValidityDuration) * time.Second,
		ForCA:      false,
		CertSigner: certSigner,
	}
	var signErr error
	var cert []byte
	var respCertChain []string
	if certSigner == """" {
		cert, signErr = s.ca.Sign([]byte(request.Csr), certOpts)
	} else {
		respCertChain, signErr = s.ca.SignWithCertChain([]byte(request.Csr), certOpts)
	}
	if signErr != nil {
		serverCaLog.Errorf(""CSR signing error (%v)"", signErr.Error())
		s.monitoring.GetCertSignError(signErr.(*caerror.Error).ErrorType()).Increment()
		return nil, status.Errorf(signErr.(*caerror.Error).HTTPErrorCode(), ""CSR signing error (%v)"", signErr.(*caerror.Error))
	}
	if certSigner == """" {
		respCertChain = []string{string(cert)}
		if len(certChainBytes) != 0 {
			respCertChain = append(respCertChain, string(certChainBytes))
		}
	}
	if len(rootCertBytes) != 0 {
		respCertChain = append(respCertChain, string(rootCertBytes))
	}
	response := &pb.IstioCertificateResponse{
		CertChain: respCertChain,
	}
	s.monitoring.Success.Increment()
	serverCaLog.Debug(""CSR successfully signed."")
	return response, nil
}
func recordCertsExpiry(keyCertBundle *util.KeyCertBundle) {
	rootCertExpiry, err := keyCertBundle.ExtractRootCertExpiryTimestamp()
	if err != nil {
		serverCaLog.Errorf(""failed to extract root cert expiry timestamp (error %v)"", err)
	}
	rootCertExpiryTimestamp.Record(rootCertExpiry)
	if len(keyCertBundle.GetCertChainPem()) == 0 {
		return
	}
	certChainExpiry, err := keyCertBundle.ExtractCACertExpiryTimestamp()
	if err != nil {
		serverCaLog.Errorf(""failed to extract CA cert expiry timestamp (error %v)"", err)
	}
	certChainExpiryTimestamp.Record(certChainExpiry)
}
// Register registers a GRPC server on the specified port.
func (s *Server) Register(grpcServer *grpc.Server) {
	pb.RegisterIstioCertificateServiceServer(grpcServer, s)
}
// New creates a new instance of `IstioCAServiceServer`
func New(ca CertificateAuthority, ttl time.Duration,
	authenticators []security.Authenticator,
) (*Server, error) {
	certBundle := ca.GetCAKeyCertBundle()
	if len(certBundle.GetRootCertPem()) != 0 {
		recordCertsExpiry(certBundle)
	}
	server := &Server{
		Authenticators: authenticators,
		serverCertTTL:  ttl,
		ca:             ca,
		monitoring:     newMonitoringMetrics(),
	}
	return server, nil
}
",CWE-863,151.0,0
"module github.com/containers/image/v5
go 1.11
require (
	github.com/14rcole/gopopulate v0.0.0-20180821133914-b175b219e774 // indirect
	github.com/BurntSushi/toml v0.3.1
	github.com/containers/libtrust v0.0.0-20190913040956-14b96171aa3b
	github.com/containers/ocicrypt v0.0.0-20190930154801-b87a4a69c741
	github.com/containers/storage v1.15.5
	github.com/docker/distribution v0.0.0-20170817175659-5f6282db7d65
	github.com/docker/docker v0.0.0-20180522102801-da99009bbb11
	github.com/docker/docker-credential-helpers v0.6.3
	github.com/docker/go-connections v0.0.0-20180212134524-7beb39f0b969
	github.com/docker/libtrust v0.0.0-20160708172513-aabc10ec26b7 // indirect
	github.com/etcd-io/bbolt v1.3.3
	github.com/ghodss/yaml v0.0.0-20161207003320-04f313413ffd
	github.com/gorilla/context v1.1.1 // indirect
	github.com/gorilla/mux v0.0.0-20170217192616-94e7d24fd285 // indirect
	github.com/gotestyourself/gotestyourself v2.2.0+incompatible // indirect
	github.com/imdario/mergo v0.3.8
	github.com/klauspost/compress v1.9.7
	github.com/klauspost/pgzip v1.2.1
	github.com/konsorten/go-windows-terminal-sequences v1.0.2 // indirect
	github.com/kr/pretty v0.1.0 // indirect
	github.com/mattn/go-isatty v0.0.4 // indirect
	github.com/mtrmac/gpgme v0.1.1
	github.com/opencontainers/go-digest v1.0.0-rc1
	github.com/opencontainers/image-spec v1.0.2-0.20190823105129-775207bd45b6
	github.com/opencontainers/selinux v1.3.0
	github.com/ostreedev/ostree-go v0.0.0-20190702140239-759a8c1ac913
	github.com/pkg/errors v0.9.1
	github.com/pquerna/ffjson v0.0.0-20190813045741-dac163c6c0a9 // indirect
	github.com/sirupsen/logrus v1.4.2
	github.com/stretchr/testify v1.4.0
	github.com/ulikunitz/xz v0.5.6
	github.com/vbatts/tar-split v0.11.1
	github.com/vbauerster/mpb/v4 v4.11.2
	github.com/xeipuuv/gojsonpointer v0.0.0-20190809123943-df4f5c81cb3b // indirect
	github.com/xeipuuv/gojsonschema v0.0.0-20190816131739-be0936907f66
	go.etcd.io/bbolt v1.3.3 // indirect
	golang.org/x/crypto v0.0.0-20191112222119-e1110fd1c708
	golang.org/x/net v0.0.0-20190628185345-da137c7871d7
	golang.org/x/sync v0.0.0-20190423024810-112230192c58
	golang.org/x/sys v0.0.0-20191127021746-63cb32ae39b2
	gopkg.in/check.v1 v1.0.0-20190902080502-41f04d3bba15 // indirect
	k8s.io/client-go v0.0.0-20170217214107-bcde30fb7eae
)
",CWE-416,49.0,0
"package account
import (
	""math/rand""
	""strconv""
	""time""
	""github.com/kongchuanhujiao/server/internal/app/datahub/internal/memory""
)
// GenerateCode 写入验证码返回一个验证码
func GenerateCode(id string) (c string) {
	rand.Seed(time.Now().UnixNano())
	c = strconv.FormatFloat(rand.Float64(), 'f', -1, 64)[2:6]
	memory.Code[id] = c
	go func() {
		timer := time.NewTimer(5 * time.Minute)
		defer timer.Stop()
		<-timer.C
		deleteCode(id)
	}()
	return
}
// VerifyCode 验证验证码
func VerifyCode(id string, code string) (ok bool) {
	if code == memory.Code[id] {
		ok = true
		deleteCode(id)
	}
	return
}
// deleteCode 删除验证码
func deleteCode(id string) { delete(memory.Code, id) }
",CWE-287,40.0,0
"package account
import (
	""github.com/kongchuanhujiao/server/internal/app/datahub/pkg/account""
	""time""
	""github.com/kongchuanhujiao/server/internal/app/kongchuanhujiao""
	""github.com/kongchuanhujiao/server/internal/pkg/config""
	""github.com/kongchuanhujiao/server/internal/pkg/logger""
	""github.com/iris-contrib/middleware/jwt""
	""go.uber.org/zap""
)
// APIs 账号 APIs
type APIs struct{}
// PostCodeReq 发送验证码 请求结构
type PostCodeReq struct {
	ID string // 标识号
}
// PostCode 发送验证码 APIs。
// 调用方法：POST apis/accounts/code
func (a *APIs) PostCode(v *PostCodeReq) *kongchuanhujiao.Response {
	if err := sendCode(v.ID); err != nil {
		return kongchuanhujiao.GenerateErrResp(1, err.Error())
	}
	return kongchuanhujiao.DefaultSuccResp
}
// ====================================================================================================================
// PostLoginReq 登录验证 请求结构
type PostLoginReq struct {
	ID   string // 标识号
	Code string // 验证码
}
// PostLogin 登录验证 APIs。
// 调用方法：POST apis/accounts/login
func (a *APIs) PostLogin(v *PostLoginReq) *kongchuanhujiao.Response {
	if account.VerifyCode(v.ID, v.Code) || v.Code == """" {
		return kongchuanhujiao.GenerateErrResp(1, ""验证码有误"")
	}
	now := time.Now()
	t, err := jwt.NewTokenWithClaims(jwt.SigningMethodES256, jwt.MapClaims{
		""iss"": config.GetJWTConf().Iss,
		""sub"": v.ID,
		""exp"": now.AddDate(0, 1, 0).Unix(),
		""nbf"": now.Unix(),
		""iat"": now.Unix(),
	}).SignedString(config.GetJWTConf().Key)
	if err != nil {
		logger.Error(""生成 JWT Token 失败"", zap.Error(err))
		return kongchuanhujiao.DefaultErrResp
	}
	return &kongchuanhujiao.Response{Message: t}
}
",CWE-287,63.0,0
"package account
import (
	""errors""
	""github.com/kongchuanhujiao/server/internal/app/client""
	""github.com/kongchuanhujiao/server/internal/app/client/message""
	""github.com/kongchuanhujiao/server/internal/app/datahub/pkg/account""
	""github.com/kongchuanhujiao/server/internal/pkg/logger""
	""go.uber.org/zap""
)
// sendCode 发送验证码
func sendCode(id string) (err error) {
	a, err := account.SelectAccount(id, 0)
	if err != nil {
		logger.Error(""发送验证码失败"", zap.Error(err))
		return
	}
	if len(a) == 0 {
		return errors.New(""账号不存在"")
	}
	client.GetClient().SendMessage(
		message.NewTextMessage(""您的验证码是："" + account.GenerateCode(id) + ""，请勿泄露给他人。有效期5分钟"").
			SetTarget(&message.Target{ID: a[0].QQ}),
	)
	return
}
",CWE-287,32.0,0
"// Copyright (C) 2015 Audrius Butkevicius and Contributors (see the CONTRIBUTORS file).
package protocol
import (
	""errors""
	""fmt""
	""io""
)
const (
	magic        = 0x9E79BC40
	ProtocolName = ""bep-relay""
)
var (
	ResponseSuccess           = Response{0, ""success""}
	ResponseNotFound          = Response{1, ""not found""}
	ResponseAlreadyConnected  = Response{2, ""already connected""}
	ResponseUnexpectedMessage = Response{100, ""unexpected message""}
)
func WriteMessage(w io.Writer, message interface{}) error {
	header := header{
		magic: magic,
	}
	var payload []byte
	var err error
	switch msg := message.(type) {
	case Ping:
		payload, err = msg.MarshalXDR()
		header.messageType = messageTypePing
	case Pong:
		payload, err = msg.MarshalXDR()
		header.messageType = messageTypePong
	case JoinRelayRequest:
		payload, err = msg.MarshalXDR()
		header.messageType = messageTypeJoinRelayRequest
	case JoinSessionRequest:
		payload, err = msg.MarshalXDR()
		header.messageType = messageTypeJoinSessionRequest
	case Response:
		payload, err = msg.MarshalXDR()
		header.messageType = messageTypeResponse
	case ConnectRequest:
		payload, err = msg.MarshalXDR()
		header.messageType = messageTypeConnectRequest
	case SessionInvitation:
		payload, err = msg.MarshalXDR()
		header.messageType = messageTypeSessionInvitation
	case RelayFull:
		payload, err = msg.MarshalXDR()
		header.messageType = messageTypeRelayFull
	default:
		err = errors.New(""unknown message type"")
	}
	if err != nil {
		return err
	}
	header.messageLength = int32(len(payload))
	headerpayload, err := header.MarshalXDR()
	if err != nil {
		return err
	}
	_, err = w.Write(append(headerpayload, payload...))
	return err
}
func ReadMessage(r io.Reader) (interface{}, error) {
	var header header
	buf := make([]byte, header.XDRSize())
	if _, err := io.ReadFull(r, buf); err != nil {
		return nil, err
	}
	if err := header.UnmarshalXDR(buf); err != nil {
		return nil, err
	}
	if header.magic != magic {
		return nil, errors.New(""magic mismatch"")
	}
	if header.messageLength < 0 || header.messageLength > 1024 {
		return nil, fmt.Errorf(""bad length (%d)"", header.messageLength)
	}
	buf = make([]byte, int(header.messageLength))
	if _, err := io.ReadFull(r, buf); err != nil {
		return nil, err
	}
	switch header.messageType {
	case messageTypePing:
		var msg Ping
		err := msg.UnmarshalXDR(buf)
		return msg, err
	case messageTypePong:
		var msg Pong
		err := msg.UnmarshalXDR(buf)
		return msg, err
	case messageTypeJoinRelayRequest:
		var msg JoinRelayRequest
		err := msg.UnmarshalXDR(buf)
		return msg, err
	case messageTypeJoinSessionRequest:
		var msg JoinSessionRequest
		err := msg.UnmarshalXDR(buf)
		return msg, err
	case messageTypeResponse:
		var msg Response
		err := msg.UnmarshalXDR(buf)
		return msg, err
	case messageTypeConnectRequest:
		var msg ConnectRequest
		err := msg.UnmarshalXDR(buf)
		return msg, err
	case messageTypeSessionInvitation:
		var msg SessionInvitation
		err := msg.UnmarshalXDR(buf)
		return msg, err
	case messageTypeRelayFull:
		var msg RelayFull
		err := msg.UnmarshalXDR(buf)
		return msg, err
	}
	return nil, errors.New(""unknown message type"")
}
",CWE-20,136.0,0
"/*
 * Copyright 2022 Thoughtworks, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//= link_tree ../images
//= link application.js
//= link lib/d3-3.1.5.min.js
// Used by legacy templates `_header.ftlh`
//= link application.css
//= link patterns/application.css
//= link css/application.css
//= link vm/application.css
//= link frameworks.css
//= link new-theme.css
//= link single_page_apps/agents.css
//= link single_page_apps/analytics.css
//= link single_page_apps/new_dashboard.css",CWE-79,33.0,0
"// Copyright 2014-2019 Ulrich Kunitz. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
package xz
import (
	""errors""
	""io""
)
// putUint32LE puts the little-endian representation of x into the first
// four bytes of p.
func putUint32LE(p []byte, x uint32) {
	p[0] = byte(x)
	p[1] = byte(x >> 8)
	p[2] = byte(x >> 16)
	p[3] = byte(x >> 24)
}
// putUint64LE puts the little-endian representation of x into the first
// eight bytes of p.
func putUint64LE(p []byte, x uint64) {
	p[0] = byte(x)
	p[1] = byte(x >> 8)
	p[2] = byte(x >> 16)
	p[3] = byte(x >> 24)
	p[4] = byte(x >> 32)
	p[5] = byte(x >> 40)
	p[6] = byte(x >> 48)
	p[7] = byte(x >> 56)
}
// uint32LE converts a little endian representation to an uint32 value.
func uint32LE(p []byte) uint32 {
	return uint32(p[0]) | uint32(p[1])<<8 | uint32(p[2])<<16 |
		uint32(p[3])<<24
}
// putUvarint puts a uvarint representation of x into the byte slice.
func putUvarint(p []byte, x uint64) int {
	i := 0
	for x >= 0x80 {
		p[i] = byte(x) | 0x80
		x >>= 7
		i++
	}
	p[i] = byte(x)
	return i + 1
}
// errOverflow indicates an overflow of the 64-bit unsigned integer.
var errOverflowU64 = errors.New(""xz: uvarint overflows 64-bit unsigned integer"")
// readUvarint reads a uvarint from the given byte reader.
func readUvarint(r io.ByteReader) (x uint64, n int, err error) {
	const maxUvarintLen = 10
	var s uint
	i := 0
	for {
		b, err := r.ReadByte()
		if err != nil {
			return x, i, err
		}
		i++
		if i > maxUvarintLen {
			return x, i, errOverflowU64
		}
		if b < 0x80 {
			if i == maxUvarintLen && b > 1 {
				return x, i, errOverflowU64
			}
			return x | uint64(b)<<s, i, nil
		}
		x |= uint64(b&0x7f) << s
		s += 7
	}
}
",CWE-835,80.0,0
"// Copyright 2014-2019 Ulrich Kunitz. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
package xz
import (
	""bytes""
	""testing""
)
func TestUvarint(t *testing.T) {
	tests := []uint64{0, 0x80, 0x100, 0xffffffff, 0x100000000, 1<<64 - 1}
	p := make([]byte, 10)
	for _, u := range tests {
		p = p[:10]
		n := putUvarint(p, u)
		if n < 1 {
			t.Fatalf(""putUvarint returned %d"", n)
		}
		r := bytes.NewReader(p[:n])
		x, m, err := readUvarint(r)
		if err != nil {
			t.Fatalf(""readUvarint returned %s"", err)
		}
		if m != n {
			t.Fatalf(""readUvarint read %d bytes; want %d"", m, n)
		}
		if x != u {
			t.Fatalf(""readUvarint returned 0x%x; want 0x%x"", x, u)
		}
	}
}
func TestUvarIntCVE_2020_16845(t *testing.T) {
	var a = []byte{0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
		0x88, 0x89, 0x8a, 0x8b}
	r := bytes.NewReader(a)
	_, _, err := readUvarint(r)
	if err != errOverflowU64 {
		t.Fatalf(""readUvarint overflow not detected"")
	}
}
",CWE-835,45.0,0
"test interpret
test run
target aarch64
target s390x
set enable_simd
target x86_64 has_sse3 has_ssse3 has_sse41
target x86_64 has_sse3 has_ssse3 has_sse41 has_avx512vl has_avx512vbmi
function %shuffle_i8x16(i8x16, i8x16) -> i8x16 {
block0(v0: i8x16, v1: i8x16):
    v2 = shuffle v0, v1, [3 0 31 26 4 6 12 11 23 13 24 4 2 15 17 5]
    return v2
}
; run: %shuffle_i8x16([1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16], [17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32]) == [4 1 32 27 5 7 13 12 24 14 25 5 3 16 18 6]
function %shuffle_zeros(i8x16, i8x16) -> i8x16 {
block0(v0: i8x16, v1: i8x16):
    v2 = shuffle v0, v1, [3 0 32 255 4 6 12 11 23 13 24 4 2 97 17 5]
    return v2
}
; run: %shuffle_zeros([1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16], [17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32]) == [4 1 0 0 5 7 13 12 24 14 25 5 3 0 18 6]
function %shuffle1(i8x16) -> i8x16 {
block0(v0: i8x16):
    v1 = shuffle v0, v0, [8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23]
    return v1
}
; run: %shuffle1([0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15]) == [8 9 10 11 12 13 14 15 0 1 2 3 4 5 6 7]
",CWE-193,29.0,0
"test interpret
test run
target aarch64
target s390x
target x86_64
target x86_64 ssse3
target x86_64 sse41
target x86_64 sse42
target x86_64 sse42 has_avx
target x86_64 sse42 has_avx has_avx2
target x86_64 sse42 has_avx has_avx2 has_avx512f has_avx512vl
target riscv64 has_v
target riscv64 has_v has_c has_zcb
function %sshr_i8x16(i8x16, i32) -> i8x16 {
block0(v0: i8x16, v1: i32):
    v2 = sshr v0, v1
    return v2
}
; run: %sshr_i8x16([0 0xff 2 0xfd 4 0xfb 6 0xf9 8 0xf7 10 0xf5 12 0xf3 14 0xf1], 1) == [0 0xff 1 0xfe 2 0xfd 3 0xfc 4 0xfb 5 0xfa 6 0xf9 7 0xf8]
; run: %sshr_i8x16([0 0xff 2 0xfd 4 0xfb 6 0xf9 8 0xf7 10 0xf5 12 0xf3 14 0xf1], 9) == [0 0xff 1 0xfe 2 0xfd 3 0xfc 4 0xfb 5 0xfa 6 0xf9 7 0xf8]
function %sshr_i16x8(i16x8, i32) -> i16x8 {
block0(v0: i16x8, v1: i32):
    v2 = sshr v0, v1
    return v2
}
; note: because of the shifted-in sign-bit, lane 0 remains -1 == 0xffff, whereas lane 4 has been shifted to -8 == 0xfff8
; run: %sshr_i16x8([-1 2 4 8 -16 32 64 128], 1) == [-1 1 2 4 -8 16 32 64]
; run: %sshr_i16x8([-1 2 4 8 -16 32 64 128], 17) == [-1 1 2 4 -8 16 32 64]
function %sshr_i32x4(i32x4, i32) -> i32x4 {
block0(v0: i32x4, v1: i32):
    v2 = sshr v0, v1
    return v2
}
; run: %sshr_i32x4([1 2 4 -8], 1) == [0 1 2 -4]
; run: %sshr_i32x4([1 2 4 -8], 33) == [0 1 2 -4]
function %sshr_i64x2(i64x2, i32) -> i64x2 {
block0(v0:i64x2, v1:i32):
    v2 = sshr v0, v1
    return v2
}
; run: %sshr_i64x2([1 -1], 0) == [1 -1]
; run: %sshr_i64x2([1 -1], 1) == [0 -1] ; note the -1 shift result
; run: %sshr_i64x2([2 -2], 1) == [1 -1]
; run: %sshr_i64x2([0x80000000_00000000 0x7FFFFFFF_FFFFFFFF], 63) == [0xFFFFFFFF_FFFFFFFF 0]
; run: %sshr_i64x2([2 -2], 65) == [1 -1]
function %sshr_imm_i32x4(i32x4) -> i32x4 {
block0(v0: i32x4):
    v1 = sshr_imm v0, 1
    return v1
}
; run: %sshr_imm_i32x4([1 2 4 -8]) == [0 1 2 -4]
function %sshr_imm_i16x8(i16x8) -> i16x8 {
block0(v0: i16x8):
    v1 = sshr_imm v0, 1
    return v1
}
; run: %sshr_imm_i16x8([1 2 4 -8 0 0 0 0]) == [0 1 2 -4 0 0 0 0]
function %i8x16_sshr_const(i8x16) -> i8x16 {
block0(v0: i8x16):
    v1 = iconst.i32 2
    v2 = sshr v0, v1
    return v2
}
; run: %i8x16_sshr_const([0x01 0x02 0x04 0x08 0x10 0x20 0x40 0x80 0 0 0 0 0 0 0 0]) == [0 0 0x01 0x02 0x04 0x08 0x10 0xe0 0 0 0 0 0 0 0 0]
function %i16x8_sshr_const(i16x8) -> i16x8 {
block0(v0: i16x8):
    v1 = iconst.i32 4
    v2 = sshr v0, v1
    return v2
}
; run: %i16x8_sshr_const([0x0001 0x0002 0x0004 0x0008 0x0010 0x0020 0x0040 0x0080]) == [0 0 0 0 0x1 0x2 0x4 0x8]
; run: %i16x8_sshr_const([-1 -2 -4 -8 -16 16 0x8000 0x80f3]) == [-1 -1 -1 -1 -1 1 0xf800 0xf80f]
function %i32x4_sshr_const(i32x4) -> i32x4 {
block0(v0: i32x4):
    v1 = iconst.i32 4
    v2 = sshr v0, v1
    return v2
}
; run: %i32x4_sshr_const([1 0xfc 0x80000000 0xf83f3000]) == [0 0xf 0xf8000000 0xff83f300]
function %i64x2_sshr_const(i64x2) -> i64x2 {
block0(v0: i64x2):
    v1 = iconst.i32 32
    v2 = sshr v0, v1
    return v2
}
; run: %i64x2_sshr_const([0x1 0xf]) == [0 0]
; run: %i64x2_sshr_const([0x100000000 0]) == [1 0]
; run: %i64x2_sshr_const([-1 -1]) == [-1 -1]
function %i64x2_sshr_const2(i64x2) -> i64x2 {
block0(v0: i64x2):
    v1 = iconst.i32 8
    v2 = sshr v0, v1
    return v2
}
; run: %i64x2_sshr_const2([0x1 0xf]) == [0 0]
; run: %i64x2_sshr_const2([0x100000000 0]) == [0x1000000 0]
; run: %i64x2_sshr_const2([-1 -1]) == [-1 -1]
function %i64x2_sshr_const3(i64x2) -> i64x2 {
block0(v0: i64x2):
    v1 = iconst.i32 40
    v2 = sshr v0, v1
    return v2
}
; run: %i64x2_sshr_const3([0x1 0xf]) == [0 0]
; run: %i64x2_sshr_const3([0x10000000000 0]) == [1 0]
; run: %i64x2_sshr_const3([-1 -1]) == [-1 -1]
; run: %i64x2_sshr_const3([0x8000000080000000 0x8000000080000000]) == [0xffffffffff800000 0xffffffffff800000]
; run: %i64x2_sshr_const3([0x2424242424244424 0x8b1b1b1bffffff24]) == [0x242424 0xffffffffff8b1b1b]
; run: %i64x2_sshr_const3([0x2424242424244424 0x1b1b1b1bffffff24]) == [0x242424 0x1b1b1b]
",CWE-193,127.0,0
"package config
import (
	""encoding/base64""
	""encoding/json""
	""github.com/docker/docker/api/types""
)
type dockerNetworkInterfaces struct {
	V4 struct {
		Subnet  string `default:""172.18.0.0/16""`
		Gateway string `default:""172.18.0.1""`
	}
	V6 struct {
		Subnet  string `default:""fdba:17c8:6c94::/64""`
		Gateway string `default:""fdba:17c8:6c94::1011""`
	}
}
type DockerNetworkConfiguration struct {
	// The interface that should be used to create the network. Must not conflict
	// with any other interfaces in use by Docker or on the system.
	Interface string `default:""172.18.0.1"" json:""interface"" yaml:""interface""`
	// The DNS settings for containers.
	Dns []string `default:""[\""1.1.1.1\"", \""1.0.0.1\""]""`
	// The name of the network to use. If this network already exists it will not
	// be created. If it is not found, a new network will be created using the interface
	// defined.
	Name       string                  `default:""pterodactyl_nw""`
	ISPN       bool                    `default:""false"" yaml:""ispn""`
	Driver     string                  `default:""bridge""`
	Mode       string                  `default:""pterodactyl_nw"" yaml:""network_mode""`
	IsInternal bool                    `default:""false"" yaml:""is_internal""`
	EnableICC  bool                    `default:""true"" yaml:""enable_icc""`
	Interfaces dockerNetworkInterfaces `yaml:""interfaces""`
}
// DockerConfiguration defines the docker configuration used by the daemon when
// interacting with containers and networks on the system.
type DockerConfiguration struct {
	// Network configuration that should be used when creating a new network
	// for containers run through the daemon.
	Network DockerNetworkConfiguration `json:""network"" yaml:""network""`
	// Domainname is the Docker domainname for all containers.
	Domainname string `default:"""" json:""domainname"" yaml:""domainname""`
	// Registries .
	Registries map[string]RegistryConfiguration `json:""registries"" yaml:""registries""`
	// The size of the /tmp directory when mounted into a container. Please be aware that Docker
	// utilizes host memory for this value, and that we do not keep track of the space used here
	// so avoid allocating too much to a server.
	TmpfsSize uint `default:""100"" json:""tmpfs_size"" yaml:""tmpfs_size""`
	// ContainerPidLimit sets the total number of processes that can be active in a container
	// at any given moment. This is a security concern in shared-hosting environments where a
	// malicious process could create enough processes to cause the host node to run out of
	// available pids and crash.
	ContainerPidLimit int64 `default:""256"" json:""container_pid_limit"" yaml:""container_pid_limit""`
}
// RegistryConfiguration defines the authentication credentials for a given
// Docker registry.
type RegistryConfiguration struct {
	Username string `yaml:""username""`
	Password string `yaml:""password""`
}
// Base64 returns the authentication for a given registry as a base64 encoded
// string value.
func (c RegistryConfiguration) Base64() (string, error) {
	b, err := json.Marshal(types.AuthConfig{
		Username: c.Username,
		Password: c.Password,
	})
	if err != nil {
		return """", err
	}
	return base64.URLEncoding.EncodeToString(b), nil
}
",CWE-770,85.0,0
"package environment
import (
	""fmt""
	""math""
	""strconv""
	""github.com/apex/log""
	""github.com/pterodactyl/wings/config""
)
type Mount struct {
	// In Docker environments this makes no difference, however in a non-Docker environment you
	// should treat the ""Default"" mount as the root directory for the server. All other mounts
	// are just in addition to that one, and generally things like shared maps or timezone data.
	Default bool `json:""-""`
	// The target path on the system. This is ""/home/container"" for all server's Default mount
	// but in non-container environments you can likely ignore the target and just work with the
	// source.
	Target string `json:""target""`
	// The directory from which the files will be read. In Docker environments this is the directory
	// that we're mounting into the container at the Target location.
	Source string `json:""source""`
	// Whether or not the directory is being mounted as read-only. It is up to the environment to
	// handle this value correctly and ensure security expectations are met with its usage.
	ReadOnly bool `json:""read_only""`
}
// Limits is the build settings for a given server that impact docker container
// creation and resource limits for a server instance.
type Limits struct {
	// The total amount of memory in megabytes that this server is allowed to
	// use on the host system.
	MemoryLimit int64 `json:""memory_limit""`
	// The amount of additional swap space to be provided to a container instance.
	Swap int64 `json:""swap""`
	// The relative weight for IO operations in a container. This is relative to other
	// containers on the system and should be a value between 10 and 1000.
	IoWeight uint16 `json:""io_weight""`
	// The percentage of CPU that this instance is allowed to consume relative to
	// the host. A value of 200% represents complete utilization of two cores. This
	// should be a value between 1 and THREAD_COUNT * 100.
	CpuLimit int64 `json:""cpu_limit""`
	// The amount of disk space in megabytes that a server is allowed to use.
	DiskSpace int64 `json:""disk_space""`
	// Sets which CPU threads can be used by the docker instance.
	Threads string `json:""threads""`
	OOMDisabled bool `json:""oom_disabled""`
}
// ConvertedCpuLimit converts the CPU limit for a server build into a number
// that can be better understood by the Docker environment. If there is no limit
// set, return -1 which will indicate to Docker that it has unlimited CPU quota.
func (r *Limits) ConvertedCpuLimit() int64 {
	if r.CpuLimit == 0 {
		return -1
	}
	return r.CpuLimit * 1000
}
// MemoryOverheadMultiplier sets the hard limit for memory usage to be 5% more
// than the amount of memory assigned to the server. If the memory limit for the
// server is < 4G, use 10%, if less than 2G use 15%. This avoids unexpected
// crashes from processes like Java which run over the limit.
func (r *Limits) MemoryOverheadMultiplier() float64 {
	if r.MemoryLimit <= 2048 {
		return 1.15
	} else if r.MemoryLimit <= 4096 {
		return 1.10
	}
	return 1.05
}
func (r *Limits) BoundedMemoryLimit() int64 {
	return int64(math.Round(float64(r.MemoryLimit) * r.MemoryOverheadMultiplier() * 1_000_000))
}
// ConvertedSwap returns the amount of swap available as a total in bytes. This
// is returned as the amount of memory available to the server initially, PLUS
// the amount of additional swap to include which is the format used by Docker.
func (r *Limits) ConvertedSwap() int64 {
	if r.Swap < 0 {
		return -1
	}
	return (r.Swap * 1_000_000) + r.BoundedMemoryLimit()
}
// ProcessLimit returns the process limit for a container. This is currently
// defined at a system level and not on a per-server basis.
func (r *Limits) ProcessLimit() int64 {
	return config.Get().Docker.ContainerPidLimit
}
type Variables map[string]interface{}
// Get is an ugly hacky function to handle environment variables that get passed
// through as not-a-string from the Panel. Ideally we'd just say only pass
// strings, but that is a fragile idea and if a string wasn't passed through
// you'd cause a crash or the server to become unavailable. For now try to
// handle the most likely values from the JSON and hope for the best.
func (v Variables) Get(key string) string {
	val, ok := v[key]
	if !ok {
		return """"
	}
	switch val.(type) {
	case int:
		return strconv.Itoa(val.(int))
	case int32:
		return strconv.FormatInt(val.(int64), 10)
	case int64:
		return strconv.FormatInt(val.(int64), 10)
	case float32:
		return fmt.Sprintf(""%f"", val.(float32))
	case float64:
		return fmt.Sprintf(""%f"", val.(float64))
	case bool:
		return strconv.FormatBool(val.(bool))
	case string:
		return val.(string)
	}
	// TODO: I think we can add a check for val == nil and return an empty string for those
	//  and this warning should theoretically never happen?
	log.Warn(fmt.Sprintf(""failed to marshal environment variable \""%s\"" of type %+v into string"", key, val))
	return """"
}
",CWE-770,142.0,0
"package filesystem
import (
	""context""
	iofs ""io/fs""
	""os""
	""path/filepath""
	""strings""
	""sync""
	""emperror.dev/errors""
	""golang.org/x/sync/errgroup""
)
// Checks if the given file or path is in the server's file denylist. If so, an Error
// is returned, otherwise nil is returned.
func (fs *Filesystem) IsIgnored(paths ...string) error {
	for _, p := range paths {
		sp, err := fs.SafePath(p)
		if err != nil {
			return err
		}
		if fs.denylist.MatchesPath(sp) {
			return errors.WithStack(&Error{code: ErrCodeDenylistFile, path: p, resolved: sp})
		}
	}
	return nil
}
// Normalizes a directory being passed in to ensure the user is not able to escape
// from their data directory. After normalization if the directory is still within their home
// path it is returned. If they managed to ""escape"" an error will be returned.
//
// This logic is actually copied over from the SFTP server code. Ideally that eventually
// either gets ported into this application, or is able to make use of this package.
func (fs *Filesystem) SafePath(p string) (string, error) {
	// Start with a cleaned up path before checking the more complex bits.
	r := fs.unsafeFilePath(p)
	// At the same time, evaluate the symlink status and determine where this file or folder
	// is truly pointing to.
	ep, err := filepath.EvalSymlinks(r)
	if err != nil && !os.IsNotExist(err) {
		return """", errors.Wrap(err, ""server/filesystem: failed to evaluate symlink"")
	} else if os.IsNotExist(err) {
		// The target of one of the symlinks (EvalSymlinks is recursive) does not exist.
		// So we get what target path does not exist and check if it's within the data
		// directory. If it is, we return the original path, otherwise we return an error.
		pErr, ok := err.(*iofs.PathError)
		if !ok {
			return """", errors.Wrap(err, ""server/filesystem: failed to evaluate symlink"")
		}
		ep = pErr.Path
	}
	// If the requested directory from EvalSymlinks begins with the server root directory go
	// ahead and return it. If not we'll return an error which will block any further action
	// on the file.
	if fs.unsafeIsInDataDirectory(ep) {
		// Returning the original path here instead of the resolved path ensures that
		// whatever the user is trying to do will work as expected. If we returned the
		// resolved path, the user would be unable to know that it is in fact a symlink.
		return r, nil
	}
	return """", NewBadPathResolution(p, r)
}
// Generate a path to the file by cleaning it up and appending the root server path to it. This
// DOES NOT guarantee that the file resolves within the server data directory. You'll want to use
// the fs.unsafeIsInDataDirectory(p) function to confirm.
func (fs *Filesystem) unsafeFilePath(p string) string {
	// Calling filepath.Clean on the joined directory will resolve it to the absolute path,
	// removing any ../ type of resolution arguments, and leaving us with a direct path link.
	//
	// This will also trim the existing root path off the beginning of the path passed to
	// the function since that can get a bit messy.
	return filepath.Clean(filepath.Join(fs.Path(), strings.TrimPrefix(p, fs.Path())))
}
// Check that that path string starts with the server data directory path. This function DOES NOT
// validate that the rest of the path does not end up resolving out of this directory, or that the
// targeted file or folder is not a symlink doing the same thing.
func (fs *Filesystem) unsafeIsInDataDirectory(p string) bool {
	return strings.HasPrefix(strings.TrimSuffix(p, ""/"")+""/"", strings.TrimSuffix(fs.Path(), ""/"")+""/"")
}
// Executes the fs.SafePath function in parallel against an array of paths. If any of the calls
// fails an error will be returned.
func (fs *Filesystem) ParallelSafePath(paths []string) ([]string, error) {
	var cleaned []string
	// Simple locker function to avoid racy appends to the array of cleaned paths.
	m := new(sync.Mutex)
	push := func(c string) {
		m.Lock()
		cleaned = append(cleaned, c)
		m.Unlock()
	}
	// Create an error group that we can use to run processes in parallel while retaining
	// the ability to cancel the entire process immediately should any of it fail.
	g, ctx := errgroup.WithContext(context.Background())
	// Iterate over all of the paths and generate a cleaned path, if there is an error for any
	// of the files, abort the process.
	for _, p := range paths {
		// Create copy so we can use it within the goroutine correctly.
		pi := p
		// Recursively call this function to continue digging through the directory tree within
		// a separate goroutine. If the context is canceled abort this process.
		g.Go(func() error {
			select {
			case <-ctx.Done():
				return ctx.Err()
			default:
				// If the callback returns true, go ahead and keep walking deeper. This allows
				// us to programmatically continue deeper into directories, or stop digging
				// if that pathway knows it needs nothing else.
				if c, err := fs.SafePath(pi); err != nil {
					return err
				} else {
					push(c)
				}
				return nil
			}
		})
	}
	// Block until all of the routines finish and have returned a value.
	return cleaned, g.Wait()
}
",CWE-59,135.0,0
"package configuration
import (
	""encoding/json""
	""net/url""
	""time""
	""github.com/gobuffalo/packr/v2""
	""github.com/ory/fosite""
	""github.com/ory/x/tracing""
	""github.com/rs/cors""
)
var schemas = packr.New(""schemas"", ""../../.schema"")
const (
	ForbiddenStrategyErrorType = ""forbidden""
)
// MatchingStrategy defines matching strategy such as Regexp or Glob.
// Empty string defaults to ""regexp"".
type MatchingStrategy string
// Possible matching strategies.
const (
	Regexp MatchingStrategy = ""regexp""
	Glob   MatchingStrategy = ""glob""
)
type Provider interface {
	CORSEnabled(iface string) bool
	CORSOptions(iface string) cors.Options
	ProviderAuthenticators
	ProviderErrorHandlers
	ProviderAuthorizers
	ProviderMutators
	ProxyReadTimeout() time.Duration
	ProxyWriteTimeout() time.Duration
	ProxyIdleTimeout() time.Duration
	APIReadTimeout() time.Duration
	APIWriteTimeout() time.Duration
	APIIdleTimeout() time.Duration
	AccessRuleRepositories() []url.URL
	AccessRuleMatchingStrategy() MatchingStrategy
	ProxyServeAddress() string
	APIServeAddress() string
	PrometheusServeAddress() string
	PrometheusMetricsPath() string
	PrometheusCollapseRequestPaths() bool
	ToScopeStrategy(value string, key string) fosite.ScopeStrategy
	ParseURLs(sources []string) ([]url.URL, error)
	JSONWebKeyURLs() []string
	TracingServiceName() string
	TracingProvider() string
	TracingJaegerConfig() *tracing.JaegerConfig
}
type ProviderErrorHandlers interface {
	ErrorHandlerConfig(id string, override json.RawMessage, dest interface{}) error
	ErrorHandlerIsEnabled(id string) bool
	ErrorHandlerFallbackSpecificity() []string
}
type ProviderAuthenticators interface {
	AuthenticatorConfig(id string, overrides json.RawMessage, destination interface{}) error
	AuthenticatorIsEnabled(id string) bool
	AuthenticatorJwtJwkMaxWait() time.Duration
	AuthenticatorJwtJwkTtl() time.Duration
}
type ProviderAuthorizers interface {
	AuthorizerConfig(id string, overrides json.RawMessage, destination interface{}) error
	AuthorizerIsEnabled(id string) bool
}
type ProviderMutators interface {
	MutatorConfig(id string, overrides json.RawMessage, destination interface{}) error
	MutatorIsEnabled(id string) bool
}
",CWE-863,89.0,0
"{
	""name"": ""GlobalNewFiles"",
	""author"": [
		""John Lewis"",
		""Paladox"",
		""Southparkfan"",
		""Universal Omega""
	],
	""url"": ""//github.com/miraheze/GlobalNewFiles"",
	""descriptionmsg"": ""globalnewfiles-description"",
	""license-name"": ""GPL-3.0-or-later"",
	""type"": ""specialpage"",
	""requires"": {
		""MediaWiki"": "">= 1.36.0"",
		""extensions"": {
			""CreateWiki"": ""*""
		}
	},
	""MessagesDirs"": {
		""GlobalNewFiles"": [
			""i18n""
		]
	},
	""ExtensionMessagesFiles"": {
		""GlobalNewFilesAliases"": ""includes/GlobalNewFilesAliases.php""
	},
	""AvailableRights"": [
		""viewglobalprivatefiles""
	],
	""AutoloadClasses"": {
		""GlobalNewFilesHooks"": ""includes/GlobalNewFilesHooks.php"",
		""GlobalNewFilesPager"": ""includes/GlobalNewFilesPager.php"",
		""SpecialGlobalNewFiles"": ""includes/SpecialGlobalNewFiles.php"",
		""GlobalNewFilesInsertJob"": ""includes/jobs/GlobalNewFilesInsertJob.php"",
		""GlobalNewFilesDeleteJob"": ""includes/jobs/GlobalNewFilesDeleteJob.php"",
		""GlobalNewFilesMoveJob"": ""includes/jobs/GlobalNewFilesMoveJob.php""
	},
	""JobClasses"": {
		""GlobalNewFilesInsertJob"": ""GlobalNewFilesInsertJob"",
		""GlobalNewFilesDeleteJob"": ""GlobalNewFilesDeleteJob"",
		""GlobalNewFilesMoveJob"": ""GlobalNewFilesMoveJob""
	},
	""SpecialPages"": {
		""GlobalNewFiles"": ""SpecialGlobalNewFiles""
	},
	""Hooks"": {
		""CreateWikiTables"": [
			""GlobalNewFilesHooks::onCreateWikiTables""
		],
		""LoadExtensionSchemaUpdates"": [
			""GlobalNewFilesHooks::onLoadExtensionSchemaUpdates""
		],
		""FileDeleteComplete"": [
			""GlobalNewFilesHooks::onFileDeleteComplete""
		],
		""PageMoveComplete"": [
			""GlobalNewFilesHooks::onPageMoveComplete""
		],
		""UploadComplete"": [
			""GlobalNewFilesHooks::onUploadComplete""
		]
	},
	""ConfigRegistry"": {
		""globalnewfiles"": ""GlobalVarConfig::newInstance""
	},
	""manifest_version"": 2
}
",CWE-400,68.0,0
"{
	""name"": ""GlobalNewFiles"",
	""author"": [
		""John Lewis"",
		""Paladox"",
		""Southparkfan"",
		""Universal Omega""
	],
	""url"": ""//github.com/miraheze/GlobalNewFiles"",
	""descriptionmsg"": ""globalnewfiles-description"",
	""license-name"": ""GPL-3.0-or-later"",
	""type"": ""specialpage"",
	""requires"": {
		""MediaWiki"": "">= 1.36.0"",
		""extensions"": {
			""CreateWiki"": ""*""
		}
	},
	""MessagesDirs"": {
		""GlobalNewFiles"": [
			""i18n""
		]
	},
	""ExtensionMessagesFiles"": {
		""GlobalNewFilesAliases"": ""includes/GlobalNewFilesAliases.php""
	},
	""AvailableRights"": [
		""viewglobalprivatefiles""
	],
	""AutoloadClasses"": {
		""GlobalNewFilesHooks"": ""includes/GlobalNewFilesHooks.php"",
		""GlobalNewFilesPager"": ""includes/GlobalNewFilesPager.php"",
		""SpecialGlobalNewFiles"": ""includes/SpecialGlobalNewFiles.php"",
		""GlobalNewFilesInsertJob"": ""includes/jobs/GlobalNewFilesInsertJob.php"",
		""GlobalNewFilesDeleteJob"": ""includes/jobs/GlobalNewFilesDeleteJob.php"",
		""GlobalNewFilesMoveJob"": ""includes/jobs/GlobalNewFilesMoveJob.php""
	},
	""JobClasses"": {
		""GlobalNewFilesInsertJob"": ""GlobalNewFilesInsertJob"",
		""GlobalNewFilesDeleteJob"": ""GlobalNewFilesDeleteJob"",
		""GlobalNewFilesMoveJob"": ""GlobalNewFilesMoveJob""
	},
	""SpecialPages"": {
		""GlobalNewFiles"": {
			""class"": ""SpecialGlobalNewFiles"",
			""services"": [
				""LinkRenderer""
			]
		}
	},
	""Hooks"": {
		""CreateWikiTables"": [
			""GlobalNewFilesHooks::onCreateWikiTables""
		],
		""LoadExtensionSchemaUpdates"": [
			""GlobalNewFilesHooks::onLoadExtensionSchemaUpdates""
		],
		""FileDeleteComplete"": [
			""GlobalNewFilesHooks::onFileDeleteComplete""
		],
		""PageMoveComplete"": [
			""GlobalNewFilesHooks::onPageMoveComplete""
		],
		""UploadComplete"": [
			""GlobalNewFilesHooks::onUploadComplete""
		]
	},
	""ConfigRegistry"": {
		""globalnewfiles"": ""GlobalVarConfig::newInstance""
	},
	""manifest_version"": 2
}
",CWE-20,73.0,0
"module github.com/projectcontour/contour
go 1.15
require (
	github.com/ahmetb/gen-crd-api-reference-docs v0.3.0
	github.com/bombsimon/logrusr v1.0.0
	github.com/davecgh/go-spew v1.1.1 // indirect
	github.com/envoyproxy/go-control-plane v0.9.9-0.20210111201334-f1f47757da33
	github.com/go-logr/logr v0.4.0
	github.com/golang/protobuf v1.5.2
	github.com/google/go-cmp v0.5.5
	github.com/google/uuid v1.1.2
	github.com/grpc-ecosystem/go-grpc-prometheus v1.2.0
	github.com/jetstack/cert-manager v1.3.0
	github.com/onsi/ginkgo v1.16.4
	github.com/onsi/gomega v1.13.0
	github.com/prometheus/client_golang v1.9.0
	github.com/prometheus/client_model v0.2.0
	github.com/prometheus/common v0.15.0
	github.com/sirupsen/logrus v1.7.0
	github.com/stretchr/testify v1.6.1
	google.golang.org/genproto v0.0.0-20201110150050-8816d57aaa9a
	google.golang.org/grpc v1.27.1
	google.golang.org/protobuf v1.26.0
	gopkg.in/alecthomas/kingpin.v2 v2.2.6
	gopkg.in/yaml.v2 v2.4.0
	k8s.io/api v0.21.0
	k8s.io/apiextensions-apiserver v0.21.0
	k8s.io/apimachinery v0.21.0
	k8s.io/client-go v0.21.0
	k8s.io/klog/v2 v2.8.1-0.20210504170414-0cc9b8363efc
	k8s.io/utils v0.0.0-20210305010621-2afb4311ab10
	sigs.k8s.io/controller-runtime v0.9.0-beta.1
	sigs.k8s.io/controller-tools v0.5.0
	sigs.k8s.io/gateway-api v0.3.0
	sigs.k8s.io/kustomize/kyaml v0.1.1
)
",CWE-610,39.0,0
"// Copyright Project Contour Authors
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package dag
import (
	""errors""
	""testing""
	""github.com/projectcontour/contour/internal/fixture""
	""github.com/stretchr/testify/assert""
	v1 ""k8s.io/api/core/v1""
	metav1 ""k8s.io/apimachinery/pkg/apis/meta/v1""
	""k8s.io/apimachinery/pkg/types""
	""k8s.io/apimachinery/pkg/util/intstr""
)
func TestBuilderLookupService(t *testing.T) {
	s1 := &v1.Service{
		ObjectMeta: metav1.ObjectMeta{
			Name:      ""kuard"",
			Namespace: ""default"",
		},
		Spec: v1.ServiceSpec{
			Ports: []v1.ServicePort{{
				Name:       ""http"",
				Protocol:   ""TCP"",
				Port:       8080,
				TargetPort: intstr.FromInt(8080),
			}},
		},
	}
	externalNameValid := &v1.Service{
		ObjectMeta: metav1.ObjectMeta{
			Name:      ""externalnamevalid"",
			Namespace: ""default"",
		},
		Spec: v1.ServiceSpec{
			Type:         v1.ServiceTypeExternalName,
			ExternalName: ""external.projectcontour.io"",
			Ports: []v1.ServicePort{{
				Name:       ""http"",
				Protocol:   ""TCP"",
				Port:       80,
				TargetPort: intstr.FromInt(80),
			}},
		},
	}
	externalNameLocalhost := &v1.Service{
		ObjectMeta: metav1.ObjectMeta{
			Name:      ""externalnamelocalhost"",
			Namespace: ""default"",
		},
		Spec: v1.ServiceSpec{
			Type:         v1.ServiceTypeExternalName,
			ExternalName: ""localhost"",
			Ports: []v1.ServicePort{{
				Name:       ""http"",
				Protocol:   ""TCP"",
				Port:       80,
				TargetPort: intstr.FromInt(80),
			}},
		},
	}
	services := map[types.NamespacedName]*v1.Service{
		{Name: ""service1"", Namespace: ""default""}:              s1,
		{Name: ""externalnamevalid"", Namespace: ""default""}:     externalNameValid,
		{Name: ""externalnamelocalhost"", Namespace: ""default""}: externalNameLocalhost,
	}
	tests := map[string]struct {
		types.NamespacedName
		port                  intstr.IntOrString
		enableExternalNameSvc bool
		want                  *Service
		wantErr               error
	}{
		""lookup service by port number"": {
			NamespacedName: types.NamespacedName{Name: ""service1"", Namespace: ""default""},
			port:           intstr.FromInt(8080),
			want:           service(s1),
		},
		""lookup service by port name"": {
			NamespacedName: types.NamespacedName{Name: ""service1"", Namespace: ""default""},
			port:           intstr.FromString(""http""),
			want:           service(s1),
		},
		""lookup service by port number (as string)"": {
			NamespacedName: types.NamespacedName{Name: ""service1"", Namespace: ""default""},
			port:           intstr.Parse(""8080""),
			want:           service(s1),
		},
		""lookup service by port number (from string)"": {
			NamespacedName: types.NamespacedName{Name: ""service1"", Namespace: ""default""},
			port:           intstr.FromString(""8080""),
			want:           service(s1),
		},
		""when service does not exist an error is returned"": {
			NamespacedName: types.NamespacedName{Name: ""nonexistent-service"", Namespace: ""default""},
			port:           intstr.FromString(""8080""),
			wantErr:        errors.New(`service ""default/nonexistent-service"" not found`),
		},
		""when port does not exist an error is returned"": {
			NamespacedName: types.NamespacedName{Name: ""service1"", Namespace: ""default""},
			port:           intstr.FromString(""9999""),
			wantErr:        errors.New(`port ""9999"" on service ""default/service1"" not matched`),
		},
		""When ExternalName Services are not disabled no error is returned"": {
			NamespacedName: types.NamespacedName{Name: ""externalnamevalid"", Namespace: ""default""},
			port:           intstr.FromString(""80""),
			want: &Service{
				Weighted: WeightedService{
					Weight:           1,
					ServiceName:      ""externalnamevalid"",
					ServiceNamespace: ""default"",
					ServicePort: v1.ServicePort{
						Name:       ""http"",
						Protocol:   ""TCP"",
						Port:       80,
						TargetPort: intstr.FromInt(80),
					},
				},
				ExternalName: ""external.projectcontour.io"",
			},
			enableExternalNameSvc: true,
		},
		""When ExternalName Services are disabled an error is returned"": {
			NamespacedName: types.NamespacedName{Name: ""externalnamevalid"", Namespace: ""default""},
			port:           intstr.FromString(""80""),
			wantErr:        errors.New(`default/externalnamevalid is an ExternalName service, these are not currently enabled. See the config.enableExternalNameService config file setting`),
		},
		""When ExternalName Services are enabled but a localhost ExternalName is used an error is returned"": {
			NamespacedName:        types.NamespacedName{Name: ""externalnamelocalhost"", Namespace: ""default""},
			port:                  intstr.FromString(""80""),
			wantErr:               errors.New(`default/externalnamelocalhost is an ExternalName service that points to localhost, this is not allowed`),
			enableExternalNameSvc: true,
		},
	}
	for name, tc := range tests {
		t.Run(name, func(t *testing.T) {
			b := Builder{
				Source: KubernetesCache{
					services:    services,
					FieldLogger: fixture.NewTestLogger(t),
				},
			}
			var dag DAG
			got, gotErr := dag.EnsureService(tc.NamespacedName, tc.port, &b.Source, tc.enableExternalNameSvc)
			assert.Equal(t, tc.want, got)
			assert.Equal(t, tc.wantErr, gotErr)
		})
	}
}
",CWE-610,170.0,0
"// Copyright Project Contour Authors
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package dag
import (
	""path""
	""strings""
	contour_api_v1 ""github.com/projectcontour/contour/apis/projectcontour/v1""
	contour_api_v1alpha1 ""github.com/projectcontour/contour/apis/projectcontour/v1alpha1""
	""github.com/projectcontour/contour/internal/k8s""
	""github.com/projectcontour/contour/internal/status""
	""github.com/projectcontour/contour/internal/xds""
	""github.com/sirupsen/logrus""
	corev1 ""k8s.io/api/core/v1""
	""k8s.io/apimachinery/pkg/types""
	""k8s.io/apimachinery/pkg/util/intstr""
)
type ExtensionServiceProcessor struct {
	logrus.FieldLogger
	// ClientCertificate is the optional identifier of the TLS
	// secret containing client certificate and private key to be
	// used when establishing TLS connection to upstream cluster.
	ClientCertificate *types.NamespacedName
}
var _ Processor = &ExtensionServiceProcessor{}
func (p *ExtensionServiceProcessor) Run(dag *DAG, cache *KubernetesCache) {
	for _, e := range cache.extensions {
		extStatus, commit := status.ExtensionAccessor(&dag.StatusCache, e)
		validCondition := extStatus.ConditionFor(status.ValidCondition)
		if ext := p.buildExtensionService(cache, e, validCondition); ext != nil {
			if len(validCondition.Errors) == 0 {
				dag.AddRoot(ext)
			}
		}
		if len(validCondition.Errors) == 0 {
			validCondition.Status = contour_api_v1.ConditionTrue
			validCondition.Reason = ""Valid""
			validCondition.Message = ""Valid ExtensionService""
		}
		commit()
	}
}
// ExtensionClusterName generates a unique Envoy cluster name
// for an ExtensionCluster.
// The namespaced name of an ExtensionCluster is globally
// unique, so we can simply use that as the cluster name. As
// long as we scope the context with the ""extension"" prefix
// there can't be a conflict. Note that the name doesn't include
// a hash of the contents because we want a 1-1 mapping between
// ExtensionServices and Envoy Clusters; we don't want a new
// Envoy Cluster just because a field changed.
func ExtensionClusterName(meta types.NamespacedName) string {
	return strings.Join([]string{""extension"", meta.Namespace, meta.Name}, ""/"")
}
// buildExtensionService builds one ExtensionCluster record based
// on the corresponding CRD.
func (p *ExtensionServiceProcessor) buildExtensionService(
	cache *KubernetesCache,
	ext *contour_api_v1alpha1.ExtensionService,
	validCondition *contour_api_v1.DetailedCondition,
) *ExtensionCluster {
	tp, err := timeoutPolicy(ext.Spec.TimeoutPolicy)
	if err != nil {
		validCondition.AddErrorf(contour_api_v1.ConditionTypeSpecError, ""TimeoutPolicyNotValid"",
			""spec.timeoutPolicy failed to parse: %s"", err)
	}
	var clientCertSecret *Secret
	if p.ClientCertificate != nil {
		clientCertSecret, err = cache.LookupSecret(*p.ClientCertificate, validSecret)
		if err != nil {
			validCondition.AddErrorf(contour_api_v1.ConditionTypeTLSError, ""SecretNotValid"",
				""tls.envoy-client-certificate Secret %q is invalid: %s"", p.ClientCertificate, err)
		}
	}
	extension := ExtensionCluster{
		Name: ExtensionClusterName(k8s.NamespacedNameOf(ext)),
		Upstream: ServiceCluster{
			ClusterName: path.Join(
				""extension"",
				xds.ClusterLoadAssignmentName(k8s.NamespacedNameOf(ext), """"),
			),
		},
		Protocol:           ""h2"",
		UpstreamValidation: nil,
		TimeoutPolicy:      tp,
		SNI:                """",
		ClientCertificate:  clientCertSecret,
	}
	lbPolicy := loadBalancerPolicy(ext.Spec.LoadBalancerPolicy)
	switch lbPolicy {
	case LoadBalancerPolicyCookie, LoadBalancerPolicyRequestHash:
		validCondition.AddWarningf(contour_api_v1.ConditionTypeSpecError, ""IgnoredField"",
			""ignoring field %q; %s load balancer policy is not supported for ExtensionClusters"",
			"".Spec.LoadBalancerPolicy"", lbPolicy)
		// Reset load balancer policy to ensure the default.
		lbPolicy = """"
	}
	extension.LoadBalancerPolicy = lbPolicy
	// Timeouts are specified above the cluster (e.g.
	// in the ext_authz filter). The ext_authz filter
	// doesn't have an idle timeout (only a request
	// timeout), so validate that it is not provided here.
	if timeouts := ext.Spec.TimeoutPolicy; timeouts != nil && timeouts.Idle != """" {
		validCondition.AddWarningf(""SpecError"", ""IgnoredField"",
			""ignoring field %q; idle timeouts are not supported for ExtensionClusters"",
			"".Spec.TimeoutPolicy.Idle"")
	}
	// API server validation ensures that the protocol is ""h2"" or ""h2c"".
	if ext.Spec.Protocol != nil {
		extension.Protocol = stringOrDefault(*ext.Spec.Protocol, extension.Protocol)
	}
	if v := ext.Spec.UpstreamValidation; v != nil {
		if uv, err := cache.LookupUpstreamValidation(v, ext.GetNamespace()); err != nil {
			validCondition.AddErrorf(contour_api_v1.ConditionTypeSpecError, ""TLSUpstreamValidation"",
				""TLS upstream validation policy error: %s"", err.Error())
		} else {
			extension.UpstreamValidation = uv
			// Default the SNI server name to the name
			// we need to validate. It is a bit onerous
			// to also have to provide a CA bundle here,
			// but maybe we can make that optional in the
			// future.
			//
			// TODO(jpeach): expose SNI in the API, https://github.com/projectcontour/contour/issues/2893.
			extension.SNI = uv.SubjectName
		}
		if extension.Protocol != ""h2"" {
			validCondition.AddErrorf(contour_api_v1.ConditionTypeSpecError, ""InconsistentProtocol"",
				""upstream TLS validation not supported for %q protocol"", extension.Protocol)
		}
	}
	for _, target := range ext.Spec.Services {
		// Note that ExtensionServices only expose Kubernetes
		// Service resources that are in the same namespace.
		// This prevent using a cross-namespace reference to
		// subvert the Contour installation.
		svcName := types.NamespacedName{
			Namespace: ext.GetNamespace(),
			Name:      target.Name,
		}
		svc, port, err := cache.LookupService(svcName, intstr.FromInt(target.Port))
		if err != nil {
			validCondition.AddErrorf(contour_api_v1.ConditionTypeServiceError, ""ServiceUnresolvedReference"",
				""unresolved service %q: %s"", svcName, err)
			continue
		}
		// TODO(jpeach): Add ExternalName support in https://github.com/projectcontour/contour/issues/2875.
		// TODO(youngnick): If ExternalName support is added, we must pass down the EnableExternalNameService bool
		// and check it first.
		if svc.Spec.ExternalName != """" {
			validCondition.AddErrorf(contour_api_v1.ConditionTypeServiceError, ""UnsupportedServiceType"",
				""Service %q is of unsupported type %q."", svcName, corev1.ServiceTypeExternalName)
			continue
		}
		extension.Upstream.AddWeightedService(target.Weight, svcName, port)
	}
	return &extension
}
",CWE-610,193.0,0
"package ops
import (
	""fmt""
	. ""github.com/onsi/ginkgo""
	. ""github.com/onsi/gomega""
	""github.com/openshift/assisted-installer/src/config""
)
var _ = Describe(""ExecCommandError"", func() {
	pullSecret := ""TEST-TOKEN""
	config.GlobalConfig.PullSecretToken = pullSecret
	It(""Creates the correct error for mkdir"", func() {
		err := &ExecCommandError{
			Command: ""mkdir"",
			Args:    []string{""-p"", ""/somedir""},
			Env:     []string{""HOME=/home/userZ""},
			ExitErr: fmt.Errorf(""Permission denied""),
			Output:  ""mkdir: cannot create directory ‘/somedir’: Permission denied"",
		}
		wantError := ""failed executing mkdir [-p /somedir], Error Permission denied, LastOutput \""mkdir: cannot create directory ‘/somedir’: Permission denied\""""
		wantDetailedError := ""failed executing mkdir [-p /somedir], env vars [HOME=/home/userZ], error Permission denied, waitStatus 0, Output \""mkdir: cannot create directory ‘/somedir’: Permission denied\""""
		Expect(err.Error()).To(Equal(wantError))
		Expect(err.DetailedError()).To(Equal(wantDetailedError))
	})
	It(""Creates the correct error for ignition extract"", func() {
		err := &ExecCommandError{
			Command:    ""nsenter"",
			Args:       []string{""-t"", ""1"", ""-m"", ""-i"", ""--"", ""podman"", ""run"", ""--net"", ""host"", ""--volume"", ""/:/rootfs:rw"", ""--volume"", ""/usr/bin/rpm-ostree:/usr/bin/rpm-ostree"", ""--privileged"", ""--entrypoint"", ""/usr/bin/machine-config-daemon"", ""quay.io/openshift-release-dev/ocp-v4.0-art-dev@sha256:dc1a34f55c712b2b9c5e5a14dd85e67cbdae11fd147046ac2fef9eaf179ab221"", ""start"", ""--node-name"", ""localhost"", ""--root-mount"", ""/rootfs"", ""--once-from"", ""/opt/install-dir/bootstrap.ign"", ""--skip-reboot"", ""--pull-secret"", pullSecret},
			Env:        []string{""HOME=/home/userZ"", fmt.Sprintf(""PULL_SECRET_TOKEN=%s"", pullSecret)},
			ExitErr:    fmt.Errorf(""exit status 255""),
			WaitStatus: 255,
			Output:     ""Trying to pull quay.io/openshift-release-dev/ocp-v4.0-art-dev@sha256:dc1a34f55c712b2b9c5e5a14dd85e67cbdae11fd147046ac2fef9eaf179ab221...\nGetting image source signatures\nCopying blob sha256:74cbb6607642df5f9f70e8588e3c56d6de795d1a9af22866ea4cc82f2dad4f14\nCopying blob sha256:c9fa7d57b9028d4bd02b51cef3c3039fa7b23a8b2d9d26a6ce66b3428f6e2457\nCopying blob sha256:c676df4ac84e718ecee4f8129e43e9c2b7492942606cc65f1fc5e6f3da413160\nCopying blob sha256:b147db91a07555d29ed6085e4733f34dbaa673076488caa8f95f4677f55b3a5c\nCopying blob sha256:ad956945835b7630565fc23fcbd8194eef32b4300c28546d574b2a377fe5d0a5\nCopying config sha256:c4356549f53a30a1baefc5d1515ec1ab8b3786a4bf1738c0abaedc0e44829498\nWriting manifest to image destination\nStoring signatures\nI1019 19:03:28.797092 1 start.go:108] Version: v4.6.0-202008262209.p0-dirty (16d243c4bed178f5d4fd400c0518ebf1dbaface8)\nI1019 19:03:28.797227 1 start.go:118] Calling chroot(\""/rootfs\"")\nI1019 19:03:28.797307 1 rpm-ostree.go:261] Running captured: rpm-ostree status --json\nerror: Timeout was reached\nF1019 19:04:35.869592 1 start.go:147] Failed to initialize single run daemon: error reading osImageURL from rpm-ostree: error running rpm-ostree status --json: : exit status 1)"",
		}
		wantError := `failed executing nsenter [-t 1 -m -i -- podman run --net host --volume /:/rootfs:rw --volume /usr/bin/rpm-ostree:/usr/bin/rpm-ostree --privileged --entrypoint /usr/bin/machine-config-daemon quay.io/openshift-release-dev/ocp-v4.0-art-dev@sha256:dc1a34f55c712b2b9c5e5a14dd85e67cbdae11fd147046ac2fef9eaf179ab221 start --node-name localhost --root-mount /rootfs --once-from /opt/install-dir/bootstrap.ign --skip-reboot --pull-secret <SECRET>], Error exit status 255, LastOutput ""... or: Timeout was reached
F1019 19:04:35.869592 1 start.go:147] Failed to initialize single run daemon: error reading osImageURL from rpm-ostree: error running rpm-ostree status --json: : exit status 1)""`
		wantDetailedError := `failed executing nsenter [-t 1 -m -i -- podman run --net host --volume /:/rootfs:rw --volume /usr/bin/rpm-ostree:/usr/bin/rpm-ostree --privileged --entrypoint /usr/bin/machine-config-daemon quay.io/openshift-release-dev/ocp-v4.0-art-dev@sha256:dc1a34f55c712b2b9c5e5a14dd85e67cbdae11fd147046ac2fef9eaf179ab221 start --node-name localhost --root-mount /rootfs --once-from /opt/install-dir/bootstrap.ign --skip-reboot --pull-secret <SECRET>], env vars [HOME=/home/userZ PULL_SECRET_TOKEN=<SECRET>], error exit status 255, waitStatus 255, Output ""Trying to pull quay.io/openshift-release-dev/ocp-v4.0-art-dev@sha256:dc1a34f55c712b2b9c5e5a14dd85e67cbdae11fd147046ac2fef9eaf179ab221...
Getting image source signatures
Copying blob sha256:74cbb6607642df5f9f70e8588e3c56d6de795d1a9af22866ea4cc82f2dad4f14
Copying blob sha256:c9fa7d57b9028d4bd02b51cef3c3039fa7b23a8b2d9d26a6ce66b3428f6e2457
Copying blob sha256:c676df4ac84e718ecee4f8129e43e9c2b7492942606cc65f1fc5e6f3da413160
Copying blob sha256:b147db91a07555d29ed6085e4733f34dbaa673076488caa8f95f4677f55b3a5c
Copying blob sha256:ad956945835b7630565fc23fcbd8194eef32b4300c28546d574b2a377fe5d0a5
Copying config sha256:c4356549f53a30a1baefc5d1515ec1ab8b3786a4bf1738c0abaedc0e44829498
Writing manifest to image destination
Storing signatures
I1019 19:03:28.797092 1 start.go:108] Version: v4.6.0-202008262209.p0-dirty (16d243c4bed178f5d4fd400c0518ebf1dbaface8)
I1019 19:03:28.797227 1 start.go:118] Calling chroot(""/rootfs"")
I1019 19:03:28.797307 1 rpm-ostree.go:261] Running captured: rpm-ostree status --json
error: Timeout was reached
F1019 19:04:35.869592 1 start.go:147] Failed to initialize single run daemon: error reading osImageURL from rpm-ostree: error running rpm-ostree status --json: : exit status 1)""`
		Expect(err.Error()).To(Equal(wantError))
		Expect(err.DetailedError()).To(Equal(wantDetailedError))
	})
})
var _ = Describe(""installerArgs"", func() {
	var (
		device       = ""/dev/sda""
		ignitionPath = ""/tmp/ignition.ign""
	)
	It(""Returns the correct list with no extra args"", func() {
		args := installerArgs(ignitionPath, device, nil)
		expected := []string{""install"", ""--insecure"", ""-i"", ""/tmp/ignition.ign"", ""/dev/sda""}
		Expect(args).To(Equal(expected))
	})
	It(""Returns the correct list with empty extra args"", func() {
		args := installerArgs(ignitionPath, device, []string{})
		expected := []string{""install"", ""--insecure"", ""-i"", ""/tmp/ignition.ign"", ""/dev/sda""}
		Expect(args).To(Equal(expected))
	})
	It(""Returns the correct list with extra args"", func() {
		args := installerArgs(ignitionPath, device, []string{""-n"", ""--append-karg"", ""nameserver=8.8.8.8""})
		expected := []string{""install"", ""--insecure"", ""-i"", ""/tmp/ignition.ign"", ""-n"", ""--append-karg"", ""nameserver=8.8.8.8"", ""/dev/sda""}
		Expect(args).To(Equal(expected))
	})
})
",CWE-532,86.0,0
"package unicorn
// For Unicorn Engine. AUTO-GENERATED FILE, DO NOT EDIT [arm_const.go]
const (
// ARM CPU
	CPU_ARM_926 = 0
	CPU_ARM_946 = 1
	CPU_ARM_1026 = 2
	CPU_ARM_1136_R2 = 3
	CPU_ARM_1136 = 4
	CPU_ARM_1176 = 5
	CPU_ARM_11MPCORE = 6
	CPU_ARM_CORTEX_M0 = 7
	CPU_ARM_CORTEX_M3 = 8
	CPU_ARM_CORTEX_M4 = 9
	CPU_ARM_CORTEX_M7 = 10
	CPU_ARM_CORTEX_M33 = 11
	CPU_ARM_CORTEX_R5 = 12
	CPU_ARM_CORTEX_R5F = 13
	CPU_ARM_CORTEX_A7 = 14
	CPU_ARM_CORTEX_A8 = 15
	CPU_ARM_CORTEX_A9 = 16
	CPU_ARM_CORTEX_A15 = 17
	CPU_ARM_TI925T = 18
	CPU_ARM_SA1100 = 19
	CPU_ARM_SA1110 = 20
	CPU_ARM_PXA250 = 21
	CPU_ARM_PXA255 = 22
	CPU_ARM_PXA260 = 23
	CPU_ARM_PXA261 = 24
	CPU_ARM_PXA262 = 25
	CPU_ARM_PXA270 = 26
	CPU_ARM_PXA270A0 = 27
	CPU_ARM_PXA270A1 = 28
	CPU_ARM_PXA270B0 = 29
	CPU_ARM_PXA270B1 = 30
	CPU_ARM_PXA270C0 = 31
	CPU_ARM_PXA270C5 = 32
	CPU_ARM_MAX = 33
	CPU_ARM_ENDING = 34
// ARM registers
	ARM_REG_INVALID = 0
	ARM_REG_APSR = 1
	ARM_REG_APSR_NZCV = 2
	ARM_REG_CPSR = 3
	ARM_REG_FPEXC = 4
	ARM_REG_FPINST = 5
	ARM_REG_FPSCR = 6
	ARM_REG_FPSCR_NZCV = 7
	ARM_REG_FPSID = 8
	ARM_REG_ITSTATE = 9
	ARM_REG_LR = 10
	ARM_REG_PC = 11
	ARM_REG_SP = 12
	ARM_REG_SPSR = 13
	ARM_REG_D0 = 14
	ARM_REG_D1 = 15
	ARM_REG_D2 = 16
	ARM_REG_D3 = 17
	ARM_REG_D4 = 18
	ARM_REG_D5 = 19
	ARM_REG_D6 = 20
	ARM_REG_D7 = 21
	ARM_REG_D8 = 22
	ARM_REG_D9 = 23
	ARM_REG_D10 = 24
	ARM_REG_D11 = 25
	ARM_REG_D12 = 26
	ARM_REG_D13 = 27
	ARM_REG_D14 = 28
	ARM_REG_D15 = 29
	ARM_REG_D16 = 30
	ARM_REG_D17 = 31
	ARM_REG_D18 = 32
	ARM_REG_D19 = 33
	ARM_REG_D20 = 34
	ARM_REG_D21 = 35
	ARM_REG_D22 = 36
	ARM_REG_D23 = 37
	ARM_REG_D24 = 38
	ARM_REG_D25 = 39
	ARM_REG_D26 = 40
	ARM_REG_D27 = 41
	ARM_REG_D28 = 42
	ARM_REG_D29 = 43
	ARM_REG_D30 = 44
	ARM_REG_D31 = 45
	ARM_REG_FPINST2 = 46
	ARM_REG_MVFR0 = 47
	ARM_REG_MVFR1 = 48
	ARM_REG_MVFR2 = 49
	ARM_REG_Q0 = 50
	ARM_REG_Q1 = 51
	ARM_REG_Q2 = 52
	ARM_REG_Q3 = 53
	ARM_REG_Q4 = 54
	ARM_REG_Q5 = 55
	ARM_REG_Q6 = 56
	ARM_REG_Q7 = 57
	ARM_REG_Q8 = 58
	ARM_REG_Q9 = 59
	ARM_REG_Q10 = 60
	ARM_REG_Q11 = 61
	ARM_REG_Q12 = 62
	ARM_REG_Q13 = 63
	ARM_REG_Q14 = 64
	ARM_REG_Q15 = 65
	ARM_REG_R0 = 66
	ARM_REG_R1 = 67
	ARM_REG_R2 = 68
	ARM_REG_R3 = 69
	ARM_REG_R4 = 70
	ARM_REG_R5 = 71
	ARM_REG_R6 = 72
	ARM_REG_R7 = 73
	ARM_REG_R8 = 74
	ARM_REG_R9 = 75
	ARM_REG_R10 = 76
	ARM_REG_R11 = 77
	ARM_REG_R12 = 78
	ARM_REG_S0 = 79
	ARM_REG_S1 = 80
	ARM_REG_S2 = 81
	ARM_REG_S3 = 82
	ARM_REG_S4 = 83
	ARM_REG_S5 = 84
	ARM_REG_S6 = 85
	ARM_REG_S7 = 86
	ARM_REG_S8 = 87
	ARM_REG_S9 = 88
	ARM_REG_S10 = 89
	ARM_REG_S11 = 90
	ARM_REG_S12 = 91
	ARM_REG_S13 = 92
	ARM_REG_S14 = 93
	ARM_REG_S15 = 94
	ARM_REG_S16 = 95
	ARM_REG_S17 = 96
	ARM_REG_S18 = 97
	ARM_REG_S19 = 98
	ARM_REG_S20 = 99
	ARM_REG_S21 = 100
	ARM_REG_S22 = 101
	ARM_REG_S23 = 102
	ARM_REG_S24 = 103
	ARM_REG_S25 = 104
	ARM_REG_S26 = 105
	ARM_REG_S27 = 106
	ARM_REG_S28 = 107
	ARM_REG_S29 = 108
	ARM_REG_S30 = 109
	ARM_REG_S31 = 110
	ARM_REG_C1_C0_2 = 111
	ARM_REG_C13_C0_2 = 112
	ARM_REG_C13_C0_3 = 113
	ARM_REG_IPSR = 114
	ARM_REG_MSP = 115
	ARM_REG_PSP = 116
	ARM_REG_CONTROL = 117
	ARM_REG_IAPSR = 118
	ARM_REG_EAPSR = 119
	ARM_REG_XPSR = 120
	ARM_REG_EPSR = 121
	ARM_REG_IEPSR = 122
	ARM_REG_PRIMASK = 123
	ARM_REG_BASEPRI = 124
	ARM_REG_BASEPRI_MAX = 125
	ARM_REG_FAULTMASK = 126
	ARM_REG_APSR_NZCVQ = 127
	ARM_REG_APSR_G = 128
	ARM_REG_APSR_NZCVQG = 129
	ARM_REG_IAPSR_NZCVQ = 130
	ARM_REG_IAPSR_G = 131
	ARM_REG_IAPSR_NZCVQG = 132
	ARM_REG_EAPSR_NZCVQ = 133
	ARM_REG_EAPSR_G = 134
	ARM_REG_EAPSR_NZCVQG = 135
	ARM_REG_XPSR_NZCVQ = 136
	ARM_REG_XPSR_G = 137
	ARM_REG_XPSR_NZCVQG = 138
	ARM_REG_CP_REG = 139
	ARM_REG_ENDING = 140
// alias registers
	ARM_REG_R13 = 12
	ARM_REG_R14 = 10
	ARM_REG_R15 = 11
	ARM_REG_SB = 75
	ARM_REG_SL = 76
	ARM_REG_FP = 77
	ARM_REG_IP = 78
)",CWE-665,195.0,0
"package unicorn
// For Unicorn Engine. AUTO-GENERATED FILE, DO NOT EDIT [m68k_const.go]
const (
// M68K CPU
	CPU_M68K_M5206 = 0
	CPU_M68K_M68000 = 1
	CPU_M68K_M68020 = 2
	CPU_M68K_M68030 = 3
	CPU_M68K_M68040 = 4
	CPU_M68K_M68060 = 5
	CPU_M68K_M5208 = 6
	CPU_M68K_CFV4E = 7
	CPU_M68K_ANY = 8
	CPU_M68K_ENDING = 9
// M68K registers
	M68K_REG_INVALID = 0
	M68K_REG_A0 = 1
	M68K_REG_A1 = 2
	M68K_REG_A2 = 3
	M68K_REG_A3 = 4
	M68K_REG_A4 = 5
	M68K_REG_A5 = 6
	M68K_REG_A6 = 7
	M68K_REG_A7 = 8
	M68K_REG_D0 = 9
	M68K_REG_D1 = 10
	M68K_REG_D2 = 11
	M68K_REG_D3 = 12
	M68K_REG_D4 = 13
	M68K_REG_D5 = 14
	M68K_REG_D6 = 15
	M68K_REG_D7 = 16
	M68K_REG_SR = 17
	M68K_REG_PC = 18
	M68K_REG_ENDING = 19
)",CWE-665,40.0,0
"package http
import (
	""io/fs""
	""net/http""
	""github.com/gorilla/mux""
	""github.com/filebrowser/filebrowser/v2/settings""
	""github.com/filebrowser/filebrowser/v2/storage""
)
type modifyRequest struct {
	What  string   `json:""what""`  // Answer to: what data type?
	Which []string `json:""which""` // Answer to: which fields?
}
func NewHandler(
	imgSvc ImgService,
	fileCache FileCache,
	store *storage.Storage,
	server *settings.Server,
	assetsFs fs.FS,
) (http.Handler, error) {
	server.Clean()
	r := mux.NewRouter()
	r.Use(func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			w.Header().Set(""Content-Security-Policy"", `default-src 'self'`)
			next.ServeHTTP(w, r)
		})
	})
	index, static := getStaticHandlers(store, server, assetsFs)
	// NOTE: This fixes the issue where it would redirect if people did not put a
	// trailing slash in the end. I hate this decision since this allows some awful
	// URLs https://www.gorillatoolkit.org/pkg/mux
	r = r.SkipClean(true)
	monkey := func(fn handleFunc, prefix string) http.Handler {
		return handle(fn, prefix, store, server)
	}
	r.HandleFunc(""/health"", healthHandler)
	r.PathPrefix(""/static"").Handler(static)
	r.NotFoundHandler = index
	api := r.PathPrefix(""/api"").Subrouter()
	api.Handle(""/login"", monkey(loginHandler, """"))
	api.Handle(""/signup"", monkey(signupHandler, """"))
	api.Handle(""/renew"", monkey(renewHandler, """"))
	users := api.PathPrefix(""/users"").Subrouter()
	users.Handle("""", monkey(usersGetHandler, """")).Methods(""GET"")
	users.Handle("""", monkey(userPostHandler, """")).Methods(""POST"")
	users.Handle(""/{id:[0-9]+}"", monkey(userPutHandler, """")).Methods(""PUT"")
	users.Handle(""/{id:[0-9]+}"", monkey(userGetHandler, """")).Methods(""GET"")
	users.Handle(""/{id:[0-9]+}"", monkey(userDeleteHandler, """")).Methods(""DELETE"")
	api.PathPrefix(""/resources"").Handler(monkey(resourceGetHandler, ""/api/resources"")).Methods(""GET"")
	api.PathPrefix(""/resources"").Handler(monkey(resourceDeleteHandler(fileCache), ""/api/resources"")).Methods(""DELETE"")
	api.PathPrefix(""/resources"").Handler(monkey(resourcePostHandler(fileCache), ""/api/resources"")).Methods(""POST"")
	api.PathPrefix(""/resources"").Handler(monkey(resourcePutHandler, ""/api/resources"")).Methods(""PUT"")
	api.PathPrefix(""/resources"").Handler(monkey(resourcePatchHandler(fileCache), ""/api/resources"")).Methods(""PATCH"")
	api.Path(""/shares"").Handler(monkey(shareListHandler, ""/api/shares"")).Methods(""GET"")
	api.PathPrefix(""/share"").Handler(monkey(shareGetsHandler, ""/api/share"")).Methods(""GET"")
	api.PathPrefix(""/share"").Handler(monkey(sharePostHandler, ""/api/share"")).Methods(""POST"")
	api.PathPrefix(""/share"").Handler(monkey(shareDeleteHandler, ""/api/share"")).Methods(""DELETE"")
	api.Handle(""/settings"", monkey(settingsGetHandler, """")).Methods(""GET"")
	api.Handle(""/settings"", monkey(settingsPutHandler, """")).Methods(""PUT"")
	api.PathPrefix(""/raw"").Handler(monkey(rawHandler, ""/api/raw"")).Methods(""GET"")
	api.PathPrefix(""/preview/{size}/{path:.*}"").
		Handler(monkey(previewHandler(imgSvc, fileCache, server.EnableThumbnails, server.ResizePreview), ""/api/preview"")).Methods(""GET"")
	api.PathPrefix(""/command"").Handler(monkey(commandsHandler, ""/api/command"")).Methods(""GET"")
	api.PathPrefix(""/search"").Handler(monkey(searchHandler, ""/api/search"")).Methods(""GET"")
	public := api.PathPrefix(""/public"").Subrouter()
	public.PathPrefix(""/dl"").Handler(monkey(publicDlHandler, ""/api/public/dl/"")).Methods(""GET"")
	public.PathPrefix(""/share"").Handler(monkey(publicShareHandler, ""/api/public/share/"")).Methods(""GET"")
	return stripPrefix(server.BaseURL, r), nil
}
",CWE-79,88.0,0
"package http
import (
	""bufio""
	""io""
	""log""
	""net/http""
	""os/exec""
	""strings""
	""time""
	""github.com/gorilla/websocket""
	""github.com/filebrowser/filebrowser/v2/runner""
)
const (
	WSWriteDeadline = 10 * time.Second
)
var upgrader = websocket.Upgrader{
	ReadBufferSize:  1024,
	WriteBufferSize: 1024,
}
var (
	cmdNotAllowed = []byte(""Command not allowed."")
)
func wsErr(ws *websocket.Conn, r *http.Request, status int, err error) { //nolint:unparam
	txt := http.StatusText(status)
	if err != nil || status >= 400 {
		log.Printf(""%s: %v %s %v"", r.URL.Path, status, r.RemoteAddr, err)
	}
	if err := ws.WriteControl(websocket.CloseInternalServerErr, []byte(txt), time.Now().Add(WSWriteDeadline)); err != nil {
		log.Print(err)
	}
}
var commandsHandler = withUser(func(w http.ResponseWriter, r *http.Request, d *data) (int, error) {
	conn, err := upgrader.Upgrade(w, r, nil)
	if err != nil {
		return http.StatusInternalServerError, err
	}
	defer conn.Close()
	var raw string
	for {
		_, msg, err := conn.ReadMessage() //nolint:govet
		if err != nil {
			wsErr(conn, r, http.StatusInternalServerError, err)
			return 0, nil
		}
		raw = strings.TrimSpace(string(msg))
		if raw != """" {
			break
		}
	}
	command, err := runner.ParseCommand(d.settings, raw)
	if err != nil {
		if err := conn.WriteMessage(websocket.TextMessage, []byte(err.Error())); err != nil { //nolint:govet
			wsErr(conn, r, http.StatusInternalServerError, err)
		}
		return 0, nil
	}
	if !d.server.EnableExec || !d.user.CanExecute(command[0]) {
		if err := conn.WriteMessage(websocket.TextMessage, cmdNotAllowed); err != nil { //nolint:govet
			wsErr(conn, r, http.StatusInternalServerError, err)
		}
		return 0, nil
	}
	cmd := exec.Command(command[0], command[1:]...) //nolint:gosec
	cmd.Dir = d.user.FullPath(r.URL.Path)
	stdout, err := cmd.StdoutPipe()
	if err != nil {
		wsErr(conn, r, http.StatusInternalServerError, err)
		return 0, nil
	}
	stderr, err := cmd.StderrPipe()
	if err != nil {
		wsErr(conn, r, http.StatusInternalServerError, err)
		return 0, nil
	}
	if err := cmd.Start(); err != nil {
		wsErr(conn, r, http.StatusInternalServerError, err)
		return 0, nil
	}
	s := bufio.NewScanner(io.MultiReader(stdout, stderr))
	for s.Scan() {
		if err := conn.WriteMessage(websocket.TextMessage, s.Bytes()); err != nil {
			log.Print(err)
		}
	}
	if err := cmd.Wait(); err != nil {
		wsErr(conn, r, http.StatusInternalServerError, err)
	}
	return 0, nil
})
",CWE-352,111.0,0
"// +build !libsodium
package internal
// This file contains functions that should return `nil`,
// in order to be able to build wal-g without specific implementations of the crypter.
// And the configure_crypter_<crypter>.go files must have a real implementation of the function.
//
// Thus, if the tag is missing, the condition:
// if crypter := configure<crypter>Crypter(); crypter != nil {
//     return crypter
// }
// will never be met.
// If there is a tag, we can configure the correct implementation of crypter.
import (
	""github.com/spf13/viper""
	""github.com/wal-g/tracelog""
	""github.com/wal-g/wal-g/internal/crypto""
)
func configureLibsodiumCrypter() crypto.Crypter {
	if viper.IsSet(LibsodiumKeySetting) {
		tracelog.ErrorLogger.Fatalf(""non-empty WALG_LIBSODIUM_KEY but wal-g was not compiled with libsodium"")
	}
	if viper.IsSet(LibsodiumKeyPathSetting) {
		tracelog.ErrorLogger.Fatalf(""non-empty WALG_LIBSODIUM_KEY_PATH but wal-g was not compiled with libsodium"")
	}
	return nil
}
",CWE-754,33.0,0
"package encoding
import (
	""encoding/binary""
	""io""
	""github.com/v2fly/v2ray-core/v4/common""
	""github.com/v2fly/v2ray-core/v4/common/buf""
	""github.com/v2fly/v2ray-core/v4/common/net""
	""github.com/v2fly/v2ray-core/v4/common/protocol""
	""github.com/v2fly/v2ray-core/v4/common/serial""
	""github.com/v2fly/v2ray-core/v4/common/uuid""
)
var (
	ErrCommandTypeMismatch = newError(""Command type mismatch."")
	ErrUnknownCommand      = newError(""Unknown command."")
	ErrCommandTooLarge     = newError(""Command too large."")
)
func MarshalCommand(command interface{}, writer io.Writer) error {
	if command == nil {
		return ErrUnknownCommand
	}
	var cmdID byte
	var factory CommandFactory
	switch command.(type) {
	case *protocol.CommandSwitchAccount:
		factory = new(CommandSwitchAccountFactory)
		cmdID = 1
	default:
		return ErrUnknownCommand
	}
	buffer := buf.New()
	defer buffer.Release()
	err := factory.Marshal(command, buffer)
	if err != nil {
		return err
	}
	auth := Authenticate(buffer.Bytes())
	length := buffer.Len() + 4
	if length > 255 {
		return ErrCommandTooLarge
	}
	common.Must2(writer.Write([]byte{cmdID, byte(length), byte(auth >> 24), byte(auth >> 16), byte(auth >> 8), byte(auth)}))
	common.Must2(writer.Write(buffer.Bytes()))
	return nil
}
func UnmarshalCommand(cmdID byte, data []byte) (protocol.ResponseCommand, error) {
	if len(data) <= 4 {
		return nil, newError(""insufficient length"")
	}
	expectedAuth := Authenticate(data[4:])
	actualAuth := binary.BigEndian.Uint32(data[:4])
	if expectedAuth != actualAuth {
		return nil, newError(""invalid auth"")
	}
	var factory CommandFactory
	switch cmdID {
	case 1:
		factory = new(CommandSwitchAccountFactory)
	default:
		return nil, ErrUnknownCommand
	}
	return factory.Unmarshal(data[4:])
}
type CommandFactory interface {
	Marshal(command interface{}, writer io.Writer) error
	Unmarshal(data []byte) (interface{}, error)
}
type CommandSwitchAccountFactory struct{}
func (f *CommandSwitchAccountFactory) Marshal(command interface{}, writer io.Writer) error {
	cmd, ok := command.(*protocol.CommandSwitchAccount)
	if !ok {
		return ErrCommandTypeMismatch
	}
	hostStr := """"
	if cmd.Host != nil {
		hostStr = cmd.Host.String()
	}
	common.Must2(writer.Write([]byte{byte(len(hostStr))}))
	if len(hostStr) > 0 {
		common.Must2(writer.Write([]byte(hostStr)))
	}
	common.Must2(serial.WriteUint16(writer, cmd.Port.Value()))
	idBytes := cmd.ID.Bytes()
	common.Must2(writer.Write(idBytes))
	common.Must2(serial.WriteUint16(writer, cmd.AlterIds))
	common.Must2(writer.Write([]byte{byte(cmd.Level)}))
	common.Must2(writer.Write([]byte{cmd.ValidMin}))
	return nil
}
func (f *CommandSwitchAccountFactory) Unmarshal(data []byte) (interface{}, error) {
	cmd := new(protocol.CommandSwitchAccount)
	if len(data) == 0 {
		return nil, newError(""insufficient length."")
	}
	lenHost := int(data[0])
	if len(data) < lenHost+1 {
		return nil, newError(""insufficient length."")
	}
	if lenHost > 0 {
		cmd.Host = net.ParseAddress(string(data[1 : 1+lenHost]))
	}
	portStart := 1 + lenHost
	if len(data) < portStart+2 {
		return nil, newError(""insufficient length."")
	}
	cmd.Port = net.PortFromBytes(data[portStart : portStart+2])
	idStart := portStart + 2
	if len(data) < idStart+16 {
		return nil, newError(""insufficient length."")
	}
	cmd.ID, _ = uuid.ParseBytes(data[idStart : idStart+16])
	alterIDStart := idStart + 16
	if len(data) < alterIDStart+2 {
		return nil, newError(""insufficient length."")
	}
	cmd.AlterIds = binary.BigEndian.Uint16(data[alterIDStart : alterIDStart+2])
	levelStart := alterIDStart + 2
	if len(data) < levelStart+1 {
		return nil, newError(""insufficient length."")
	}
	cmd.Level = uint32(data[levelStart])
	timeStart := levelStart + 1
	if len(data) < timeStart+1 {
		return nil, newError(""insufficient length."")
	}
	cmd.ValidMin = data[timeStart]
	return cmd, nil
}
",CWE-193,148.0,0
"package encoding_test
import (
	""github.com/stretchr/testify/assert""
	""testing""
	""github.com/google/go-cmp/cmp""
	""github.com/v2fly/v2ray-core/v4/common""
	""github.com/v2fly/v2ray-core/v4/common/buf""
	""github.com/v2fly/v2ray-core/v4/common/protocol""
	""github.com/v2fly/v2ray-core/v4/common/uuid""
	. ""github.com/v2fly/v2ray-core/v4/proxy/vmess/encoding""
)
func TestSwitchAccount(t *testing.T) {
	sa := &protocol.CommandSwitchAccount{
		Port:     1234,
		ID:       uuid.New(),
		AlterIds: 1024,
		Level:    128,
		ValidMin: 16,
	}
	buffer := buf.New()
	common.Must(MarshalCommand(sa, buffer))
	cmd, err := UnmarshalCommand(1, buffer.BytesFrom(2))
	common.Must(err)
	sa2, ok := cmd.(*protocol.CommandSwitchAccount)
	if !ok {
		t.Fatal(""failed to convert command to CommandSwitchAccount"")
	}
	if r := cmp.Diff(sa2, sa); r != """" {
		t.Error(r)
	}
}
func TestSwitchAccountBugOffByOne(t *testing.T) {
	sa := &protocol.CommandSwitchAccount{
		Port:     1234,
		ID:       uuid.New(),
		AlterIds: 1024,
		Level:    128,
		ValidMin: 16,
	}
	buffer := buf.New()
	csaf := CommandSwitchAccountFactory{}
	common.Must(csaf.Marshal(sa, buffer))
	Payload := buffer.Bytes()
	cmd, err := csaf.Unmarshal(Payload[:len(Payload)-1])
	assert.Error(t, err)
	assert.Nil(t, cmd)
}
",CWE-193,59.0,0
"package operator
// Supported versions of the Grafana Agent.
var (
	AgentCompatibilityMatrix = []string{
		""v0.14.0"",
		""v0.15.0"",
		// ""v0.16.0"", // Pulled due to critical bug fixed in v0.16.1.
		""v0.16.1"",
		""v0.17.0"",
		""v0.18.0"",
		""v0.18.1"",
		""v0.18.2"",
		""v0.18.3"",
		""v0.18.4"",
		""v0.19.0"",
		""v0.20.0"",
		""v0.20.1"",
		""v0.21.0"",
		""v0.21.1"",
		""v0.21.2"",
		// NOTE(rfratto): when performing an upgrade, add the newest version above instead of changing the existing reference.
	}
	DefaultAgentVersion   = AgentCompatibilityMatrix[len(AgentCompatibilityMatrix)-1]
	DefaultAgentBaseImage = ""grafana/agent""
	DefaultAgentImage     = DefaultAgentBaseImage + "":"" + DefaultAgentVersion
)
",CWE-312,30.0,0
"{
	""name"": ""DynamicPageList3"",
	""version"": ""3.3.6"",
	""author"": [
		""Alexia E. Smith"",
		""[https://meta.miraheze.org/wiki/User:Universal_Omega Universal Omega]"",
		""[https://de.wikipedia.org/wiki/Benutzer:Algorithmix Gero Scholz]""
	],
	""url"": ""https://www.mediawiki.org/wiki/Extension:DynamicPageList3"",
	""descriptionmsg"": ""dpl-desc"",
	""license-name"": ""GPL-3.0-or-later"",
	""type"": ""parserhook"",
	""requires"": {
		""MediaWiki"": "">= 1.36.0""
	},
	""GroupPermissions"": {
		""sysop"": {
			""dpl_param_update_rules"": true,
			""dpl_param_delete_rules"": true
		}
	},
	""AvailableRights"": [
		""dpl_param_update_rules"",
		""dpl_param_delete_rules""
	],
	""MessagesDirs"": {
		""DynamicPageList"": [
			""i18n""
		]
	},
	""ExtensionMessagesFiles"": {
		""DynamicPageListMagic"": ""includes/DynamicPageListMagic.php""
	},
	""AutoloadClasses"": {
		""DPL\\Article"": ""includes/Article.php"",
		""DPL\\Config"": ""includes/Config.php"",
		""DPL\\Heading\\DefinitionHeading"": ""includes/heading/DefinitionHeading.php"",
		""DPL\\Heading\\Heading"": ""includes/heading/Heading.php"",
		""DPL\\Heading\\OrderedHeading"": ""includes/heading/OrderedHeading.php"",
		""DPL\\Heading\\TieredHeading"": ""includes/heading/TieredHeading.php"",
		""DPL\\Heading\\UnorderedHeading"": ""includes/heading/UnorderedHeading.php"",
		""DPL\\Lister\\CategoryList"": ""includes/lister/CategoryList.php"",
		""DPL\\Lister\\DefinitionList"": ""includes/lister/DefinitionList.php"",
		""DPL\\Lister\\GalleryList"": ""includes/lister/GalleryList.php"",
		""DPL\\Lister\\InlineList"": ""includes/lister/InlineList.php"",
		""DPL\\Lister\\Lister"": ""includes/lister/Lister.php"",
		""DPL\\Lister\\OrderedList"": ""includes/lister/OrderedList.php"",
		""DPL\\Lister\\SubPageList"": ""includes/lister/SubPageList.php"",
		""DPL\\Lister\\UnorderedList"": ""includes/lister/UnorderedList.php"",
		""DPL\\Lister\\UserFormatList"": ""includes/lister/UserFormatList.php"",
		""DPL\\Logger"": ""includes/Logger.php"",
		""DPL\\LST"": ""includes/LST.php"",
		""DPL\\Maintenance\\CreateTemplate"": ""maintenance/createTemplate.php"",
		""DPL\\Parameters"": ""includes/Parameters.php"",
		""DPL\\ParametersData"": ""includes/ParametersData.php"",
		""DPL\\Parse"": ""includes/Parse.php"",
		""DPL\\Query"": ""includes/Query.php"",
		""DPL\\UpdateArticle"": ""includes/UpdateArticle.php"",
		""DPL\\Variables"": ""includes/Variables.php"",
		""DPL\\RevisionJoinBuilder"": ""includes/RevisionJoinBuilder.php"",
		""DPL\\UserQueryBuilder"": ""includes/UserQueryBuilder.php"",
		""DPL\\DynamicPageListHooks"": ""includes/DynamicPageListHooks.php"",
		""DPL\\DPLIntegrationTestCase"": ""tests/phpunit/DPLIntegrationTestCase.php""
	},
	""Hooks"": {
		""ParserFirstCallInit"": [
			""DPL\\DynamicPageListHooks::onParserFirstCallInit""
		],
		""LoadExtensionSchemaUpdates"": [
			""DPL\\DynamicPageListHooks::onLoadExtensionSchemaUpdates""
		]
	},
	""config"": {
		""DplSettings"": {
			""allowedNamespaces"": null,
			""allowUnlimitedCategories"": false,
			""allowUnlimitedResults"": false,
			""behavingLikeIntersection"": false,
			""categoryStyleListCutoff"": 6,
			""fixedCategories"": [],
			""functionalRichness"": 3,
			""maxCategoryCount"": 4,
			""minCategoryCount"": 0,
			""maxResultCount"": 500,
			""recursiveTagParse"": false,
			""runFromProtectedPagesOnly"": false,
			""handleSectionTag"": false,
			""alwaysCacheResults"": false
		}
	},
	""TrackingCategories"": [
		""dpl-tag-tracking-category"",
		""dpl-intersection-tracking-category"",
		""dpl-parserfunc-tracking-category"",
		""dplnum-parserfunc-tracking-category"",
		""dplvar-parserfunc-tracking-category"",
		""dplreplace-parserfunc-tracking-category"",
		""dplchapter-parserfunc-tracking-category"",
		""dplmatrix-parserfunc-tracking-category""
	],
	""manifest_version"": 1
}
",CWE-400,103.0,0
"package authz
import (
	""time""
	proto ""github.com/gogo/protobuf/proto""
	cdctypes ""github.com/cosmos/cosmos-sdk/codec/types""
	sdkerrors ""github.com/cosmos/cosmos-sdk/types/errors""
)
// NewGrant returns new Grant
func NewGrant( /*blockTime time.Time, */ a Authorization, expiration time.Time) (Grant, error) {
	// TODO: add this for 0.45
	// if !expiration.After(blockTime) {
	// 	return Grant{}, sdkerrors.ErrInvalidRequest.Wrapf(""expiration must be after the current block time (%v), got %v"", blockTime.Format(time.RFC3339), expiration.Format(time.RFC3339))
	// }
	g := Grant{
		Expiration: expiration,
	}
	msg, ok := a.(proto.Message)
	if !ok {
		return Grant{}, sdkerrors.Wrapf(sdkerrors.ErrPackAny, ""cannot proto marshal %T"", a)
	}
	any, err := cdctypes.NewAnyWithValue(msg)
	if err != nil {
		return Grant{}, err
	}
	g.Authorization = any
	return g, nil
}
var (
	_ cdctypes.UnpackInterfacesMessage = &Grant{}
)
// UnpackInterfaces implements UnpackInterfacesMessage.UnpackInterfaces
func (g Grant) UnpackInterfaces(unpacker cdctypes.AnyUnpacker) error {
	var authorization Authorization
	return unpacker.UnpackAny(g.Authorization, &authorization)
}
// GetAuthorization returns the cached value from the Grant.Authorization if present.
func (g Grant) GetAuthorization() Authorization {
	if g.Authorization == nil {
		return nil
	}
	a, ok := g.Authorization.GetCachedValue().(Authorization)
	if !ok {
		return nil
	}
	return a
}
func (g Grant) ValidateBasic() error {
	av := g.Authorization.GetCachedValue()
	a, ok := av.(Authorization)
	if !ok {
		return sdkerrors.Wrapf(sdkerrors.ErrInvalidType, ""expected %T, got %T"", (Authorization)(nil), av)
	}
	return a.ValidateBasic()
}
",CWE-754,65.0,0
"package authz
import (
	""testing""
	""time""
	// banktypes ""github.com/cosmos/cosmos-sdk/x/bank/types""
	""github.com/stretchr/testify/require""
)
func expecError(r *require.Assertions, expected string, received error) {
	if expected == """" {
		r.NoError(received)
	} else {
		r.Error(received)
		r.Contains(received.Error(), expected)
	}
}
func TestNewGrant(t *testing.T) {
	// ba := banktypes.NewSendAuthorization(sdk.NewCoins(sdk.NewInt64Coin(""foo"", 123)))
	a := NewGenericAuthorization(""some-type"")
	var tcs = []struct {
		title     string
		a         Authorization
		blockTime time.Time
		expire    time.Time
		err       string
	}{
		// {""wrong expire time (1)"", a, time.Unix(10, 0), time.Unix(8, 0), ""expiration must be after""},
		// {""wrong expire time (2)"", a, time.Unix(10, 0), time.Unix(10, 0), ""expiration must be after""},
		{""good expire time (1)"", a, time.Unix(10, 0), time.Unix(10, 1), """"},
		{""good expire time (2)"", a, time.Unix(10, 0), time.Unix(11, 0), """"},
	}
	for _, tc := range tcs {
		t.Run(tc.title, func(t *testing.T) {
			// _, err := NewGrant(tc.blockTime, tc.a, tc.expire)
			_, err := NewGrant(tc.a, tc.expire)
			expecError(require.New(t), tc.err, err)
		})
	}
}
",CWE-754,45.0,0
"package keeper
import (
	""context""
	sdk ""github.com/cosmos/cosmos-sdk/types""
	sdkerrors ""github.com/cosmos/cosmos-sdk/types/errors""
	""github.com/cosmos/cosmos-sdk/x/authz""
)
var _ authz.MsgServer = Keeper{}
// GrantAuthorization implements the MsgServer.Grant method to create a new grant.
func (k Keeper) Grant(goCtx context.Context, msg *authz.MsgGrant) (*authz.MsgGrantResponse, error) {
	ctx := sdk.UnwrapSDKContext(goCtx)
	grantee, err := sdk.AccAddressFromBech32(msg.Grantee)
	if err != nil {
		return nil, err
	}
	granter, err := sdk.AccAddressFromBech32(msg.Granter)
	if err != nil {
		return nil, err
	}
	authorization := msg.GetAuthorization()
	if authorization == nil {
		return nil, sdkerrors.ErrUnpackAny.Wrap(""Authorization is not present in the msg"")
	}
	t := authorization.MsgTypeURL()
	if k.router.HandlerByTypeURL(t) == nil {
		return nil, sdkerrors.Wrapf(sdkerrors.ErrInvalidType, ""%s doesn't exist."", t)
	}
	err = k.SaveGrant(ctx, grantee, granter, authorization, msg.Grant.Expiration)
	if err != nil {
		return nil, err
	}
	return &authz.MsgGrantResponse{}, nil
}
// RevokeAuthorization implements the MsgServer.Revoke method.
func (k Keeper) Revoke(goCtx context.Context, msg *authz.MsgRevoke) (*authz.MsgRevokeResponse, error) {
	ctx := sdk.UnwrapSDKContext(goCtx)
	grantee, err := sdk.AccAddressFromBech32(msg.Grantee)
	if err != nil {
		return nil, err
	}
	granter, err := sdk.AccAddressFromBech32(msg.Granter)
	if err != nil {
		return nil, err
	}
	err = k.DeleteGrant(ctx, grantee, granter, msg.MsgTypeUrl)
	if err != nil {
		return nil, err
	}
	return &authz.MsgRevokeResponse{}, nil
}
// Exec implements the MsgServer.Exec method.
func (k Keeper) Exec(goCtx context.Context, msg *authz.MsgExec) (*authz.MsgExecResponse, error) {
	ctx := sdk.UnwrapSDKContext(goCtx)
	grantee, err := sdk.AccAddressFromBech32(msg.Grantee)
	if err != nil {
		return nil, err
	}
	msgs, err := msg.GetMessages()
	if err != nil {
		return nil, err
	}
	results, err := k.DispatchActions(ctx, grantee, msgs)
	if err != nil {
		return nil, err
	}
	return &authz.MsgExecResponse{Results: results}, nil
}
",CWE-754,79.0,0
"package authz_test
import (
	""testing""
	""time""
	""github.com/stretchr/testify/require""
	cdctypes ""github.com/cosmos/cosmos-sdk/codec/types""
	sdk ""github.com/cosmos/cosmos-sdk/types""
	""github.com/cosmos/cosmos-sdk/x/authz""
	banktypes ""github.com/cosmos/cosmos-sdk/x/bank/types""
)
var (
	coinsPos = sdk.NewCoins(sdk.NewInt64Coin(""steak"", 100))
	granter  = sdk.AccAddress(""_______granter______"")
	grantee  = sdk.AccAddress(""_______grantee______"")
)
func TestMsgExecAuthorized(t *testing.T) {
	tests := []struct {
		title      string
		grantee    sdk.AccAddress
		msgs       []sdk.Msg
		expectPass bool
	}{
		{""nil grantee address"", nil, []sdk.Msg{}, false},
		{""zero-messages test: should fail"", grantee, []sdk.Msg{}, false},
		{""valid test: msg type"", grantee, []sdk.Msg{
			&banktypes.MsgSend{
				Amount:      sdk.NewCoins(sdk.NewInt64Coin(""steak"", 2)),
				FromAddress: granter.String(),
				ToAddress:   grantee.String(),
			},
		}, true},
	}
	for i, tc := range tests {
		msg := authz.NewMsgExec(tc.grantee, tc.msgs)
		if tc.expectPass {
			require.NoError(t, msg.ValidateBasic(), ""test: %v"", i)
		} else {
			require.Error(t, msg.ValidateBasic(), ""test: %v"", i)
		}
	}
}
func TestMsgRevokeAuthorization(t *testing.T) {
	tests := []struct {
		title            string
		granter, grantee sdk.AccAddress
		msgType          string
		expectPass       bool
	}{
		{""nil Granter address"", nil, grantee, ""hello"", false},
		{""nil Grantee address"", granter, nil, ""hello"", false},
		{""nil Granter and Grantee address"", nil, nil, ""hello"", false},
		{""valid test case"", granter, grantee, ""hello"", true},
	}
	for i, tc := range tests {
		msg := authz.NewMsgRevoke(tc.granter, tc.grantee, tc.msgType)
		if tc.expectPass {
			require.NoError(t, msg.ValidateBasic(), ""test: %v"", i)
		} else {
			require.Error(t, msg.ValidateBasic(), ""test: %v"", i)
		}
	}
}
func TestMsgGrantAuthorization(t *testing.T) {
	tests := []struct {
		title            string
		granter, grantee sdk.AccAddress
		authorization    authz.Authorization
		expiration       time.Time
		expectErr        bool
		expectPass       bool
	}{
		{""nil granter address"", nil, grantee, &banktypes.SendAuthorization{SpendLimit: coinsPos}, time.Now(), false, false},
		{""nil grantee address"", granter, nil, &banktypes.SendAuthorization{SpendLimit: coinsPos}, time.Now(), false, false},
		{""nil granter and grantee address"", nil, nil, &banktypes.SendAuthorization{SpendLimit: coinsPos}, time.Now(), false, false},
		{""nil authorization"", granter, grantee, nil, time.Now(), true, false},
		{""valid test case"", granter, grantee, &banktypes.SendAuthorization{SpendLimit: coinsPos}, time.Now().AddDate(0, 1, 0), false, true},
		{""past time"", granter, grantee, &banktypes.SendAuthorization{SpendLimit: coinsPos}, time.Now().AddDate(0, 0, -1), false, true}, // TODO need 0.45
	}
	for i, tc := range tests {
		msg, err := authz.NewMsgGrant(
			tc.granter, tc.grantee, tc.authorization, tc.expiration,
		)
		if !tc.expectErr {
			require.NoError(t, err)
		} else {
			continue
		}
		if tc.expectPass {
			require.NoError(t, msg.ValidateBasic(), ""test: %v"", i)
		} else {
			require.Error(t, msg.ValidateBasic(), ""test: %v"", i)
		}
	}
}
func TestMsgGrantGetAuthorization(t *testing.T) {
	require := require.New(t)
	m := authz.MsgGrant{}
	require.Nil(m.GetAuthorization())
	g := authz.GenericAuthorization{Msg: ""some_type""}
	var err error
	m.Grant.Authorization, err = cdctypes.NewAnyWithValue(&g)
	require.NoError(err)
	require.Equal(m.GetAuthorization(), &g)
	g = authz.GenericAuthorization{Msg: ""some_type2""}
	m.SetAuthorization(&g)
	require.Equal(m.GetAuthorization(), &g)
}
",CWE-754,118.0,0
"package main
import (
	""crypto/tls""
	""errors""
	""fmt""
	""log""
	""net/http""
	""github.com/StevenWeathers/thunderdome-planning-poker/pkg/database""
	ldap ""github.com/go-ldap/ldap/v3""
	""github.com/spf13/viper""
)
func (s *server) createCookie(UserID string) *http.Cookie {
	encoded, err := s.cookie.Encode(s.config.SecureCookieName, UserID)
	var NewCookie *http.Cookie
	if err == nil {
		NewCookie = &http.Cookie{
			Name:     s.config.SecureCookieName,
			Value:    encoded,
			Path:     s.config.PathPrefix + ""/"",
			HttpOnly: true,
			Domain:   s.config.AppDomain,
			MaxAge:   86400 * 30, // 30 days
			Secure:   s.config.SecureCookieFlag,
			SameSite: http.SameSiteStrictMode,
		}
	}
	return NewCookie
}
func (s *server) authUserDatabase(UserEmail string, UserPassword string) (*database.User, error) {
	AuthedUser, err := s.database.AuthUser(UserEmail, UserPassword)
	if err != nil {
		log.Println(""Failed authenticating user"", UserEmail)
	} else if AuthedUser == nil {
		log.Println(""Unknown user"", UserEmail)
	}
	return AuthedUser, err
}
// Authenticate using LDAP and if user does not exist, automatically add user as a verified user
func (s *server) authAndCreateUserLdap(UserName string, UserPassword string) (*database.User, error) {
	var AuthedUser *database.User
	l, err := ldap.DialURL(viper.GetString(""auth.ldap.url""))
	if err != nil {
		log.Println(""Failed connecting to ldap server at"", viper.GetString(""auth.ldap.url""))
		return AuthedUser, err
	}
	defer l.Close()
	if viper.GetBool(""auth.ldap.use_tls"") {
		err = l.StartTLS(&tls.Config{InsecureSkipVerify: true})
		if err != nil {
			log.Println(""Failed securing ldap connection"", err)
			return AuthedUser, err
		}
	}
	if viper.GetString(""auth.ldap.bindname"") != """" {
		err = l.Bind(viper.GetString(""auth.ldap.bindname""), viper.GetString(""auth.ldap.bindpass""))
		if err != nil {
			log.Println(""Failed binding for authentication:"", err)
			return AuthedUser, err
		}
	}
	searchRequest := ldap.NewSearchRequest(viper.GetString(""auth.ldap.basedn""),
		ldap.ScopeWholeSubtree, ldap.NeverDerefAliases, 0, 0, false,
		fmt.Sprintf(viper.GetString(""auth.ldap.filter""), ldap.EscapeFilter(UserName)),
		[]string{""dn"", viper.GetString(""auth.ldap.mail_attr""), viper.GetString(""auth.ldap.cn_attr"")},
		nil,
	)
	sr, err := l.Search(searchRequest)
	if err != nil {
		log.Println(""Failed performing ldap search query for"", UserName, "":"", err)
		return AuthedUser, err
	}
	if len(sr.Entries) != 1 {
		log.Println(""User"", UserName, ""does not exist or too many entries returned"")
		return AuthedUser, errors.New(""user not found"")
	}
	userdn := sr.Entries[0].DN
	useremail := sr.Entries[0].GetAttributeValue(viper.GetString(""auth.ldap.mail_attr""))
	usercn := sr.Entries[0].GetAttributeValue(viper.GetString(""auth.ldap.cn_attr""))
	err = l.Bind(userdn, UserPassword)
	if err != nil {
		log.Println(""Failed authenticating user "", UserName)
		return AuthedUser, err
	}
	AuthedUser, err = s.database.GetUserByEmail(useremail)
	if AuthedUser == nil {
		log.Println(""User"", useremail, ""does not exist in database, auto-recruit"")
		newUser, verifyID, err := s.database.CreateUserRegistered(usercn, useremail, """", """")
		if err != nil {
			log.Println(""Failed auto-creating new user"", err)
			return AuthedUser, err
		}
		err = s.database.VerifyUserAccount(verifyID)
		if err != nil {
			log.Println(""Failed verifying new user"", err)
			return AuthedUser, err
		}
		AuthedUser = newUser
	}
	return AuthedUser, nil
}
",CWE-74,115.0,0
"package main
import (
	""crypto/tls""
	""errors""
	""fmt""
	""log""
	""net/http""
	""github.com/StevenWeathers/thunderdome-planning-poker/pkg/database""
	ldap ""github.com/go-ldap/ldap/v3""
	""github.com/spf13/viper""
)
func (s *server) createCookie(UserID string) *http.Cookie {
	encoded, err := s.cookie.Encode(s.config.SecureCookieName, UserID)
	var NewCookie *http.Cookie
	if err == nil {
		NewCookie = &http.Cookie{
			Name:     s.config.SecureCookieName,
			Value:    encoded,
			Path:     s.config.PathPrefix + ""/"",
			HttpOnly: true,
			Domain:   s.config.AppDomain,
			MaxAge:   86400 * 30, // 30 days
			Secure:   s.config.SecureCookieFlag,
			SameSite: http.SameSiteStrictMode,
		}
	}
	return NewCookie
}
func (s *server) authUserDatabase(UserEmail string, UserPassword string) (*database.User, error) {
	AuthedUser, err := s.database.AuthUser(UserEmail, UserPassword)
	if err != nil {
		log.Println(""Failed authenticating user"", UserEmail)
	} else if AuthedUser == nil {
		log.Println(""Unknown user"", UserEmail)
	}
	return AuthedUser, err
}
// Authenticate using LDAP and if user does not exist, automatically add user as a verified user
func (s *server) authAndCreateUserLdap(UserName string, UserPassword string) (*database.User, error) {
	var AuthedUser *database.User
	l, err := ldap.DialURL(viper.GetString(""auth.ldap.url""))
	if err != nil {
		log.Println(""Failed connecting to ldap server at"", viper.GetString(""auth.ldap.url""))
		return AuthedUser, err
	}
	defer l.Close()
	if viper.GetBool(""auth.ldap.use_tls"") {
		err = l.StartTLS(&tls.Config{InsecureSkipVerify: true})
		if err != nil {
			log.Println(""Failed securing ldap connection"", err)
			return AuthedUser, err
		}
	}
	if viper.GetString(""auth.ldap.bindname"") != """" {
		err = l.Bind(viper.GetString(""auth.ldap.bindname""), viper.GetString(""auth.ldap.bindpass""))
		if err != nil {
			log.Println(""Failed binding for authentication:"", err)
			return AuthedUser, err
		}
	}
	searchRequest := ldap.NewSearchRequest(viper.GetString(""auth.ldap.basedn""),
		ldap.ScopeWholeSubtree, ldap.NeverDerefAliases, 0, 0, false,
		fmt.Sprintf(viper.GetString(""auth.ldap.filter""), ldap.EscapeFilter(UserName)),
		[]string{""dn"", viper.GetString(""auth.ldap.mail_attr""), viper.GetString(""auth.ldap.cn_attr"")},
		nil,
	)
	sr, err := l.Search(searchRequest)
	if err != nil {
		log.Println(""Failed performing ldap search query for"", UserName, "":"", err)
		return AuthedUser, err
	}
	if len(sr.Entries) != 1 {
		log.Println(""User"", UserName, ""does not exist or too many entries returned"")
		return AuthedUser, errors.New(""user not found"")
	}
	userdn := sr.Entries[0].DN
	useremail := sr.Entries[0].GetAttributeValue(viper.GetString(""auth.ldap.mail_attr""))
	usercn := sr.Entries[0].GetAttributeValue(viper.GetString(""auth.ldap.cn_attr""))
	err = l.Bind(userdn, UserPassword)
	if err != nil {
		log.Println(""Failed authenticating user "", UserName)
		return AuthedUser, err
	}
	AuthedUser, err = s.database.GetUserByEmail(useremail)
	if AuthedUser == nil {
		log.Println(""User"", useremail, ""does not exist in database, auto-recruit"")
		newUser, verifyID, err := s.database.CreateUserRegistered(usercn, useremail, """", """")
		if err != nil {
			log.Println(""Failed auto-creating new user"", err)
			return AuthedUser, err
		}
		err = s.database.VerifyUserAccount(verifyID)
		if err != nil {
			log.Println(""Failed verifying new user"", err)
			return AuthedUser, err
		}
		AuthedUser = newUser
	}
	return AuthedUser, nil
}
",CWE-116,115.0,0
"package etm
import (
	""bytes""
	""crypto/cipher""
	""crypto/rand""
	""encoding/hex""
	""fmt""
	""io""
	""regexp""
	""testing""
)
var _ cipher.AEAD = &etmAEAD{}
var whitespace = regexp.MustCompile(`[\s]+`)
func decode(s string) []byte {
	b, err := hex.DecodeString(whitespace.ReplaceAllString(s, """"))
	if err != nil {
		panic(err)
	}
	return b
}
func TestOverhead(t *testing.T) {
	aead, err := NewAES256SHA512(make([]byte, 64))
	if err != nil {
		t.Fatal(err)
	}
	expected := 72
	actual := aead.Overhead()
	if actual != expected {
		t.Errorf(""Expected %v but was %v"", expected, actual)
	}
}
func TestNonceSize(t *testing.T) {
	aead, err := NewAES256SHA512(make([]byte, 64))
	if err != nil {
		t.Fatal(err)
	}
	expected := 16
	actual := aead.NonceSize()
	if actual != expected {
		t.Errorf(""Expected %v but was %v"", expected, actual)
	}
}
func TestBadKeySizes(t *testing.T) {
	aead, err := NewAES256SHA512(nil)
	if err == nil {
		t.Errorf(""No error for 256/512, got %v instead"", aead)
	}
}
func TestBadMessage(t *testing.T) {
	aead, err := NewAES256SHA512(make([]byte, 64))
	if err != nil {
		t.Fatal(err)
	}
	input := make([]byte, 100)
	output := aead.Seal(nil, make([]byte, aead.NonceSize()), input, nil)
	output[91] ^= 3
	b, err := aead.Open(nil, make([]byte, aead.NonceSize()), output, nil)
	if err == nil {
		t.Errorf(""Expected error but got %v"", b)
	}
}
func TestAEAD_AES_256_CBC_HMAC_SHA_512(t *testing.T) {
	aead, err := NewAES256SHA512(decode(`
20 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f
30 31 32 33 34 35 36 37 38 39 3a 3b 3c 3d 3e 3f
00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f
10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f
`))
	if err != nil {
		t.Fatal(err)
	}
	p := decode(`
41 20 63 69 70 68 65 72 20 73 79 73 74 65 6d 20
6d 75 73 74 20 6e 6f 74 20 62 65 20 72 65 71 75
69 72 65 64 20 74 6f 20 62 65 20 73 65 63 72 65
74 2c 20 61 6e 64 20 69 74 20 6d 75 73 74 20 62
65 20 61 62 6c 65 20 74 6f 20 66 61 6c 6c 20 69
6e 74 6f 20 74 68 65 20 68 61 6e 64 73 20 6f 66
20 74 68 65 20 65 6e 65 6d 79 20 77 69 74 68 6f
75 74 20 69 6e 63 6f 6e 76 65 6e 69 65 6e 63 65
`)
	iv := decode(`
1a f3 8c 2d c2 b9 6f fd d8 66 94 09 23 41 bc 04
`)
	a := decode(`
54 68 65 20 73 65 63 6f 6e 64 20 70 72 69 6e 63
69 70 6c 65 20 6f 66 20 41 75 67 75 73 74 65 20
4b 65 72 63 6b 68 6f 66 66 73
`)
	expected := decode(`
1a f3 8c 2d c2 b9 6f fd d8 66 94 09 23 41 bc 04
4a ff aa ad b7 8c 31 c5 da 4b 1b 59 0d 10 ff bd
3d d8 d5 d3 02 42 35 26 91 2d a0 37 ec bc c7 bd
82 2c 30 1d d6 7c 37 3b cc b5 84 ad 3e 92 79 c2
e6 d1 2a 13 74 b7 7f 07 75 53 df 82 94 10 44 6b
36 eb d9 70 66 29 6a e6 42 7e a7 5c 2e 08 46 a1
1a 09 cc f5 37 0d c8 0b fe cb ad 28 c7 3f 09 b3
a3 b7 5e 66 2a 25 94 41 0a e4 96 b2 e2 e6 60 9e
31 e6 e0 2c c8 37 f0 53 d2 1f 37 ff 4f 51 95 0b
be 26 38 d0 9d d7 a4 93 09 30 80 6d 07 03 b1 f6
4d d3 b4 c0 88 a7 f4 5c 21 68 39 64 5b 20 12 bf
2e 62 69 a8 c5 6a 81 6d bc 1b 26 77 61 95 5b c5
`)
	c := aead.Seal(nil, iv, p, a)
	if !bytes.Equal(expected, c) {
		t.Errorf(""Expected \n%x\n but was \n%x"", expected, c)
	}
	p2, err := aead.Open(nil, iv, c, a)
	if err != nil {
		t.Fatal(err)
	}
	if !bytes.Equal(p, p2) {
		t.Error(""Bad round-trip"")
	}
}
func Example() {
	key := []byte(""yellow submarine was a love song hunt for red october was a film"")
	plaintext := []byte(""this is a secret value"")
	data := []byte(""this is a public value"")
	aead, err := NewAES256SHA512(key)
	if err != nil {
		fmt.Println(err)
		return
	}
	nonce := make([]byte, aead.NonceSize())
	_, _ = io.ReadFull(rand.Reader, nonce)
	ciphertext := aead.Seal(nil, nonce, plaintext, data)
	secret, err := aead.Open(nil, nil, ciphertext, data)
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Println(string(secret))
	// Output:
	// this is a secret value
}
",CWE-327,163.0,0
"//
// Copyright (c) 2021 One Track Consulting
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package transforms
import (
	""crypto/rand""
	""encoding/base64""
	""encoding/hex""
	""fmt""
	""github.com/edgexfoundry/app-functions-sdk-go/v2/internal/etm""
	""github.com/edgexfoundry/app-functions-sdk-go/v2/pkg/interfaces""
	""github.com/edgexfoundry/app-functions-sdk-go/v2/pkg/util""
	""github.com/edgexfoundry/go-mod-core-contracts/v2/common""
)
type AESProtection struct {
	SecretPath    string
	SecretName    string
	EncryptionKey string
}
// NewAESProtection creates, initializes and returns a new instance of AESProtection configured
// to retrieve the encryption key from the Secret Store
func NewAESProtection(secretPath string, secretName string) AESProtection {
	return AESProtection{
		SecretPath: secretPath,
		SecretName: secretName,
	}
}
// Encrypt encrypts a string, []byte, or json.Marshaller type using AES 256 encryption.
// It also signs the data using a SHA512 hash.
// It will return a Base64 encode []byte of the encrypted data.
func (protection AESProtection) Encrypt(ctx interfaces.AppFunctionContext, data interface{}) (bool, interface{}) {
	if data == nil {
		return false, fmt.Errorf(""function Encrypt in pipeline '%s': No Data Received"", ctx.PipelineId())
	}
	ctx.LoggingClient().Debugf(""Encrypting with AES256 in pipeline '%s'"", ctx.PipelineId())
	byteData, err := util.CoerceType(data)
	if err != nil {
		return false, err
	}
	key, err := protection.getKey(ctx)
	if err != nil {
		return false, err
	}
	if len(key) == 0 {
		return false, fmt.Errorf(""AES256 encryption key not set in pipeline '%s'"", ctx.PipelineId())
	}
	aead, err := etm.NewAES256SHA512(key)
	if err != nil {
		return false, err
	}
	nonce := make([]byte, aead.NonceSize())
	_, err = rand.Read(nonce)
	if err != nil {
		return false, err
	}
	dst := make([]byte, 0)
	encrypted := aead.Seal(dst, nonce, byteData, nil)
	clearKey(key)
	encodedData := []byte(base64.StdEncoding.EncodeToString(encrypted))
	// Set response ""content-type"" header to ""text/plain""
	ctx.SetResponseContentType(common.ContentTypeText)
	return true, encodedData
}
func (protection *AESProtection) getKey(ctx interfaces.AppFunctionContext) ([]byte, error) {
	// If using Secret Store for the encryption key
	if len(protection.SecretPath) != 0 && len(protection.SecretName) != 0 {
		// Note secrets are cached so this call doesn't result in unneeded calls to SecretStore Service and
		// the cache is invalidated when StoreSecrets is used.
		secretData, err := ctx.GetSecret(protection.SecretPath, protection.SecretName)
		if err != nil {
			return nil, fmt.Errorf(
				""unable to retieve encryption key at secret path=%s and name=%s in pipeline '%s'"",
				protection.SecretPath,
				protection.SecretName,
				ctx.PipelineId())
		}
		key, ok := secretData[protection.SecretName]
		if !ok {
			return nil, fmt.Errorf(
				""unable find encryption key in secret data for name=%s in pipeline '%s'"",
				protection.SecretName,
				ctx.PipelineId())
		}
		ctx.LoggingClient().Debugf(
			""Using encryption key from Secret Store at path=%s & name=%s in pipeline '%s'"",
			protection.SecretPath,
			protection.SecretName,
			ctx.PipelineId())
		return hex.DecodeString(key)
	}
	return nil, fmt.Errorf(""No key configured"")
}
func clearKey(key []byte) {
	for i := range key {
		key[i] = 0
	}
}
",CWE-327,136.0,0
"//
// Copyright (c) 2021 One Track Consulting
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package transforms
import (
	""encoding/base64""
	""encoding/hex""
	""fmt""
	""github.com/edgexfoundry/app-functions-sdk-go/v2/internal/etm""
	""github.com/edgexfoundry/app-functions-sdk-go/v2/pkg/interfaces/mocks""
	""github.com/edgexfoundry/app-functions-sdk-go/v2/pkg/util""
	""github.com/edgexfoundry/go-mod-core-contracts/v2/clients/logger""
	""github.com/edgexfoundry/go-mod-core-contracts/v2/common""
	""github.com/google/uuid""
	""github.com/stretchr/testify/assert""
	""github.com/stretchr/testify/require""
	""testing""
)
func TestNewAESProtection(t *testing.T) {
	secretPath := uuid.NewString()
	secretName := uuid.NewString()
	sut := NewAESProtection(secretPath, secretName)
	assert.Equal(t, secretPath, sut.SecretPath)
	assert.Equal(t, secretName, sut.SecretName)
}
func TestAESProtection_clearKey(t *testing.T) {
	key := []byte(uuid.NewString())
	clearKey(key)
	for _, v := range key {
		assert.Equal(t, byte(0), v)
	}
}
func TestAESProtection_getKey(t *testing.T) {
	secretPath := uuid.NewString()
	secretName := uuid.NewString()
	pipelineId := uuid.NewString()
	key := ""217A24432646294A404E635266556A586E3272357538782F413F442A472D4B6150645367566B59703373367639792442264529482B4D6251655468576D5A7134""
	type fields struct {
		SecretPath    string
		SecretName    string
		EncryptionKey string
	}
	tests := []struct {
		name     string
		fields   fields
		ctxSetup func(ctx *mocks.AppFunctionContext)
		wantErr  bool
	}{
		{name: ""no key"", wantErr: true},
		{
			name:   ""secret error"",
			fields: fields{SecretPath: secretPath, SecretName: secretName},
			ctxSetup: func(ctx *mocks.AppFunctionContext) {
				ctx.On(""GetSecret"", secretPath, secretName).Return(nil, fmt.Errorf(""secret error""))
			},
			wantErr: true,
		},
		{
			name:   ""secret not in map"",
			fields: fields{SecretPath: secretPath, SecretName: secretName},
			ctxSetup: func(ctx *mocks.AppFunctionContext) {
				ctx.On(""GetSecret"", secretPath, secretName).Return(map[string]string{}, nil)
			},
			wantErr: true,
		},
		{
			name:   ""happy"",
			fields: fields{SecretPath: secretPath, SecretName: secretName},
			ctxSetup: func(ctx *mocks.AppFunctionContext) {
				ctx.On(""SetResponsesContentType"", common.ContentTypeText).Return()
				ctx.On(""GetSecret"", secretPath, secretName).Return(map[string]string{secretName: key}, nil)
			},
			wantErr: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			aesData := &AESProtection{
				SecretPath:    tt.fields.SecretPath,
				SecretName:    tt.fields.SecretName,
				EncryptionKey: tt.fields.EncryptionKey,
			}
			ctx := &mocks.AppFunctionContext{}
			ctx.On(""PipelineId"").Return(pipelineId)
			ctx.On(""LoggingClient"").Return(logger.NewMockClient())
			if tt.ctxSetup != nil {
				tt.ctxSetup(ctx)
			}
			if k, err := aesData.getKey(ctx); (err != nil) != tt.wantErr {
				t.Errorf(""getKey() error = %v, wantErr %v"", err, tt.wantErr)
				if !tt.wantErr {
					assert.Equal(t, key, k)
				}
			}
		})
	}
}
func TestAESProtection_Encrypt(t *testing.T) {
	secretPath := uuid.NewString()
	secretName := uuid.NewString()
	key := ""217A24432646294A404E635266556A586E3272357538782F413F442A472D4B6150645367566B59703373367639792442264529482B4D6251655468576D5A7134""
	ctx := &mocks.AppFunctionContext{}
	ctx.On(""SetResponseContentType"", common.ContentTypeText).Return()
	ctx.On(""PipelineId"").Return(""pipeline-id"")
	ctx.On(""LoggingClient"").Return(logger.NewMockClient())
	ctx.On(""GetSecret"", secretPath, secretName).Return(map[string]string{secretName: key}, nil)
	enc := NewAESProtection(secretPath, secretName)
	continuePipeline, encrypted := enc.Encrypt(ctx, []byte(plainString))
	assert.True(t, continuePipeline)
	ebytes, err := util.CoerceType(encrypted)
	require.NoError(t, err)
	//output is base64 encoded
	dbytes, err := base64.StdEncoding.DecodeString(string(ebytes))
	if err != nil {
		panic(err)
	}
	decrypted := aes256Decrypt(t, dbytes, key)
	assert.Equal(t, plainString, string(decrypted))
}
func aes256Decrypt(t *testing.T, dbytes []byte, key string) []byte {
	k, err := hex.DecodeString(key)
	if err != nil {
		panic(err)
	}
	//internally we are leaning heavily on ETM logic
	//do not want to re-implement here
	etm, err := etm.NewAES256SHA512(k)
	require.NoError(t, err)
	dst := make([]byte, 0)
	res, err := etm.Open(dst, nil, dbytes, nil)
	require.NoError(t, err)
	return res
}
",CWE-327,178.0,0
"//
// Copyright (c) 2017 Cavium
// Copyright (c) 2021 Intel Corporation
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package transforms
import (
	""bytes""
	""crypto/aes""
	""crypto/cipher""
	""crypto/sha1"" //nolint: gosec
	""encoding/base64""
	""fmt""
	""github.com/edgexfoundry/app-functions-sdk-go/v2/pkg/interfaces""
	""github.com/edgexfoundry/app-functions-sdk-go/v2/pkg/util""
	""github.com/edgexfoundry/go-mod-core-contracts/v2/common""
)
// Deprecated: use AESProtection
type Encryption struct {
	SecretPath           string
	SecretName           string
	EncryptionKey        string
	InitializationVector string
}
// NewEncryption creates, initializes and returns a new instance of Encryption
// Deprecated: use NewAESProtection
func NewEncryption(encryptionKey string, initializationVector string) Encryption {
	return Encryption{
		EncryptionKey:        encryptionKey,
		InitializationVector: initializationVector,
	}
}
// NewEncryptionWithSecrets creates, initializes and returns a new instance of Encryption configured
// to retrieve the encryption key from the Secret Store
// Deprecated: use NewAESProtection
func NewEncryptionWithSecrets(secretPath string, secretName string, initializationVector string) Encryption {
	return Encryption{
		SecretPath:           secretPath,
		SecretName:           secretName,
		InitializationVector: initializationVector,
	}
}
// IV and KEY must be 16 bytes
const blockSize = 16
func pkcs5Padding(ciphertext []byte, blockSize int) []byte {
	padding := blockSize - len(ciphertext)%blockSize
	padText := bytes.Repeat([]byte{byte(padding)}, padding)
	return append(ciphertext, padText...)
}
// EncryptWithAES encrypts a string, []byte, or json.Marshaller type using AES encryption.
// It will return a Base64 encode []byte of the encrypted data.
// Deprecated: use AESProtection.Encrypt
func (aesData Encryption) EncryptWithAES(ctx interfaces.AppFunctionContext, data interface{}) (bool, interface{}) {
	if data == nil {
		return false, fmt.Errorf(""function EncryptWithAES in pipeline '%s': No Data Received"", ctx.PipelineId())
	}
	ctx.LoggingClient().Warnf(""EncryptWithAES has been deprecated - please use the new AESProtection.Encrypt in pipeline '%s'"", ctx.PipelineId())
	ctx.LoggingClient().Debugf(""Encrypting with AES in pipeline '%s'"", ctx.PipelineId())
	byteData, err := util.CoerceType(data)
	if err != nil {
		return false, err
	}
	iv := make([]byte, blockSize)
	copy(iv, aesData.InitializationVector)
	hash := sha1.New() //nolint: gosec
	// If using Secret Store for the encryption key
	if len(aesData.SecretPath) != 0 && len(aesData.SecretName) != 0 {
		// Note secrets are cached so this call doesn't result in unneeded calls to SecretStore Service and
		// the cache is invalidated when StoreSecrets is used.
		secretData, err := ctx.GetSecret(aesData.SecretPath, aesData.SecretName)
		if err != nil {
			return false, fmt.Errorf(
				""unable to retieve encryption key at secret path=%s and name=%s in pipeline '%s'"",
				aesData.SecretPath,
				aesData.SecretName,
				ctx.PipelineId())
		}
		key, ok := secretData[aesData.SecretName]
		if !ok {
			return false, fmt.Errorf(
				""unable find encryption key in secret data for name=%s in pipeline '%s'"",
				aesData.SecretName,
				ctx.PipelineId())
		}
		ctx.LoggingClient().Debugf(
			""Using encryption key from Secret Store at path=%s & name=%s in pipeline '%s'"",
			aesData.SecretPath,
			aesData.SecretName,
			ctx.PipelineId())
		aesData.EncryptionKey = key
	}
	if len(aesData.EncryptionKey) == 0 {
		return false, fmt.Errorf(""AES encryption key not set in pipeline '%s'"", ctx.PipelineId())
	}
	hash.Write([]byte((aesData.EncryptionKey)))
	key := hash.Sum(nil)
	key = key[:blockSize]
	block, err := aes.NewCipher(key)
	if err != nil {
		return false, fmt.Errorf(""failed to create new AES Cipher in pipeline '%s': %s"", ctx.PipelineId(), err)
	}
	ecb := cipher.NewCBCEncrypter(block, iv)
	content := pkcs5Padding(byteData, block.BlockSize())
	encrypted := make([]byte, len(content))
	ecb.CryptBlocks(encrypted, content)
	encodedData := []byte(base64.StdEncoding.EncodeToString(encrypted))
	// Set response ""content-type"" header to ""text/plain""
	ctx.SetResponseContentType(common.ContentTypeText)
	return true, encodedData
}
",CWE-327,148.0,0
"package web
import (
	""encoding/json""
	""net/http""
	""github.com/gorilla/websocket""
	""github.com/julienschmidt/httprouter""
)
// Socket register a new websocket server at the given path
func (s *Server) Socket(path string, handle SocketHandle, options HandleOptions) {
	s.registerSocketEndpoint(""GET"", path, handle, options)
}
func (s *Server) registerSocketEndpoint(method string, path string, handle SocketHandle, options HandleOptions) {
	s.log.Debug(""Register HTTP %s %s"", method, path)
	s.router.Handle(method, path, s.socketHandler(handle, options))
}
var upgrader = websocket.Upgrader{
	ReadBufferSize:  1024,
	WriteBufferSize: 1024,
}
func (s *Server) socketHandler(endpointHandle SocketHandle, options HandleOptions) httprouter.Handle {
	return func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
		var userData interface{}
		if options.AuthenticateMethod != nil {
			userData = options.AuthenticateMethod(r)
			if isUserdataNil(userData) {
				if options.UnauthorizedMethod == nil {
					s.log.Warn(""Rejected authenticated request"")
					w.Header().Set(""Content-Type"", ""application/json"")
					w.WriteHeader(http.StatusUnauthorized)
					json.NewEncoder(w).Encode(Error{401, ""Unauthorized""})
					return
				}
				options.UnauthorizedMethod(w, r)
				return
			}
		}
		conn, err := upgrader.Upgrade(w, r, nil)
		if err != nil {
			s.log.Error(""Error upgrading client for websocket connection: %s"", err.Error())
			return
		}
		endpointHandle(Request{
			Params:   ps,
			UserData: userData,
			log:      s.log,
		}, WSConn{
			c: conn,
		})
		s.log.Debug(""HTTP WS Request: ws://%s"", r.RequestURI)
	}
}
",CWE-476,61.0,0
"package goutils
import (
	""regexp""
	""strconv""
	""testing""
	""unicode/utf8""
)
func TestCryptoRandomNonAlphaNumeric(t *testing.T) {
	// If asked for a string 0 characters long, CryptoRandomNonAlphaNumeric should provide an empty string.
	if x, _ := CryptoRandomNonAlphaNumeric(0); utf8.RuneCountInString(x) != 0 {
		t.Errorf(""String should be 0 characters; string was %v characters"", utf8.RuneCountInString(x))
	}
	// Test CryptoRandomNonAlphaNumeric's ability to generate strings 1 through 100 characters in length.
	for i := 1; i < 101; i++ {
		if x, _ := CryptoRandomNonAlphaNumeric(i); utf8.RuneCountInString(x) != i {
			t.Errorf(""String should be %v characters; string was %v characters"", i, utf8.RuneCountInString(x))
		}
	}
}
func TestCryptoRandomAscii(t *testing.T) {
	// If asked for a string 0 characters long, CryptoRandomAscii should provide an empty string.
	if x, _ := CryptoRandomAscii(0); len(x) != 0 {
		t.Errorf(""String should be 0 characters; string was %v characters"", len(x))
	}
	// Test CryptoRandomAscii's ability to generate strings 1 through 100 characters in length.
	for i := 1; i < 101; i++ {
		if x, _ := CryptoRandomAscii(i); len(x) != i {
			t.Errorf(""String should be %v characters; string was %v characters"", i, len(x))
		}
	}
}
func TestCryptoRandomNumeric(t *testing.T) {
	// If asked for a string 0 characters long, CryptoRandomNumeric should provide an empty string.
	if x, _ := CryptoRandomNumeric(0); len(x) != 0 {
		t.Errorf(""String should be 0 characters; string was %v characters"", len(x))
	}
	// Test CryptoRandomNumeric's ability to generate strings 1 through 100 characters in length.
	for i := 1; i < 101; i++ {
		if x, _ := CryptoRandomNumeric(i); len(x) != i {
			t.Errorf(""String should be %v characters; string was %v characters"", i, len(x))
		}
	}
}
func TestCryptoRandomAlphabetic(t *testing.T) {
	// If asked for a string 0 characters long, CryptoRandomAlphabetic should provide an empty string.
	if x, _ := CryptoRandomAlphabetic(0); len(x) != 0 {
		t.Errorf(""String should be 0 characters; string was %v characters"", len(x))
	}
	// Test CryptoRandomAlphabetic's ability to generate strings 1 through 100 characters in length.
	for i := 1; i < 101; i++ {
		if x, _ := CryptoRandomAlphabetic(i); len(x) != i {
			t.Errorf(""String should be %v characters; string was %v characters"", i, len(x))
		}
	}
}
func TestCryptoRandomAlphaNumeric(t *testing.T) {
	// If asked for a string 0 characters long, CryptoRandomAlphaNumeric should provide an empty string.
	if x, _ := CryptoRandomAlphaNumeric(0); len(x) != 0 {
		t.Errorf(""String should be 0 characters; string was %v characters"", len(x))
	}
	// Test CryptoRandomAlphaNumeric's ability to generate strings 1 through 100 characters in length.
	for i := 1; i < 101; i++ {
		if x, _ := CryptoRandomAlphaNumeric(i); len(x) != i {
			t.Errorf(""String should be %v characters; string was %v characters"", i, len(x))
		}
	}
}
func TestCryptoRandAlphaNumeric_FuzzOnlyNumeric(t *testing.T) {
	// Testing for a reported regression in which some versions produced
	// a predictably small set of chars.
	iters := 1000
	charlen := 0
	for i := 0; i < 16; i++ {
		numOnly := 0
		charlen++
		for i := 0; i < iters; i++ {
			out, err := CryptoRandomAlphaNumeric(charlen)
			println(out)
			if err != nil {
				t.Fatal(""func failed to produce a random thinger"")
			}
			if _, err := strconv.Atoi(out); err == nil {
				numOnly++
			}
			m, err := regexp.MatchString(""^[0-9a-zA-Z]+$"", out)
			if err != nil {
				t.Fatal(err)
			}
			if !m {
				t.Fatal(""Character is not alphanum"")
			}
		}
		if numOnly == iters {
			t.Fatalf(""Got %d numeric-only random sequences"", numOnly)
		}
	}
}
",CWE-331,114.0,0
"package goutils
import (
	""fmt""
	""math/rand""
	""regexp""
	""strconv""
	""testing""
)
// ****************************** TESTS ********************************************
func TestRandomSeed(t *testing.T) {
	// count, start, end, letters, numbers := 5, 0, 0, true, true
	random := rand.New(rand.NewSource(10))
	out := ""3ip9v""
	// Test 1: Simulating RandomAlphaNumeric(count int)
	if x, _ := RandomSeed(5, 0, 0, true, true, nil, random); x != out {
		t.Errorf(""RandomSeed(%v, %v, %v, %v, %v, %v, %v) = %v, want %v"", 5, 0, 0, true, true, nil, random, x, out)
	}
	// Test 2: Simulating RandomAlphabetic(count int)
	out = ""MBrbj""
	if x, _ := RandomSeed(5, 0, 0, true, false, nil, random); x != out {
		t.Errorf(""RandomSeed(%v, %v, %v, %v, %v, %v, %v) = %v, want %v"", 5, 0, 0, true, false, nil, random, x, out)
	}
	// Test 3: Simulating RandomNumeric(count int)
	out = ""88935""
	if x, _ := RandomSeed(5, 0, 0, false, true, nil, random); x != out {
		t.Errorf(""RandomSeed(%v, %v, %v, %v, %v, %v, %v) = %v, want %v"", 5, 0, 0, false, true, nil, random, x, out)
	}
	// Test 4: Simulating RandomAscii(count int)
	out = ""H_I;E""
	if x, _ := RandomSeed(5, 32, 127, false, false, nil, random); x != out {
		t.Errorf(""RandomSeed(%v, %v, %v, %v, %v, %v, %v) = %v, want %v"", 5, 32, 127, false, false, nil, random, x, out)
	}
	// Test 5: Simulating RandomSeed(...) with custom chars
	chars := []rune{'1', '2', '3', 'a', 'b', 'c'}
	out = ""2b2ca""
	if x, _ := RandomSeed(5, 0, 0, false, false, chars, random); x != out {
		t.Errorf(""RandomSeed(%v, %v, %v, %v, %v, %v, %v) = %v, want %v"", 5, 0, 0, false, false, chars, random, x, out)
	}
}
// ****************************** EXAMPLES ********************************************
func ExampleRandomSeed() {
	var seed int64 = 10 // If you change this seed 
	random := rand.New(rand.NewSource(seed))
	chars := []rune{'1', '2', '3', 'a', 'b', 'c'}
	rand1, _ := RandomSeed(5, 0, 0, true, true, nil, random)      // RandomAlphaNumeric (Alphabets and numbers possible)
	rand2, _ := RandomSeed(5, 0, 0, true, false, nil, random)     // RandomAlphabetic (Only alphabets)
	rand3, _ := RandomSeed(5, 0, 0, false, true, nil, random)     // RandomNumeric (Only numbers)
	rand4, _ := RandomSeed(5, 32, 127, false, false, nil, random) // RandomAscii (Alphabets, numbers, and other ASCII chars)
	rand5, _ := RandomSeed(5, 0, 0, true, true, chars, random)    // RandomSeed with custom characters
	fmt.Println(rand1)
	fmt.Println(rand2)
	fmt.Println(rand3)
	fmt.Println(rand4)
	fmt.Println(rand5)
	// Output:
	// 3ip9v
	// MBrbj
	// 88935
	// H_I;E
	// 2b2ca
}
func TestRandAlphaNumeric_FuzzOnlyNumeric(t *testing.T) {
	// Testing for a reported regression in which some versions produced
	// a predictably small set of chars.
	iters := 1000
	charlen := 0
	for i := 0; i < 16; i++ {
		numOnly := 0
		charlen++
		for i := 0; i < iters; i++ {
			out, err := RandomAlphaNumeric(charlen)
			println(out)
			if err != nil {
				t.Fatal(""func failed to produce a random thinger"")
			}
			if _, err := strconv.Atoi(out); err == nil {
				numOnly++
			}
			m, err := regexp.MatchString(""^[0-9a-zA-Z]+$"", out)
			if err != nil {
				t.Fatal(err)
			}
			if !m {
				t.Fatal(""Character is not alphanum"")
			}
		}
		if numOnly == iters {
			t.Fatalf(""Got %d numeric-only random sequences"", numOnly)
		}
	}
}
",CWE-331,116.0,0
"package osin
import ""crypto/subtle""
// Client information
type Client interface {
	// Client id
	GetId() string
	// Client secret
	GetSecret() string
	// Base client uri
	GetRedirectUri() string
	// Data to be passed to storage. Not used by the library.
	GetUserData() interface{}
}
// ClientSecretMatcher is an optional interface clients can implement
// which allows them to be the one to determine if a secret matches.
// If a Client implements ClientSecretMatcher, the framework will never call GetSecret
type ClientSecretMatcher interface {
	// SecretMatches returns true if the given secret matches
	ClientSecretMatches(secret string) bool
}
// DefaultClient stores all data in struct variables
type DefaultClient struct {
	Id          string
	Secret      string
	RedirectUri string
	UserData    interface{}
}
func (d *DefaultClient) GetId() string {
	return d.Id
}
func (d *DefaultClient) GetSecret() string {
	return d.Secret
}
func (d *DefaultClient) GetRedirectUri() string {
	return d.RedirectUri
}
func (d *DefaultClient) GetUserData() interface{} {
	return d.UserData
}
// Implement the ClientSecretMatcher interface
func (d *DefaultClient) ClientSecretMatches(secret string) bool {
	return subtle.ConstantTimeCompare([]byte(d.Secret), []byte(secret)) == 1
}
func (d *DefaultClient) CopyFrom(client Client) {
	d.Id = client.GetId()
	d.Secret = client.GetSecret()
	d.RedirectUri = client.GetRedirectUri()
	d.UserData = client.GetUserData()
}
",CWE-203,63.0,0
"package osin
import (
	""crypto/subtle""
	""encoding/base64""
	""errors""
	""net/http""
	""net/url""
	""strings""
)
// Parse basic authentication header
type BasicAuth struct {
	Username string
	Password string
}
// Parse bearer authentication header
type BearerAuth struct {
	Code string
}
// CheckClientSecret determines whether the given secret matches a secret held by the client.
// Public clients return true for a secret of """"
func CheckClientSecret(client Client, secret string) bool {
	switch client := client.(type) {
	case ClientSecretMatcher:
		// Prefer the more secure method of giving the secret to the client for comparison
		return client.ClientSecretMatches(secret)
	default:
		// Fallback to the less secure method of extracting the plain text secret from the client for comparison
		return subtle.ConstantTimeCompare([]byte(client.GetSecret()), []byte(secret)) == 1
	}
}
// Return authorization header data
func CheckBasicAuth(r *http.Request) (*BasicAuth, error) {
	if r.Header.Get(""Authorization"") == """" {
		return nil, nil
	}
	s := strings.SplitN(r.Header.Get(""Authorization""), "" "", 2)
	if len(s) != 2 || s[0] != ""Basic"" {
		return nil, errors.New(""Invalid authorization header"")
	}
	b, err := base64.StdEncoding.DecodeString(s[1])
	if err != nil {
		return nil, err
	}
	pair := strings.SplitN(string(b), "":"", 2)
	if len(pair) != 2 {
		return nil, errors.New(""Invalid authorization message"")
	}
	// Decode the client_id and client_secret pairs as per
	// https://tools.ietf.org/html/rfc6749
	username, err := url.QueryUnescape(pair[0])
	if err != nil {
		return nil, err
	}
	password, err := url.QueryUnescape(pair[1])
	if err != nil {
		return nil, err
	}
	return &BasicAuth{Username: username, Password: password}, nil
}
// Return ""Bearer"" token from request. The header has precedence over query string.
func CheckBearerAuth(r *http.Request) *BearerAuth {
	authHeader := r.Header.Get(""Authorization"")
	authForm := r.FormValue(""code"")
	if authHeader == """" && authForm == """" {
		return nil
	}
	token := authForm
	if authHeader != """" {
		s := strings.SplitN(authHeader, "" "", 2)
		if (len(s) != 2 || strings.ToLower(s[0]) != ""bearer"") && token == """" {
			return nil
		}
		//Use authorization header token only if token type is bearer else query string access token would be returned
		if len(s) > 0 && strings.ToLower(s[0]) == ""bearer"" {
			token = s[1]
		}
	}
	return &BearerAuth{Code: token}
}
// getClientAuth checks client basic authentication in params if allowed,
// otherwise gets it from the header.
// Sets an error on the response if no auth is present or a server error occurs.
func (s Server) getClientAuth(w *Response, r *http.Request, allowQueryParams bool) *BasicAuth {
	if allowQueryParams {
		// Allow for auth without password
		if _, hasSecret := r.Form[""client_secret""]; hasSecret {
			auth := &BasicAuth{
				Username: r.FormValue(""client_id""),
				Password: r.FormValue(""client_secret""),
			}
			if auth.Username != """" {
				return auth
			}
		}
	}
	auth, err := CheckBasicAuth(r)
	if err != nil {
		s.setErrorAndLog(w, E_INVALID_REQUEST, err, ""get_client_auth=%s"", ""check auth error"")
		return nil
	}
	if auth == nil {
		s.setErrorAndLog(w, E_INVALID_REQUEST, errors.New(""Client authentication not sent""), ""get_client_auth=%s"", ""client authentication not sent"")
		return nil
	}
	return auth
}
",CWE-203,122.0,0
"module github.com/crypto-org-chain/cronos
go 1.17
require (
	github.com/armon/go-metrics v0.3.9
	github.com/cosmos/cosmos-sdk v0.44.3
	github.com/cosmos/ibc-go v1.2.2
	github.com/ethereum/go-ethereum v1.10.3
	github.com/gogo/protobuf v1.3.3
	github.com/golang/protobuf v1.5.2
	github.com/gorilla/mux v1.8.0
	github.com/grpc-ecosystem/grpc-gateway v1.16.0
	github.com/rakyll/statik v0.1.7
	github.com/spf13/cast v1.4.1
	github.com/spf13/cobra v1.2.1
	github.com/spf13/pflag v1.0.5
	github.com/stretchr/testify v1.7.0
	github.com/tendermint/tendermint v0.34.14
	github.com/tendermint/tm-db v0.6.4
	github.com/tharsis/ethermint v0.7.2
	google.golang.org/genproto v0.0.0-20210909211513-a8c4777a87af
	google.golang.org/grpc v1.41.0
	gopkg.in/yaml.v2 v2.4.0
)
require (
	filippo.io/edwards25519 v1.0.0-beta.2 // indirect
	github.com/99designs/keyring v1.1.6 // indirect
	github.com/ChainSafe/go-schnorrkel v0.0.0-20200405005733-88cbf1b4c40d // indirect
	github.com/DataDog/zstd v1.4.8 // indirect
	github.com/StackExchange/wmi v1.2.1 // indirect
	github.com/VictoriaMetrics/fastcache v1.5.7 // indirect
	github.com/Workiva/go-datastructures v1.0.52 // indirect
	github.com/allegro/bigcache v1.2.1 // indirect
	github.com/beorn7/perks v1.0.1 // indirect
	github.com/bgentry/speakeasy v0.1.0 // indirect
	github.com/btcsuite/btcd v0.22.0-beta // indirect
	github.com/btcsuite/btcutil v1.0.3-0.20201208143702-a53e38424cce // indirect
	github.com/cespare/xxhash v1.1.0 // indirect
	github.com/cespare/xxhash/v2 v2.1.1 // indirect
	github.com/coinbase/rosetta-sdk-go v0.6.10 // indirect
	github.com/confio/ics23/go v0.6.6 // indirect
	github.com/cosmos/go-bip39 v1.0.0 // indirect
	github.com/cosmos/iavl v0.17.1 // indirect
	github.com/cosmos/ledger-cosmos-go v0.11.1 // indirect
	github.com/cosmos/ledger-go v0.9.2 // indirect
	github.com/danieljoos/wincred v1.0.2 // indirect
	github.com/davecgh/go-spew v1.1.1 // indirect
	github.com/deckarep/golang-set v0.0.0-20180603214616-504e848d77ea // indirect
	github.com/desertbit/timer v0.0.0-20180107155436-c41aec40b27f // indirect
	github.com/dgraph-io/badger/v2 v2.2007.2 // indirect
	github.com/dgraph-io/ristretto v0.0.3 // indirect
	github.com/dgryski/go-farm v0.0.0-20200201041132-a6ae2369ad13 // indirect
	github.com/dustin/go-humanize v1.0.0 // indirect
	github.com/dvsekhvalnov/jose2go v0.0.0-20200901110807-248326c1351b // indirect
	github.com/edsrzf/mmap-go v1.0.0 // indirect
	github.com/enigmampc/btcutil v1.0.3-0.20200723161021-e2fb6adb2a25 // indirect
	github.com/felixge/httpsnoop v1.0.1 // indirect
	github.com/fsnotify/fsnotify v1.5.1 // indirect
	github.com/gballet/go-libpcsclite v0.0.0-20190607065134-2772fd86a8ff // indirect
	github.com/go-kit/kit v0.10.0 // indirect
	github.com/go-logfmt/logfmt v0.5.0 // indirect
	github.com/go-ole/go-ole v1.2.5 // indirect
	github.com/go-stack/stack v1.8.0 // indirect
	github.com/godbus/dbus v0.0.0-20190726142602-4481cbc300e2 // indirect
	github.com/gogo/gateway v1.1.0 // indirect
	github.com/golang/snappy v0.0.3 // indirect
	github.com/google/btree v1.0.1 // indirect
	github.com/google/orderedcode v0.0.1 // indirect
	github.com/google/uuid v1.3.0 // indirect
	github.com/gorilla/handlers v1.5.1 // indirect
	github.com/gorilla/websocket v1.4.2 // indirect
	github.com/grpc-ecosystem/go-grpc-middleware v1.3.0 // indirect
	github.com/gsterjov/go-libsecret v0.0.0-20161001094733-a6f4afe4910c // indirect
	github.com/gtank/merlin v0.1.1 // indirect
	github.com/gtank/ristretto255 v0.1.2 // indirect
	github.com/hashicorp/go-immutable-radix v1.0.0 // indirect
	github.com/hashicorp/go-uuid v1.0.2 // indirect
	github.com/hashicorp/golang-lru v0.5.5-0.20210104140557-80c98217689d // indirect
	github.com/hashicorp/hcl v1.0.0 // indirect
	github.com/hdevalence/ed25519consensus v0.0.0-20210204194344-59a8610d2b87 // indirect
	github.com/holiman/bloomfilter/v2 v2.0.3 // indirect
	github.com/holiman/uint256 v1.1.1 // indirect
	github.com/huin/goupnp v1.0.1-0.20210310174557-0ca763054c88 // indirect
	github.com/improbable-eng/grpc-web v0.14.1 // indirect
	github.com/inconshreveable/mousetrap v1.0.0 // indirect
	github.com/jackpal/go-nat-pmp v1.0.2-0.20160603034137-1fa385a6f458 // indirect
	github.com/jmhodges/levigo v1.0.0 // indirect
	github.com/keybase/go-keychain v0.0.0-20190712205309-48d3d31d256d // indirect
	github.com/klauspost/compress v1.11.9 // indirect
	github.com/lib/pq v1.10.2 // indirect
	github.com/libp2p/go-buffer-pool v0.0.2 // indirect
	github.com/magiconair/properties v1.8.5 // indirect
	github.com/mattn/go-isatty v0.0.14 // indirect
	github.com/mattn/go-runewidth v0.0.9 // indirect
	github.com/matttproud/golang_protobuf_extensions v1.0.1 // indirect
	github.com/mimoo/StrobeGo v0.0.0-20181016162300-f8f6d4d2b643 // indirect
	github.com/minio/highwayhash v1.0.1 // indirect
	github.com/mitchellh/mapstructure v1.4.2 // indirect
	github.com/mtibben/percent v0.2.1 // indirect
	github.com/olekukonko/tablewriter v0.0.5 // indirect
	github.com/palantir/stacktrace v0.0.0-20161112013806-78658fd2d177 // indirect
	github.com/pelletier/go-toml v1.9.4 // indirect
	github.com/petermattis/goid v0.0.0-20180202154549-b0b1615b78e5 // indirect
	github.com/pkg/errors v0.9.1 // indirect
	github.com/pmezard/go-difflib v1.0.0 // indirect
	github.com/prometheus/client_golang v1.11.0 // indirect
	github.com/prometheus/client_model v0.2.0 // indirect
	github.com/prometheus/common v0.29.0 // indirect
	github.com/prometheus/procfs v0.6.0 // indirect
	github.com/prometheus/tsdb v0.7.1 // indirect
	github.com/rcrowley/go-metrics v0.0.0-20201227073835-cf1acfcdf475 // indirect
	github.com/regen-network/cosmos-proto v0.3.1 // indirect
	github.com/rjeczalik/notify v0.9.1 // indirect
	github.com/rs/cors v1.8.0 // indirect
	github.com/rs/zerolog v1.25.0 // indirect
	github.com/sasha-s/go-deadlock v0.2.1-0.20190427202633-1595213edefa // indirect
	github.com/shirou/gopsutil v3.21.4-0.20210419000835-c7a38de76ee5+incompatible // indirect
	github.com/spf13/afero v1.6.0 // indirect
	github.com/spf13/jwalterweatherman v1.1.0 // indirect
	github.com/spf13/viper v1.9.0 // indirect
	github.com/status-im/keycard-go v0.0.0-20200402102358-957c09536969 // indirect
	github.com/subosito/gotenv v1.2.0 // indirect
	github.com/syndtr/goleveldb v1.0.1-0.20210305035536-64b5b1c73954 // indirect
	github.com/tecbot/gorocksdb v0.0.0-20191217155057-f0fad39f321c // indirect
	github.com/tendermint/btcd v0.1.1 // indirect
	github.com/tendermint/crypto v0.0.0-20191022145703-50d29ede1e15 // indirect
	github.com/tendermint/go-amino v0.16.0 // indirect
	github.com/tklauser/go-sysconf v0.3.7 // indirect
	github.com/tklauser/numcpus v0.2.3 // indirect
	github.com/tyler-smith/go-bip39 v1.1.0 // indirect
	github.com/zondax/hid v0.9.0 // indirect
	go.etcd.io/bbolt v1.3.6 // indirect
	golang.org/x/crypto v0.0.0-20210817164053-32db794688a5 // indirect
	golang.org/x/net v0.0.0-20210903162142-ad29c8ab022f // indirect
	golang.org/x/sync v0.0.0-20210220032951-036812b2e83c // indirect
	golang.org/x/sys v0.0.0-20210903071746-97244b99971b // indirect
	golang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1 // indirect
	golang.org/x/text v0.3.6 // indirect
	google.golang.org/protobuf v1.27.1 // indirect
	gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c // indirect
	gopkg.in/ini.v1 v1.63.2 // indirect
	gopkg.in/natefinch/npipe.v2 v2.0.0-20160621034901-c1b8fa8bdcce // indirect
	gopkg.in/olebedev/go-duktape.v3 v3.0.0-20200619000410-60c24ae608a6 // indirect
	gopkg.in/yaml.v3 v3.0.0-20210107192922-496545a6307b // indirect
	nhooyr.io/websocket v1.8.6 // indirect
)
replace google.golang.org/grpc => google.golang.org/grpc v1.33.2
replace github.com/gogo/protobuf => github.com/regen-network/protobuf v1.3.3-alpha.regen.1
// TODO: fix keyring upstream
replace github.com/99designs/keyring => github.com/crypto-org-chain/keyring v1.1.6-fixes
// TODO: remove when middleware will be implemented
replace github.com/cosmos/ibc-go => github.com/crypto-org-chain/ibc-go v1.2.1-hooks
replace github.com/cosmos/iavl => github.com/cosmos/iavl v0.17.1
replace github.com/ethereum/go-ethereum => github.com/crypto-org-chain/go-ethereum v1.10.3-patched
// TODO: remove when ibc-go and ethermint upgrades cosmos-sdk
replace github.com/cosmos/cosmos-sdk => github.com/cosmos/cosmos-sdk v0.44.2
replace github.com/tharsis/ethermint => github.com/crypto-org-chain/ethermint v0.7.2-cronos-6
",CWE-670,168.0,0
"/*
 * SPDX-License-Identifier: Apache-2.0
 *
 * The OpenSearch Contributors require contributions made to
 * this file be licensed under the Apache-2.0 license or a
 * compatible open source license.
 *
 * Modifications Copyright OpenSearch Contributors. See
 * GitHub history for details.
 */
/*
 * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the ""license"" file accompanying this file. This file is distributed
 * on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package commands
import (
	""fmt""
	""opensearch-cli/entity""
	""os""
	""path/filepath""
	""runtime""
	""github.com/spf13/cobra""
)
const (
	configFileType        = ""yaml""
	defaultConfigFileName = ""config""
	flagConfig            = ""config""
	flagProfileName       = ""profile""
	FolderPermission      = 0700 // only owner can read, write and execute
	FilePermission        = 0600 // only owner can read and write
	ConfigEnvVarName      = ""OPENSEARCH_CLI_CONFIG""
	RootCommandName       = ""opensearch-cli""
	version               = ""1.0.0""
)
func buildVersionString() string {
	return fmt.Sprintf(""%s %s/%s"", version, runtime.GOOS, runtime.GOARCH)
}
var rootCommand = &cobra.Command{
	Use:     RootCommandName,
	Short:   ""opensearch-cli is a unified command line interface for managing OpenSearch clusters"",
	Version: buildVersionString(),
}
func GetRoot() *cobra.Command {
	return rootCommand
}
// Execute executes the root command.
func Execute() error {
	err := rootCommand.Execute()
	return err
}
func GetDefaultConfigFilePath() string {
	return filepath.Join(
		getDefaultConfigFolderRootPath(),
		fmt.Sprintf("".%s"", RootCommandName),
		fmt.Sprintf(""%s.%s"", defaultConfigFileName, configFileType),
	)
}
func getDefaultConfigFolderRootPath() string {
	if homeDir, err := os.UserHomeDir(); err == nil {
		return homeDir
	}
	if cwd, err := os.Getwd(); err == nil {
		return cwd
	}
	return """"
}
func init() {
	cobra.OnInitialize()
	configFilePath := GetDefaultConfigFilePath()
	rootCommand.PersistentFlags().StringP(flagConfig, ""c"", """", fmt.Sprintf(""Configuration file for opensearch-cli, default is %s"", configFilePath))
	rootCommand.PersistentFlags().StringP(flagProfileName, ""p"", """", ""Use a specific profile from your configuration file"")
	rootCommand.Flags().BoolP(""version"", ""v"", false, ""Version for opensearch-cli"")
	rootCommand.Flags().BoolP(""help"", ""h"", false, ""Help for opensearch-cli"")
}
// GetConfigFilePath gets config file path for execution
func GetConfigFilePath(configFlagValue string) (string, error) {
	if configFlagValue != """" {
		return configFlagValue, nil
	}
	if value, ok := os.LookupEnv(ConfigEnvVarName); ok {
		return value, nil
	}
	if err := createDefaultConfigFileIfNotExists(); err != nil {
		return """", err
	}
	return GetDefaultConfigFilePath(), nil
}
// createDefaultConfigFolderIfNotExists creates default config file along with folder if
// it doesn't exists
func createDefaultConfigFileIfNotExists() error {
	defaultFilePath := GetDefaultConfigFilePath()
	if isExists(defaultFilePath) {
		return nil
	}
	folderPath := filepath.Dir(defaultFilePath)
	if !isExists(folderPath) {
		err := os.Mkdir(folderPath, FolderPermission)
		if err != nil {
			return err
		}
	}
	f, err := os.Create(defaultFilePath)
	if err != nil {
		return err
	}
	if err = f.Chmod(FilePermission); err != nil {
		return err
	}
	return f.Close()
}
//isExists check if given path exists or not
//if path is just a name, it will check in current directory
func isExists(path string) bool {
	if _, err := os.Stat(path); os.IsNotExist(err) {
		return false
	}
	return true
}
// DisplayError prints command name and error on console and exists as well.
func DisplayError(err error, cmdName string) {
	if err != nil {
		fmt.Println(cmdName, ""Command failed."")
		fmt.Println(""Reason:"", err)
	}
}
// GetProfile gets profile details for current execution
func GetProfile() (*entity.Profile, error) {
	p, err := GetProfileController()
	if err != nil {
		return nil, err
	}
	profileFlagValue, err := rootCommand.PersistentFlags().GetString(flagProfileName)
	if err != nil {
		return nil, err
	}
	profile, ok, err := p.GetProfileForExecution(profileFlagValue)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, fmt.Errorf(""no profile found for execution. Try %s %s --help for more information"", RootCommandName, ProfileCommandName)
	}
	return &profile, nil
}
",CWE-276,173.0,0
"package logic
import (
	""errors""
	""fmt""
	""time""
	""github.com/golang-jwt/jwt/v4""
	""github.com/gravitl/netmaker/logger""
	""github.com/gravitl/netmaker/models""
	""github.com/gravitl/netmaker/servercfg""
)
var jwtSecretKey []byte
// SetJWTSecret - sets the jwt secret on server startup
func SetJWTSecret() {
	currentSecret, jwtErr := FetchJWTSecret()
	if jwtErr != nil {
		newValue, err := GenerateCryptoString(64)
		if err != nil {
			logger.FatalLog(""something went wrong when generating JWT signature"")
		}
		jwtSecretKey = []byte(newValue) // 512 bit random password
		if err := StoreJWTSecret(string(jwtSecretKey)); err != nil {
			logger.FatalLog(""something went wrong when configuring JWT authentication"")
		}
	} else {
		jwtSecretKey = []byte(currentSecret)
	}
}
// CreateJWT func will used to create the JWT while signing in and signing out
func CreateJWT(uuid string, macAddress string, network string) (response string, err error) {
	expirationTime := time.Now().Add(5 * time.Minute)
	claims := &models.Claims{
		ID:         uuid,
		Network:    network,
		MacAddress: macAddress,
		StandardClaims: jwt.StandardClaims{
			Issuer:    ""Netmaker"",
			Subject:   fmt.Sprintf(""node|%s"", uuid),
			IssuedAt:  time.Now().Unix(),
			ExpiresAt: expirationTime.Unix(),
		},
	}
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	tokenString, err := token.SignedString(jwtSecretKey)
	if err == nil {
		return tokenString, nil
	}
	return """", err
}
// CreateUserJWT - creates a user jwt token
func CreateUserJWT(username string, networks []string, isadmin bool) (response string, err error) {
	expirationTime := time.Now().Add(60 * 12 * time.Minute)
	claims := &models.UserClaims{
		UserName: username,
		Networks: networks,
		IsAdmin:  isadmin,
		StandardClaims: jwt.StandardClaims{
			Issuer:    ""Netmaker"",
			IssuedAt:  time.Now().Unix(),
			Subject:   fmt.Sprintf(""user|%s"", username),
			ExpiresAt: expirationTime.Unix(),
		},
	}
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	tokenString, err := token.SignedString(jwtSecretKey)
	if err == nil {
		return tokenString, nil
	}
	return """", err
}
// VerifyToken func will used to Verify the JWT Token while using APIS
func VerifyUserToken(tokenString string) (username string, networks []string, isadmin bool, err error) {
	claims := &models.UserClaims{}
	if tokenString == servercfg.GetMasterKey() {
		return ""masteradministrator"", nil, true, nil
	}
	token, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {
		return jwtSecretKey, nil
	})
	if token != nil && token.Valid {
		// check that user exists
		if user, err := GetUser(claims.UserName); user.UserName != """" && err == nil {
			return claims.UserName, claims.Networks, claims.IsAdmin, nil
		}
		err = errors.New(""user does not exist"")
	}
	return """", nil, false, err
}
// VerifyToken - gRPC [nodes] Only
func VerifyToken(tokenString string) (nodeID string, mac string, network string, err error) {
	claims := &models.Claims{}
	//this may be a stupid way of serving up a master key
	//TODO: look into a different method. Encryption?
	if tokenString == servercfg.GetMasterKey() {
		return ""mastermac"", """", """", nil
	}
	token, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {
		return jwtSecretKey, nil
	})
	if token != nil {
		return claims.ID, claims.MacAddress, claims.Network, nil
	}
	return """", """", """", err
}
",CWE-321,120.0,0
"{
	""root"": true,
	""extends"": ""@ljharb/eslint-config/node/6"",
	""rules"": {
		""consistent-return"": 1,
		""func-name-matching"": 0,
		""max-nested-callbacks"": 0,
		""max-lines-per-function"": 0,
		""sort-keys"": 0,
	},
}
",CWE-78,14.0,0
"// Copyright 2014 The Gogs Authors. All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.
//go:build pam
// +build pam
package pam
import (
	""errors""
	""github.com/msteinert/pam""
)
// Supported is true when built with PAM
var Supported = true
// Auth pam auth service
func Auth(serviceName, userName, passwd string) (string, error) {
	t, err := pam.StartFunc(serviceName, userName, func(s pam.Style, msg string) (string, error) {
		switch s {
		case pam.PromptEchoOff:
			return passwd, nil
		case pam.PromptEchoOn, pam.ErrorMsg, pam.TextInfo:
			return """", nil
		}
		return """", errors.New(""Unrecognized PAM message style"")
	})
	if err != nil {
		return """", err
	}
	if err = t.Authenticate(0); err != nil {
		return """", err
	}
	
	if err = t.AcctMgmt(0); err != nil {
	  return """", err
  }
	// PAM login names might suffer transformations in the PAM stack.
	// We should take whatever the PAM stack returns for it.
	return t.GetItem(pam.User)
}
",CWE-862,46.0,0
"// Copyright 2021 The Gitea Authors. All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.
package typesniffer
import (
	""fmt""
	""io""
	""net/http""
	""regexp""
	""strings""
	""code.gitea.io/gitea/modules/util""
)
// Use at most this many bytes to determine Content Type.
const sniffLen = 1024
const (
	// SvgMimeType MIME type of SVG images.
	SvgMimeType = ""image/svg+xml""
	// ApplicationOctetStream MIME type of binary files.
	ApplicationOctetStream = ""application/octet-stream""
)
var (
	svgTagRegex      = regexp.MustCompile(`(?si)\A\s*(?:(<!--.*?-->|<!DOCTYPE\s+svg([\s:]+.*?>|>))\s*)*<svg[\s>\/]`)
	svgTagInXMLRegex = regexp.MustCompile(`(?si)\A<\?xml\b.*?\?>\s*(?:(<!--.*?-->|<!DOCTYPE\s+svg([\s:]+.*?>|>))\s*)*<svg[\s>\/]`)
)
// SniffedType contains information about a blobs type.
type SniffedType struct {
	contentType string
}
// IsText etects if content format is plain text.
func (ct SniffedType) IsText() bool {
	return strings.Contains(ct.contentType, ""text/"")
}
// IsImage detects if data is an image format
func (ct SniffedType) IsImage() bool {
	return strings.Contains(ct.contentType, ""image/"")
}
// IsSvgImage detects if data is an SVG image format
func (ct SniffedType) IsSvgImage() bool {
	return strings.Contains(ct.contentType, SvgMimeType)
}
// IsPDF detects if data is a PDF format
func (ct SniffedType) IsPDF() bool {
	return strings.Contains(ct.contentType, ""application/pdf"")
}
// IsVideo detects if data is an video format
func (ct SniffedType) IsVideo() bool {
	return strings.Contains(ct.contentType, ""video/"")
}
// IsAudio detects if data is an video format
func (ct SniffedType) IsAudio() bool {
	return strings.Contains(ct.contentType, ""audio/"")
}
// IsRepresentableAsText returns true if file content can be represented as
// plain text or is empty.
func (ct SniffedType) IsRepresentableAsText() bool {
	return ct.IsText() || ct.IsSvgImage()
}
// DetectContentType extends http.DetectContentType with more content types. Defaults to text/unknown if input is empty.
func DetectContentType(data []byte) SniffedType {
	if len(data) == 0 {
		return SniffedType{""text/unknown""}
	}
	ct := http.DetectContentType(data)
	if len(data) > sniffLen {
		data = data[:sniffLen]
	}
	if (strings.Contains(ct, ""text/plain"") || strings.Contains(ct, ""text/html"")) && svgTagRegex.Match(data) ||
		strings.Contains(ct, ""text/xml"") && svgTagInXMLRegex.Match(data) {
		// SVG is unsupported. https://github.com/golang/go/issues/15888
		ct = SvgMimeType
	}
	return SniffedType{ct}
}
// DetectContentTypeFromReader guesses the content type contained in the reader.
func DetectContentTypeFromReader(r io.Reader) (SniffedType, error) {
	buf := make([]byte, sniffLen)
	n, err := util.ReadAtMost(r, buf)
	if err != nil {
		return SniffedType{}, fmt.Errorf(""DetectContentTypeFromReader io error: %w"", err)
	}
	buf = buf[:n]
	return DetectContentType(buf), nil
}
",CWE-79,105.0,0
"// Copyright 2021 The Gitea Authors. All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.
package common
import (
	""fmt""
	""io""
	""path""
	""path/filepath""
	""strings""
	""time""
	""code.gitea.io/gitea/modules/charset""
	""code.gitea.io/gitea/modules/context""
	""code.gitea.io/gitea/modules/git""
	""code.gitea.io/gitea/modules/httpcache""
	""code.gitea.io/gitea/modules/log""
	""code.gitea.io/gitea/modules/setting""
	""code.gitea.io/gitea/modules/typesniffer""
	""code.gitea.io/gitea/modules/util""
)
// ServeBlob download a git.Blob
func ServeBlob(ctx *context.Context, blob *git.Blob, lastModified time.Time) error {
	if httpcache.HandleGenericETagTimeCache(ctx.Req, ctx.Resp, `""`+blob.ID.String()+`""`, lastModified) {
		return nil
	}
	dataRc, err := blob.DataAsync()
	if err != nil {
		return err
	}
	defer func() {
		if err = dataRc.Close(); err != nil {
			log.Error(""ServeBlob: Close: %v"", err)
		}
	}()
	return ServeData(ctx, ctx.Repo.TreePath, blob.Size(), dataRc)
}
// ServeData download file from io.Reader
func ServeData(ctx *context.Context, name string, size int64, reader io.Reader) error {
	buf := make([]byte, 1024)
	n, err := util.ReadAtMost(reader, buf)
	if err != nil {
		return err
	}
	if n >= 0 {
		buf = buf[:n]
	}
	ctx.Resp.Header().Set(""Cache-Control"", ""public,max-age=86400"")
	if size >= 0 {
		ctx.Resp.Header().Set(""Content-Length"", fmt.Sprintf(""%d"", size))
	} else {
		log.Error(""ServeData called to serve data: %s with size < 0: %d"", name, size)
	}
	name = path.Base(name)
	// Google Chrome dislike commas in filenames, so let's change it to a space
	name = strings.ReplaceAll(name, "","", "" "")
	st := typesniffer.DetectContentType(buf)
	mappedMimeType := """"
	if setting.MimeTypeMap.Enabled {
		fileExtension := strings.ToLower(filepath.Ext(name))
		mappedMimeType = setting.MimeTypeMap.Map[fileExtension]
	}
	if st.IsText() || ctx.FormBool(""render"") {
		cs, err := charset.DetectEncoding(buf)
		if err != nil {
			log.Error(""Detect raw file %s charset failed: %v, using by default utf-8"", name, err)
			cs = ""utf-8""
		}
		if mappedMimeType == """" {
			mappedMimeType = ""text/plain""
		}
		ctx.Resp.Header().Set(""Content-Type"", mappedMimeType+""; charset=""+strings.ToLower(cs))
	} else {
		ctx.Resp.Header().Set(""Access-Control-Expose-Headers"", ""Content-Disposition"")
		if mappedMimeType != """" {
			ctx.Resp.Header().Set(""Content-Type"", mappedMimeType)
		}
		if (st.IsImage() || st.IsPDF()) && (setting.UI.SVG.Enabled || !st.IsSvgImage()) {
			ctx.Resp.Header().Set(""Content-Disposition"", fmt.Sprintf(`inline; filename=""%s""`, name))
			if st.IsSvgImage() || st.IsPDF() {
				ctx.Resp.Header().Set(""Content-Security-Policy"", ""default-src 'none'; style-src 'unsafe-inline'; sandbox"")
				ctx.Resp.Header().Set(""X-Content-Type-Options"", ""nosniff"")
				if st.IsSvgImage() {
					ctx.Resp.Header().Set(""Content-Type"", typesniffer.SvgMimeType)
				} else {
					ctx.Resp.Header().Set(""Content-Type"", typesniffer.ApplicationOctetStream)
				}
			}
		} else {
			ctx.Resp.Header().Set(""Content-Disposition"", fmt.Sprintf(`attachment; filename=""%s""`, name))
		}
	}
	_, err = ctx.Resp.Write(buf)
	if err != nil {
		return err
	}
	_, err = io.Copy(ctx.Resp, reader)
	return err
}
",CWE-79,112.0,0
"// Copyright 2023 The Gitea Authors. All rights reserved.
// SPDX-License-Identifier: MIT
package context
import (
	""errors""
	""fmt""
	""net""
	""net/http""
	""net/url""
	""path""
	""strconv""
	""strings""
	""time""
	user_model ""code.gitea.io/gitea/models/user""
	""code.gitea.io/gitea/modules/base""
	""code.gitea.io/gitea/modules/log""
	""code.gitea.io/gitea/modules/setting""
	""code.gitea.io/gitea/modules/templates""
	""code.gitea.io/gitea/modules/web/middleware""
)
// RedirectToUser redirect to a differently-named user
func RedirectToUser(ctx *Base, userName string, redirectUserID int64) {
	user, err := user_model.GetUserByID(ctx, redirectUserID)
	if err != nil {
		ctx.Error(http.StatusInternalServerError, ""unable to get user"")
		return
	}
	redirectPath := strings.Replace(
		ctx.Req.URL.EscapedPath(),
		url.PathEscape(userName),
		url.PathEscape(user.Name),
		1,
	)
	if ctx.Req.URL.RawQuery != """" {
		redirectPath += ""?"" + ctx.Req.URL.RawQuery
	}
	ctx.Redirect(path.Join(setting.AppSubURL, redirectPath), http.StatusTemporaryRedirect)
}
// RedirectToFirst redirects to first not empty URL
func (ctx *Context) RedirectToFirst(location ...string) {
	for _, loc := range location {
		if len(loc) == 0 {
			continue
		}
		// Unfortunately browsers consider a redirect Location with preceding ""//"", ""\\"" and ""/\"" as meaning redirect to ""http(s)://REST_OF_PATH""
		// Therefore we should ignore these redirect locations to prevent open redirects
		if len(loc) > 1 && (loc[0] == '/' || loc[0] == '\\') && (loc[1] == '/' || loc[1] == '\\') {
			continue
		}
		u, err := url.Parse(loc)
		if err != nil || ((u.Scheme != """" || u.Host != """") && !strings.HasPrefix(strings.ToLower(loc), strings.ToLower(setting.AppURL))) {
			continue
		}
		ctx.Redirect(loc)
		return
	}
	ctx.Redirect(setting.AppSubURL + ""/"")
}
const tplStatus500 base.TplName = ""status/500""
// HTML calls Context.HTML and renders the template to HTTP response
func (ctx *Context) HTML(status int, name base.TplName) {
	log.Debug(""Template: %s"", name)
	tmplStartTime := time.Now()
	if !setting.IsProd {
		ctx.Data[""TemplateName""] = name
	}
	ctx.Data[""TemplateLoadTimes""] = func() string {
		return strconv.FormatInt(time.Since(tmplStartTime).Nanoseconds()/1e6, 10) + ""ms""
	}
	err := ctx.Render.HTML(ctx.Resp, status, string(name), ctx.Data)
	if err == nil {
		return
	}
	// if rendering fails, show error page
	if name != tplStatus500 {
		err = fmt.Errorf(""failed to render template: %s, error: %s"", name, templates.HandleTemplateRenderingError(err))
		ctx.ServerError(""Render failed"", err) // show the 500 error page
	} else {
		ctx.PlainText(http.StatusInternalServerError, ""Unable to render status/500 page, the template system is broken, or Gitea can't find your template files."")
		return
	}
}
// RenderToString renders the template content to a string
func (ctx *Context) RenderToString(name base.TplName, data map[string]interface{}) (string, error) {
	var buf strings.Builder
	err := ctx.Render.HTML(&buf, http.StatusOK, string(name), data)
	return buf.String(), err
}
// RenderWithErr used for page has form validation but need to prompt error to users.
func (ctx *Context) RenderWithErr(msg string, tpl base.TplName, form interface{}) {
	if form != nil {
		middleware.AssignForm(form, ctx.Data)
	}
	ctx.Flash.ErrorMsg = msg
	ctx.Data[""Flash""] = ctx.Flash
	ctx.HTML(http.StatusOK, tpl)
}
// NotFound displays a 404 (Not Found) page and prints the given error, if any.
func (ctx *Context) NotFound(logMsg string, logErr error) {
	ctx.notFoundInternal(logMsg, logErr)
}
func (ctx *Context) notFoundInternal(logMsg string, logErr error) {
	if logErr != nil {
		log.Log(2, log.DEBUG, ""%s: %v"", logMsg, logErr)
		if !setting.IsProd {
			ctx.Data[""ErrorMsg""] = logErr
		}
	}
	// response simple message if Accept isn't text/html
	showHTML := false
	for _, part := range ctx.Req.Header[""Accept""] {
		if strings.Contains(part, ""text/html"") {
			showHTML = true
			break
		}
	}
	if !showHTML {
		ctx.plainTextInternal(3, http.StatusNotFound, []byte(""Not found.\n""))
		return
	}
	ctx.Data[""IsRepo""] = ctx.Repo.Repository != nil
	ctx.Data[""Title""] = ""Page Not Found""
	ctx.HTML(http.StatusNotFound, base.TplName(""status/404""))
}
// ServerError displays a 500 (Internal Server Error) page and prints the given error, if any.
func (ctx *Context) ServerError(logMsg string, logErr error) {
	ctx.serverErrorInternal(logMsg, logErr)
}
func (ctx *Context) serverErrorInternal(logMsg string, logErr error) {
	if logErr != nil {
		log.ErrorWithSkip(2, ""%s: %v"", logMsg, logErr)
		if _, ok := logErr.(*net.OpError); ok || errors.Is(logErr, &net.OpError{}) {
			// This is an error within the underlying connection
			// and further rendering will not work so just return
			return
		}
		// it's safe to show internal error to admin users, and it helps
		if !setting.IsProd || (ctx.Doer != nil && ctx.Doer.IsAdmin) {
			ctx.Data[""ErrorMsg""] = fmt.Sprintf(""%s, %s"", logMsg, logErr)
		}
	}
	ctx.Data[""Title""] = ""Internal Server Error""
	ctx.HTML(http.StatusInternalServerError, tplStatus500)
}
// NotFoundOrServerError use error check function to determine if the error
// is about not found. It responds with 404 status code for not found error,
// or error context description for logging purpose of 500 server error.
func (ctx *Context) NotFoundOrServerError(logMsg string, errCheck func(error) bool, logErr error) {
	if errCheck(logErr) {
		ctx.notFoundInternal(logMsg, logErr)
		return
	}
	ctx.serverErrorInternal(logMsg, logErr)
}
",CWE-601,182.0,0
"{
	""name"": ""git-interface"",
	""version"": ""2.1.2"",
	""description"": ""some interfaces for work with git repository"",
	""main"": ""dist/index"",
	""typings"": ""dist/index"",
	""scripts"": {
		""clean"": ""rm -rf ./dist"",
		""build"": ""npm run clean && npm run ts"",
		""dev"": ""npm run clean &&  ./node_modules/.bin/tsc -w"",
		""ts"": ""./node_modules/.bin/tsc"",
		""prepublishOnly"": ""npm run build && bump""
	},
	""repository"": {
		""type"": ""git"",
		""url"": ""git://github.com/yarkeev/git-interface.git""
	},
	""keywords"": [
		""git"",
		""hash"",
		""pull"",
		""push"",
		""commit"",
		""last changes"",
		""checkout"",
		""merge"",
		""conflicts"",
		""cvs""
	],
	""author"": ""Yarkeev Denis <denis.yarkeev@gmail.com>"",
	""license"": ""MIT"",
	""bugs"": {
		""url"": ""https://github.com/yarkeev/git-interface/issues""
	},
	""homepage"": ""https://github.com/yarkeev/git-interface"",
	""devDependencies"": {
		""@types/node"": ""^10.10.3"",
		""typescript"": ""^3.0.3"",
		""version-bump-prompt"": ""^6.1.0""
	}
}
",CWE-78,42.0,0
"package restful
// Copyright 2013 Ernest Micklei. All rights reserved.
// Use of this source code is governed by a license
// that can be found in the LICENSE file.
import (
	""regexp""
	""strconv""
	""strings""
)
// CrossOriginResourceSharing is used to create a Container Filter that implements CORS.
// Cross-origin resource sharing (CORS) is a mechanism that allows JavaScript on a web page
// to make XMLHttpRequests to another domain, not the domain the JavaScript originated from.
//
// http://en.wikipedia.org/wiki/Cross-origin_resource_sharing
// http://enable-cors.org/server.html
// http://www.html5rocks.com/en/tutorials/cors/
type CrossOriginResourceSharing struct {
	ExposeHeaders []string // list of Header names
	// AllowedHeaders is alist of Header names. Checking is case-insensitive.
	// The list may contain the special wildcard string "".*"" ; all is allowed
	AllowedHeaders []string
	// AllowedDomains is a list of allowed values for Http Origin.
	// The list may contain the special wildcard string "".*"" ; all is allowed
	// If empty all are allowed.
	AllowedDomains []string
	// AllowedDomainFunc is optional and is a function that will do the check
	// when the origin is not part of the AllowedDomains and it does not contain the wildcard "".*"".
	AllowedDomainFunc func(origin string) bool
	// AllowedMethods is either empty or has a list of http methods names. Checking is case-insensitive.
	AllowedMethods []string
	MaxAge         int // number of seconds before requiring new Options request
	CookiesAllowed bool
	Container      *Container
	allowedOriginPatterns []*regexp.Regexp // internal field for origin regexp check.
}
// Filter is a filter function that implements the CORS flow as documented on http://enable-cors.org/server.html
// and http://www.html5rocks.com/static/images/cors_server_flowchart.png
func (c CrossOriginResourceSharing) Filter(req *Request, resp *Response, chain *FilterChain) {
	origin := req.Request.Header.Get(HEADER_Origin)
	if len(origin) == 0 {
		if trace {
			traceLogger.Print(""no Http header Origin set"")
		}
		chain.ProcessFilter(req, resp)
		return
	}
	if !c.isOriginAllowed(origin) { // check whether this origin is allowed
		if trace {
			traceLogger.Printf(""HTTP Origin:%s is not part of %v, neither matches any part of %v"", origin, c.AllowedDomains, c.allowedOriginPatterns)
		}
		chain.ProcessFilter(req, resp)
		return
	}
	if req.Request.Method != ""OPTIONS"" {
		c.doActualRequest(req, resp)
		chain.ProcessFilter(req, resp)
		return
	}
	if acrm := req.Request.Header.Get(HEADER_AccessControlRequestMethod); acrm != """" {
		c.doPreflightRequest(req, resp)
	} else {
		c.doActualRequest(req, resp)
		chain.ProcessFilter(req, resp)
		return
	}
}
func (c CrossOriginResourceSharing) doActualRequest(req *Request, resp *Response) {
	c.setOptionsHeaders(req, resp)
	// continue processing the response
}
func (c *CrossOriginResourceSharing) doPreflightRequest(req *Request, resp *Response) {
	if len(c.AllowedMethods) == 0 {
		if c.Container == nil {
			c.AllowedMethods = DefaultContainer.computeAllowedMethods(req)
		} else {
			c.AllowedMethods = c.Container.computeAllowedMethods(req)
		}
	}
	acrm := req.Request.Header.Get(HEADER_AccessControlRequestMethod)
	if !c.isValidAccessControlRequestMethod(acrm, c.AllowedMethods) {
		if trace {
			traceLogger.Printf(""Http header %s:%s is not in %v"",
				HEADER_AccessControlRequestMethod,
				acrm,
				c.AllowedMethods)
		}
		return
	}
	acrhs := req.Request.Header.Get(HEADER_AccessControlRequestHeaders)
	if len(acrhs) > 0 {
		for _, each := range strings.Split(acrhs, "","") {
			if !c.isValidAccessControlRequestHeader(strings.Trim(each, "" "")) {
				if trace {
					traceLogger.Printf(""Http header %s:%s is not in %v"",
						HEADER_AccessControlRequestHeaders,
						acrhs,
						c.AllowedHeaders)
				}
				return
			}
		}
	}
	resp.AddHeader(HEADER_AccessControlAllowMethods, strings.Join(c.AllowedMethods, "",""))
	resp.AddHeader(HEADER_AccessControlAllowHeaders, acrhs)
	c.setOptionsHeaders(req, resp)
	// return http 200 response, no body
}
func (c CrossOriginResourceSharing) setOptionsHeaders(req *Request, resp *Response) {
	c.checkAndSetExposeHeaders(resp)
	c.setAllowOriginHeader(req, resp)
	c.checkAndSetAllowCredentials(resp)
	if c.MaxAge > 0 {
		resp.AddHeader(HEADER_AccessControlMaxAge, strconv.Itoa(c.MaxAge))
	}
}
func (c CrossOriginResourceSharing) isOriginAllowed(origin string) bool {
	if len(origin) == 0 {
		return false
	}
	lowerOrigin := strings.ToLower(origin)
	if len(c.AllowedDomains) == 0 {
		if c.AllowedDomainFunc != nil {
			return c.AllowedDomainFunc(lowerOrigin)
		}
		return true
	}
	// exact match on each allowed domain
	for _, domain := range c.AllowedDomains {
		if domain == "".*"" || strings.ToLower(domain) == lowerOrigin {
			return true
		}
	}
	if c.AllowedDomainFunc != nil {
		return c.AllowedDomainFunc(origin)
	}
	return false
}
func (c CrossOriginResourceSharing) setAllowOriginHeader(req *Request, resp *Response) {
	origin := req.Request.Header.Get(HEADER_Origin)
	if c.isOriginAllowed(origin) {
		resp.AddHeader(HEADER_AccessControlAllowOrigin, origin)
	}
}
func (c CrossOriginResourceSharing) checkAndSetExposeHeaders(resp *Response) {
	if len(c.ExposeHeaders) > 0 {
		resp.AddHeader(HEADER_AccessControlExposeHeaders, strings.Join(c.ExposeHeaders, "",""))
	}
}
func (c CrossOriginResourceSharing) checkAndSetAllowCredentials(resp *Response) {
	if c.CookiesAllowed {
		resp.AddHeader(HEADER_AccessControlAllowCredentials, ""true"")
	}
}
func (c CrossOriginResourceSharing) isValidAccessControlRequestMethod(method string, allowedMethods []string) bool {
	for _, each := range allowedMethods {
		if each == method {
			return true
		}
	}
	return false
}
func (c CrossOriginResourceSharing) isValidAccessControlRequestHeader(header string) bool {
	for _, each := range c.AllowedHeaders {
		if strings.ToLower(each) == strings.ToLower(header) {
			return true
		}
		if each == ""*"" {
			return true
		}
	}
	return false
}
",CWE-639,194.0,0
"package restful
import (
	""net/http""
	""net/http/httptest""
	""testing""
)
// go test -v -test.run TestCORSFilter_Preflight ...restful
// http://www.html5rocks.com/en/tutorials/cors/
func TestCORSFilter_Preflight(t *testing.T) {
	tearDown()
	ws := new(WebService)
	ws.Route(ws.PUT(""/cors"").To(dummy))
	Add(ws)
	cors := CrossOriginResourceSharing{
		ExposeHeaders:  []string{""X-Custom-Header""},
		AllowedHeaders: []string{""X-Custom-Header"", ""X-Additional-Header""},
		CookiesAllowed: true,
		Container:      DefaultContainer}
	Filter(cors.Filter)
	// Preflight
	httpRequest, _ := http.NewRequest(""OPTIONS"", ""http://api.alice.com/cors"", nil)
	httpRequest.Method = ""OPTIONS""
	httpRequest.Header.Set(HEADER_Origin, ""http://api.bob.com"")
	httpRequest.Header.Set(HEADER_AccessControlRequestMethod, ""PUT"")
	httpRequest.Header.Set(HEADER_AccessControlRequestHeaders, ""X-Custom-Header, X-Additional-Header"")
	httpWriter := httptest.NewRecorder()
	DefaultContainer.Dispatch(httpWriter, httpRequest)
	actual := httpWriter.Header().Get(HEADER_AccessControlAllowOrigin)
	if ""http://api.bob.com"" != actual {
		t.Fatal(""expected: http://api.bob.com but got:"" + actual)
	}
	actual = httpWriter.Header().Get(HEADER_AccessControlAllowMethods)
	if ""PUT"" != actual {
		t.Fatal(""expected: PUT but got:"" + actual)
	}
	actual = httpWriter.Header().Get(HEADER_AccessControlAllowHeaders)
	if ""X-Custom-Header, X-Additional-Header"" != actual {
		t.Fatal(""expected: X-Custom-Header, X-Additional-Header but got:"" + actual)
	}
	if !cors.isOriginAllowed(""somewhere"") {
		t.Fatal(""origin expected to be allowed"")
	}
	cors.AllowedDomains = []string{""overthere.com""}
	if cors.isOriginAllowed(""somewhere"") {
		t.Fatal(""origin [somewhere] expected NOT to be allowed"")
	}
	if !cors.isOriginAllowed(""overthere.com"") {
		t.Fatal(""origin [overthere] expected to be allowed"")
	}
}
// go test -v -test.run TestCORSFilter_Actual ...restful
// http://www.html5rocks.com/en/tutorials/cors/
func TestCORSFilter_Actual(t *testing.T) {
	tearDown()
	ws := new(WebService)
	ws.Route(ws.PUT(""/cors"").To(dummy))
	Add(ws)
	cors := CrossOriginResourceSharing{
		ExposeHeaders:  []string{""X-Custom-Header""},
		AllowedHeaders: []string{""X-Custom-Header"", ""X-Additional-Header""},
		CookiesAllowed: true,
		Container:      DefaultContainer}
	Filter(cors.Filter)
	// Actual
	httpRequest, _ := http.NewRequest(""PUT"", ""http://api.alice.com/cors"", nil)
	httpRequest.Header.Set(HEADER_Origin, ""http://api.bob.com"")
	httpRequest.Header.Set(""X-Custom-Header"", ""value"")
	httpWriter := httptest.NewRecorder()
	DefaultContainer.Dispatch(httpWriter, httpRequest)
	actual := httpWriter.Header().Get(HEADER_AccessControlAllowOrigin)
	if ""http://api.bob.com"" != actual {
		t.Fatal(""expected: http://api.bob.com but got:"" + actual)
	}
	if httpWriter.Body.String() != ""dummy"" {
		t.Fatal(""expected: dummy but got:"" + httpWriter.Body.String())
	}
}
var allowedDomainInput = []struct {
	domains []string
	origin  string
	allowed bool
}{
	{[]string{}, ""http://anything.com"", true},
	{[]string{""example.com""}, ""example.com"", true},
	{[]string{""example.com""}, ""not-allowed"", false},
	{[]string{""not-matching.com"", ""example.com""}, ""example.com"", true},
	{[]string{"".*""}, ""example.com"", true},
}
// go test -v -test.run TestCORSFilter_AllowedDomains ...restful
func TestCORSFilter_AllowedDomains(t *testing.T) {
	for _, each := range allowedDomainInput {
		tearDown()
		ws := new(WebService)
		ws.Route(ws.PUT(""/cors"").To(dummy))
		Add(ws)
		cors := CrossOriginResourceSharing{
			AllowedDomains: each.domains,
			CookiesAllowed: true,
			Container:      DefaultContainer}
		Filter(cors.Filter)
		httpRequest, _ := http.NewRequest(""PUT"", ""http://api.his.com/cors"", nil)
		httpRequest.Header.Set(HEADER_Origin, each.origin)
		httpWriter := httptest.NewRecorder()
		DefaultContainer.Dispatch(httpWriter, httpRequest)
		actual := httpWriter.Header().Get(HEADER_AccessControlAllowOrigin)
		if actual != each.origin && each.allowed {
			t.Error(""expected to be accepted"", each)
		}
		if actual == each.origin && !each.allowed {
			t.Error(""did not expect to be accepted"")
		}
	}
}
func TestCORSFilter_AllowedDomainFunc(t *testing.T) {
	cors := CrossOriginResourceSharing{
		AllowedDomains: []string{""here"", ""there""},
		AllowedDomainFunc: func(origin string) bool {
			return ""where"" == origin
		},
	}
	if got, want := cors.isOriginAllowed(""here""), true; got != want {
		t.Errorf(""got [%v:%T] want [%v:%T]"", got, got, want, want)
	}
	if got, want := cors.isOriginAllowed(""HERE""), true; got != want {
		t.Errorf(""got [%v:%T] want [%v:%T]"", got, got, want, want)
	}
	if got, want := cors.isOriginAllowed(""there""), true; got != want {
		t.Errorf(""got [%v:%T] want [%v:%T]"", got, got, want, want)
	}
	if got, want := cors.isOriginAllowed(""where""), true; got != want {
		t.Errorf(""got [%v:%T] want [%v:%T]"", got, got, want, want)
	}
	if got, want := cors.isOriginAllowed(""nowhere""), false; got != want {
		t.Errorf(""got [%v:%T] want [%v:%T]"", got, got, want, want)
	}
	// just func
	cors.AllowedDomains = []string{}
	if got, want := cors.isOriginAllowed(""here""), false; got != want {
		t.Errorf(""got [%v:%T] want [%v:%T]"", got, got, want, want)
	}
	if got, want := cors.isOriginAllowed(""where""), true; got != want {
		t.Errorf(""got [%v:%T] want [%v:%T]"", got, got, want, want)
	}
	// empty domain
	if got, want := cors.isOriginAllowed(""""), false; got != want {
		t.Errorf(""got [%v:%T] want [%v:%T]"", got, got, want, want)
	}
}
",CWE-639,166.0,0
"package fasthttp
var (
	defaultServerName  = []byte(""fasthttp"")
	defaultUserAgent   = []byte(""fasthttp"")
	defaultContentType = []byte(""text/plain; charset=utf-8"")
)
var (
	strSlash                    = []byte(""/"")
	strSlashSlash               = []byte(""//"")
	strSlashDotDot              = []byte(""/.."")
	strSlashDotSlash            = []byte(""/./"")
	strSlashDotDotSlash         = []byte(""/../"")
	strBackSlashDotDot          = []byte(`\..`)
	strBackSlashDotBackSlash    = []byte(`\.\`)
	strSlashDotDotBackSlash     = []byte(`/..\`)
	strBackSlashDotDotBackSlash = []byte(`\..\`)
	strCRLF                     = []byte(""\r\n"")
	strHTTP                     = []byte(""http"")
	strHTTPS                    = []byte(""https"")
	strHTTP10                   = []byte(""HTTP/1.0"")
	strHTTP11                   = []byte(""HTTP/1.1"")
	strColon                    = []byte("":"")
	strColonSlashSlash          = []byte(""://"")
	strColonSpace               = []byte("": "")
	strCommaSpace               = []byte("", "")
	strGMT                      = []byte(""GMT"")
	strResponseContinue = []byte(""HTTP/1.1 100 Continue\r\n\r\n"")
	strExpect             = []byte(HeaderExpect)
	strConnection         = []byte(HeaderConnection)
	strContentLength      = []byte(HeaderContentLength)
	strContentType        = []byte(HeaderContentType)
	strDate               = []byte(HeaderDate)
	strHost               = []byte(HeaderHost)
	strReferer            = []byte(HeaderReferer)
	strServer             = []byte(HeaderServer)
	strTransferEncoding   = []byte(HeaderTransferEncoding)
	strContentEncoding    = []byte(HeaderContentEncoding)
	strAcceptEncoding     = []byte(HeaderAcceptEncoding)
	strUserAgent          = []byte(HeaderUserAgent)
	strCookie             = []byte(HeaderCookie)
	strSetCookie          = []byte(HeaderSetCookie)
	strLocation           = []byte(HeaderLocation)
	strIfModifiedSince    = []byte(HeaderIfModifiedSince)
	strLastModified       = []byte(HeaderLastModified)
	strAcceptRanges       = []byte(HeaderAcceptRanges)
	strRange              = []byte(HeaderRange)
	strContentRange       = []byte(HeaderContentRange)
	strAuthorization      = []byte(HeaderAuthorization)
	strTE                 = []byte(HeaderTE)
	strTrailer            = []byte(HeaderTrailer)
	strMaxForwards        = []byte(HeaderMaxForwards)
	strProxyConnection    = []byte(HeaderProxyConnection)
	strProxyAuthenticate  = []byte(HeaderProxyAuthenticate)
	strProxyAuthorization = []byte(HeaderProxyAuthorization)
	strWWWAuthenticate    = []byte(HeaderWWWAuthenticate)
	strCookieExpires        = []byte(""expires"")
	strCookieDomain         = []byte(""domain"")
	strCookiePath           = []byte(""path"")
	strCookieHTTPOnly       = []byte(""HttpOnly"")
	strCookieSecure         = []byte(""secure"")
	strCookieMaxAge         = []byte(""max-age"")
	strCookieSameSite       = []byte(""SameSite"")
	strCookieSameSiteLax    = []byte(""Lax"")
	strCookieSameSiteStrict = []byte(""Strict"")
	strCookieSameSiteNone   = []byte(""None"")
	strClose               = []byte(""close"")
	strGzip                = []byte(""gzip"")
	strBr                  = []byte(""br"")
	strDeflate             = []byte(""deflate"")
	strKeepAlive           = []byte(""keep-alive"")
	strUpgrade             = []byte(""Upgrade"")
	strChunked             = []byte(""chunked"")
	strIdentity            = []byte(""identity"")
	str100Continue         = []byte(""100-continue"")
	strPostArgsContentType = []byte(""application/x-www-form-urlencoded"")
	strDefaultContentType  = []byte(""application/octet-stream"")
	strMultipartFormData   = []byte(""multipart/form-data"")
	strBoundary            = []byte(""boundary"")
	strBytes               = []byte(""bytes"")
	strBasicSpace          = []byte(""Basic "")
	strApplicationSlash = []byte(""application/"")
	strImageSVG         = []byte(""image/svg"")
	strImageIcon        = []byte(""image/x-icon"")
	strFontSlash        = []byte(""font/"")
	strMultipartSlash   = []byte(""multipart/"")
	strTextSlash        = []byte(""text/"")
)
",CWE-22,95.0,0
"{
	""name"": ""ShortDescription"",
	""license-name"": ""GPL-3.0-or-later"",
	""version"": ""2.3.4"",
	""url"": ""https://www.mediawiki.org/wiki/Extension:ShortDescription"",
	""author"": [
		""alistair3149""
	],
	""namemsg"": ""shortdescription"",
	""descriptionmsg"": ""shortdescription-desc"",
	""type"": ""api"",
	""requires"": {
		""MediaWiki"": "">= 1.35.0""
	},
	""MessagesDirs"": {
		""ShortDescription"": [
			""i18n"",
			""i18n/api""
		]
	},
	""ResourceFileModulePaths"": {
		""localBasePath"": ""modules"",
		""remoteExtPath"": ""ShortDescription/modules""
	},
	""ResourceModules"": {
		""ext.shortDescription"": {
			""scripts"": [
				""ext.shortDescription.js""
			],
			""styles"": ""ext.shortDescription.less""
		}
	},
	""AutoloadNamespaces"": {
		""MediaWiki\\Extension\\ShortDescription\\"": ""includes/""
	},
	""APIPropModules"": {
		""description"": ""MediaWiki\\Extension\\ShortDescription\\ApiQueryDescription""
	},
	""ExtensionMessagesFiles"": {
		""ShortDescriptionMagic"": ""ShortDescription.i18n.magic.php""
	},
	""Hooks"": {
		""ApiOpenSearchSuggest"": ""api"",
		""BeforePageDisplay"": ""page"",
		""InfoAction"": ""actions"",
		""OutputPageParserOutput"": ""parser"",
		""ParserFirstCallInit"": ""parser"",
		""SearchResultProvideDescription"": ""rest""
	},
	""HookHandlers"": {
		""actions"": {
			""class"": ""MediaWiki\\Extension\\ShortDescription\\Hooks\\ActionsHooks""
		},
		""api"": {
			""class"": ""MediaWiki\\Extension\\ShortDescription\\Hooks\\ApiHooks""
		},
		""page"": {
			""class"": ""MediaWiki\\Extension\\ShortDescription\\Hooks\\PageHooks""
		},
		""parser"": {
			""class"": ""MediaWiki\\Extension\\ShortDescription\\Hooks\\ParserHooks""
		},
		""rest"": {
			""class"": ""MediaWiki\\Extension\\ShortDescription\\Hooks\\RestHooks""
		}
	},
	""config"": {
		""ShortDescriptionEnableTagline"": {
			""value"": true,
			""description"": ""Enable short description in site tagline.""
		},
		""ShortDescriptionExtendOpenSearchXml"": {
			""value"": false,
			""description"": ""Provide short description to the Opensearch API module.""
		}
	},
	""ConfigRegistry"": {
		""shortdescription"": ""GlobalVarConfig::newInstance""
	},
	""manifest_version"": 2
}
",CWE-79,82.0,0
"package auth
import (
	""time""
	""github.com/golang-jwt/jwt""
	""github.com/sipcapture/homer-app/config""
	""github.com/sipcapture/homer-app/model""
	""github.com/sipcapture/homer-app/utils/logger""
)
// jwt token claims which contains info regarding user
type JwtUserClaim struct {
	UserName        string `json:""username""`
	UserAdmin       bool   `json:""useradmin""`
	UserGroup       string `json:""usergroup""`
	ExternalAuth    bool   `json:""externalauth""`
	ExternalProfile string `json:""externaltype""`
	DisplayName     string `json:""displayname""`
	Avatar          string `json:""avatar""`
	jwt.StandardClaims
}
func Token(user model.TableUser) (string, error) {
	tNow := time.Now()
	tUTC := tNow
	newTUTC := tUTC.Add(time.Duration(TokenExpiryTime) * time.Minute)
	// Set custom claims
	claims := &JwtUserClaim{
		user.UserName,
		user.IsAdmin,
		user.UserGroup,
		user.ExternalAuth,
		user.ExternalProfile,
		user.FirstName + "" "" + user.LastName,
		user.Avatar,
		jwt.StandardClaims{
			ExpiresAt: newTUTC.Unix(),
		},
	}
	logger.Debug(""Current time : "", tNow)
	logger.Debug(""Local time : "", tUTC)
	logger.Debug(""Expire Local time : "", newTUTC)
	// Create token with claims
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	// Generate encoded token and send it as response.
	t, err := token.SignedString([]byte(config.Setting.AUTH_SETTINGS.JwtSecret))
	if err != nil {
		return """", err
	}
	return t, nil
}
",CWE-798,60.0,0
"package config
import (
	""net/http""
	""github.com/sipcapture/homer-app/model""
	""golang.org/x/oauth2""
)
var Setting HomerSettingServer
var OAuth2TokenMap map[string]model.OAuth2MapToken
type HomerSettingServer struct {
	MAIN_SETTINGS struct {
		IsolateQuery        string `default:""""`
		IsolateGroup        string `default:""""`
		UseCaptureIDInAlias bool   `default:""false""`
		DefaultAuth         string `default:""internal""`
		EnableGravatar      bool   `default:""false""`
		GravatarUrl         string `default:""https://www.gravatar.com/avatar/%s.jpg""`
		OAuth2Config        oauth2.Config
		GlobalToken         *oauth2.Token
		UserGroups          []string `default:""[admin,user,support]""`
		SubscribeHttpClient *http.Client
		TimeoutHttpClient   uint32 `default:""10""`
	}
	GRAFANA_SETTINGS struct {
		URL      string `default:""http://grafana/""`
		AuthKey  string `default:""""`
		User     string `default:""""`
		Password string `default:""""`
		Path     string `default:""/grafana""`
		Enable   bool   `default:""false""`
	}
	TRANSACTION_SETTINGS struct {
		DedupModel        string `default:""message-ip-pair""`
		GlobalDeduplicate bool   `default:""false""`
	}
	DASHBOARD_SETTINGS struct {
		ExternalHomeDashboard string `default:""""`
	}
	AUTH_SETTINGS struct {
		JwtSecret string `default:""""`
	}
	OAUTH2_SETTINGS struct {
		Enable               bool     `default:""false""`
		ClientID             string   `default:""1234565""`
		ClientSecret         string   `default:""FAKE""`
		ProjectID            string   `default:""Homer Oauth2""`
		AuthUri              string   `default:""https://accounts.google.com/o/oauth2/auth""`
		TokenUri             string   `default:""https://oauth2.googleapis.com/token""`
		AuthProviderCert     string   `default:""https://www.googleapis.com/oauth2/v1/certs""`
		RedirectUri          string   `default:""http://localhost:80/api/v3/oauth2/auth""`
		ProfileURL           string   `default:""https://www.googleapis.com/oauth2/v1/userinfo""`
		Method               string   `default:""GET""`
		UserToken            string   `default:""checkRandom""`
		ServiceProviderName  string   `default:""google""`
		ServiceProviderImage string   `default:""""`
		StateValue           string   `default:""jkwh027yasj""`
		UrlToServiceRedirect string   `default:""/api/v3/oauth2/redirect""`
		Scope                []string `default:""[email,openid,profile]""`
		EnableGravatar       bool     `default:""false""`
		AuthStyle            int      `default:""0""`
		GravatarUrl          string   `default:""https://www.gravatar.com/avatar/%s.jpg""`
		ExpireSSOToken       uint32   `default:""5""`
	}
	LOG_SETTINGS struct {
		Enable        bool   `default:""true""`
		MaxAgeDays    uint32 `default:""7""`
		RotationHours uint32 `default:""24""`
		Path          string `default:""/usr/local/homer/log""`
		Level         string `default:""error""`
		Name          string `default:""homer-app.log""`
		Stdout        bool   `default:""false""`
		Json          bool   `default:""true""`
		SysLogLevel   string `default:""LOG_INFO""`
		SysLog        bool   `default:""false""`
		SyslogUri     string `default:""""`
	}
	SWAGGER struct {
		Enable  bool   `default:""true""`
		ApiJson string `default:""/usr/local/homer/etc/swagger.json""`
		ApiHost string `default:""127.0.0.1:9080""`
	}
	DECODER_SHARK struct {
		Bin        string   `default:""/usr/local/bin/tshark""`
		Param      string   `default:""""`
		Protocols  []string `default:""""`
		UID        uint32   `default:""0""`
		GID        uint32   `default:""0""`
		ImportNode string   `default:""""`
		Enable     bool     `default:""false""`
	}
}
",CWE-798,104.0,0
"package main
//VERSION
var VERSION_APPLICATION = ""1.4.28""
//NAME
var NAME_APPLICATION = ""homer-app""
func getVersion() string {
	return VERSION_APPLICATION
}
func getName() string {
	return NAME_APPLICATION
}
",CWE-798,16.0,0
"// Copyright 2019 The Nakama Authors
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package server
import (
	""context""
	""crypto""
	""database/sql""
	""errors""
	""fmt""
	""github.com/gofrs/uuid""
	""google.golang.org/protobuf/types/known/emptypb""
	""time""
	jwt ""github.com/golang-jwt/jwt/v4""
	""github.com/heroiclabs/nakama/v3/console""
	""github.com/jackc/pgtype""
	""go.uber.org/zap""
	""golang.org/x/crypto/bcrypt""
	""google.golang.org/grpc/codes""
	""google.golang.org/grpc/status""
)
type ConsoleTokenClaims struct {
	ID        string           `json:""id,omitempty""`
	Username  string           `json:""usn,omitempty""`
	Email     string           `json:""ema,omitempty""`
	Role      console.UserRole `json:""rol,omitempty""`
	ExpiresAt int64            `json:""exp,omitempty""`
	Cookie    string           `json:""cki,omitempty""`
}
func (stc *ConsoleTokenClaims) Valid() error {
	// Verify expiry.
	if stc.ExpiresAt <= time.Now().UTC().Unix() {
		vErr := new(jwt.ValidationError)
		vErr.Inner = errors.New(""Token is expired"")
		vErr.Errors |= jwt.ValidationErrorExpired
		return vErr
	}
	return nil
}
func parseConsoleToken(hmacSecretByte []byte, tokenString string) (id, username, email string, role console.UserRole, exp int64, ok bool) {
	token, err := jwt.ParseWithClaims(tokenString, &ConsoleTokenClaims{}, func(token *jwt.Token) (interface{}, error) {
		if s, ok := token.Method.(*jwt.SigningMethodHMAC); !ok || s.Hash != crypto.SHA256 {
			return nil, fmt.Errorf(""unexpected signing method: %v"", token.Header[""alg""])
		}
		return hmacSecretByte, nil
	})
	if err != nil {
		return
	}
	claims, ok := token.Claims.(*ConsoleTokenClaims)
	if !ok || !token.Valid {
		return
	}
	return claims.ID, claims.Username, claims.Email, claims.Role, claims.ExpiresAt, true
}
func (s *ConsoleServer) Authenticate(ctx context.Context, in *console.AuthenticateRequest) (*console.ConsoleSession, error) {
	role := console.UserRole_USER_ROLE_UNKNOWN
	var uname string
	var email string
	var id uuid.UUID
	switch in.Username {
	case s.config.GetConsole().Username:
		if in.Password == s.config.GetConsole().Password {
			role = console.UserRole_USER_ROLE_ADMIN
			uname = in.Username
			id = uuid.Nil
		}
	default:
		var err error
		id, uname, email, role, err = s.lookupConsoleUser(ctx, in.Username, in.Password)
		if err != nil {
			return nil, err
		}
	}
	if role == console.UserRole_USER_ROLE_UNKNOWN {
		return nil, status.Error(codes.Unauthenticated, ""Invalid credentials."")
	}
	exp := time.Now().UTC().Add(time.Duration(s.config.GetConsole().TokenExpirySec) * time.Second).Unix()
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, &ConsoleTokenClaims{
		ExpiresAt: exp,
		ID:        id.String(),
		Username:  uname,
		Email:     email,
		Role:      role,
		Cookie:    s.cookie,
	})
	key := []byte(s.config.GetConsole().SigningKey)
	signedToken, _ := token.SignedString(key)
	s.consoleSessionCache.Add(id, exp, signedToken, 0, """")
	return &console.ConsoleSession{Token: signedToken}, nil
}
func (s *ConsoleServer) AuthenticateLogout(ctx context.Context, in *console.AuthenticateLogoutRequest) (*emptypb.Empty, error) {
	token, err := jwt.Parse(in.Token, func(token *jwt.Token) (interface{}, error) {
		if s, ok := token.Method.(*jwt.SigningMethodHMAC); !ok || s.Hash != crypto.SHA256 {
			return nil, fmt.Errorf(""unexpected signing method: %v"", token.Header[""alg""])
		}
		return []byte(s.config.GetConsole().SigningKey), nil
	})
	if err != nil {
		s.logger.Error(""Failed to parse the session token."", zap.Error(err))
	}
	id, _, _, _, exp, ok := parseConsoleToken([]byte(s.config.GetConsole().SigningKey), in.Token)
	if !ok || !token.Valid {
		s.logger.Error(""Invalid token."", zap.Error(err))
	}
	idUuid, err := uuid.FromString(id)
	if id != """" && err == nil {
		s.consoleSessionCache.Remove(idUuid, exp, in.Token, 0, """")
	}
	return &emptypb.Empty{}, nil
}
func (s *ConsoleServer) lookupConsoleUser(ctx context.Context, unameOrEmail, password string) (id uuid.UUID, uname string, email string, role console.UserRole, err error) {
	role = console.UserRole_USER_ROLE_UNKNOWN
	query := ""SELECT id, username, email, role, password, disable_time FROM console_user WHERE username = $1 OR email = $1""
	var dbPassword []byte
	var dbDisableTime pgtype.Timestamptz
	err = s.db.QueryRowContext(ctx, query, unameOrEmail).Scan(&id, &uname, &email, &role, &dbPassword, &dbDisableTime)
	if err != nil {
		if err == sql.ErrNoRows {
			err = nil
		}
		return
	}
	// Check if it's disabled.
	if dbDisableTime.Status == pgtype.Present && dbDisableTime.Time.Unix() != 0 {
		s.logger.Info(""Console user account is disabled."", zap.String(""username"", unameOrEmail))
		err = status.Error(codes.PermissionDenied, ""Invalid credentials."")
		return
	}
	// Check password
	err = bcrypt.CompareHashAndPassword(dbPassword, []byte(password))
	if err != nil {
		err = status.Error(codes.Unauthenticated, ""Invalid credentials."")
		return
	}
	return
}
",CWE-613,165.0,0
"// Copyright 2021 The Nakama Authors
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package server
import (
	""context""
	""sync""
	""time""
	""github.com/gofrs/uuid""
)
type SessionCache interface {
	Stop()
	// Check if a given user, expiry, and session token combination is valid.
	IsValidSession(userID uuid.UUID, exp int64, token string) bool
	// Check if a given user, expiry, and refresh token combination is valid.
	IsValidRefresh(userID uuid.UUID, exp int64, token string) bool
	// Add a valid session and/or refresh token for a given user.
	Add(userID uuid.UUID, sessionExp int64, sessionToken string, refreshExp int64, refreshToken string)
	// Remove a session and/or refresh token for a given user.
	Remove(userID uuid.UUID, sessionExp int64, sessionToken string, refreshExp int64, refreshToken string)
	// Remove all of a user's session and refresh tokens.
	RemoveAll(userID uuid.UUID)
	// Mark a set of users as banned.
	Ban(userIDs []uuid.UUID)
	// Unban a set of users.
	Unban(userIDs []uuid.UUID)
}
type sessionCacheUser struct {
	sessionTokens map[string]int64
	refreshTokens map[string]int64
}
type LocalSessionCache struct {
	sync.RWMutex
	config Config
	ctx         context.Context
	ctxCancelFn context.CancelFunc
	cache map[uuid.UUID]*sessionCacheUser
}
func NewLocalSessionCache(config Config, tokenExpirySec int64) SessionCache {
	ctx, ctxCancelFn := context.WithCancel(context.Background())
	s := &LocalSessionCache{
		config: config,
		ctx:         ctx,
		ctxCancelFn: ctxCancelFn,
		cache: make(map[uuid.UUID]*sessionCacheUser),
	}
	go func() {
		ticker := time.NewTicker(2 * time.Duration(tokenExpirySec) * time.Second)
		for {
			select {
			case <-s.ctx.Done():
				ticker.Stop()
				return
			case t := <-ticker.C:
				tMs := t.UTC().Unix()
				s.Lock()
				for userID, cache := range s.cache {
					for token, exp := range cache.sessionTokens {
						if exp <= tMs {
							delete(cache.sessionTokens, token)
						}
					}
					for token, exp := range cache.refreshTokens {
						if exp <= tMs {
							delete(cache.refreshTokens, token)
						}
					}
					if len(cache.sessionTokens) == 0 && len(cache.refreshTokens) == 0 {
						delete(s.cache, userID)
					}
				}
				s.Unlock()
			}
		}
	}()
	return s
}
func (s *LocalSessionCache) Stop() {
	s.ctxCancelFn()
}
func (s *LocalSessionCache) IsValidSession(userID uuid.UUID, exp int64, token string) bool {
	s.RLock()
	cache, found := s.cache[userID]
	if !found {
		s.RUnlock()
		return false
	}
	_, found = cache.sessionTokens[token]
	s.RUnlock()
	return found
}
func (s *LocalSessionCache) IsValidRefresh(userID uuid.UUID, exp int64, token string) bool {
	s.RLock()
	cache, found := s.cache[userID]
	if !found {
		s.RUnlock()
		return false
	}
	_, found = cache.refreshTokens[token]
	s.RUnlock()
	return found
}
func (s *LocalSessionCache) Add(userID uuid.UUID, sessionExp int64, sessionToken string, refreshExp int64, refreshToken string) {
	s.Lock()
	cache, found := s.cache[userID]
	if !found {
		cache = &sessionCacheUser{
			sessionTokens: make(map[string]int64),
			refreshTokens: make(map[string]int64),
		}
		s.cache[userID] = cache
	}
	if sessionToken != """" {
		cache.sessionTokens[sessionToken] = sessionExp + 1
	}
	if refreshToken != """" {
		cache.refreshTokens[refreshToken] = refreshExp + 1
	}
	s.Unlock()
}
func (s *LocalSessionCache) Remove(userID uuid.UUID, sessionExp int64, sessionToken string, refreshExp int64, refreshToken string) {
	s.Lock()
	cache, found := s.cache[userID]
	if !found {
		s.Unlock()
		return
	}
	if sessionToken != """" {
		delete(cache.sessionTokens, sessionToken)
	}
	if refreshToken != """" {
		delete(cache.refreshTokens, refreshToken)
	}
	if len(cache.sessionTokens) == 0 && len(cache.refreshTokens) == 0 {
		delete(s.cache, userID)
	}
	s.Unlock()
}
func (s *LocalSessionCache) RemoveAll(userID uuid.UUID) {
	s.Lock()
	delete(s.cache, userID)
	s.Unlock()
}
func (s *LocalSessionCache) Ban(userIDs []uuid.UUID) {
	s.Lock()
	for _, userID := range userIDs {
		delete(s.cache, userID)
	}
	s.Unlock()
}
func (s *LocalSessionCache) Unban(userIDs []uuid.UUID) {}
",CWE-613,185.0,0
"// Copyright 2022 The Nakama Authors
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package server
import (
	""context""
	""sync""
	""time""
)
type LockoutType uint8
const (
	LockoutTypeNone LockoutType = iota
	LockoutTypeAccount
	LockoutTypeIp
)
const (
	maxAttemptsAccount   = 5
	lockoutPeriodAccount = time.Minute * 1
	maxAttemptsIp   = 10
	lockoutPeriodIp = time.Minute * 10
)
type LoginAttemptCache interface {
	Stop()
	// Allow checks whether account or IP is locked out or should be allowed to attempt to authenticate.
	Allow(account, ip string) bool
	// Add a failed attempt and return current lockout status.
	Add(account, ip string) (LockoutType, time.Time)
	// Reset account attempts on successful login.
	Reset(account string)
}
type lockoutStatus struct {
	lockedUntil time.Time
	attempts    []time.Time
}
func (ls *lockoutStatus) trim(now time.Time, retentionPeriod time.Duration) bool {
	if ls.lockedUntil.Before(now) {
		ls.lockedUntil = time.Time{}
	}
	for i := len(ls.attempts) - 1; i >= 0; i-- {
		if now.Sub(ls.attempts[i]) >= retentionPeriod {
			ls.attempts = ls.attempts[i+1:]
			break
		}
	}
	return ls.lockedUntil.IsZero() && len(ls.attempts) == 0
}
type LocalLoginAttemptCache struct {
	sync.RWMutex
	ctx         context.Context
	ctxCancelFn context.CancelFunc
	accountCache map[string]*lockoutStatus
	ipCache      map[string]*lockoutStatus
}
func NewLocalLoginAttemptCache() LoginAttemptCache {
	ctx, ctxCancelFn := context.WithCancel(context.Background())
	c := &LocalLoginAttemptCache{
		accountCache: make(map[string]*lockoutStatus),
		ipCache:      make(map[string]*lockoutStatus),
		ctx:         ctx,
		ctxCancelFn: ctxCancelFn,
	}
	go func() {
		ticker := time.NewTicker(10 * time.Minute)
		for {
			select {
			case <-c.ctx.Done():
				ticker.Stop()
				return
			case t := <-ticker.C:
				now := t.UTC()
				c.Lock()
				for account, status := range c.accountCache {
					if status.trim(now, lockoutPeriodAccount) {
						delete(c.accountCache, account)
					}
				}
				for ip, status := range c.ipCache {
					if status.trim(now, lockoutPeriodIp) {
						delete(c.ipCache, ip)
					}
				}
				c.Unlock()
			}
		}
	}()
	return c
}
func (c *LocalLoginAttemptCache) Stop() {
	c.ctxCancelFn()
}
func (c *LocalLoginAttemptCache) Allow(account, ip string) bool {
	now := time.Now().UTC()
	c.RLock()
	defer c.RUnlock()
	if status, found := c.accountCache[account]; found && !status.lockedUntil.IsZero() && status.lockedUntil.After(now) {
		return false
	}
	if status, found := c.ipCache[ip]; found && !status.lockedUntil.IsZero() && status.lockedUntil.After(now) {
		return false
	}
	return true
}
func (c *LocalLoginAttemptCache) Reset(account string) {
	c.Lock()
	delete(c.accountCache, account)
	c.Unlock()
}
func (c *LocalLoginAttemptCache) Add(account, ip string) (LockoutType, time.Time) {
	now := time.Now().UTC()
	var lockoutType LockoutType
	var lockedUntil time.Time
	c.Lock()
	defer c.Unlock()
	if account != """" {
		status, found := c.accountCache[account]
		if !found {
			status = &lockoutStatus{}
			c.accountCache[account] = status
		}
		status.attempts = append(status.attempts, now)
		_ = status.trim(now, lockoutPeriodAccount)
		if len(status.attempts) >= maxAttemptsAccount {
			status.lockedUntil = now.Add(lockoutPeriodAccount)
			lockedUntil = status.lockedUntil
			lockoutType = LockoutTypeAccount
		}
	}
	if ip != """" {
		status, found := c.ipCache[ip]
		if !found {
			status = &lockoutStatus{}
			c.ipCache[ip] = status
		}
		status.attempts = append(status.attempts, now)
		_ = status.trim(now, lockoutPeriodIp)
		if len(status.attempts) >= maxAttemptsIp {
			status.lockedUntil = now.Add(lockoutPeriodIp)
			lockedUntil = status.lockedUntil
			lockoutType = LockoutTypeIp
		}
	}
	return lockoutType, lockedUntil
}
",CWE-307,175.0,0
"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: MIT
package main
import (
	""flag""
	""log""
	""os""
	""os/user""
	""path/filepath""
	""github.com/aws/amazon-cloudwatch-agent/cfg/commonconfig""
	""github.com/aws/amazon-cloudwatch-agent/translator""
	""github.com/aws/amazon-cloudwatch-agent/translator/cmdutil""
	""github.com/aws/amazon-cloudwatch-agent/translator/context""
	translatorUtil ""github.com/aws/amazon-cloudwatch-agent/translator/util""
)
const (
	exitErrorMessage  = ""Configuration validation first phase failed. Agent version: %v. Verify the JSON input is only using features supported by this version.\n""
	version           = ""1.0""
	envConfigFileName = ""env-config.json""
)
func initFlags() {
	var inputOs = flag.String(""os"", """", ""Please provide the os preference, valid value: windows/linux."")
	var inputJsonFile = flag.String(""input"", """", ""Please provide the path of input agent json config file"")
	var inputJsonDir = flag.String(""input-dir"", """", ""Please provide the path of input agent json config directory."")
	var inputTomlFile = flag.String(""output"", """", ""Please provide the path of the output CWAgent config file"")
	var inputMode = flag.String(""mode"", ""ec2"", ""Please provide the mode, i.e. ec2, onPremise, onPrem, auto"")
	var inputConfig = flag.String(""config"", """", ""Please provide the common-config file"")
	var multiConfig = flag.String(""multi-config"", ""remove"", ""valid values: default, append, remove"")
	flag.Parse()
	ctx := context.CurrentContext()
	ctx.SetOs(*inputOs)
	ctx.SetInputJsonFilePath(*inputJsonFile)
	ctx.SetInputJsonDirPath(*inputJsonDir)
	ctx.SetMultiConfig(*multiConfig)
	ctx.SetOutputTomlFilePath(*inputTomlFile)
	if *inputConfig != """" {
		f, err := os.Open(*inputConfig)
		if err != nil {
			log.Fatalf(""E! Failed to open common-config file %s with error: %v"", *inputConfig, err)
		}
		defer f.Close()
		conf, err := commonconfig.Parse(f)
		if err != nil {
			log.Fatalf(""E! Failed to parse common-config file %s with error: %v"", *inputConfig, err)
		}
		ctx.SetCredentials(conf.CredentialsMap())
		ctx.SetProxy(conf.ProxyMap())
		ctx.SetSSL(conf.SSLMap())
	}
	translatorUtil.SetProxyEnv(ctx.Proxy())
	translatorUtil.SetSSLEnv(ctx.SSL())
	ctx.SetMode(translatorUtil.DetectAgentMode(*inputMode))
}
/**
 *	config-translator --input ${JSON} --input-dir ${JSON_DIR} --output ${TOML} --mode ${param_mode} --config ${COMMON_CONFIG}
 *  --multi-config [default|append|remove]
 *
 *		multi-config:
 *			default:	only process .tmp files
 *			append:		process both existing files and .tmp files
 *			remove:		only process existing files
 */
func main() {
	initFlags()
	defer func() {
		if r := recover(); r != nil {
			// Only emit error message if panic content is string(pre-checked)
			// Not emitting the non-handled error message for now, we don't want to show non-user-friendly error message to customer
			if val, ok := r.(string); ok {
				log.Println(val)
			}
			//If the Input JSON config file is invalid, output all the error path and error messages.
			for _, errMessage := range translator.ErrorMessages {
				log.Println(errMessage)
			}
			log.Printf(exitErrorMessage, version)
			os.Exit(1)
		}
	}()
	ctx := context.CurrentContext()
	mergedJsonConfigMap, err := cmdutil.GenerateMergedJsonConfigMap(ctx)
	if err != nil {
		log.Panicf(""E! Failed to generate merged json config: %v"", err)
	}
	if !ctx.RunInContainer() {
		// run as user only applies to non container situation.
		current, err := user.Current()
		if err == nil && current.Name == ""root"" {
			runAsUser, err := cmdutil.DetectRunAsUser(mergedJsonConfigMap)
			if err != nil {
				log.Panic(""E! Failed to detectRunAsUser"")
			}
			cmdutil.VerifyCredentials(ctx, runAsUser)
		}
	}
	tomlConfigPath := cmdutil.GetTomlConfigPath(ctx.OutputTomlFilePath())
	cmdutil.TranslateJsonMapToTomlFile(mergedJsonConfigMap, tomlConfigPath)
	// Put env config into the same folder as the toml config.
	envConfigPath := filepath.Join(filepath.Dir(tomlConfigPath), envConfigFileName)
	cmdutil.TranslateJsonMapToEnvConfigFile(mergedJsonConfigMap, envConfigPath)
}
",CWE-274,113.0,0
"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: MIT
package config
const (
	ModeEC2       = ""ec2""
	ModeOnPrem    = ""onPrem""
        ModeOnPremise = ""onPremise""
)
",CWE-274,11.0,0
"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: MIT
package context
import (
	""log""
	""os""
	""github.com/aws/amazon-cloudwatch-agent/translator/config""
)
const (
	TmpFileSuffix = "".tmp""
)
var ctx *Context
func CurrentContext() *Context {
	if ctx == nil {
		ctx = &Context{
			credentials:         make(map[string]string),
			proxy:               make(map[string]string),
			cloudWatchLogConfig: make(map[string]interface{}),
			runInContainer:      os.Getenv(config.RUN_IN_CONTAINER) == config.RUN_IN_CONTAINER_TRUE,
		}
	}
	return ctx
}
//Testing only
func ResetContext() {
	ctx = nil
}
type Context struct {
	os                  string
	inputJsonFilePath   string
	inputJsonDirPath    string
	multiConfig         string
	outputTomlFilePath  string
	mode                string
	credentials         map[string]string
	proxy               map[string]string
	ssl                 map[string]string
	cloudWatchLogConfig map[string]interface{}
	runInContainer      bool
}
func (ctx *Context) Os() string {
	return ctx.os
}
func (ctx *Context) SetOs(os string) {
	ctx.os = config.ToValidOs(os)
}
func (ctx *Context) InputJsonFilePath() string {
	return ctx.inputJsonFilePath
}
func (ctx *Context) SetInputJsonFilePath(inputJsonFilePath string) {
	ctx.inputJsonFilePath = inputJsonFilePath
}
func (ctx *Context) InputJsonDirPath() string {
	return ctx.inputJsonDirPath
}
func (ctx *Context) SetInputJsonDirPath(inputJsonDirPath string) {
	ctx.inputJsonDirPath = inputJsonDirPath
}
func (ctx *Context) MultiConfig() string {
	return ctx.multiConfig
}
func (ctx *Context) SetMultiConfig(multiConfig string) {
	ctx.multiConfig = multiConfig
}
func (ctx *Context) OutputTomlFilePath() string {
	return ctx.outputTomlFilePath
}
func (ctx *Context) SetOutputTomlFilePath(outputTomlFilePath string) {
	ctx.outputTomlFilePath = outputTomlFilePath
}
func (ctx *Context) Mode() string {
	if ctx.mode == """" {
		ctx.mode = config.ModeEC2
	}
	return ctx.mode
}
func (ctx *Context) Credentials() map[string]string {
	return ctx.credentials
}
func (ctx *Context) SSL() map[string]string {
	return ctx.ssl
}
func (ctx *Context) Proxy() map[string]string {
	return ctx.proxy
}
func (ctx *Context) SetMode(mode string) {
	switch mode {
	case config.ModeEC2:
		ctx.mode = config.ModeEC2
	case config.ModeOnPrem,config.ModeOnPremise:
		ctx.mode = config.ModeOnPrem
	default:
		log.Panicf(""Invalid mode %s. Valid mode values are %s and %s."", mode, config.ModeEC2, config.ModeOnPrem)
	}
}
func (ctx *Context) SetCredentials(creds map[string]string) {
	ctx.credentials = creds
}
func (ctx *Context) SetSSL(ssl map[string]string) {
	ctx.ssl = ssl
}
func (ctx *Context) SetProxy(proxy map[string]string) {
	ctx.proxy = proxy
}
func (ctx *Context) SetCloudWatchLogConfig(config map[string]interface{}) {
	ctx.cloudWatchLogConfig = config
}
func (ctx *Context) CloudWatchLogConfig() map[string]interface{} {
	return ctx.cloudWatchLogConfig
}
func (ctx *Context) RunInContainer() bool {
	return ctx.runInContainer
}
func (ctx *Context) SetRunInContainer(runInContainer bool) {
	ctx.runInContainer = runInContainer
}
",CWE-274,147.0,0
"//
// Copyright 2021 The Sigstore Authors.
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package sget
import (
	""context""
	""io""
	""github.com/google/go-containerregistry/pkg/authn""
	""github.com/google/go-containerregistry/pkg/name""
	""github.com/google/go-containerregistry/pkg/v1/remote""
	""github.com/pkg/errors""
	""github.com/sigstore/cosign/cmd/cosign/cli/fulcio""
	""github.com/sigstore/cosign/cmd/cosign/cli/options""
	""github.com/sigstore/cosign/cmd/cosign/cli/verify""
	""github.com/sigstore/cosign/pkg/cosign""
	ociremote ""github.com/sigstore/cosign/pkg/oci/remote""
	sigs ""github.com/sigstore/cosign/pkg/signature""
)
func New(image, key string, out io.Writer) *SecureGet {
	return &SecureGet{
		ImageRef: image,
		KeyRef:   key,
		Out:      out,
	}
}
type SecureGet struct {
	ImageRef string
	KeyRef   string
	Out      io.Writer
}
func (sg *SecureGet) Do(ctx context.Context) error {
	ref, err := name.ParseReference(sg.ImageRef)
	if err != nil {
		return err
	}
	opts := []remote.Option{
		remote.WithAuthFromKeychain(authn.DefaultKeychain),
		remote.WithContext(ctx),
	}
	co := &cosign.CheckOpts{
		ClaimVerifier:      cosign.SimpleClaimVerifier,
		RegistryClientOpts: []ociremote.Option{ociremote.WithRemoteOptions(opts...)},
	}
	if _, ok := ref.(name.Tag); ok {
		if sg.KeyRef == """" && !options.EnableExperimental() {
			return errors.New(""public key must be specified when fetching by tag, you must fetch by digest or supply a public key"")
		}
	}
	// Overwrite ""ref"" with a digest to avoid a race where we verify the tag,
	// and then access the file through the tag.  This has a race where we
	// might download content that isn't what we verified.
	ref, err = ociremote.ResolveDigest(ref, co.RegistryClientOpts...)
	if err != nil {
		return err
	}
	if sg.KeyRef != """" {
		pub, err := sigs.LoadPublicKey(ctx, sg.KeyRef)
		if err != nil {
			return err
		}
		co.SigVerifier = pub
	}
	if co.SigVerifier != nil || options.EnableExperimental() {
		// NB: There are only 2 kinds of verification right now:
		// 1. You gave us the public key explicitly to verify against so co.SigVerifier is non-nil or,
		// 2. We're going to find an x509 certificate on the signature and verify against Fulcio root trust
		// TODO(nsmith5): Refactor this verification logic to pass back _how_ verification
		// was performed so we don't need to use this fragile logic here.
		fulcioVerified := (co.SigVerifier == nil)
		co.RootCerts = fulcio.GetRoots()
		sp, bundleVerified, err := cosign.VerifyImageSignatures(ctx, ref, co)
		if err != nil {
			return err
		}
		verify.PrintVerificationHeader(sg.ImageRef, co, bundleVerified, fulcioVerified)
		verify.PrintVerification(sg.ImageRef, sp, ""text"")
	}
	// TODO(mattmoor): Depending on what this is, use the higher-level stuff.
	img, err := remote.Image(ref, opts...)
	if err != nil {
		return err
	}
	layers, err := img.Layers()
	if err != nil {
		return err
	}
	if len(layers) != 1 {
		return errors.New(""invalid artifact"")
	}
	rc, err := layers[0].Compressed()
	if err != nil {
		return err
	}
	_, err = io.Copy(sg.Out, rc)
	return err
}
",CWE-295,123.0,0
"// Copyright 2022 The Sigstore Authors.
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package mock
import (
	""errors""
	""github.com/go-openapi/runtime""
	""github.com/sigstore/rekor/pkg/generated/client/entries""
	""github.com/sigstore/rekor/pkg/generated/models""
)
// EntriesClient is a client that implements entries.ClientService for Rekor
// To use:
// var mClient client.Rekor
// mClient.Entries = &logEntry
type EntriesClient struct {
	Entries *models.LogEntry
}
func (m *EntriesClient) CreateLogEntry(params *entries.CreateLogEntryParams, opts ...entries.ClientOption) (*entries.CreateLogEntryCreated, error) {
	if m.Entries != nil {
		return &entries.CreateLogEntryCreated{
			ETag:     """",
			Location: """",
			Payload:  *m.Entries,
		}, nil
	}
	return nil, errors.New(""entry not provided"")
}
func (m *EntriesClient) GetLogEntryByIndex(params *entries.GetLogEntryByIndexParams, opts ...entries.ClientOption) (*entries.GetLogEntryByIndexOK, error) {
	if m.Entries != nil {
		return &entries.GetLogEntryByIndexOK{
			Payload: *m.Entries,
		}, nil
	}
	return nil, errors.New(""entry not provided"")
}
func (m *EntriesClient) GetLogEntryByUUID(params *entries.GetLogEntryByUUIDParams, opts ...entries.ClientOption) (*entries.GetLogEntryByUUIDOK, error) {
	if m.Entries != nil {
		return &entries.GetLogEntryByUUIDOK{
			Payload: *m.Entries,
		}, nil
	}
	return nil, errors.New(""entry not provided"")
}
func (m *EntriesClient) SearchLogQuery(params *entries.SearchLogQueryParams, opts ...entries.ClientOption) (*entries.SearchLogQueryOK, error) {
	resp := []models.LogEntry{}
	if m.Entries != nil {
		resp = append(resp, *m.Entries)
	}
	return &entries.SearchLogQueryOK{
		Payload: resp,
	}, nil
}
// TODO: Implement mock
func (m *EntriesClient) SetTransport(transport runtime.ClientTransport) {
}
",CWE-347,76.0,0
"// Copyright 2022 The Sigstore Authors.
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package rekor
import (
	""bytes""
	""context""
	""crypto""
	""encoding/base64""
	""strings""
	""testing""
	""github.com/go-openapi/swag""
	""github.com/sigstore/cosign/internal/pkg/cosign/payload""
	""github.com/sigstore/cosign/internal/pkg/cosign/rekor/mock""
	""github.com/sigstore/cosign/pkg/cosign""
	""github.com/sigstore/rekor/pkg/generated/client""
	""github.com/sigstore/rekor/pkg/generated/models""
	""github.com/sigstore/sigstore/pkg/signature""
)
func mustGetNewSigner(t *testing.T) signature.Signer {
	t.Helper()
	priv, err := cosign.GeneratePrivateKey()
	if err != nil {
		t.Fatalf(""cosign.GeneratePrivateKey() failed: %v"", err)
	}
	s, err := signature.LoadECDSASignerVerifier(priv, crypto.SHA256)
	if err != nil {
		t.Fatalf(""signature.LoadECDSASignerVerifier(key, crypto.SHA256) failed: %v"", err)
	}
	return s
}
func TestSigner(t *testing.T) {
	// Need real cert and chain
	payloadSigner := payload.NewSigner(mustGetNewSigner(t))
	// Mock out Rekor client
	var mClient client.Rekor
	mClient.Entries = &mock.EntriesClient{
		Entries: &models.LogEntry{""123"": models.LogEntryAnon{
			LogIndex: swag.Int64(123),
		}},
	}
	testSigner := NewSigner(payloadSigner, &mClient)
	testPayload := ""test payload""
	ociSig, pub, err := testSigner.Sign(context.Background(), strings.NewReader(testPayload))
	if err != nil {
		t.Fatalf(""Sign() returned error: %v"", err)
	}
	// Verify that the wrapped signer was called.
	verifier, err := signature.LoadVerifier(pub, crypto.SHA256)
	if err != nil {
		t.Fatalf(""signature.LoadVerifier(pub) returned error: %v"", err)
	}
	b64Sig, err := ociSig.Base64Signature()
	if err != nil {
		t.Fatalf(""ociSig.Base64Signature() returned error: %v"", err)
	}
	sig, err := base64.StdEncoding.DecodeString(b64Sig)
	if err != nil {
		t.Fatalf(""base64.StdEncoding.DecodeString(b64Sig) returned error: %v"", err)
	}
	gotPayload, err := ociSig.Payload()
	if err != nil {
		t.Fatalf(""ociSig.Payload() returned error: %v"", err)
	}
	if string(gotPayload) != testPayload {
		t.Errorf(""ociSig.Payload() returned %q, wanted %q"", string(gotPayload), testPayload)
	}
	if err = verifier.VerifySignature(bytes.NewReader(sig), bytes.NewReader(gotPayload)); err != nil {
		t.Errorf(""VerifySignature() returned error: %v"", err)
	}
}
",CWE-347,93.0,0
"module github.com/clastix/capsule-proxy
go 1.16
require (
	github.com/clastix/capsule v0.1.0
	github.com/go-logr/logr v0.4.0
	github.com/golang-jwt/jwt v3.2.2+incompatible
	github.com/gorilla/handlers v1.5.1
	github.com/gorilla/mux v1.8.0
	github.com/pkg/errors v0.9.1
	github.com/spf13/pflag v1.0.5
	go.uber.org/zap v1.18.1
	golang.org/x/net v0.0.0-20210520170846-37e1c6afe023
	k8s.io/api v0.22.0
	k8s.io/apimachinery v0.22.1
	k8s.io/apiserver v0.22.0
	k8s.io/client-go v0.22.0
	sigs.k8s.io/controller-runtime v0.9.5
)
",CWE-287,21.0,0
"// Package criteria implements a Criteria API based on Masterminds/squirrel
package criteria
import (
	""encoding/json""
	""errors""
	""strings""
	""github.com/navidrome/navidrome/log""
	""github.com/Masterminds/squirrel""
)
type Expression = squirrel.Sqlizer
type Criteria struct {
	Expression
	Sort   string
	Order  string
	Limit  int
	Offset int
}
func (c Criteria) OrderBy() string {
	if c.Sort == """" {
		c.Sort = ""title""
	}
	f := fieldMap[strings.ToLower(c.Sort)]
	var mapped string
	if f == nil {
		log.Error(""Invalid field in 'sort' field. Using 'title'"", ""sort"", c.Sort)
		mapped = fieldMap[""title""].field
	} else {
		if f.order == """" {
			mapped = f.field
		} else {
			mapped = f.order
		}
	}
	if c.Order != """" {
		if strings.EqualFold(c.Order, ""asc"") || strings.EqualFold(c.Order, ""desc"") {
			mapped = mapped + "" "" + c.Order
		} else {
			log.Error(""Invalid value in 'order' field. Valid values: 'asc', 'desc'"", ""order"", c.Order)
		}
	}
	return mapped
}
func (c Criteria) ToSql() (sql string, args []interface{}, err error) {
	return c.Expression.ToSql()
}
func (c Criteria) MarshalJSON() ([]byte, error) {
	aux := struct {
		All    []Expression `json:""all,omitempty""`
		Any    []Expression `json:""any,omitempty""`
		Sort   string       `json:""sort,omitempty""`
		Order  string       `json:""order,omitempty""`
		Limit  int          `json:""limit,omitempty""`
		Offset int          `json:""offset,omitempty""`
	}{
		Sort:   c.Sort,
		Order:  c.Order,
		Limit:  c.Limit,
		Offset: c.Offset,
	}
	switch rules := c.Expression.(type) {
	case Any:
		aux.Any = rules
	case All:
		aux.All = rules
	default:
		aux.All = All{rules}
	}
	return json.Marshal(aux)
}
func (c *Criteria) UnmarshalJSON(data []byte) error {
	var aux struct {
		All    unmarshalConjunctionType `json:""all""`
		Any    unmarshalConjunctionType `json:""any""`
		Sort   string                   `json:""sort""`
		Order  string                   `json:""order""`
		Limit  int                      `json:""limit""`
		Offset int                      `json:""offset""`
	}
	if err := json.Unmarshal(data, &aux); err != nil {
		return err
	}
	if len(aux.Any) > 0 {
		c.Expression = Any(aux.Any)
	} else if len(aux.All) > 0 {
		c.Expression = All(aux.All)
	} else {
		return errors.New(""invalid criteria json. missing rules (key 'all' or 'any')"")
	}
	c.Sort = aux.Sort
	c.Order = aux.Order
	c.Limit = aux.Limit
	c.Offset = aux.Offset
	return nil
}
",CWE-89,104.0,0
"/*
 * @Author: LinkLeong link@icewhale.org
 * @Date: 2022-07-26 18:13:22
 * @LastEditors: LinkLeong
 * @LastEditTime: 2022-08-04 20:10:31
 * @FilePath: /CasaOS/service/connections.go
 * @Description:
 * @Website: https://www.casaos.io
 * Copyright (c) 2022 by icewhale, All Rights Reserved.
 */
package service
import (
	""fmt""
	""github.com/IceWhaleTech/CasaOS/service/model""
	model2 ""github.com/IceWhaleTech/CasaOS/service/model""
	""github.com/moby/sys/mount""
	""golang.org/x/sys/unix""
	""gorm.io/gorm""
)
type ConnectionsService interface {
	GetConnectionsList() (connections []model2.ConnectionsDBModel)
	GetConnectionByHost(host string) (connections []model2.ConnectionsDBModel)
	GetConnectionByID(id string) (connections model2.ConnectionsDBModel)
	CreateConnection(connection *model2.ConnectionsDBModel)
	DeleteConnection(id string)
	UpdateConnection(connection *model2.ConnectionsDBModel)
	MountSmaba(username, host, directory, port, mountPoint, password string) error
	UnmountSmaba(mountPoint string) error
}
type connectionsStruct struct {
	db *gorm.DB
}
func (s *connectionsStruct) GetConnectionByHost(host string) (connections []model2.ConnectionsDBModel) {
	s.db.Select(""username,host,status,id"").Where(""host = ?"", host).Find(&connections)
	return
}
func (s *connectionsStruct) GetConnectionByID(id string) (connections model2.ConnectionsDBModel) {
	s.db.Select(""username,password,host,status,id,directories,mount_point,port"").Where(""id = ?"", id).First(&connections)
	return
}
func (s *connectionsStruct) GetConnectionsList() (connections []model2.ConnectionsDBModel) {
	s.db.Select(""username,host,port,status,id,mount_point"").Find(&connections)
	return
}
func (s *connectionsStruct) CreateConnection(connection *model2.ConnectionsDBModel) {
	s.db.Create(connection)
}
func (s *connectionsStruct) UpdateConnection(connection *model2.ConnectionsDBModel) {
	s.db.Save(connection)
}
func (s *connectionsStruct) DeleteConnection(id string) {
	s.db.Where(""id= ?"", id).Delete(&model.ConnectionsDBModel{})
}
func (s *connectionsStruct) MountSmaba(username, host, directory, port, mountPoint, password string) error {
	err := unix.Mount(
		fmt.Sprintf(""//%s/%s"", host, directory),
		mountPoint,
		""cifs"",
		unix.MS_NOATIME|unix.MS_NODEV|unix.MS_NOSUID,
		fmt.Sprintf(""username=%s,password=%s"", username, password),
	)
	return err
	//str := command2.ExecResultStr(""source "" + config.AppInfo.ShellPath + ""/helper.sh ;MountCIFS "" + username + "" "" + host + "" "" + directory + "" "" + port + "" "" + mountPoint + "" "" + password)
	//return str
}
func (s *connectionsStruct) UnmountSmaba(mountPoint string) error {
	return mount.Unmount(mountPoint)
}
func NewConnectionsService(db *gorm.DB) ConnectionsService {
	return &connectionsStruct{db: db}
}
",CWE-77,79.0,0
"module github.com/IceWhaleTech/CasaOS
go 1.20
require (
	github.com/Curtis-Milo/nat-type-identifier-go v0.0.0-20220215191915-18d42168c63d
	github.com/IceWhaleTech/CasaOS-Common v0.4.4-alpha4
	github.com/coreos/go-systemd v0.0.0-20191104093116-d3cd4ed1dbcf
	github.com/deckarep/golang-set/v2 v2.3.0
	github.com/deepmap/oapi-codegen v1.12.4
	github.com/disintegration/imaging v1.6.2
	github.com/dsoprea/go-exif/v3 v3.0.0-20221012082141-d21ac8e2de85
	github.com/getkin/kin-openapi v0.115.0
	github.com/gin-contrib/gzip v0.0.6
	github.com/gin-gonic/gin v1.9.0
	github.com/glebarez/sqlite v1.7.0
	github.com/go-ini/ini v1.67.0
	github.com/go-resty/resty/v2 v2.7.0
	github.com/golang/mock v1.6.0
	github.com/gomodule/redigo v1.8.9
	github.com/google/go-github/v36 v36.0.0
	github.com/googollee/go-socket.io v1.7.0
	github.com/gorilla/websocket v1.5.0
	github.com/h2non/filetype v1.1.3
	github.com/hirochachacha/go-smb2 v1.1.0
	github.com/json-iterator/go v1.1.12
	github.com/labstack/echo/v4 v4.10.2
	github.com/maruel/natural v1.1.0
	github.com/mholt/archiver/v3 v3.5.1
	github.com/mileusna/useragent v1.2.1
	github.com/moby/sys/mount v0.3.3
	github.com/moby/sys/mountinfo v0.6.2
	github.com/patrickmn/go-cache v2.1.0+incompatible
	github.com/pkg/errors v0.9.1
	github.com/robfig/cron/v3 v3.0.1
	github.com/samber/lo v1.38.1
	github.com/satori/go.uuid v1.2.0
	github.com/shirou/gopsutil/v3 v3.23.2
	github.com/sirupsen/logrus v1.9.0
	github.com/stretchr/testify v1.8.2
	github.com/tidwall/gjson v1.14.4
	go.uber.org/goleak v1.2.1
	go.uber.org/zap v1.24.0
	golang.org/x/crypto v0.8.0
	golang.org/x/oauth2 v0.6.0
	golang.org/x/sync v0.1.0
	golang.org/x/sys v0.7.0
	gorm.io/gorm v1.24.6
	gotest.tools v2.2.0+incompatible
)
require (
	github.com/andybalholm/brotli v1.0.5 // indirect
	github.com/apapsch/go-jsonmerge/v2 v2.0.0 // indirect
	github.com/benbjohnson/clock v1.3.0 // indirect
	github.com/bytedance/sonic v1.8.5 // indirect
	github.com/chenzhuoyu/base64x v0.0.0-20221115062448-fe3a3abad311 // indirect
	github.com/coreos/go-systemd/v22 v22.5.0 // indirect
	github.com/davecgh/go-spew v1.1.1 // indirect
	github.com/dsnet/compress v0.0.2-0.20210315054119-f66993602bf5 // indirect
	github.com/dsoprea/go-logging v0.0.0-20200710184922-b02d349568dd // indirect
	github.com/dsoprea/go-utility/v2 v2.0.0-20221003172846-a3e1774ef349 // indirect
	github.com/dustin/go-humanize v1.0.1 // indirect
	github.com/geoffgarside/ber v1.1.0 // indirect
	github.com/gin-contrib/sse v0.1.0 // indirect
	github.com/glebarez/go-sqlite v1.21.0 // indirect
	github.com/go-errors/errors v1.4.2 // indirect
	github.com/go-ole/go-ole v1.2.6 // indirect
	github.com/go-openapi/jsonpointer v0.19.6 // indirect
	github.com/go-openapi/swag v0.22.3 // indirect
	github.com/go-playground/locales v0.14.1 // indirect
	github.com/go-playground/universal-translator v0.18.1 // indirect
	github.com/go-playground/validator/v10 v10.12.0 // indirect
	github.com/goccy/go-json v0.10.2 // indirect
	github.com/godbus/dbus/v5 v5.1.0 // indirect
	github.com/gofrs/uuid v4.4.0+incompatible // indirect
	github.com/golang-jwt/jwt v3.2.2+incompatible // indirect
	github.com/golang-jwt/jwt/v4 v4.5.0 // indirect
	github.com/golang/geo v0.0.0-20210211234256-740aa86cb551 // indirect
	github.com/golang/protobuf v1.5.3 // indirect
	github.com/golang/snappy v0.0.4 // indirect
	github.com/google/go-cmp v0.5.9 // indirect
	github.com/google/go-querystring v1.1.0 // indirect
	github.com/google/uuid v1.3.0 // indirect
	github.com/gorilla/mux v1.8.0 // indirect
	github.com/invopop/yaml v0.2.0 // indirect
	github.com/jinzhu/inflection v1.0.0 // indirect
	github.com/jinzhu/now v1.1.5 // indirect
	github.com/josharian/intern v1.0.0 // indirect
	github.com/klauspost/compress v1.16.5 // indirect
	github.com/klauspost/cpuid/v2 v2.2.4 // indirect
	github.com/klauspost/pgzip v1.2.5 // indirect
	github.com/kr/pretty v0.3.1 // indirect
	github.com/labstack/gommon v0.4.0 // indirect
	github.com/leodido/go-urn v1.2.3 // indirect
	github.com/lufia/plan9stats v0.0.0-20230110061619-bbe2e5e100de // indirect
	github.com/mailru/easyjson v0.7.7 // indirect
	github.com/mattn/go-colorable v0.1.13 // indirect
	github.com/mattn/go-isatty v0.0.18 // indirect
	github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect
	github.com/modern-go/reflect2 v1.0.2 // indirect
	github.com/mohae/deepcopy v0.0.0-20170929034955-c48cc78d4826 // indirect
	github.com/nwaples/rardecode v1.1.3 // indirect
	github.com/pelletier/go-toml/v2 v2.0.7 // indirect
	github.com/perimeterx/marshmallow v1.1.4 // indirect
	github.com/pierrec/lz4/v4 v4.1.17 // indirect
	github.com/pmezard/go-difflib v1.0.0 // indirect
	github.com/power-devops/perfstat v0.0.0-20221212215047-62379fc7944b // indirect
	github.com/remyoudompheng/bigfft v0.0.0-20230129092748-24d4a6f8daec // indirect
	github.com/tidwall/match v1.1.1 // indirect
	github.com/tidwall/pretty v1.2.1 // indirect
	github.com/tklauser/go-sysconf v0.3.11 // indirect
	github.com/tklauser/numcpus v0.6.0 // indirect
	github.com/twitchyliquid64/golang-asm v0.15.1 // indirect
	github.com/ugorji/go/codec v1.2.11 // indirect
	github.com/ulikunitz/xz v0.5.11 // indirect
	github.com/valyala/bytebufferpool v1.0.0 // indirect
	github.com/valyala/fasttemplate v1.2.2 // indirect
	github.com/xi2/xz v0.0.0-20171230120015-48954b6210f8 // indirect
	github.com/yusufpapurcu/wmi v1.2.2 // indirect
	go.uber.org/atomic v1.10.0 // indirect
	go.uber.org/multierr v1.11.0 // indirect
	golang.org/x/arch v0.3.0 // indirect
	golang.org/x/exp v0.0.0-20220303212507-bbda1eaf7a17 // indirect
	golang.org/x/image v0.6.0 // indirect
	golang.org/x/net v0.9.0 // indirect
	golang.org/x/text v0.9.0 // indirect
	golang.org/x/time v0.3.0 // indirect
	google.golang.org/appengine v1.6.7 // indirect
	google.golang.org/protobuf v1.30.0 // indirect
	gopkg.in/natefinch/lumberjack.v2 v2.2.1 // indirect
	gopkg.in/yaml.v2 v2.4.0 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
	modernc.org/libc v1.22.3 // indirect
	modernc.org/mathutil v1.5.0 // indirect
	modernc.org/memory v1.5.0 // indirect
	modernc.org/sqlite v1.21.0 // indirect
)
",CWE-287,139.0,0
"package route
import (
	""crypto/ecdsa""
	""os""
	""github.com/IceWhaleTech/CasaOS-Common/external""
	""github.com/IceWhaleTech/CasaOS-Common/middleware""
	""github.com/IceWhaleTech/CasaOS-Common/utils/jwt""
	""github.com/IceWhaleTech/CasaOS/pkg/config""
	v1 ""github.com/IceWhaleTech/CasaOS/route/v1""
	""github.com/gin-contrib/gzip""
	""github.com/gin-gonic/gin""
)
func InitV1Router() *gin.Engine {
	ginMode := gin.ReleaseMode
	if config.ServerInfo.RunMode != """" {
		ginMode = config.ServerInfo.RunMode
	}
	if os.Getenv(gin.EnvGinMode) != """" {
		ginMode = os.Getenv(gin.EnvGinMode)
	}
	gin.SetMode(ginMode)
	r := gin.New()
	r.Use(gin.Recovery())
	r.Use(middleware.Cors())
	r.Use(gzip.Gzip(gzip.DefaultCompression))
	if ginMode != gin.ReleaseMode {
		r.Use(middleware.WriteLog())
	}
	r.GET(""/v1/sys/debug"", v1.GetSystemConfigDebug) // //debug
	r.GET(""/v1/sys/version/check"", v1.GetSystemCheckVersion)
	r.GET(""/ping"", func(ctx *gin.Context) {
		ctx.String(200, ""pong"")
	})
	r.GET(""/v1/recover/:type"", v1.GetRecoverStorage)
	v1Group := r.Group(""/v1"")
	v1Group.Use(jwt.JWT(
		func() (*ecdsa.PublicKey, error) {
			return external.GetPublicKey(config.CommonInfo.RuntimePath)
		},
	))
	{
		v1SysGroup := v1Group.Group(""/sys"")
		v1SysGroup.Use()
		{
			v1SysGroup.GET(""/version"", v1.GetSystemCheckVersion) // version/check
			v1SysGroup.POST(""/update"", v1.SystemUpdate)
			v1SysGroup.GET(""/hardware"", v1.GetSystemHardwareInfo) // hardware/info
			v1SysGroup.GET(""/wsssh"", v1.WsSsh)
			v1SysGroup.POST(""/ssh-login"", v1.PostSshLogin)
			// v1SysGroup.GET(""/config"", v1.GetSystemConfig) //delete
			// v1SysGroup.POST(""/config"", v1.PostSetSystemConfig)
			v1SysGroup.GET(""/logs"", v1.GetCasaOSErrorLogs) // error/logs
			// v1SysGroup.GET(""/widget/config"", v1.GetWidgetConfig)//delete
			// v1SysGroup.POST(""/widget/config"", v1.PostSetWidgetConfig)//delete
			v1SysGroup.POST(""/stop"", v1.PostKillCasaOS)
			v1SysGroup.GET(""/utilization"", v1.GetSystemUtilization)
			// v1SysGroup.GET(""/cpu"", v1.GetSystemCupInfo)
			// v1SysGroup.GET(""/mem"", v1.GetSystemMemInfo)
			// v1SysGroup.GET(""/disk"", v1.GetSystemDiskInfo)
			// v1SysGroup.GET(""/network"", v1.GetSystemNetInfo)
			v1SysGroup.GET(""/server-info"", nil)
			v1SysGroup.PUT(""/server-info"", nil)
			// v1SysGroup.GET(""/port"", v1.GetCasaOSPort)
			// v1SysGroup.PUT(""/port"", v1.PutCasaOSPort)
			v1SysGroup.GET(""/proxy"", v1.GetSystemProxy)
			v1SysGroup.PUT(""/state/:state"", v1.PutSystemState)
		}
		v1PortGroup := v1Group.Group(""/port"")
		v1PortGroup.Use()
		{
			v1PortGroup.GET(""/"", v1.GetPort)              // app/port
			v1PortGroup.GET(""/state/:port"", v1.PortCheck) // app/check/:port
		}
		v1FileGroup := v1Group.Group(""/file"")
		v1FileGroup.Use()
		{
			v1FileGroup.GET("""", v1.GetDownloadSingleFile) // download/:path
			v1FileGroup.POST("""", v1.PostCreateFile)
			v1FileGroup.PUT("""", v1.PutFileContent)
			v1FileGroup.PUT(""/name"", v1.RenamePath)
			// file/rename
			v1FileGroup.GET(""/content"", v1.GetFilerContent) // file/read
			// File uploads need to be handled separately, and will not be modified here
			//v1FileGroup.POST(""/upload"", v1.PostFileUpload)
			v1FileGroup.POST(""/upload"", v1.PostFileUpload)
			v1FileGroup.GET(""/upload"", v1.GetFileUpload)
			// v1FileGroup.GET(""/download"", v1.UserFileDownloadCommonService)
			v1FileGroup.GET(""/ws"", v1.ConnectWebSocket)
			v1FileGroup.GET(""/peers"", v1.GetPeers)
		}
		v1CloudGroup := v1Group.Group(""/cloud"")
		v1CloudGroup.Use()
		{
			v1CloudGroup.GET("""", v1.ListStorages)
			v1CloudGroup.DELETE("""", v1.UmountStorage)
		}
		v1DriverGroup := v1Group.Group(""/driver"")
		v1DriverGroup.Use()
		{
			v1DriverGroup.GET("""", v1.ListDriverInfo)
		}
		v1FolderGroup := v1Group.Group(""/folder"")
		v1FolderGroup.Use()
		{
			v1FolderGroup.PUT(""/name"", v1.RenamePath)
			v1FolderGroup.GET("""", v1.DirPath)   ///file/dirpath
			v1FolderGroup.POST("""", v1.MkdirAll) ///file/mkdir
			v1FolderGroup.GET(""/size"", v1.GetSize)
			v1FolderGroup.GET(""/count"", v1.GetFileCount)
		}
		v1BatchGroup := v1Group.Group(""/batch"")
		v1BatchGroup.Use()
		{
			v1BatchGroup.DELETE("""", v1.DeleteFile) // file/delete
			v1BatchGroup.DELETE(""/:id/task"", v1.DeleteOperateFileOrDir)
			v1BatchGroup.POST(""/task"", v1.PostOperateFileOrDir) // file/operate
			v1BatchGroup.GET("""", v1.GetDownloadFile)
		}
		v1ImageGroup := v1Group.Group(""/image"")
		v1ImageGroup.Use()
		{
			v1ImageGroup.GET("""", v1.GetFileImage)
		}
		v1SambaGroup := v1Group.Group(""/samba"")
		v1SambaGroup.Use()
		{
			v1ConnectionsGroup := v1SambaGroup.Group(""/connections"")
			v1ConnectionsGroup.Use()
			{
				v1ConnectionsGroup.GET("""", v1.GetSambaConnectionsList)
				v1ConnectionsGroup.POST("""", v1.PostSambaConnectionsCreate)
				v1ConnectionsGroup.DELETE(""/:id"", v1.DeleteSambaConnections)
			}
			v1SharesGroup := v1SambaGroup.Group(""/shares"")
			v1SharesGroup.Use()
			{
				v1SharesGroup.GET("""", v1.GetSambaSharesList)
				v1SharesGroup.POST("""", v1.PostSambaSharesCreate)
				v1SharesGroup.DELETE(""/:id"", v1.DeleteSambaShares)
				v1SharesGroup.GET(""/status"", v1.GetSambaStatus)
			}
		}
		v1NotifyGroup := v1Group.Group(""/notify"")
		v1NotifyGroup.Use()
		{
			v1NotifyGroup.POST(""/:path"", v1.PostNotifyMessage)
			// merge to system
			v1NotifyGroup.POST(""/system_status"", v1.PostSystemStatusNotify)
		}
		v1OtherGroup := v1Group.Group(""/other"")
		v1OtherGroup.Use()
		{
			v1OtherGroup.GET(""/search"", v1.GetSearchResult)
		}
	}
	return r
}
",CWE-287,180.0,0
"/*
 * Copyright 2022 Snyk Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package config
import (
	""os""
	""testing""
	""time""
	""github.com/google/uuid""
	""github.com/stretchr/testify/assert""
)
func TestSetToken(t *testing.T) {
	SetCurrentConfig(New())
	oldToken := CurrentConfig().Token()
	CurrentConfig().SetToken(""asdf"")
	assert.Equal(t, CurrentConfig().Token(), ""asdf"")
	CurrentConfig().SetToken(oldToken)
}
func TestConfigDefaults(t *testing.T) {
	c := New()
	assert.True(t, c.IsTelemetryEnabled(), ""Telemetry should be enabled by default"")
	assert.True(t, c.IsErrorReportingEnabled(), ""Error Reporting should be enabled by default"")
	assert.False(t, c.IsSnykAdvisorEnabled(), ""Advisor should be disabled by default"")
	assert.False(t, c.IsSnykCodeEnabled(), ""Snyk Code should be disabled by default"")
	assert.False(t, c.IsSnykContainerEnabled(), ""Snyk Container should be enabled by default"")
	assert.True(t, c.IsSnykOssEnabled(), ""Snyk Open Source should be enabled by default"")
	assert.True(t, c.IsSnykIacEnabled(), ""Snyk IaC should be enabled by default"")
	assert.Equal(t, """", c.LogPath(), ""Logpath should be empty by default"")
	assert.Equal(t, ""md"", c.Format(), ""Output format should be md by default"")
	assert.Empty(t, c.trustedFolders)
}
func Test_TokenChanged_ChannelsInformed(t *testing.T) {
	// Arrange
	c := New()
	tokenChangedChannel := c.TokenChangesChannel()
	// Act
	// There's a 1 in 5 undecillion (5 * 10^36) chance for a collision here so let's hold our fingers
	c.SetToken(uuid.New().String())
	// Assert
	// This will either pass the test or fail by deadlock immediately if SetToken did not write to the change channels,
	// therefore there's no need for assert.Eventually
	<-tokenChangedChannel
}
func Test_TokenChangedToSameToken_ChannelsNotInformed(t *testing.T) {
	// Arrange
	c := New()
	tokenChangedChannel := c.TokenChangesChannel()
	token := c.Token()
	// Act
	c.SetToken(token)
	// Assert
	select {
	case newToken := <-tokenChangedChannel:
		assert.Fail(t, ""Expected empty token changes channel, but received new token (%v)"", newToken)
	default:
		// This case triggers when tokenChangedChannel is empty, test passes
	}
}
func Test_SnykCodeAnalysisTimeoutReturnsTimeoutFromEnvironment(t *testing.T) {
	t.Setenv(snykCodeTimeoutKey, ""1s"")
	duration, _ := time.ParseDuration(""1s"")
	assert.Equal(t, duration, snykCodeAnalysisTimeoutFromEnv())
}
func Test_SnykCodeAnalysisTimeoutReturnsDefaultIfNoEnvVariableFound(t *testing.T) {
	t.Setenv(snykCodeTimeoutKey, """")
	duration, _ := time.ParseDuration(""10m"")
	assert.Equal(t, duration, snykCodeAnalysisTimeoutFromEnv())
}
func Test_updatePath(t *testing.T) {
	t.Setenv(""PATH"", ""a"")
	c := New()
	c.updatePath(""b"")
	assert.Contains(t, c.path, string(os.PathListSeparator)+""b"")
	assert.Contains(t, c.path, ""a""+string(os.PathListSeparator))
}
func Test_loadFile(t *testing.T) {
	t.Setenv(""A"", """")
	t.Setenv(""C"", """")
	os.Unsetenv(""A"")
	os.Unsetenv(""C"")
	envData := []byte(""A=B\nC=D"")
	file, err := os.CreateTemp(""."", ""config_test_loadFile"")
	if err != nil {
		assert.Fail(t, ""Couldn't create temp file"", err)
	}
	defer func(file *os.File) {
		_ = file.Close()
		_ = os.Remove(file.Name())
	}(file)
	if err != nil {
		assert.Fail(t, ""Couldn't create test file"")
	}
	_, _ = file.Write(envData)
	if err != nil {
		assert.Fail(t, ""Couldn't write to test file"")
	}
	CurrentConfig().loadFile(file.Name())
	assert.Equal(t, ""B"", os.Getenv(""A""))
	assert.Equal(t, ""D"", os.Getenv(""C""))
}
func TestSnykCodeApi(t *testing.T) {
	t.Run(""endpoint not provided"", func(t *testing.T) {
		codeApiEndpoint, _ := getCodeApiUrlFromCustomEndpoint("""")
		assert.Equal(t, ""https://deeproxy.snyk.io"", codeApiEndpoint)
	})
	t.Run(""endpoint provided without 'app' prefix"", func(t *testing.T) {
		endpoint := ""https://snyk.io/api/v1""
		codeApiEndpoint, _ := getCodeApiUrlFromCustomEndpoint(endpoint)
		assert.Equal(t, ""https://deeproxy.snyk.io"", codeApiEndpoint)
	})
	t.Run(""endpoint provided with 'app' prefix with v1 suffix"", func(t *testing.T) {
		endpoint := ""https://app.snyk.io/api/v1""
		codeApiEndpoint, _ := getCodeApiUrlFromCustomEndpoint(endpoint)
		assert.Equal(t, ""https://deeproxy.snyk.io"", codeApiEndpoint)
	})
	t.Run(""endpoint provided with 'app' prefix without v1 suffix"", func(t *testing.T) {
		endpoint := ""https://app.snyk.io/api""
		codeApiEndpoint, _ := getCodeApiUrlFromCustomEndpoint(endpoint)
		assert.Equal(t, ""https://deeproxy.snyk.io"", codeApiEndpoint)
	})
	t.Run(""endpoint provided with 'api' prefix"", func(t *testing.T) {
		endpoint := ""https://api.snyk.io""
		codeApiEndpoint, _ := getCodeApiUrlFromCustomEndpoint(endpoint)
		assert.Equal(t, ""https://deeproxy.snyk.io"", codeApiEndpoint)
	})
	t.Run(""proxy endpoint provided via 'DEEPROXY_API_URL' environment variable"", func(t *testing.T) {
		customDeeproxyUrl := ""https://deeproxy.custom.url.snyk.io""
		t.Setenv(""DEEPROXY_API_URL"", customDeeproxyUrl)
		codeApiEndpoint, _ := getCodeApiUrlFromCustomEndpoint("""")
		assert.Equal(t, customDeeproxyUrl, codeApiEndpoint)
	})
}
",CWE-78,169.0,0
"/*
 * Copyright 2022 Snyk Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package server
import (
	""context""
	""github.com/atotto/clipboard""
	""github.com/creachadair/jrpc2""
	""github.com/creachadair/jrpc2/handler""
	""github.com/rs/zerolog/log""
	sglsp ""github.com/sourcegraph/go-lsp""
	""github.com/snyk/snyk-ls/application/config""
	""github.com/snyk/snyk-ls/application/di""
	""github.com/snyk/snyk-ls/application/server/lsp""
	""github.com/snyk/snyk-ls/domain/ide/command""
	""github.com/snyk/snyk-ls/domain/ide/workspace""
	""github.com/snyk/snyk-ls/domain/snyk""
	""github.com/snyk/snyk-ls/internal/notification""
)
func ExecuteCommandHandler(srv *jrpc2.Server) jrpc2.Handler {
	return handler.New(func(ctx context.Context, params sglsp.ExecuteCommandParams) (interface{}, error) {
		// The context provided by the JSON-RPC server is cancelled once a new message is being processed,
		// so we don't want to propagate it to functions that start background operations
		bgCtx := context.Background()
		method := ""ExecuteCommandHandler""
		log.Info().Str(""method"", method).Interface(""command"", params).Msg(""RECEIVING"")
		defer log.Info().Str(""method"", method).Interface(""command"", params).Msg(""SENDING"")
		args := params.Arguments
		switch params.Command {
		case snyk.NavigateToRangeCommand:
			if len(args) < 2 {
				log.Warn().Str(""method"", method).Msg(""received NavigateToRangeCommand without range"")
			}
			navigateToLocation(srv, args)
		case snyk.WorkspaceScanCommand:
			w := workspace.Get()
			w.ClearIssues(bgCtx)
			w.ScanWorkspace(bgCtx)
			handleUntrustedFolders(bgCtx, srv)
		case snyk.OpenBrowserCommand:
			command.OpenBrowser(params.Arguments[0].(string))
		case snyk.TrustWorkspaceFoldersCommand:
			err := TrustWorkspaceFolders()
			if err != nil {
				log.Err(err).Msgf(""Error on %s command"", snyk.TrustWorkspaceFoldersCommand)
				notification.SendError(err)
			}
		case snyk.LoginCommand:
			authenticator := di.Authenticator()
			_, err := authenticator.Authenticate(context.Background())
			if err != nil {
				log.Err(err).Msg(""Error on snyk.login command"")
				notification.SendError(err)
			}
		case snyk.CopyAuthLinkCommand:
			url := di.Authenticator().Provider().AuthURL(bgCtx)
			err := clipboard.WriteAll(url)
			if err != nil {
				log.Err(err).Msg(""Error on snyk.copyAuthLink command"")
				notification.SendError(err)
				break
			}
		case snyk.LogoutCommand:
			di.Authenticator().Logout(bgCtx)
		}
		return nil, nil
	})
}
func TrustWorkspaceFolders() error {
	if !config.CurrentConfig().IsTrustedFolderFeatureEnabled() {
		return nil
	}
	trustedFolderPaths := config.CurrentConfig().TrustedFolders()
	_, untrusted := workspace.Get().GetFolderTrust()
	for _, folder := range untrusted {
		trustedFolderPaths = append(trustedFolderPaths, folder.Path())
	}
	config.CurrentConfig().SetTrustedFolders(trustedFolderPaths)
	notification.Send(lsp.SnykTrustedFoldersParams{TrustedFolders: trustedFolderPaths})
	return nil
}
",CWE-78,104.0,0
"/*
 * Copyright 2022 Snyk Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package server
import (
	""testing""
	""time""
	""github.com/sourcegraph/go-lsp""
	""github.com/stretchr/testify/assert""
	""github.com/atotto/clipboard""
	""github.com/snyk/snyk-ls/application/config""
	""github.com/snyk/snyk-ls/application/di""
	""github.com/snyk/snyk-ls/domain/ide/workspace""
	""github.com/snyk/snyk-ls/domain/snyk""
	""github.com/snyk/snyk-ls/infrastructure/cli/auth""
)
func Test_executeWorkspaceScanCommand_shouldStartWorkspaceScanOnCommandReceipt(t *testing.T) {
	loc := setupServer(t)
	scanner := &snyk.TestScanner{}
	workspace.Get().AddFolder(workspace.NewFolder(""dummy"", ""dummy"", scanner, di.HoverService()))
	params := lsp.ExecuteCommandParams{Command: snyk.WorkspaceScanCommand}
	_, err := loc.Client.Call(ctx, ""workspace/executeCommand"", params)
	if err != nil {
		t.Fatal(err)
	}
	assert.Eventually(t, func() bool {
		return scanner.Calls() > 0
	}, 2*time.Second, time.Millisecond)
}
func Test_executeWorkspaceScanCommand_shouldAskForTrust(t *testing.T) {
	loc := setupServer(t)
	scanner := &snyk.TestScanner{}
	workspace.Get().AddFolder(workspace.NewFolder(""dummy"", ""dummy"", scanner, di.HoverService()))
	// explicitly enable folder trust which is disabled by default in tests
	config.CurrentConfig().SetTrustedFolderFeatureEnabled(true)
	params := lsp.ExecuteCommandParams{Command: snyk.WorkspaceScanCommand}
	_, err := loc.Client.Call(ctx, ""workspace/executeCommand"", params)
	if err != nil {
		t.Fatal(err)
	}
	assert.Eventually(t, func() bool {
		return scanner.Calls() == 0 && checkTrustMessageRequest()
	}, 2*time.Second, time.Millisecond)
}
func Test_loginCommand_StartsAuthentication(t *testing.T) {
	// Arrange
	loc := setupServer(t)
	_, err := loc.Client.Call(ctx, ""initialize"", nil)
	if err != nil {
		t.Fatal(err)
	}
	authenticationMock := di.Authenticator().Provider().(*auth.FakeAuthenticationProvider)
	initialAuthenticatedStatus := authenticationMock.IsAuthenticated
	params := lsp.ExecuteCommandParams{Command: snyk.LoginCommand}
	// Act
	_, err = loc.Client.Call(ctx, ""workspace/executeCommand"", params)
	if err != nil {
		t.Fatal(err)
	}
	// Assert
	assert.False(t, initialAuthenticatedStatus)
	assert.True(t, authenticationMock.IsAuthenticated)
	assert.Eventually(t, func() bool { return len(jsonRPCRecorder.Notifications()) > 0 }, 5*time.Second, 50*time.Millisecond)
	assert.Equal(t, 1, len(jsonRPCRecorder.FindNotificationsByMethod(""$/snyk.hasAuthenticated"")))
}
func Test_executeCommand_shouldCopyAuthURLToClipboard(t *testing.T) {
	loc := setupServer(t)
	authenticationMock := di.Authenticator().Provider().(*auth.FakeAuthenticationProvider)
	params := lsp.ExecuteCommandParams{Command: snyk.CopyAuthLinkCommand}
	_, err := loc.Client.Call(ctx, ""workspace/executeCommand"", params)
	if err != nil {
		t.Fatal(err)
	}
	actualURL, _ := clipboard.ReadAll()
	assert.Equal(t, authenticationMock.ExpectedAuthURL, actualURL)
}
func Test_TrustWorkspaceFolders(t *testing.T) {
	t.Run(""Doesn't mutate trusted folders, if trusted folders disabled"", func(t *testing.T) {
		loc := setupServer(t)
		workspace.Get().AddFolder(workspace.NewFolder(""/path/to/folder1"", ""dummy"", nil, di.HoverService()))
		params := lsp.ExecuteCommandParams{Command: snyk.TrustWorkspaceFoldersCommand}
		_, err := loc.Client.Call(ctx, ""workspace/executeCommand"", params)
		if err != nil {
			t.Fatal(err)
		}
		assert.Len(t, config.CurrentConfig().TrustedFolders(), 0)
	})
	t.Run(""Updates trusted workspace folders"", func(t *testing.T) {
		loc := setupServer(t)
		workspace.Get().AddFolder(workspace.NewFolder(""/path/to/folder1"", ""dummy"", nil, di.HoverService()))
		workspace.Get().AddFolder(workspace.NewFolder(""/path/to/folder2"", ""dummy"", nil, di.HoverService()))
		config.CurrentConfig().SetTrustedFolderFeatureEnabled(true)
		params := lsp.ExecuteCommandParams{Command: snyk.TrustWorkspaceFoldersCommand}
		_, err := loc.Client.Call(ctx, ""workspace/executeCommand"", params)
		if err != nil {
			t.Fatal(err)
		}
		assert.Len(t, config.CurrentConfig().TrustedFolders(), 2)
		assert.Contains(t, config.CurrentConfig().TrustedFolders(), ""/path/to/folder1"", ""/path/to/folder2"")
	})
	t.Run(""Existing trusted workspace folders are not removed"", func(t *testing.T) {
		loc := setupServer(t)
		workspace.Get().AddFolder(workspace.NewFolder(""/path/to/folder1"", ""dummy"", nil, di.HoverService()))
		config.CurrentConfig().SetTrustedFolderFeatureEnabled(true)
		config.CurrentConfig().SetTrustedFolders([]string{""/path/to/folder2""})
		params := lsp.ExecuteCommandParams{Command: snyk.TrustWorkspaceFoldersCommand}
		_, err := loc.Client.Call(ctx, ""workspace/executeCommand"", params)
		if err != nil {
			t.Fatal(err)
		}
		assert.Len(t, config.CurrentConfig().TrustedFolders(), 2)
		assert.Contains(t, config.CurrentConfig().TrustedFolders(), ""/path/to/folder1"", ""/path/to/folder2"")
	})
}
",CWE-78,153.0,0
"/*
 * Copyright 2022 Snyk Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package server
import (
	""context""
	""fmt""
	""github.com/creachadair/jrpc2""
	""github.com/pkg/errors""
	""github.com/rs/zerolog/log""
	""github.com/snyk/snyk-ls/application/server/lsp""
	""github.com/snyk/snyk-ls/domain/ide/workspace""
)
const doTrust = ""Trust folders and continue""
const dontTrust = ""Don't trust folders""
func handleUntrustedFolders(ctx context.Context, srv *jrpc2.Server) {
	w := workspace.Get()
	// debounce requests from overzealous clients (Eclipse, I'm looking at you)
	if w.IsTrustRequestOngoing() {
		return
	}
	w.StartRequestTrustCommunication()
	defer w.EndRequestTrustCommunication()
	_, untrusted := w.GetFolderTrust()
	if len(untrusted) > 0 {
		decision, err := showTrustDialog(srv, untrusted, doTrust, dontTrust)
		if err != nil {
			return
		}
		if decision.Title == doTrust {
			w.TrustFoldersAndScan(ctx, untrusted)
		}
	}
}
func showTrustDialog(srv *jrpc2.Server, untrusted []*workspace.Folder, dontTrust string, doTrust string) (lsp.MessageActionItem, error) {
	method := ""showTrustDialog""
	result, err := srv.Callback(context.Background(), ""window/showMessageRequest"", lsp.ShowMessageRequestParams{
		Type:    lsp.Warning,
		Message: getTrustMessage(untrusted),
		Actions: []lsp.MessageActionItem{{Title: dontTrust}, {Title: doTrust}},
	})
	if err != nil {
		log.Err(errors.Wrap(err, ""couldn't show trust message"")).Str(""method"", method).Send()
		return lsp.MessageActionItem{Title: dontTrust}, err
	}
	var trust lsp.MessageActionItem
	if result != nil {
		err = result.UnmarshalResult(&trust)
		if err != nil {
			log.Err(errors.Wrap(err, ""couldn't unmarshal trust message"")).Str(""method"", method).Send()
			return lsp.MessageActionItem{Title: dontTrust}, err
		}
	}
	return trust, err
}
func getTrustMessage(untrusted []*workspace.Folder) string {
	var untrustedFolderString string
	for _, folder := range untrusted {
		untrustedFolderString += folder.Path() + ""\n""
	}
	return fmt.Sprintf(""When scanning for vulnerabilities, Snyk may automatically execute code such as invoking ""+
		""the package manager to get dependency information. You should only scan folders you trust.""+
		""\n\nUntrusted Folders: \n%s\n\n"", untrustedFolderString)
}
",CWE-78,89.0,0
"/*
 * Copyright 2022 Snyk Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package server
import (
	""context""
	""testing""
	""time""
	""github.com/creachadair/jrpc2""
	""github.com/stretchr/testify/assert""
	""github.com/snyk/snyk-ls/application/config""
	""github.com/snyk/snyk-ls/application/di""
	""github.com/snyk/snyk-ls/application/server/lsp""
	""github.com/snyk/snyk-ls/domain/ide/workspace""
	""github.com/snyk/snyk-ls/domain/snyk""
	""github.com/snyk/snyk-ls/internal/uri""
)
func Test_handleUntrustedFolders_shouldTriggerTrustRequestAndNotScan(t *testing.T) {
	loc := setupServer(t)
	w := workspace.Get()
	scanner := &snyk.TestScanner{}
	config.CurrentConfig().SetTrustedFolderFeatureEnabled(true)
	w.AddFolder(workspace.NewFolder(""dummy"", ""dummy"", scanner, di.HoverService()))
	handleUntrustedFolders(context.Background(), loc.Server)
	assert.True(t, checkTrustMessageRequest())
	assert.Equal(t, scanner.Calls(), 0)
}
func Test_handleUntrustedFolders_shouldNotTriggerTrustRequestWhenAlreadyRequesting(t *testing.T) {
	loc := setupServer(t)
	w := workspace.Get()
	scanner := &snyk.TestScanner{}
	config.CurrentConfig().SetTrustedFolderFeatureEnabled(true)
	w.AddFolder(workspace.NewFolder(""dummy"", ""dummy"", scanner, di.HoverService()))
	w.StartRequestTrustCommunication()
	handleUntrustedFolders(context.Background(), loc.Server)
	assert.Len(t, jsonRPCRecorder.FindCallbacksByMethod(""window/showMessageRequest""), 0)
	assert.Equal(t, scanner.Calls(), 0)
}
func Test_handleUntrustedFolders_shouldTriggerTrustRequestAndScanAfterConfirmation(t *testing.T) {
	loc := setupCustomServer(t, func(_ context.Context, _ *jrpc2.Request) (interface{}, error) {
		return lsp.MessageActionItem{
			Title: doTrust,
		}, nil
	})
	registerNotifier(loc.Server)
	w := workspace.Get()
	scanner := &snyk.TestScanner{}
	config.CurrentConfig().SetTrustedFolderFeatureEnabled(true)
	w.AddFolder(workspace.NewFolder(""/trusted/dummy"", ""dummy"", scanner, di.HoverService()))
	handleUntrustedFolders(context.Background(), loc.Server)
	assert.Eventually(t, func() bool {
		addTrustedSent := len(jsonRPCRecorder.FindNotificationsByMethod(""$/snyk.addTrustedFolders"")) == 1
		return scanner.Calls() == 1 && addTrustedSent
	}, time.Second, time.Millisecond)
}
func Test_handleUntrustedFolders_shouldTriggerTrustRequestAndNotScanAfterNegativeConfirmation(t *testing.T) {
	loc := setupCustomServer(t, func(_ context.Context, _ *jrpc2.Request) (interface{}, error) {
		return lsp.MessageActionItem{
			Title: dontTrust,
		}, nil
	})
	registerNotifier(loc.Server)
	w := workspace.Get()
	scanner := &snyk.TestScanner{}
	w.AddFolder(workspace.NewFolder(""/trusted/dummy"", ""dummy"", scanner, di.HoverService()))
	config.CurrentConfig().SetTrustedFolderFeatureEnabled(true)
	handleUntrustedFolders(context.Background(), loc.Server)
	assert.Equal(t, scanner.Calls(), 0)
}
func Test_initializeHandler_shouldCallHandleUntrustedFolders(t *testing.T) {
	loc := setupServer(t)
	config.CurrentConfig().SetTrustedFolderFeatureEnabled(true)
	_, err := loc.Client.Call(context.Background(), ""initialize"", lsp.InitializeParams{
		RootURI: uri.PathToUri(""/untrusted/dummy""),
	})
	if err != nil {
		t.Fatal(err, ""couldn't send initialized"")
	}
	_, err = loc.Client.Call(ctx, ""initialized"", nil)
	if err != nil {
		t.Fatal(err, ""couldn't send initialized"")
	}
	assert.NoError(t, err)
	assert.Eventually(t, func() bool { return checkTrustMessageRequest() }, time.Second, time.Millisecond)
}
func Test_DidWorkspaceFolderChange_shouldCallHandleUntrustedFolders(t *testing.T) {
	loc := setupServer(t)
	config.CurrentConfig().SetTrustedFolderFeatureEnabled(true)
	_, err := loc.Client.Call(context.Background(), ""workspace/didChangeWorkspaceFolders"", lsp.DidChangeWorkspaceFoldersParams{
		Event: lsp.WorkspaceFoldersChangeEvent{
			Added: []lsp.WorkspaceFolder{
				{Uri: uri.PathToUri(""/untrusted/dummy""), Name: ""dummy""},
			},
			Removed: []lsp.WorkspaceFolder{},
		},
	})
	assert.NoError(t, err)
	assert.Eventually(t, func() bool { return checkTrustMessageRequest() }, time.Second, time.Millisecond)
}
func checkTrustMessageRequest() bool {
	callbacks := jsonRPCRecorder.FindCallbacksByMethod(""window/showMessageRequest"")
	if len(callbacks) == 0 {
		return false
	}
	var params lsp.ShowMessageRequestParams
	_ = callbacks[0].UnmarshalParams(&params)
	_, untrusted := workspace.Get().GetFolderTrust()
	return params.Type == lsp.Warning && params.Message == getTrustMessage(untrusted)
}
",CWE-78,146.0,0
"/*
 * Copyright 2022 Snyk Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package workspace
import (
	""context""
	""sync""
	""github.com/rs/zerolog/log""
	""github.com/snyk/snyk-ls/application/config""
	""github.com/snyk/snyk-ls/application/server/lsp""
	""github.com/snyk/snyk-ls/domain/ide/hover""
	""github.com/snyk/snyk-ls/domain/observability/performance""
	""github.com/snyk/snyk-ls/domain/snyk""
	""github.com/snyk/snyk-ls/internal/notification""
	""github.com/snyk/snyk-ls/internal/uri""
)
// todo can we do without a singleton?
var instance *Workspace
var mutex = &sync.Mutex{}
// Workspace represents the highest entity in an IDE that contains code. A workspace may contain multiple folders
type Workspace struct {
	mutex               sync.Mutex
	folders             map[string]*Folder
	instrumentor        performance.Instrumentor
	scanner             snyk.Scanner
	hoverService        hover.Service
	trustMutex          sync.Mutex
	trustRequestOngoing bool // for debouncing
}
func New(instrumentor performance.Instrumentor, scanner snyk.Scanner, hoverService hover.Service) *Workspace {
	return &Workspace{
		folders:      make(map[string]*Folder, 0),
		instrumentor: instrumentor,
		scanner:      scanner,
		hoverService: hoverService,
	}
}
// todo can we move to di?
func Get() *Workspace {
	mutex.Lock()
	defer mutex.Unlock()
	return instance
}
func Set(w *Workspace) {
	mutex.Lock()
	defer mutex.Unlock()
	instance = w
}
func (w *Workspace) RemoveFolder(folder string) {
	w.mutex.Lock()
	defer w.mutex.Unlock()
	delete(w.folders, folder)
}
func (w *Workspace) AddFolder(f *Folder) {
	w.mutex.Lock()
	defer w.mutex.Unlock()
	if w.folders == nil {
		w.folders = map[string]*Folder{}
	}
	w.folders[f.Path()] = f
}
func (w *Workspace) GetFolderContaining(path string) (folder *Folder) {
	for _, folder := range w.folders {
		if folder.Contains(path) {
			return folder
		}
	}
	return nil
}
func (w *Workspace) ScanWorkspace(ctx context.Context) {
	trusted, _ := w.GetFolderTrust()
	for _, folder := range trusted {
		go folder.ScanFolder(ctx)
	}
}
func (w *Workspace) AddAndRemoveFoldersAndTriggerScan(ctx context.Context, params lsp.DidChangeWorkspaceFoldersParams) {
	for _, folder := range params.Event.Removed {
		w.RemoveFolder(uri.PathFromUri(folder.Uri))
		// TODO: check if we need to clean up the reported diagnostics, if folder was removed?
	}
	for _, folder := range params.Event.Added {
		f := NewFolder(uri.PathFromUri(folder.Uri), folder.Name, w.scanner, w.hoverService)
		w.AddFolder(f)
	}
	w.ScanWorkspace(ctx)
}
func (w *Workspace) ClearIssues(_ context.Context) {
	for _, folder := range w.folders {
		folder.ClearScannedStatus()
		folder.ClearDiagnostics()
	}
	w.hoverService.ClearAllHovers()
}
func (w *Workspace) TrustFoldersAndScan(ctx context.Context, foldersToBeTrusted []*Folder) {
	currentConfig := config.CurrentConfig()
	trustedFolderPaths := currentConfig.TrustedFolders()
	for _, f := range foldersToBeTrusted {
		// we need to append and set the trusted path to the config before the scan, as the scan is checking for trust
		trustedFolderPaths = append(trustedFolderPaths, f.Path())
		currentConfig.SetTrustedFolders(trustedFolderPaths)
		go f.ScanFolder(ctx)
	}
	notification.Send(lsp.SnykTrustedFoldersParams{TrustedFolders: trustedFolderPaths})
}
func (w *Workspace) GetFolderTrust() (trusted []*Folder, untrusted []*Folder) {
	for _, folder := range w.folders {
		if folder.IsTrusted() {
			trusted = append(trusted, folder)
			log.Info().Str(""folder"", folder.Path()).Msg(""Trusted folder"")
		} else {
			untrusted = append(untrusted, folder)
			log.Info().Str(""folder"", folder.Path()).Msg(""Untrusted folder"")
		}
	}
	return trusted, untrusted
}
",CWE-78,148.0,0
"/*
 * Copyright 2022 Snyk Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package workspace
import (
	""context""
	""testing""
	""time""
	""github.com/stretchr/testify/assert""
	""github.com/snyk/snyk-ls/application/config""
	""github.com/snyk/snyk-ls/application/server/lsp""
	""github.com/snyk/snyk-ls/domain/observability/performance""
	""github.com/snyk/snyk-ls/domain/snyk""
	""github.com/snyk/snyk-ls/internal/testutil""
	""github.com/snyk/snyk-ls/internal/uri""
)
func Test_GetFolderTrust_shouldReturnTrustedAndUntrustedFolders(t *testing.T) {
	testutil.UnitTest(t)
	const trustedDummy = ""trustedDummy""
	const untrustedDummy = ""untrustedDummy""
	scanner := &snyk.TestScanner{}
	w := New(performance.NewTestInstrumentor(), scanner, nil)
	config.CurrentConfig().SetTrustedFolderFeatureEnabled(true)
	config.CurrentConfig().SetTrustedFolders([]string{trustedDummy})
	w.AddFolder(NewFolder(trustedDummy, trustedDummy, scanner, nil))
	w.AddFolder(NewFolder(untrustedDummy, untrustedDummy, scanner, nil))
	trusted, untrusted := w.GetFolderTrust()
	assert.Equal(t, trustedDummy, trusted[0].path)
	assert.Equal(t, untrustedDummy, untrusted[0].path)
}
func Test_TrustFoldersAndScan_shouldAddFoldersToTrustedFoldersAndTriggerScan(t *testing.T) {
	testutil.UnitTest(t)
	const trustedDummy = ""trustedDummy""
	const untrustedDummy = ""untrustedDummy""
	scanner := &snyk.TestScanner{}
	w := New(performance.NewTestInstrumentor(), scanner, nil)
	config.CurrentConfig().SetTrustedFolderFeatureEnabled(true)
	trustedFolder := NewFolder(trustedDummy, trustedDummy, scanner, nil)
	w.AddFolder(trustedFolder)
	untrustedFolder := NewFolder(untrustedDummy, untrustedDummy, scanner, nil)
	w.AddFolder(untrustedFolder)
	w.TrustFoldersAndScan(context.Background(), []*Folder{trustedFolder})
	assert.Contains(t, config.CurrentConfig().TrustedFolders(), trustedFolder.path)
	assert.NotContains(t, config.CurrentConfig().TrustedFolders(), untrustedFolder.path)
	assert.Eventually(t, func() bool {
		return scanner.Calls() == 1
	}, time.Second, time.Millisecond, ""scanner should be called after trust is granted"")
}
func Test_AddAndRemoveFoldersAndTriggerScan(t *testing.T) {
	testutil.UnitTest(t)
	const trustedDummy = ""trustedDummy""
	const untrustedDummy = ""untrustedDummy""
	const toBeRemoved = ""toBeRemoved""
	trustedPathAfterConversions := uri.PathFromUri(uri.PathToUri(trustedDummy))
	toBeRemovedAbsolutePathAfterConversions := uri.PathFromUri(uri.PathToUri(toBeRemoved))
	scanner := &snyk.TestScanner{}
	w := New(performance.NewTestInstrumentor(), scanner, nil)
	toBeRemovedFolder := NewFolder(toBeRemovedAbsolutePathAfterConversions, toBeRemoved, scanner, nil)
	w.AddFolder(toBeRemovedFolder)
	config.CurrentConfig().SetTrustedFolderFeatureEnabled(true)
	config.CurrentConfig().SetTrustedFolders([]string{trustedPathAfterConversions})
	params := lsp.DidChangeWorkspaceFoldersParams{Event: lsp.WorkspaceFoldersChangeEvent{
		Added: []lsp.WorkspaceFolder{
			{Name: trustedDummy, Uri: uri.PathToUri(trustedDummy)},
			{Name: untrustedDummy, Uri: uri.PathToUri(untrustedDummy)},
		},
		Removed: []lsp.WorkspaceFolder{
			{Name: toBeRemoved, Uri: uri.PathToUri(toBeRemoved)},
		},
	}}
	w.AddAndRemoveFoldersAndTriggerScan(context.Background(), params)
	assert.Nil(t, w.GetFolderContaining(toBeRemoved))
	// one call for one trusted folder
	assert.Eventually(t, func() bool {
		return scanner.Calls() == 1
	}, time.Second, time.Millisecond, ""scanner should be called after trust is granted"")
}
func Test_Get(t *testing.T) {
	New(nil, nil, nil)
	assert.Equal(t, instance, Get())
}
func Test_Set(t *testing.T) {
	w := New(nil, nil, nil)
	Set(w)
	assert.Equal(t, w, instance)
}
",CWE-78,118.0,0
"/*
 * Copyright 2022 Snyk Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package workspace
func (w *Workspace) StartRequestTrustCommunication() {
	w.trustMutex.Lock()
	w.trustRequestOngoing = true
	w.trustMutex.Unlock()
}
func (w *Workspace) EndRequestTrustCommunication() {
	w.trustMutex.Lock()
	w.trustRequestOngoing = false
	w.trustMutex.Unlock()
}
func (w *Workspace) IsTrustRequestOngoing() bool {
	w.trustMutex.Lock()
	defer w.trustMutex.Unlock()
	return w.trustRequestOngoing
}
",CWE-78,36.0,0
"/*
 * Copyright 2022 Snyk Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package workspace
import (
	""testing""
	""github.com/stretchr/testify/assert""
	""github.com/snyk/snyk-ls/internal/testutil""
)
func TestWorkspace_TrustRequests(t *testing.T) {
	testutil.UnitTest(t)
	w := New(nil, nil, nil)
	w.StartRequestTrustCommunication()
	w.IsTrustRequestOngoing()
	assert.True(t, w.IsTrustRequestOngoing())
	w.EndRequestTrustCommunication()
	assert.False(t, w.IsTrustRequestOngoing())
}
",CWE-78,36.0,0
"/*
 * Copyright 2022 Snyk Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package snyk
const (
	NavigateToRangeCommand       = ""snyk.navigateToRange""
	WorkspaceScanCommand         = ""snyk.workspace.scan""
	OpenBrowserCommand           = ""snyk.openBrowser""
	LoginCommand                 = ""snyk.login""
	CopyAuthLinkCommand          = ""snyk.copyAuthLink""
	LogoutCommand                = ""snyk.logout""
	TrustWorkspaceFoldersCommand = ""snyk.trustWorkspaceFolders""
)
type Command struct {
	/**
	 * Title of the command, like `save`.
	 */
	Title string
	/**
	 * The identifier of the actual command handler.
	 */
	Command string
	/**
	 * Arguments that the command handler should be
	 * invoked with.
	 */
	Arguments []interface{}
}
type CommandName string
",CWE-78,46.0,0
"/*
 * Copyright 2022 Snyk Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package testutil
import (
	""os""
	""runtime""
	""testing""
	""github.com/pact-foundation/pact-go/dsl""
	""github.com/snyk/snyk-ls/application/config""
	""github.com/snyk/snyk-ls/internal/progress""
)
const (
	integTestEnvVar = ""INTEG_TESTS""
	smokeTestEnvVar = ""SMOKE_TESTS""
)
func IntegTest(t *testing.T) {
	prepareTestHelper(t, integTestEnvVar)
}
func SmokeTest(t *testing.T) {
	prepareTestHelper(t, smokeTestEnvVar)
}
func UnitTest(t *testing.T) {
	t.Helper()
	c := config.New()
	c.SetManageBinariesAutomatically(false)
	c.SetToken(""00000000-0000-0000-0000-000000000001"")
	c.SetTrustedFolderFeatureEnabled(false)
	config.SetCurrentConfig(c)
	CLIDownloadLockFileCleanUp(t)
}
func CLIDownloadLockFileCleanUp(t *testing.T) {
	t.Helper()
	// remove lock file before test and after test
	lockFileName := config.CurrentConfig().CLIDownloadLockFileName()
	file, _ := os.Open(lockFileName)
	file.Close()
	_ = os.Remove(lockFileName)
	t.Cleanup(func() {
		_ = os.Remove(lockFileName)
	})
}
func NotOnWindows(t *testing.T, reason string) {
	t.Helper()
	if //goland:noinspection GoBoolExpressions
	runtime.GOOS == ""windows"" {
		t.Skipf(""Not on windows, because %s"", reason)
	}
}
func OnlyOnWindows(t *testing.T, reason string) {
	t.Helper()
	if //goland:noinspection GoBoolExpressions
	runtime.GOOS != ""windows"" {
		t.Skipf(""Only on windows, because %s"", reason)
	}
}
func Pact(t *testing.T, pactDir string, provider string) *dsl.Pact {
	t.Helper()
	NotOnWindows(t, ""we don't have a pact cli"")
	pact := &dsl.Pact{
		Consumer: ""SnykLS"",
		Provider: provider,
		PactDir:  pactDir,
	}
	t.Cleanup(func() {
		pact.Teardown()
	})
	return pact
}
func CreateDummyProgressListener(t *testing.T) {
	t.Helper()
	var dummyProgressStopChannel = make(chan bool, 1)
	t.Cleanup(func() {
		dummyProgressStopChannel <- true
	})
	go func() {
		for {
			select {
			case <-progress.Channel:
				continue
			case <-dummyProgressStopChannel:
				return
			}
		}
	}()
}
func prepareTestHelper(t *testing.T, envVar string) {
	t.Helper()
	if os.Getenv(envVar) == """" {
		t.Logf(""%s is not set"", envVar)
		t.SkipNow()
	}
	c := config.New()
	c.SetToken(GetEnvironmentToken())
	c.SetErrorReportingEnabled(false)
	c.SetTelemetryEnabled(false)
	c.SetTrustedFolderFeatureEnabled(false)
	config.SetCurrentConfig(c)
	CLIDownloadLockFileCleanUp(t)
}
func OnlyEnableCodeAndDisableBinaryManagement() {
	config.CurrentConfig().SetSnykIacEnabled(false)
	config.CurrentConfig().SetSnykOssEnabled(false)
	config.CurrentConfig().SetSnykCodeEnabled(true)
	config.CurrentConfig().SetManageBinariesAutomatically(false)
}
",CWE-78,139.0,0
"package external
import (
	""errors""
	""fmt""
	""os""
	""path/filepath""
	""github.com/foxcpp/maddy/internal/auth""
	""github.com/foxcpp/maddy/internal/config""
	""github.com/foxcpp/maddy/internal/log""
	""github.com/foxcpp/maddy/internal/module""
)
type ExternalAuth struct {
	modName    string
	instName   string
	helperPath string
	perDomain bool
	domains   []string
	Log log.Logger
}
func NewExternalAuth(modName, instName string, _, inlineArgs []string) (module.Module, error) {
	ea := &ExternalAuth{
		modName:  modName,
		instName: instName,
		Log:      log.Logger{Name: modName},
	}
	if len(inlineArgs) != 0 {
		return nil, errors.New(""external: inline arguments are not used"")
	}
	return ea, nil
}
func (ea *ExternalAuth) Name() string {
	return ea.modName
}
func (ea *ExternalAuth) InstanceName() string {
	return ea.instName
}
func (ea *ExternalAuth) Init(cfg *config.Map) error {
	cfg.Bool(""debug"", false, false, &ea.Log.Debug)
	cfg.Bool(""perdomain"", false, false, &ea.perDomain)
	cfg.StringList(""domains"", false, false, nil, &ea.domains)
	cfg.String(""helper"", false, false, """", &ea.helperPath)
	if _, err := cfg.Process(); err != nil {
		return err
	}
	if ea.perDomain && ea.domains == nil {
		return errors.New(""auth_domains must be set if auth_perdomain is used"")
	}
	if ea.helperPath != """" {
		ea.Log.Debugln(""using helper:"", ea.helperPath)
	} else {
		ea.helperPath = filepath.Join(config.LibexecDirectory, ""maddy-auth-helper"")
	}
	if _, err := os.Stat(ea.helperPath); err != nil {
		return fmt.Errorf(""%s doesn't exist"", ea.helperPath)
	}
	ea.Log.Debugln(""using helper:"", ea.helperPath)
	return nil
}
func (ea *ExternalAuth) AuthPlain(username, password string) error {
	accountName, ok := auth.CheckDomainAuth(username, ea.perDomain, ea.domains)
	if !ok {
		return module.ErrUnknownCredentials
	}
	return AuthUsingHelper(ea.helperPath, accountName, password)
}
func init() {
	module.Register(""extauth"", NewExternalAuth)
}
",CWE-287,86.0,0
"package pam
import (
	""errors""
	""fmt""
	""os""
	""path/filepath""
	""github.com/foxcpp/maddy/internal/auth/external""
	""github.com/foxcpp/maddy/internal/config""
	""github.com/foxcpp/maddy/internal/log""
	""github.com/foxcpp/maddy/internal/module""
)
type Auth struct {
	instName   string
	useHelper  bool
	helperPath string
	Log log.Logger
}
func New(modName, instName string, _, inlineArgs []string) (module.Module, error) {
	if len(inlineArgs) != 0 {
		return nil, errors.New(""pam: inline arguments are not used"")
	}
	return &Auth{
		instName: instName,
		Log:      log.Logger{Name: modName},
	}, nil
}
func (a *Auth) Name() string {
	return ""pam""
}
func (a *Auth) InstanceName() string {
	return a.instName
}
func (a *Auth) Init(cfg *config.Map) error {
	cfg.Bool(""debug"", true, false, &a.Log.Debug)
	cfg.Bool(""use_helper"", false, false, &a.useHelper)
	if _, err := cfg.Process(); err != nil {
		return err
	}
	if !canCallDirectly && !a.useHelper {
		return errors.New(""pam: this build lacks support for direct libpam invocation, use helper binary"")
	}
	if a.useHelper {
		a.helperPath = filepath.Join(config.LibexecDirectory, ""maddy-pam-helper"")
		if _, err := os.Stat(a.helperPath); err != nil {
			return fmt.Errorf(""pam: no helper binary (maddy-pam-helper) found in %s"", config.LibexecDirectory)
		}
	}
	return nil
}
func (a *Auth) AuthPlain(username, password string) error {
	if a.useHelper {
		if err := external.AuthUsingHelper(a.helperPath, username, password); err != nil {
			return err
		}
	}
	err := runPAMAuth(username, password)
	if err != nil {
		return err
	}
	return nil
}
func init() {
	module.Register(""pam"", New)
}
",CWE-287,77.0,0
"package plain_separate
import (
	""errors""
	""github.com/foxcpp/maddy/internal/config""
	""github.com/foxcpp/maddy/internal/log""
	""github.com/foxcpp/maddy/internal/module""
)
type Auth struct {
	modName  string
	instName string
	userTbls []module.Table
	passwd   []module.PlainAuth
	onlyFirstID bool
	Log log.Logger
}
func NewAuth(modName, instName string, _, inlinargs []string) (module.Module, error) {
	a := &Auth{
		modName:     modName,
		instName:    instName,
		onlyFirstID: false,
		Log:         log.Logger{Name: modName},
	}
	if len(inlinargs) != 0 {
		return nil, errors.New(""plain_separate: inline arguments are not used"")
	}
	return a, nil
}
func (a *Auth) Name() string {
	return a.modName
}
func (a *Auth) InstanceName() string {
	return a.instName
}
func (a *Auth) Init(cfg *config.Map) error {
	cfg.Bool(""debug"", false, false, &a.Log.Debug)
	if _, err := cfg.Process(); err != nil {
		return err
	}
	return nil
}
func (a *Auth) AuthPlain(username, password string) error {
	ok := len(a.userTbls) == 0
	for _, tbl := range a.userTbls {
		_, tblOk, err := tbl.Lookup(username)
		if err != nil {
			return err
		}
		if tblOk {
			ok = true
			break
		}
	}
	if !ok {
		return errors.New(""user not found in tables"")
	}
	var lastErr error
	for _, p := range a.passwd {
		if err := p.AuthPlain(username, password); err != nil {
			lastErr = err
			continue
		}
		return nil
	}
	return lastErr
}
func init() {
	module.Register(""plain_separate"", NewAuth)
}
",CWE-287,87.0,0
"package plain_separate
import (
	""errors""
	""testing""
	""github.com/emersion/go-sasl""
	""github.com/foxcpp/maddy/internal/module""
)
type mockAuth struct {
	db map[string]bool
}
func (mockAuth) SASLMechanisms() []string {
	return []string{sasl.Plain, sasl.Login}
}
func (m mockAuth) AuthPlain(username, _ string) error {
	ok := m.db[username]
	if !ok {
		return errors.New(""invalid creds"")
	}
	return nil
}
type mockTable struct {
	db map[string]string
}
func (m mockTable) Lookup(a string) (string, bool, error) {
	b, ok := m.db[a]
	return b, ok, nil
}
func TestPlainSplit_NoUser(t *testing.T) {
	a := Auth{
		passwd: []module.PlainAuth{
			mockAuth{
				db: map[string]bool{
					""user1"": true,
				},
			},
		},
	}
	err := a.AuthPlain(""user1"", ""aaa"")
	if err != nil {
		t.Fatal(""Unexpected error:"", err)
	}
}
func TestPlainSplit_NoUser_MultiPass(t *testing.T) {
	a := Auth{
		passwd: []module.PlainAuth{
			mockAuth{
				db: map[string]bool{
					""user2"": true,
				},
			},
			mockAuth{
				db: map[string]bool{
					""user1"": true,
				},
			},
		},
	}
	err := a.AuthPlain(""user1"", ""aaa"")
	if err != nil {
		t.Fatal(""Unexpected error:"", err)
	}
}
func TestPlainSplit_UserPass(t *testing.T) {
	a := Auth{
		userTbls: []module.Table{
			mockTable{
				db: map[string]string{
					""user1"": """",
				},
			},
		},
		passwd: []module.PlainAuth{
			mockAuth{
				db: map[string]bool{
					""user2"": true,
				},
			},
			mockAuth{
				db: map[string]bool{
					""user1"": true,
				},
			},
		},
	}
	err := a.AuthPlain(""user1"", ""aaa"")
	if err != nil {
		t.Fatal(""Unexpected error:"", err)
	}
}
func TestPlainSplit_MultiUser_Pass(t *testing.T) {
	a := Auth{
		userTbls: []module.Table{
			mockTable{
				db: map[string]string{
					""userWH"": """",
				},
			},
			mockTable{
				db: map[string]string{
					""user1"": """",
				},
			},
		},
		passwd: []module.PlainAuth{
			mockAuth{
				db: map[string]bool{
					""user2"": true,
				},
			},
			mockAuth{
				db: map[string]bool{
					""user1"": true,
				},
			},
		},
	}
	err := a.AuthPlain(""user1"", ""aaa"")
	if err != nil {
		t.Fatal(""Unexpected error:"", err)
	}
}
",CWE-287,137.0,0
"package auth
import (
	""errors""
	""fmt""
	""net""
	""github.com/emersion/go-sasl""
	""github.com/foxcpp/maddy/internal/config""
	modconfig ""github.com/foxcpp/maddy/internal/config/module""
	""github.com/foxcpp/maddy/internal/log""
	""github.com/foxcpp/maddy/internal/module""
)
var (
	ErrUnsupportedMech = errors.New(""Unsupported SASL mechanism"")
)
// SASLAuth is a wrapper that initializes sasl.Server using authenticators that
// call maddy module objects.
//
// It supports reporting of multiple authorization identities so multiple
// accounts can be associated with a single set of credentials.
type SASLAuth struct {
	Log         log.Logger
	OnlyFirstID bool
	Plain []module.PlainAuth
}
func (s *SASLAuth) SASLMechanisms() []string {
	var mechs []string
	if len(s.Plain) != 0 {
		mechs = append(mechs, sasl.Plain, sasl.Login)
	}
	return mechs
}
func (s *SASLAuth) AuthPlain(username, password string) error {
	if len(s.Plain) == 0 {
		return ErrUnsupportedMech
	}
	var lastErr error
	for _, p := range s.Plain {
		err := p.AuthPlain(username, password)
		if err == nil {
			return nil
		}
		if err != nil {
			lastErr = err
			continue
		}
	}
	return fmt.Errorf(""no auth. provider accepted creds, last err: %w"", lastErr)
}
// CreateSASL creates the sasl.Server instance for the corresponding mechanism.
func (s *SASLAuth) CreateSASL(mech string, remoteAddr net.Addr, successCb func(identity string) error) sasl.Server {
	switch mech {
	case sasl.Plain:
		return sasl.NewPlainServer(func(identity, username, password string) error {
			if identity == """" {
				identity = username
			}
			err := s.AuthPlain(username, password)
			if err != nil {
				s.Log.Error(""authentication failed"", err, ""username"", username, ""src_ip"", remoteAddr)
				return errors.New(""auth: invalid credentials"")
			}
			return successCb(identity)
		})
	case sasl.Login:
		return sasl.NewLoginServer(func(username, password string) error {
			err := s.AuthPlain(username, password)
			if err != nil {
				s.Log.Error(""authentication failed"", err, ""username"", username, ""src_ip"", remoteAddr)
				return errors.New(""auth: invalid credentials"")
			}
			return successCb(username)
		})
	}
	return FailingSASLServ{Err: ErrUnsupportedMech}
}
// AddProvider adds the SASL authentication provider to its mapping by parsing
// the 'auth' configuration directive.
func (s *SASLAuth) AddProvider(m *config.Map, node *config.Node) error {
	var any interface{}
	if err := modconfig.ModuleFromNode(node.Args, node, m.Globals, &any); err != nil {
		return err
	}
	hasAny := false
	if plainAuth, ok := any.(module.PlainAuth); ok {
		s.Plain = append(s.Plain, plainAuth)
		hasAny = true
	}
	if !hasAny {
		return m.MatchErr(""auth: specified module does not provide any SASL mechanism"")
	}
	return nil
}
type FailingSASLServ struct{ Err error }
func (s FailingSASLServ) Next([]byte) ([]byte, bool, error) {
	return nil, true, s.Err
}
",CWE-287,117.0,0
"package auth
import (
	""errors""
	""net""
	""testing""
	""github.com/foxcpp/maddy/internal/module""
	""github.com/foxcpp/maddy/internal/testutils""
)
type mockAuth struct {
	db map[string]bool
}
func (m mockAuth) AuthPlain(username, _ string) error {
	ok := m.db[username]
	if !ok {
		return errors.New(""invalid creds"")
	}
	return nil
}
func TestCreateSASL(t *testing.T) {
	a := SASLAuth{
		Log: testutils.Logger(t, ""saslauth""),
		Plain: []module.PlainAuth{
			&mockAuth{
				db: map[string]bool{
					""user1"": true,
				},
			},
		},
	}
	t.Run(""XWHATEVER"", func(t *testing.T) {
		srv := a.CreateSASL(""XWHATEVER"", &net.TCPAddr{}, func(string) error { return nil })
		_, _, err := srv.Next([]byte(""""))
		if err == nil {
			t.Error(""No error for XWHATEVER use"")
		}
	})
	t.Run(""PLAIN"", func(t *testing.T) {
		srv := a.CreateSASL(""PLAIN"", &net.TCPAddr{}, func(id string) error {
			if id != ""user1"" {
				t.Fatal(""Wrong auth. identities passed to callback:"", id)
			}
			return nil
		})
		_, _, err := srv.Next([]byte(""\x00user1\x00aa""))
		if err != nil {
			t.Error(""Unexpected error:"", err)
		}
	})
	t.Run(""PLAIN with authorization identity"", func(t *testing.T) {
		srv := a.CreateSASL(""PLAIN"", &net.TCPAddr{}, func(id string) error {
			if id != ""user1a"" {
				t.Fatal(""Wrong authorization identity passed:"", id)
			}
			return nil
		})
		_, _, err := srv.Next([]byte(""user1a\x00user1\x00aa""))
		if err != nil {
			t.Error(""Unexpected error:"", err)
		}
	})
}
",CWE-287,72.0,0
"// +build !windows
package shadow
import (
	""errors""
	""fmt""
	""os""
	""path/filepath""
	""github.com/foxcpp/maddy/internal/auth/external""
	""github.com/foxcpp/maddy/internal/config""
	""github.com/foxcpp/maddy/internal/log""
	""github.com/foxcpp/maddy/internal/module""
)
type Auth struct {
	instName   string
	useHelper  bool
	helperPath string
	Log log.Logger
}
func New(modName, instName string, _, inlineArgs []string) (module.Module, error) {
	if len(inlineArgs) != 0 {
		return nil, errors.New(""shadow: inline arguments are not used"")
	}
	return &Auth{
		instName: instName,
		Log:      log.Logger{Name: modName},
	}, nil
}
func (a *Auth) Name() string {
	return ""shadow""
}
func (a *Auth) InstanceName() string {
	return a.instName
}
func (a *Auth) Init(cfg *config.Map) error {
	cfg.Bool(""debug"", true, false, &a.Log.Debug)
	cfg.Bool(""use_helper"", false, false, &a.useHelper)
	if _, err := cfg.Process(); err != nil {
		return err
	}
	if a.useHelper {
		a.helperPath = filepath.Join(config.LibexecDirectory, ""maddy-shadow-helper"")
		if _, err := os.Stat(a.helperPath); err != nil {
			return fmt.Errorf(""shadow: no helper binary (maddy-shadow-helper) found in %s"", config.LibexecDirectory)
		}
	} else {
		f, err := os.Open(""/etc/shadow"")
		if err != nil {
			if os.IsPermission(err) {
				return fmt.Errorf(""shadow: can't read /etc/shadow due to permission error, use helper binary or run maddy as a privileged user"")
			}
			return fmt.Errorf(""shadow: can't read /etc/shadow: %v"", err)
		}
		f.Close()
	}
	return nil
}
func (a *Auth) AuthPlain(username, password string) error {
	if a.useHelper {
		return external.AuthUsingHelper(a.helperPath, username, password)
	}
	ent, err := Lookup(username)
	if err != nil {
		return err
	}
	if !ent.IsAccountValid() {
		return fmt.Errorf(""shadow: account is expired"")
	}
	if !ent.IsPasswordValid() {
		return fmt.Errorf(""shadow: password is expired"")
	}
	if err := ent.VerifyPassword(password); err != nil {
		if err == ErrWrongPassword {
			return module.ErrUnknownCredentials
		}
		return err
	}
	return nil
}
func init() {
	module.Register(""shadow"", New)
}
",CWE-287,100.0,0
"package modconfig
import (
	""github.com/foxcpp/maddy/internal/config""
	""github.com/foxcpp/maddy/internal/module""
)
func MessageCheck(globals map[string]interface{}, args []string, block *config.Node) (module.Check, error) {
	var check module.Check
	if err := ModuleFromNode(args, block, globals, &check); err != nil {
		return nil, err
	}
	return check, nil
}
// deliveryDirective is a callback for use in config.Map.Custom.
//
// It does all work necessary to create a module instance from the config
// directive with the following structure:
// directive_name mod_name [inst_name] [{
//   inline_mod_config
// }]
//
// Note that if used configuration structure lacks directive_name before mod_name - this function
// should not be used (call DeliveryTarget directly).
func DeliveryDirective(m *config.Map, node *config.Node) (interface{}, error) {
	return DeliveryTarget(m.Globals, node.Args, node)
}
func DeliveryTarget(globals map[string]interface{}, args []string, block *config.Node) (module.DeliveryTarget, error) {
	var target module.DeliveryTarget
	if err := ModuleFromNode(args, block, globals, &target); err != nil {
		return nil, err
	}
	return target, nil
}
func MsgModifier(globals map[string]interface{}, args []string, block *config.Node) (module.Modifier, error) {
	var check module.Modifier
	if err := ModuleFromNode(args, block, globals, &check); err != nil {
		return nil, err
	}
	return check, nil
}
func StorageDirective(m *config.Map, node *config.Node) (interface{}, error) {
	var backend module.Storage
	if err := ModuleFromNode(node.Args, node, m.Globals, &backend); err != nil {
		return nil, err
	}
	return backend, nil
}
func TableDirective(m *config.Map, node *config.Node) (interface{}, error) {
	var tbl module.Table
	if err := ModuleFromNode(node.Args, node, m.Globals, &tbl); err != nil {
		return nil, err
	}
	return tbl, nil
}
",CWE-287,61.0,0
"package module
import ""errors""
var (
	// ErrUnknownCredentials should be returned by auth. provider if supplied
	// credentials are valid for it but are not recognized (e.g. not found in
	// used DB).
	ErrUnknownCredentials = errors.New(""unknown credentials"")
)
// PlainAuth is the interface implemented by modules providing authentication using
// username:password pairs.
type PlainAuth interface {
	AuthPlain(username, password string) error
}
",CWE-287,17.0,0
"package module
import (
	""context""
	""github.com/emersion/go-message/textproto""
	""github.com/foxcpp/maddy/internal/buffer""
	""github.com/foxcpp/maddy/internal/config""
)
// Dummy is a struct that implements PlainAuth and DeliveryTarget
// interfaces but does nothing. Useful for testing.
//
// It is always registered under the 'dummy' name and can be used in both tests
// and the actual server code (but the latter is kinda pointless).
type Dummy struct{ instName string }
func (d *Dummy) AuthPlain(username, _ string) error {
	return nil
}
func (d *Dummy) Name() string {
	return ""dummy""
}
func (d *Dummy) InstanceName() string {
	return d.instName
}
func (d *Dummy) Init(_ *config.Map) error {
	return nil
}
func (d *Dummy) Start(ctx context.Context, msgMeta *MsgMetadata, mailFrom string) (Delivery, error) {
	return dummyDelivery{}, nil
}
type dummyDelivery struct{}
func (dd dummyDelivery) AddRcpt(ctx context.Context, to string) error {
	return nil
}
func (dd dummyDelivery) Body(ctx context.Context, header textproto.Header, body buffer.Buffer) error {
	return nil
}
func (dd dummyDelivery) Abort(ctx context.Context) error {
	return nil
}
func (dd dummyDelivery) Commit(ctx context.Context) error {
	return nil
}
func init() {
	Register(""dummy"", func(_, instName string, _, _ []string) (Module, error) {
		return &Dummy{instName: instName}, nil
	})
}
",CWE-287,61.0,0
"/*
Maddy Mail Server - Composable all-in-one email server.
Copyright © 2019-2020 Max Mazurov <fox.cpp@disroot.org>, Maddy Mail Server contributors
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/
package auth
import (
	""errors""
	""fmt""
	""net""
	""github.com/emersion/go-sasl""
	""github.com/foxcpp/maddy/framework/config""
	modconfig ""github.com/foxcpp/maddy/framework/config/module""
	""github.com/foxcpp/maddy/framework/log""
	""github.com/foxcpp/maddy/framework/module""
)
var (
	ErrUnsupportedMech = errors.New(""Unsupported SASL mechanism"")
	ErrInvalidAuthCred = errors.New(""auth: invalid credentials"")
)
// SASLAuth is a wrapper that initializes sasl.Server using authenticators that
// call maddy module objects.
//
// It supports reporting of multiple authorization identities so multiple
// accounts can be associated with a single set of credentials.
type SASLAuth struct {
	Log         log.Logger
	OnlyFirstID bool
	Plain []module.PlainAuth
}
func (s *SASLAuth) SASLMechanisms() []string {
	var mechs []string
	if len(s.Plain) != 0 {
		mechs = append(mechs, sasl.Plain, sasl.Login)
	}
	return mechs
}
func (s *SASLAuth) AuthPlain(username, password string) error {
	if len(s.Plain) == 0 {
		return ErrUnsupportedMech
	}
	var lastErr error
	for _, p := range s.Plain {
		lastErr = p.AuthPlain(username, password)
		if lastErr == nil {
			return nil
		}
	}
	return fmt.Errorf(""no auth. provider accepted creds, last err: %w"", lastErr)
}
// CreateSASL creates the sasl.Server instance for the corresponding mechanism.
func (s *SASLAuth) CreateSASL(mech string, remoteAddr net.Addr, successCb func(identity string) error) sasl.Server {
	switch mech {
	case sasl.Plain:
		return sasl.NewPlainServer(func(identity, username, password string) error {
			if identity == """" {
				identity = username
			}
			if identity != username {
				return ErrInvalidAuthCred
			}
			err := s.AuthPlain(username, password)
			if err != nil {
				s.Log.Error(""authentication failed"", err, ""username"", username, ""src_ip"", remoteAddr)
				return ErrInvalidAuthCred
			}
			return successCb(identity)
		})
	case sasl.Login:
		return sasl.NewLoginServer(func(username, password string) error {
			err := s.AuthPlain(username, password)
			if err != nil {
				s.Log.Error(""authentication failed"", err, ""username"", username, ""src_ip"", remoteAddr)
				return ErrInvalidAuthCred
			}
			return successCb(username)
		})
	}
	return FailingSASLServ{Err: ErrUnsupportedMech}
}
// AddProvider adds the SASL authentication provider to its mapping by parsing
// the 'auth' configuration directive.
func (s *SASLAuth) AddProvider(m *config.Map, node config.Node) error {
	var any interface{}
	if err := modconfig.ModuleFromNode(""auth"", node.Args, node, m.Globals, &any); err != nil {
		return err
	}
	hasAny := false
	if plainAuth, ok := any.(module.PlainAuth); ok {
		s.Plain = append(s.Plain, plainAuth)
		hasAny = true
	}
	if !hasAny {
		return config.NodeErr(node, ""auth: specified module does not provide any SASL mechanism"")
	}
	return nil
}
type FailingSASLServ struct{ Err error }
func (s FailingSASLServ) Next([]byte) ([]byte, bool, error) {
	return nil, true, s.Err
}
",CWE-287,135.0,0
"/*
Maddy Mail Server - Composable all-in-one email server.
Copyright © 2019-2020 Max Mazurov <fox.cpp@disroot.org>, Maddy Mail Server contributors
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/
package auth
import (
	""errors""
	""net""
	""testing""
	""github.com/foxcpp/maddy/framework/module""
	""github.com/foxcpp/maddy/internal/testutils""
)
type mockAuth struct {
	db map[string]bool
}
func (m mockAuth) AuthPlain(username, _ string) error {
	ok := m.db[username]
	if !ok {
		return errors.New(""invalid creds"")
	}
	return nil
}
func TestCreateSASL(t *testing.T) {
	a := SASLAuth{
		Log: testutils.Logger(t, ""saslauth""),
		Plain: []module.PlainAuth{
			&mockAuth{
				db: map[string]bool{
					""user1"": true,
				},
			},
		},
	}
	t.Run(""XWHATEVER"", func(t *testing.T) {
		srv := a.CreateSASL(""XWHATEVER"", &net.TCPAddr{}, func(string) error { return nil })
		_, _, err := srv.Next([]byte(""""))
		if err == nil {
			t.Error(""No error for XWHATEVER use"")
		}
	})
	t.Run(""PLAIN"", func(t *testing.T) {
		srv := a.CreateSASL(""PLAIN"", &net.TCPAddr{}, func(id string) error {
			if id != ""user1"" {
				t.Fatal(""Wrong auth. identities passed to callback:"", id)
			}
			return nil
		})
		_, _, err := srv.Next([]byte(""\x00user1\x00aa""))
		if err != nil {
			t.Error(""Unexpected error:"", err)
		}
	})
	t.Run(""PLAIN with authorization identity"", func(t *testing.T) {
		srv := a.CreateSASL(""PLAIN"", &net.TCPAddr{}, func(id string) error {
			if id != ""user1"" {
				t.Fatal(""Wrong authorization identity passed:"", id)
			}
			return nil
		})
		_, _, err := srv.Next([]byte(""user1\x00user1\x00aa""))
		if err != nil {
			t.Error(""Unexpected error:"", err)
		}
	})
}
",CWE-287,90.0,0
"// Code generated by statik. DO NOT EDIT.
package statik
import (
	""github.com/rakyll/statik/fs""
)
func init() {
	data := ""PK\x03\x04\x14\x00\x08\x00\x08\x00wheT\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x11\x00	\x00favicon-16x16.pngUT\x05\x00\x01\xb2_
		fs.Register(data)
	}
	",CWE-287,14.0,0
"package types
import (
	sdkerrors ""github.com/cosmos/cosmos-sdk/types/errors""
)
// RootCodespace is the codespace for all errors defined in this package
const RootCodespace = ""evmos""
// root error codes for Evmos
const (
	codeKeyTypeNotSupported = iota + 2
)
// errors
var (
	ErrKeyTypeNotSupported = sdkerrors.Register(RootCodespace, codeKeyTypeNotSupported, ""key type 'secp256k1' not supported"")
)
",CWE-287,19.0,0
"package keeper
import (
	""strings""
	sdk ""github.com/cosmos/cosmos-sdk/types""
	sdkerrors ""github.com/cosmos/cosmos-sdk/types/errors""
	transfertypes ""github.com/cosmos/ibc-go/v3/modules/apps/transfer/types""
	channeltypes ""github.com/cosmos/ibc-go/v3/modules/core/04-channel/types""
	""github.com/cosmos/ibc-go/v3/modules/core/exported""
	evmos ""github.com/tharsis/evmos/v2/types""
	""github.com/tharsis/evmos/v2/x/claims/types""
)
// OnRecvPacket performs an IBC receive callback. It performs a no-op if
// claims are inactive
func (k Keeper) OnRecvPacket(
	ctx sdk.Context,
	packet channeltypes.Packet,
	ack exported.Acknowledgement,
) exported.Acknowledgement {
	params := k.GetParams(ctx)
	// short (no-op) circuit by returning original ACK in case the claim is not active
	if !params.IsClaimsActive(ctx.BlockTime()) {
		return ack
	}
	// unmarshal packet data to obtain the sender and recipient
	var data transfertypes.FungibleTokenPacketData
	if err := transfertypes.ModuleCdc.UnmarshalJSON(packet.GetData(), &data); err != nil {
		err = sdkerrors.Wrapf(sdkerrors.ErrUnknownRequest, ""cannot unmarshal ICS-20 transfer packet data"")
		return channeltypes.NewErrorAcknowledgement(err.Error())
	}
	// validate the sender bech32 address from the counterparty chain
	bech32Prefix := strings.Split(data.Sender, ""1"")[0]
	if bech32Prefix == data.Sender {
		return channeltypes.NewErrorAcknowledgement(
			sdkerrors.Wrapf(sdkerrors.ErrInvalidAddress, ""invalid sender: %s"", data.Sender).Error(),
		)
	}
	senderBz, err := sdk.GetFromBech32(data.Sender, bech32Prefix)
	if err != nil {
		return channeltypes.NewErrorAcknowledgement(
			sdkerrors.Wrapf(sdkerrors.ErrInvalidAddress, ""invalid sender %s, %s"", data.Sender, err.Error()).Error(),
		)
	}
	// change the bech32 human readable prefix (HRP) of the sender to `evmos1`
	sender := sdk.AccAddress(senderBz)
	// obtain the evmos recipient address
	recipient, err := sdk.AccAddressFromBech32(data.Receiver)
	if err != nil {
		return channeltypes.NewErrorAcknowledgement(
			sdkerrors.Wrapf(sdkerrors.ErrInvalidAddress, ""invalid receiver address %s"", err.Error()).Error(),
		)
	}
	senderClaimsRecord, senderRecordFound := k.GetClaimsRecord(ctx, sender)
	// NOTE: we know that the connected chains from the authorized IBC channels
	// don't support ethereum keys (i.e `ethsecp256k1`). Thus, so we return an error,
	// unless the destination channel from a connection to a chain that is EVM-compatible
	// or supports ethereum keys (eg: Cronos, Injective).
	if sender.Equals(recipient) && !params.IsEVMChannel(packet.DestinationChannel) {
		switch {
		// case 1: secp256k1 key from sender/recipient has no claimed actions -> error ACK to prevent funds from getting stuck
		case senderRecordFound && !senderClaimsRecord.HasClaimedAny():
			return channeltypes.NewErrorAcknowledgement(
				sdkerrors.Wrapf(
					evmos.ErrKeyTypeNotSupported, ""receiver address %s is not a valid ethereum address"", data.Receiver,
				).Error(),
			)
		default:
			// case 2: sender/recipient has funds stuck -> error acknowledgement to prevent more transferred tokens from
			// getting stuck while we implement IBC withdrawals
			return channeltypes.NewErrorAcknowledgement(
				sdkerrors.Wrapf(
					evmos.ErrKeyTypeNotSupported,
					""reverted transfer to unsupported address %s to prevent more funds from getting stuck"",
					data.Receiver,
				).Error(),
			)
		}
	}
	// return original ACK in case the destination channel is not authorized
	if !params.IsAuthorizedChannel(packet.DestinationChannel) {
		return ack
	}
	recipientClaimsRecord, recipientRecordFound := k.GetClaimsRecord(ctx, recipient)
	// handle the 4 cases for the recipient and sender claim records
	switch {
	case senderRecordFound && recipientRecordFound:
		// 1. Both sender and recipient have a claims record
		// Merge sender's record with the recipient's record and
		// claim actions that have been completed by one or the other
		recipientClaimsRecord, err = k.MergeClaimsRecords(ctx, recipient, senderClaimsRecord, recipientClaimsRecord, params)
		if err != nil {
			return channeltypes.NewErrorAcknowledgement(err.Error())
		}
		// update the recipient's record with the new merged one, while deleting the
		// sender's record
		k.SetClaimsRecord(ctx, recipient, recipientClaimsRecord)
		k.DeleteClaimsRecord(ctx, sender)
	case senderRecordFound && !recipientRecordFound:
		// 2. Only the sender has a claims record.
		// Migrate the sender record to the recipient address
		k.SetClaimsRecord(ctx, recipient, senderClaimsRecord)
		k.DeleteClaimsRecord(ctx, sender)
		// claim IBC action
		_, err = k.ClaimCoinsForAction(ctx, recipient, senderClaimsRecord, types.ActionIBCTransfer, params)
	case !senderRecordFound && recipientRecordFound:
		// 3. Only the recipient has a claims record.
		// Only claim IBC transfer action
		_, err = k.ClaimCoinsForAction(ctx, recipient, recipientClaimsRecord, types.ActionIBCTransfer, params)
	case !senderRecordFound && !recipientRecordFound:
		// 4. Neither the sender or recipient have a claims record.
		// Perform a no-op by returning the  original success acknowledgement
		return ack
	}
	if err != nil {
		return channeltypes.NewErrorAcknowledgement(err.Error())
	}
	// return the original success acknowledgement
	return ack
}
// OnAcknowledgementPacket claims the amount from the `ActionIBCTransfer` for
// the sender of the IBC transfer.
// The function performs a no-op if claims are disabled globally,
// acknowledgment failed, or if sender the sender has no claims record.
func (k Keeper) OnAcknowledgementPacket(
	ctx sdk.Context,
	packet channeltypes.Packet,
	acknowledgement []byte,
) error {
	params := k.GetParams(ctx)
	// short circuit in case claim is not active (no-op)
	if !params.IsClaimsActive(ctx.BlockTime()) {
		return nil
	}
	var ack channeltypes.Acknowledgement
	if err := transfertypes.ModuleCdc.UnmarshalJSON(acknowledgement, &ack); err != nil {
		return sdkerrors.Wrapf(sdkerrors.ErrUnknownRequest, ""cannot unmarshal ICS-20 transfer packet acknowledgement: %v"", err)
	}
	// no-op if the acknowledgement is an error ACK
	if !ack.Success() {
		return nil
	}
	var data transfertypes.FungibleTokenPacketData
	if err := transfertypes.ModuleCdc.UnmarshalJSON(packet.GetData(), &data); err != nil {
		return sdkerrors.Wrapf(sdkerrors.ErrUnknownRequest, ""cannot unmarshal ICS-20 transfer packet data: %s"", err.Error())
	}
	sender, err := sdk.AccAddressFromBech32(data.Sender)
	if err != nil {
		return err
	}
	claimRecord, found := k.GetClaimsRecord(ctx, sender)
	if !found {
		// no-op. The user doesn't have a claim record so we don't need to perform
		// any claim
		return nil
	}
	// claim IBC transfer action
	_, err = k.ClaimCoinsForAction(ctx, sender, claimRecord, types.ActionIBCTransfer, params)
	if err != nil {
		return err
	}
	return nil
}
",CWE-287,191.0,0
"package claims
import (
	""context""
	""encoding/json""
	""fmt""
	""github.com/gorilla/mux""
	""github.com/grpc-ecosystem/grpc-gateway/runtime""
	""github.com/spf13/cobra""
	abci ""github.com/tendermint/tendermint/abci/types""
	""github.com/cosmos/cosmos-sdk/client""
	""github.com/cosmos/cosmos-sdk/codec""
	cdctypes ""github.com/cosmos/cosmos-sdk/codec/types""
	sdk ""github.com/cosmos/cosmos-sdk/types""
	""github.com/cosmos/cosmos-sdk/types/module""
	""github.com/tharsis/evmos/v2/x/claims/client/cli""
	""github.com/tharsis/evmos/v2/x/claims/keeper""
	""github.com/tharsis/evmos/v2/x/claims/types""
)
var (
	_ module.AppModule      = AppModule{}
	_ module.AppModuleBasic = AppModuleBasic{}
)
// ----------------------------------------------------------------------------
// AppModuleBasic
// ----------------------------------------------------------------------------
// AppModuleBasic implements the AppModuleBasic interface for the claim module.
type AppModuleBasic struct {
	cdc codec.Codec
}
func NewAppModuleBasic(cdc codec.Codec) AppModuleBasic {
	return AppModuleBasic{cdc: cdc}
}
// Name returns the claim module's name.
func (AppModuleBasic) Name() string {
	return types.ModuleName
}
func (AppModuleBasic) RegisterLegacyAminoCodec(cdc *codec.LegacyAmino) {
}
// RegisterInterfaces registers the module's interface types
func (a AppModuleBasic) RegisterInterfaces(reg cdctypes.InterfaceRegistry) {
}
// DefaultGenesis returns the claim module's default genesis state.
func (AppModuleBasic) DefaultGenesis(cdc codec.JSONCodec) json.RawMessage {
	return cdc.MustMarshalJSON(types.DefaultGenesis())
}
// ValidateGenesis performs genesis state validation for the claim module.
func (AppModuleBasic) ValidateGenesis(cdc codec.JSONCodec, config client.TxEncodingConfig, bz json.RawMessage) error {
	var genState types.GenesisState
	if err := cdc.UnmarshalJSON(bz, &genState); err != nil {
		return fmt.Errorf(""failed to unmarshal %s genesis state: %w"", types.ModuleName, err)
	}
	return genState.Validate()
}
// RegisterRESTRoutes registers the claim module's REST service handlers.
func (AppModuleBasic) RegisterRESTRoutes(clientCtx client.Context, rtr *mux.Router) {
}
// RegisterGRPCGatewayRoutes registers the gRPC Gateway routes for the module.
func (AppModuleBasic) RegisterGRPCGatewayRoutes(clientCtx client.Context, mux *runtime.ServeMux) {
	err := types.RegisterQueryHandlerClient(context.Background(), mux, types.NewQueryClient(clientCtx))
	if err != nil {
		panic(err)
	}
}
// GetTxCmd returns the claim module's root tx command.
func (a AppModuleBasic) GetTxCmd() *cobra.Command { return nil }
// GetQueryCmd returns the claim module's root query command.
func (AppModuleBasic) GetQueryCmd() *cobra.Command {
	return cli.GetQueryCmd()
}
// ----------------------------------------------------------------------------
// AppModule
// ----------------------------------------------------------------------------
// AppModule implements the AppModule interface for the claim module.
type AppModule struct {
	AppModuleBasic
	keeper keeper.Keeper
}
func NewAppModule(cdc codec.Codec, keeper keeper.Keeper) AppModule {
	return AppModule{
		AppModuleBasic: NewAppModuleBasic(cdc),
		keeper:         keeper,
	}
}
// Name returns the claim module's name.
func (am AppModule) Name() string {
	return am.AppModuleBasic.Name()
}
// Route returns the claim module's message routing key.
func (am AppModule) Route() sdk.Route {
	return sdk.NewRoute(types.RouterKey, NewHandler(am.keeper))
}
// QuerierRoute returns the claim module's query routing key.
func (AppModule) QuerierRoute() string { return """" }
// LegacyQuerierHandler returns the claim module's Querier.
func (am AppModule) LegacyQuerierHandler(legacyQuerierCdc *codec.LegacyAmino) sdk.Querier {
	return nil
}
// RegisterServices registers a GRPC query service to respond to the
// module-specific GRPC queries.
func (am AppModule) RegisterServices(cfg module.Configurator) {
	types.RegisterQueryServer(cfg.QueryServer(), am.keeper)
	migrator := keeper.NewMigrator(am.keeper)
	// register v1 -> v2 migration
	if err := cfg.RegisterMigration(types.ModuleName, 1, migrator.Migrate1to2); err != nil {
		panic(fmt.Errorf(""failed to migrate %s to v2: %w"", types.ModuleName, err))
	}
}
// RegisterInvariants registers the claim module's invariants.
func (am AppModule) RegisterInvariants(_ sdk.InvariantRegistry) {}
// InitGenesis performs the claim module's genesis initialization It returns
// no validator updates.
func (am AppModule) InitGenesis(ctx sdk.Context, cdc codec.JSONCodec, gs json.RawMessage) []abci.ValidatorUpdate {
	var genState types.GenesisState
	// Initialize global index to index in genesis state
	cdc.MustUnmarshalJSON(gs, &genState)
	InitGenesis(ctx, am.keeper, genState)
	return []abci.ValidatorUpdate{}
}
// ExportGenesis returns the claim module's exported genesis state as raw JSON bytes.
func (am AppModule) ExportGenesis(ctx sdk.Context, cdc codec.JSONCodec) json.RawMessage {
	genState := ExportGenesis(ctx, am.keeper)
	return cdc.MustMarshalJSON(genState)
}
// BeginBlock executes all ABCI BeginBlock logic respective to the claim module.
func (am AppModule) BeginBlock(_ sdk.Context, _ abci.RequestBeginBlock) {}
// EndBlock executes all ABCI EndBlock logic respective to the claim module. It
// returns no validator updates.
func (am AppModule) EndBlock(ctx sdk.Context, _ abci.RequestEndBlock) []abci.ValidatorUpdate {
	am.keeper.EndBlocker(ctx)
	return []abci.ValidatorUpdate{}
}
// ConsensusVersion implements AppModule/ConsensusVersion.
func (AppModule) ConsensusVersion() uint64 { return 2 }
",CWE-287,171.0,0
"package types
import (
	""errors""
	""fmt""
	sdk ""github.com/cosmos/cosmos-sdk/types""
)
// NewClaimsRecord creates a new claim record instance
func NewClaimsRecord(initialClaimableAmt sdk.Int) ClaimsRecord {
	return ClaimsRecord{
		InitialClaimableAmount: initialClaimableAmt,
		ActionsCompleted:       []bool{false, false, false, false},
	}
}
// Validate performs a stateless validation of the fields
func (cr ClaimsRecord) Validate() error {
	if cr.InitialClaimableAmount.IsNil() {
		return errors.New(""initial claimable amount is nil"")
	}
	if !cr.InitialClaimableAmount.IsPositive() {
		return fmt.Errorf(""initial claimable amount is not positive, %s"", cr.InitialClaimableAmount)
	}
	if len(cr.ActionsCompleted) == 0 || len(Action_value)-1 != len(cr.ActionsCompleted) {
		return fmt.Errorf(""action length mismatch, expected %d, got %d"", len(Action_value)-1, len(cr.ActionsCompleted))
	}
	return nil
}
// ClaimAction marks the given action as completed. It performs a no-op if the
// action is invalid or if the ActionsCompleted slice has an invalid length.
func (cr *ClaimsRecord) ClaimAction(action Action) {
	switch {
	case len(cr.ActionsCompleted) != len(Action_value)-1:
		return
	case action == ActionUnspecified || int(action) > len(Action_value)-1:
		return
	default:
		cr.ActionsCompleted[action-1] = true
	}
}
// HasClaimedAction checks if the user has claimed a given action. It also
// returns false if the action is invalid or if the ActionsCompleted slice has
// an invalid length.
func (cr ClaimsRecord) HasClaimedAction(action Action) bool {
	switch {
	case len(cr.ActionsCompleted) != len(Action_value)-1:
		return false
	case action == 0 || int(action) > len(Action_value)-1:
		return false
	default:
		return cr.ActionsCompleted[action-1]
	}
}
// HasClaimedAny returns true if the user has claimed at least one reward from the
// available actions
func (cr ClaimsRecord) HasClaimedAny() bool {
	for _, completed := range cr.ActionsCompleted {
		if completed {
			return true
		}
	}
	return false
}
// HasClaimedAll returns true if the user has claimed all the rewards from the
// available actions
func (cr ClaimsRecord) HasClaimedAll() bool {
	if len(cr.ActionsCompleted) == 0 {
		return false
	}
	for _, completed := range cr.ActionsCompleted {
		if !completed {
			return false
		}
	}
	return true
}
// NewClaimsRecordAddress creates a new claim record instance
func NewClaimsRecordAddress(address sdk.AccAddress, initialClaimableAmt sdk.Int) ClaimsRecordAddress {
	return ClaimsRecordAddress{
		Address:                address.String(),
		InitialClaimableAmount: initialClaimableAmt,
		ActionsCompleted:       []bool{false, false, false, false},
	}
}
// Validate performs a stateless validation of the fields
func (cra ClaimsRecordAddress) Validate() error {
	if _, err := sdk.AccAddressFromBech32(cra.Address); err != nil {
		return err
	}
	if cra.InitialClaimableAmount.IsNil() {
		return errors.New(""initial claimable amount is nil"")
	}
	if !cra.InitialClaimableAmount.IsPositive() {
		return fmt.Errorf(""initial claimable amount is not positive, %s"", cra.InitialClaimableAmount)
	}
	if len(Action_value)-1 != len(cra.ActionsCompleted) {
		return fmt.Errorf(""action length mismatch, expected %d, got %d"", len(Action_value)-1, len(cra.ActionsCompleted))
	}
	return nil
}
",CWE-287,114.0,0
"package erc20
import (
	""context""
	""encoding/json""
	""fmt""
	""math/rand""
	""github.com/cosmos/cosmos-sdk/client""
	""github.com/cosmos/cosmos-sdk/codec""
	codectypes ""github.com/cosmos/cosmos-sdk/codec/types""
	sdk ""github.com/cosmos/cosmos-sdk/types""
	""github.com/cosmos/cosmos-sdk/types/module""
	simtypes ""github.com/cosmos/cosmos-sdk/types/simulation""
	authkeeper ""github.com/cosmos/cosmos-sdk/x/auth/keeper""
	""github.com/gorilla/mux""
	""github.com/grpc-ecosystem/grpc-gateway/runtime""
	""github.com/spf13/cobra""
	abci ""github.com/tendermint/tendermint/abci/types""
	""github.com/tharsis/evmos/v2/x/erc20/client/cli""
	""github.com/tharsis/evmos/v2/x/erc20/keeper""
	""github.com/tharsis/evmos/v2/x/erc20/types""
)
// type check to ensure the interface is properly implemented
var (
	_ module.AppModule           = AppModule{}
	_ module.AppModuleBasic      = AppModuleBasic{}
	_ module.AppModuleSimulation = AppModule{}
)
// app module Basics object
type AppModuleBasic struct{}
func (AppModuleBasic) Name() string {
	return types.ModuleName
}
// RegisterLegacyAminoCodec performs a no-op as the erc20 doesn't support Amino encoding
func (AppModuleBasic) RegisterLegacyAminoCodec(cdc *codec.LegacyAmino) {}
// ConsensusVersion returns the consensus state-breaking version for the module.
func (AppModuleBasic) ConsensusVersion() uint64 {
	return 2
}
// RegisterInterfaces registers interfaces and implementations of the erc20 module.
func (AppModuleBasic) RegisterInterfaces(interfaceRegistry codectypes.InterfaceRegistry) {
	types.RegisterInterfaces(interfaceRegistry)
}
// DefaultGenesis returns default genesis state as raw bytes for the erc20
// module.
func (AppModuleBasic) DefaultGenesis(cdc codec.JSONCodec) json.RawMessage {
	return cdc.MustMarshalJSON(types.DefaultGenesisState())
}
func (b AppModuleBasic) ValidateGenesis(cdc codec.JSONCodec, config client.TxEncodingConfig, bz json.RawMessage) error {
	var genesisState types.GenesisState
	if err := cdc.UnmarshalJSON(bz, &genesisState); err != nil {
		return fmt.Errorf(""failed to unmarshal %s genesis state: %w"", types.ModuleName, err)
	}
	return genesisState.Validate()
}
// RegisterRESTRoutes performs a no-op as the erc20 module doesn't expose REST
// endpoints
func (AppModuleBasic) RegisterRESTRoutes(clientCtx client.Context, rtr *mux.Router) {}
func (b AppModuleBasic) RegisterGRPCGatewayRoutes(c client.Context, serveMux *runtime.ServeMux) {
	if err := types.RegisterQueryHandlerClient(context.Background(), serveMux, types.NewQueryClient(c)); err != nil {
		panic(err)
	}
}
// GetTxCmd returns the root tx command for the erc20 module.
func (AppModuleBasic) GetTxCmd() *cobra.Command {
	return cli.NewTxCmd()
}
// GetQueryCmd returns no root query command for the erc20 module.
func (AppModuleBasic) GetQueryCmd() *cobra.Command {
	return cli.GetQueryCmd()
}
type AppModule struct {
	AppModuleBasic
	keeper keeper.Keeper
	ak     authkeeper.AccountKeeper
}
// NewAppModule creates a new AppModule Object
func NewAppModule(
	k keeper.Keeper,
	ak authkeeper.AccountKeeper,
) AppModule {
	return AppModule{
		AppModuleBasic: AppModuleBasic{},
		keeper:         k,
		ak:             ak,
	}
}
func (AppModule) Name() string {
	return types.ModuleName
}
func (am AppModule) RegisterInvariants(ir sdk.InvariantRegistry) {}
func (am AppModule) NewHandler() sdk.Handler {
	return NewHandler(am.keeper)
}
func (am AppModule) Route() sdk.Route {
	return sdk.NewRoute(types.RouterKey, am.NewHandler())
}
func (am AppModule) QuerierRoute() string {
	return types.RouterKey
}
func (am AppModule) LegacyQuerierHandler(amino *codec.LegacyAmino) sdk.Querier {
	return nil
}
func (am AppModule) RegisterServices(cfg module.Configurator) {
	types.RegisterMsgServer(cfg.MsgServer(), am.keeper)
	types.RegisterQueryServer(cfg.QueryServer(), am.keeper)
	migrator := keeper.NewMigrator(am.keeper)
	// register v1 -> v2 migration
	if err := cfg.RegisterMigration(types.ModuleName, 1, migrator.Migrate1to2); err != nil {
		panic(fmt.Errorf(""failed to migrate %s to v2: %w"", types.ModuleName, err))
	}
}
func (am AppModule) BeginBlock(_ sdk.Context, _ abci.RequestBeginBlock) {
}
func (am AppModule) EndBlock(_ sdk.Context, _ abci.RequestEndBlock) []abci.ValidatorUpdate {
	return []abci.ValidatorUpdate{}
}
func (am AppModule) InitGenesis(ctx sdk.Context, cdc codec.JSONCodec, data json.RawMessage) []abci.ValidatorUpdate {
	var genesisState types.GenesisState
	cdc.MustUnmarshalJSON(data, &genesisState)
	InitGenesis(ctx, am.keeper, am.ak, genesisState)
	return []abci.ValidatorUpdate{}
}
func (am AppModule) ExportGenesis(ctx sdk.Context, cdc codec.JSONCodec) json.RawMessage {
	gs := ExportGenesis(ctx, am.keeper)
	return cdc.MustMarshalJSON(gs)
}
func (am AppModule) GenerateGenesisState(input *module.SimulationState) {
}
func (am AppModule) ProposalContents(simState module.SimulationState) []simtypes.WeightedProposalContent {
	return []simtypes.WeightedProposalContent{}
}
func (am AppModule) RandomizedParams(r *rand.Rand) []simtypes.ParamChange {
	return []simtypes.ParamChange{}
}
func (am AppModule) RegisterStoreDecoder(decoderRegistry sdk.StoreDecoderRegistry) {
}
func (am AppModule) WeightedOperations(simState module.SimulationState) []simtypes.WeightedOperation {
	return []simtypes.WeightedOperation{}
}
",CWE-287,177.0,0
"package inflation
import (
	sdk ""github.com/cosmos/cosmos-sdk/types""
	""github.com/tharsis/evmos/v2/x/inflation/keeper""
	""github.com/tharsis/evmos/v2/x/inflation/types""
)
// InitGenesis import module genesis
func InitGenesis(
	ctx sdk.Context,
	k keeper.Keeper,
	ak types.AccountKeeper,
	_ types.StakingKeeper,
	data types.GenesisState,
) {
	// Ensure inflation module account is set on genesis
	if acc := ak.GetModuleAccount(ctx, types.ModuleName); acc == nil {
		panic(""the inflation module account has not been set"")
	}
	// Set genesis state
	params := data.Params
	k.SetParams(ctx, params)
	period := data.Period
	k.SetPeriod(ctx, period)
	epochIdentifier := data.EpochIdentifier
	k.SetEpochIdentifier(ctx, epochIdentifier)
	epochsPerPeriod := data.EpochsPerPeriod
	k.SetEpochsPerPeriod(ctx, epochsPerPeriod)
	// Get bondedRatio
	bondedRatio := k.BondedRatio(ctx)
	// Calculate epoch mint provision
	epochMintProvision := types.CalculateEpochMintProvision(
		params,
		period,
		epochsPerPeriod,
		bondedRatio,
	)
	k.SetEpochMintProvision(ctx, epochMintProvision)
}
// ExportGenesis returns a GenesisState for a given context and keeper.
func ExportGenesis(ctx sdk.Context, k keeper.Keeper) *types.GenesisState {
	return &types.GenesisState{
		Params:          k.GetParams(ctx),
		Period:          k.GetPeriod(ctx),
		EpochIdentifier: k.GetEpochIdentifier(ctx),
		EpochsPerPeriod: k.GetEpochsPerPeriod(ctx),
	}
}
",CWE-287,57.0,0
"package keeper
import (
	""fmt""
	sdk ""github.com/cosmos/cosmos-sdk/types""
	epochstypes ""github.com/tharsis/evmos/v2/x/epochs/types""
	""github.com/tharsis/evmos/v2/x/inflation/types""
)
// BeforeEpochStart: noop, We don't need to do anything here
func (k Keeper) BeforeEpochStart(_ sdk.Context, _ string, _ int64) {
}
// AfterEpochEnd mints and distributes coins at the end of each epoch end
func (k Keeper) AfterEpochEnd(ctx sdk.Context, epochIdentifier string, epochNumber int64) {
	params := k.GetParams(ctx)
	expEpochID := k.GetEpochIdentifier(ctx)
	if epochIdentifier != expEpochID {
		return
	}
	// mint coins, update supply
	epochMintProvision, found := k.GetEpochMintProvision(ctx)
	if !found {
		panic(""the epochMintProvision was not found"")
	}
	mintedCoin := sdk.NewCoin(params.MintDenom, epochMintProvision.TruncateInt())
	if err := k.MintAndAllocateInflation(ctx, mintedCoin); err != nil {
		panic(err)
	}
	// check if a period is over. If it's completed, update period, and epochMintProvision
	period := k.GetPeriod(ctx)
	epochsPerPeriod := k.GetEpochsPerPeriod(ctx)
	newProvision := epochMintProvision
	// current epoch number needs to be within range for the period
	// Given, epochNumber = 1, period = 0, epochPerPeriod = 365
	// 1 - 365 * 0 < 365 --- nothing to do here
	// Given, epochNumber = 731, period = 1, epochPerPeriod = 365
	// 731 - 1 * 365 > 365 --- a period has passed! we change the epochMintProvision and set a new period
	if epochNumber-epochsPerPeriod*int64(period) > epochsPerPeriod {
		period++
		k.SetPeriod(ctx, period)
		period = k.GetPeriod(ctx)
		bondedRatio := k.BondedRatio(ctx)
		newProvision = types.CalculateEpochMintProvision(
			params,
			period,
			epochsPerPeriod,
			bondedRatio,
		)
		k.SetEpochMintProvision(ctx, newProvision)
	}
	ctx.EventManager().EmitEvent(
		sdk.NewEvent(
			types.EventTypeMint,
			sdk.NewAttribute(types.AttributeEpochNumber, fmt.Sprintf(""%d"", epochNumber)),
			sdk.NewAttribute(types.AttributeKeyEpochProvisions, newProvision.String()),
			sdk.NewAttribute(sdk.AttributeKeyAmount, mintedCoin.Amount.String()),
		),
	)
}
// ___________________________________________________________________________________________________
// Hooks wrapper struct for incentives keeper
type Hooks struct {
	k Keeper
}
var _ epochstypes.EpochHooks = Hooks{}
// Return the wrapper struct
func (k Keeper) Hooks() Hooks {
	return Hooks{k}
}
// epochs hooks
func (h Hooks) BeforeEpochStart(ctx sdk.Context, epochIdentifier string, epochNumber int64) {
	h.k.BeforeEpochStart(ctx, epochIdentifier, epochNumber)
}
func (h Hooks) AfterEpochEnd(ctx sdk.Context, epochIdentifier string, epochNumber int64) {
	h.k.AfterEpochEnd(ctx, epochIdentifier, epochNumber)
}
",CWE-287,91.0,0
"package keeper_test
import (
	""fmt""
	""time""
	""github.com/tharsis/evmos/v2/x/inflation/types""
)
func (suite *KeeperTestSuite) TestEpochIdentifierAfterEpochEnd() {
	testCases := []struct {
		name            string
		epochIdentifier string
		expDistribution bool
	}{
		{
			""correct epoch identifier"",
			""day"",
			true,
		},
		{
			""incorrect epoch identifier"",
			""week"",
			false,
		},
	}
	for _, tc := range testCases {
		suite.Run(fmt.Sprintf(""Case %s"", tc.name), func() {
			suite.SetupTest()
			futureCtx := suite.ctx.WithBlockTime(time.Now().Add(time.Hour))
			newHeight := suite.app.LastBlockHeight() + 1
			feePoolOrigin := suite.app.DistrKeeper.GetFeePool(suite.ctx)
			suite.app.EpochsKeeper.BeforeEpochStart(futureCtx, tc.epochIdentifier, newHeight)
			suite.app.EpochsKeeper.AfterEpochEnd(futureCtx, tc.epochIdentifier, newHeight)
			suite.app.EpochsKeeper.AfterEpochEnd(futureCtx, tc.epochIdentifier, newHeight)
			// check the distribution happened as well
			feePoolNew := suite.app.DistrKeeper.GetFeePool(suite.ctx)
			if tc.expDistribution {
				// Actual distribution portions are tested elsewhere; we just want to verify the value of the pool is greater here
				suite.Require().Greater(feePoolNew.CommunityPool.AmountOf(denomMint).BigInt().Uint64(),
					feePoolOrigin.CommunityPool.AmountOf(denomMint).BigInt().Uint64())
			} else {
				suite.Require().Equal(feePoolNew.CommunityPool.AmountOf(denomMint), feePoolOrigin.CommunityPool.AmountOf(denomMint))
			}
		})
	}
}
func (suite *KeeperTestSuite) TestPeriodChangesAfterEpochEnd() {
	suite.SetupTest()
	currentEpochPeriod := suite.app.InflationKeeper.GetEpochsPerPeriod(suite.ctx)
	// bondingRatio is zero in tests
	bondedRatio := suite.app.InflationKeeper.BondedRatio(suite.ctx)
	testCases := []struct {
		name    string
		height  int64
		changes bool
	}{
		{
			""[Period 0] period stays the same under epoch per period"",
			currentEpochPeriod - 10, // so it's within range
			false,
		},
		{
			""[Period 0] period changes once enough epochs have passed"",
			currentEpochPeriod + 1,
			true,
		},
		{
			""[Period 1] period stays the same under the epoch per period"",
			2*currentEpochPeriod - 1,
			false,
		},
		{
			""[Period 1] period changes once enough epochs have passed"",
			2*currentEpochPeriod + 1,
			true,
		},
	}
	for _, tc := range testCases {
		suite.Run(fmt.Sprintf(""Case %s"", tc.name), func() {
			currentPeriod := suite.app.InflationKeeper.GetPeriod(suite.ctx)
			epochIdentifier := suite.app.InflationKeeper.GetEpochIdentifier(suite.ctx)
			originalProvision, found := suite.app.InflationKeeper.GetEpochMintProvision(suite.ctx)
			suite.Require().True(found)
			futureCtx := suite.ctx.WithBlockTime(time.Now().Add(time.Minute))
			suite.app.EpochsKeeper.BeforeEpochStart(futureCtx, epochIdentifier, tc.height)
			suite.app.EpochsKeeper.AfterEpochEnd(futureCtx, epochIdentifier, tc.height)
			newPeriod := suite.app.InflationKeeper.GetPeriod(suite.ctx)
			if tc.changes {
				newProvision, found := suite.app.InflationKeeper.GetEpochMintProvision(suite.ctx)
				suite.Require().True(found)
				expectedProvision := types.CalculateEpochMintProvision(
					suite.app.InflationKeeper.GetParams(suite.ctx),
					newPeriod,
					currentEpochPeriod,
					bondedRatio,
				)
				suite.Require().Equal(expectedProvision, newProvision)
				// mint provisions will change
				suite.Require().NotEqual(newProvision.BigInt().Uint64(), originalProvision.BigInt().Uint64())
				suite.Require().Equal(currentPeriod+1, newPeriod)
			} else {
				suite.Require().Equal(newPeriod, currentPeriod)
			}
		})
	}
}
",CWE-287,118.0,0
"package keeper
import (
	sdk ""github.com/cosmos/cosmos-sdk/types""
	ethermint ""github.com/tharsis/ethermint/types""
	incentivestypes ""github.com/tharsis/evmos/v2/x/incentives/types""
	""github.com/tharsis/evmos/v2/x/inflation/types""
)
// 200M token at year 4 allocated to the team
var teamAlloc = sdk.NewInt(200_000_000).Mul(ethermint.PowerReduction)
// MintAndAllocateInflation performs inflation minting and allocation
func (k Keeper) MintAndAllocateInflation(ctx sdk.Context, coin sdk.Coin) error {
	// Mint coins for distribution
	if err := k.MintCoins(ctx, coin); err != nil {
		return err
	}
	// Allocate minted coins according to allocation proportions (staking, usage
	// incentives, community pool)
	return k.AllocateExponentialInflation(ctx, coin)
}
// MintCoins implements an alias call to the underlying supply keeper's
// MintCoins to be used in BeginBlocker.
func (k Keeper) MintCoins(ctx sdk.Context, newCoin sdk.Coin) error {
	newCoins := sdk.NewCoins(newCoin)
	// skip as no coins need to be minted
	if newCoins.Empty() {
		return nil
	}
	return k.bankKeeper.MintCoins(ctx, types.ModuleName, newCoins)
}
// AllocateExponentialInflation allocates coins from the inflation to external
// modules according to allocation proportions:
//   - staking rewards -> sdk `auth` module fee collector
//   - usage incentives -> `x/incentives` module
//   - community pool -> `sdk `distr` module community pool
func (k Keeper) AllocateExponentialInflation(ctx sdk.Context, mintedCoin sdk.Coin) error {
	params := k.GetParams(ctx)
	proportions := params.InflationDistribution
	// Allocate staking rewards into fee collector account
	stakingRewardsAmt := sdk.NewCoins(k.GetProportions(ctx, mintedCoin, proportions.StakingRewards))
	err := k.bankKeeper.SendCoinsFromModuleToModule(
		ctx,
		types.ModuleName,
		k.feeCollectorName,
		stakingRewardsAmt,
	)
	if err != nil {
		return err
	}
	// Allocate usage incentives to incentives module account
	usageIncentivesAmt := sdk.NewCoins(k.GetProportions(ctx, mintedCoin, proportions.UsageIncentives))
	err = k.bankKeeper.SendCoinsFromModuleToModule(
		ctx,
		types.ModuleName,
		incentivestypes.ModuleName,
		usageIncentivesAmt,
	)
	if err != nil {
		return err
	}
	// Allocate community pool amount (remaining module balance) to community
	// pool address
	moduleAddr := k.accountKeeper.GetModuleAddress(types.ModuleName)
	communityPoolAmt := k.bankKeeper.GetAllBalances(ctx, moduleAddr)
	return k.distrKeeper.FundCommunityPool(
		ctx,
		communityPoolAmt,
		moduleAddr,
	)
}
// GetAllocationProportion calculates the proportion of coins that is to be
// allocated during inflation for a given distribution.
func (k Keeper) GetProportions(
	ctx sdk.Context,
	coin sdk.Coin,
	distribution sdk.Dec,
) sdk.Coin {
	return sdk.NewCoin(
		coin.Denom,
		coin.Amount.ToDec().Mul(distribution).TruncateInt(),
	)
}
// BondedRatio the fraction of the staking tokens which are currently bonded
// It doesn't consider team allocation for inflation
func (k Keeper) BondedRatio(ctx sdk.Context) sdk.Dec {
	stakeSupply := k.stakingKeeper.StakingTokenSupply(ctx)
	if !stakeSupply.IsPositive() || stakeSupply.LTE(teamAlloc) {
		return sdk.ZeroDec()
	}
	stakeSupply = stakeSupply.Sub(teamAlloc)
	return k.stakingKeeper.TotalBondedTokens(ctx).ToDec().QuoInt(stakeSupply)
}
",CWE-287,108.0,0
"package types // noalias
import (
	sdk ""github.com/cosmos/cosmos-sdk/types""
	""github.com/cosmos/cosmos-sdk/x/auth/types""
)
// AccountKeeper defines the contract required for account APIs.
type AccountKeeper interface {
	GetModuleAddress(name string) sdk.AccAddress
	GetModuleAccount(ctx sdk.Context, moduleName string) types.ModuleAccountI
	GetAccount(sdk.Context, sdk.AccAddress) types.AccountI
	SetAccount(sdk.Context, types.AccountI)
}
// BankKeeper defines the contract needed to be fulfilled for banking and supply
// dependencies.
type BankKeeper interface {
	GetBalance(ctx sdk.Context, addr sdk.AccAddress, denom string) sdk.Coin
	GetAllBalances(ctx sdk.Context, addr sdk.AccAddress) sdk.Coins
	SendCoinsFromModuleToAccount(ctx sdk.Context, senderModule string, recipientAddr sdk.AccAddress, amt sdk.Coins) error
	SendCoinsFromModuleToModule(ctx sdk.Context, senderModule, recipientModule string, amt sdk.Coins) error
	MintCoins(ctx sdk.Context, name string, amt sdk.Coins) error
	BurnCoins(ctx sdk.Context, name string, amt sdk.Coins) error
	HasSupply(ctx sdk.Context, denom string) bool
}
// DistrKeeper defines the contract needed to be fulfilled for distribution keeper
type DistrKeeper interface {
	FundCommunityPool(ctx sdk.Context, amount sdk.Coins, sender sdk.AccAddress) error
}
// StakingKeeper expected staking keeper
type StakingKeeper interface {
	// BondedRatio the fraction of the staking tokens which are currently bonded
	BondedRatio(ctx sdk.Context) sdk.Dec
	StakingTokenSupply(ctx sdk.Context) sdk.Int
	TotalBondedTokens(ctx sdk.Context) sdk.Int
}
",CWE-287,40.0,0
"// Copyright 2017 HootSuite Media Inc.
//
// Licensed under the Apache License, Version 2.0 (the License);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//    http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an AS IS BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Modified hereafter by contributors to runatlantis/atlantis.
package events
import (
	""crypto/subtle""
	""encoding/json""
	""fmt""
	""io""
	""net/http""
	gitlab ""github.com/xanzy/go-gitlab""
)
const secretHeader = ""X-Gitlab-Token"" // 
//go:generate pegomock generate -m --use-experimental-model-gen --package mocks -o mocks/mock_gitlab_request_parser_validator.go GitlabRequestParserValidator
// GitlabRequestParserValidator parses and validates GitLab requests.
type GitlabRequestParserValidator interface {
	// ParseAndValidate validates that the request has a token header matching secret.
	// If the secret does not match it returns an error.
	// If secret is empty it does not check the token header.
	// It then parses the request as a GitLab object depending on the header
	// provided by GitLab identifying the webhook type. If the webhook type
	// is not recognized it will return nil but will not return an error.
	// Usage:
	//	event, err := GitlabRequestParserValidator.ParseAndValidate(r, secret)
	//	if err != nil {
	//		return
	//	}
	//	switch event := event.(type) {
	//	case gitlab.MergeCommentEvent:
	//		// handle
	//	case gitlab.MergeEvent:
	//		// handle
	//	default:
	//		// unsupported event
	//	}
	ParseAndValidate(r *http.Request, secret []byte) (interface{}, error)
}
// DefaultGitlabRequestParserValidator parses and validates GitLab requests.
type DefaultGitlabRequestParserValidator struct{}
// ParseAndValidate returns the JSON payload of the request.
// See GitlabRequestParserValidator.ParseAndValidate().
func (d *DefaultGitlabRequestParserValidator) ParseAndValidate(r *http.Request, secret []byte) (interface{}, error) {
	const mergeEventHeader = ""Merge Request Hook""
	const noteEventHeader = ""Note Hook""
	// Validate secret if specified.
	headerSecret := r.Header.Get(secretHeader)
	if len(secret) != 0 && subtle.ConstantTimeCompare(secret, []byte(headerSecret)) != 1 {
		return nil, fmt.Errorf(""header %s=%s did not match expected secret"", secretHeader, headerSecret)
	}
	// Parse request into a gitlab object based on the object type specified
	// in the gitlabHeader.
	bytes, err := io.ReadAll(r.Body)
	if err != nil {
		return nil, err
	}
	switch r.Header.Get(gitlabHeader) {
	case mergeEventHeader:
		var m gitlab.MergeEvent
		if err := json.Unmarshal(bytes, &m); err != nil {
			return nil, err
		}
		return m, nil
	case noteEventHeader:
		// First, parse a small part of the json to determine if this is a
		// comment on a merge request or a commit.
		var subset struct {
			ObjectAttributes struct {
				NoteableType string `json:""noteable_type""`
			} `json:""object_attributes""`
		}
		if err := json.Unmarshal(bytes, &subset); err != nil {
			return nil, err
		}
		// We then parse into the correct comment event type.
		switch subset.ObjectAttributes.NoteableType {
		case ""Commit"":
			var e gitlab.CommitCommentEvent
			err := json.Unmarshal(bytes, &e)
			return e, err
		case ""MergeRequest"":
			var e gitlab.MergeCommentEvent
			err := json.Unmarshal(bytes, &e)
			return e, err
		}
	}
	return nil, nil
}
",CWE-203,108.0,0
"// Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
package singleflight
import (
	""errors""
	""fmt""
	""sync""
	""sync/atomic""
	""testing""
	""time""
)
func TestDo(t *testing.T) {
	t.Skip(""singleflight tests not stable"")
	var g Group
	v, err, _ := g.Do(""key"", func() (interface{}, error) {
		return ""bar"", nil
	})
	if got, want := fmt.Sprintf(""%v (%T)"", v, v), ""bar (string)""; got != want {
		t.Errorf(""Do = %v; want %v"", got, want)
	}
	if err != nil {
		t.Errorf(""Do error = %v"", err)
	}
}
func TestDoErr(t *testing.T) {
	t.Skip(""singleflight tests not stable"")
	var g Group
	someErr := errors.New(""Some error"")
	v, err, _ := g.Do(""key"", func() (interface{}, error) {
		return nil, someErr
	})
	if err != someErr {
		t.Errorf(""Do error = %v; want someErr %v"", err, someErr)
	}
	if v != nil {
		t.Errorf(""unexpected non-nil value %
	}
}
func TestDoDupSuppress(t *testing.T) {
	t.Skip(""singleflight tests not stable"")
	var g Group
	var wg1, wg2 sync.WaitGroup
	c := make(chan string, 1)
	var calls int32
	fn := func() (interface{}, error) {
		if atomic.AddInt32(&calls, 1) == 1 {
			// First invocation.
			wg1.Done()
		}
		v := <-c
		c <- v // pump; make available for any future calls
		time.Sleep(10 * time.Millisecond) // let more goroutines enter Do
		return v, nil
	}
	const n = 10
	wg1.Add(1)
	for i := 0; i < n; i++ {
		wg1.Add(1)
		wg2.Add(1)
		go func() {
			defer wg2.Done()
			wg1.Done()
			v, err, _ := g.Do(""key"", fn)
			if err != nil {
				t.Errorf(""Do error: %v"", err)
				return
			}
			if s, _ := v.(string); s != ""bar"" {
				t.Errorf(""Do = %T %v; want %q"", v, v, ""bar"")
			}
		}()
	}
	wg1.Wait()
	// At least one goroutine is in fn now and all of them have at
	// least reached the line before the Do.
	c <- ""bar""
	wg2.Wait()
	if got := atomic.LoadInt32(&calls); got <= 0 || got >= n {
		t.Errorf(""number of calls = %d; want over 0 and less than %d"", got, n)
	}
}
// Test that singleflight behaves correctly after Forget called.
// See https://github.com/golang/go/issues/31420
func TestForget(t *testing.T) {
	t.Skip(""singleflight tests not stable"")
	var g Group
	var firstStarted, firstFinished sync.WaitGroup
	firstStarted.Add(1)
	firstFinished.Add(1)
	firstCh := make(chan struct{})
	go func() {
		g.Do(""key"", func() (i interface{}, e error) {
			firstStarted.Done()
			<-firstCh
			firstFinished.Done()
			return
		})
	}()
	firstStarted.Wait()
	g.Forget(""key"") // from this point no two function using same key should be executed concurrently
	var secondStarted int32
	var secondFinished int32
	var thirdStarted int32
	secondCh := make(chan struct{})
	secondRunning := make(chan struct{})
	go func() {
		g.Do(""key"", func() (i interface{}, e error) {
			defer func() {
			}()
			atomic.AddInt32(&secondStarted, 1)
			// Notify that we started
			secondCh <- struct{}{}
			// Wait other get above signal
			<-secondRunning
			<-secondCh
			atomic.AddInt32(&secondFinished, 1)
			return 2, nil
		})
	}()
	close(firstCh)
	firstFinished.Wait() // wait for first execution (which should not affect execution after Forget)
	<-secondCh
	// Notify second that we got the signal that it started
	secondRunning <- struct{}{}
	if atomic.LoadInt32(&secondStarted) != 1 {
		t.Fatal(""Second execution should be executed due to usage of forget"")
	}
	if atomic.LoadInt32(&secondFinished) == 1 {
		t.Fatal(""Second execution should be still active"")
	}
	close(secondCh)
	result, _, _ := g.Do(""key"", func() (i interface{}, e error) {
		atomic.AddInt32(&thirdStarted, 1)
		return 3, nil
	})
	if atomic.LoadInt32(&thirdStarted) != 0 {
		t.Error(""Third call should not be started because was started during second execution"")
	}
	if result != 2 {
		t.Errorf(""We should receive result produced by second call, expected: 2, got %d"", result)
	}
}
",CWE-326,164.0,0
"package s3crypto
import (
	""io""
	""strings""
)
const (
	cbcKeySize   = 32
	cbcNonceSize = 16
)
type cbcContentCipherBuilder struct {
	generator CipherDataGenerator
	padder    Padder
}
func (cbcContentCipherBuilder) isUsingDeprecatedFeatures() error {
	return errDeprecatedCipherBuilder
}
// AESCBCContentCipherBuilder returns a new encryption only mode structure with a specific cipher
// for the master key
//
// deprecated: This content cipher builder has been deprecated. Users should migrate to AESGCMContentCipherBuilder
func AESCBCContentCipherBuilder(generator CipherDataGenerator, padder Padder) ContentCipherBuilder {
	return cbcContentCipherBuilder{generator: generator, padder: padder}
}
func (builder cbcContentCipherBuilder) ContentCipher() (ContentCipher, error) {
	cd, err := builder.generator.GenerateCipherData(cbcKeySize, cbcNonceSize)
	if err != nil {
		return nil, err
	}
	cd.Padder = builder.padder
	return newAESCBCContentCipher(cd)
}
// newAESCBCContentCipher will create a new aes cbc content cipher. If the cipher data's
// will set the CEK algorithm if it hasn't been set.
func newAESCBCContentCipher(cd CipherData) (ContentCipher, error) {
	if len(cd.CEKAlgorithm) == 0 {
		cd.CEKAlgorithm = strings.Join([]string{AESCBC, cd.Padder.Name()}, ""/"")
	}
	cipher, err := newAESCBC(cd, cd.Padder)
	if err != nil {
		return nil, err
	}
	return &aesCBCContentCipher{
		CipherData: cd,
		Cipher:     cipher,
	}, nil
}
// aesCBCContentCipher will use AES CBC for the main cipher.
type aesCBCContentCipher struct {
	CipherData CipherData
	Cipher     Cipher
}
// EncryptContents will generate a random key and iv and encrypt the data using cbc
func (cc *aesCBCContentCipher) EncryptContents(src io.Reader) (io.Reader, error) {
	return cc.Cipher.Encrypt(src), nil
}
// DecryptContents will use the symmetric key provider to instantiate a new CBC cipher.
// We grab a decrypt reader from CBC and wrap it in a CryptoReadCloser. The only error
// expected here is when the key or iv is of invalid length.
func (cc *aesCBCContentCipher) DecryptContents(src io.ReadCloser) (io.ReadCloser, error) {
	reader := cc.Cipher.Decrypt(src)
	return &CryptoReadCloser{Body: src, Decrypter: reader}, nil
}
// GetCipherData returns cipher data
func (cc aesCBCContentCipher) GetCipherData() CipherData {
	return cc.CipherData
}
",CWE-326,80.0,0
"package s3crypto
import (
	""io""
	""github.com/aws/aws-sdk-go/aws""
)
const (
	gcmKeySize   = 32
	gcmNonceSize = 12
)
type gcmContentCipherBuilder struct {
	generator CipherDataGenerator
}
func (builder gcmContentCipherBuilder) isUsingDeprecatedFeatures() error {
	if feature, ok := builder.generator.(deprecatedFeatures); ok {
		return feature.isUsingDeprecatedFeatures()
	}
	return nil
}
// AESGCMContentCipherBuilder returns a new encryption only mode structure with a specific cipher
// for the master key
func AESGCMContentCipherBuilder(generator CipherDataGenerator) ContentCipherBuilder {
	return gcmContentCipherBuilder{generator}
}
func (builder gcmContentCipherBuilder) ContentCipher() (ContentCipher, error) {
	return builder.ContentCipherWithContext(aws.BackgroundContext())
}
func (builder gcmContentCipherBuilder) ContentCipherWithContext(ctx aws.Context) (ContentCipher, error) {
	var cd CipherData
	var err error
	switch v := builder.generator.(type) {
	case CipherDataGeneratorWithCEKAlgWithContext:
		cd, err = v.GenerateCipherDataWithCEKAlgWithContext(ctx, gcmKeySize, gcmNonceSize, AESGCMNoPadding)
	case CipherDataGeneratorWithCEKAlg:
		cd, err = v.GenerateCipherDataWithCEKAlg(gcmKeySize, gcmNonceSize, AESGCMNoPadding)
	case CipherDataGeneratorWithContext:
		cd, err = v.GenerateCipherDataWithContext(ctx, gcmKeySize, gcmNonceSize)
	default:
		cd, err = builder.generator.GenerateCipherData(gcmKeySize, gcmNonceSize)
	}
	if err != nil {
		return nil, err
	}
	return newAESGCMContentCipher(cd)
}
func newAESGCMContentCipher(cd CipherData) (ContentCipher, error) {
	cd.CEKAlgorithm = AESGCMNoPadding
	cd.TagLength = ""128""
	cipher, err := newAESGCM(cd)
	if err != nil {
		return nil, err
	}
	return &aesGCMContentCipher{
		CipherData: cd,
		Cipher:     cipher,
	}, nil
}
// AESGCMContentCipher will use AES GCM for the main cipher.
type aesGCMContentCipher struct {
	CipherData CipherData
	Cipher     Cipher
}
// EncryptContents will generate a random key and iv and encrypt the data using cbc
func (cc *aesGCMContentCipher) EncryptContents(src io.Reader) (io.Reader, error) {
	return cc.Cipher.Encrypt(src), nil
}
// DecryptContents will use the symmetric key provider to instantiate a new GCM cipher.
// We grab a decrypt reader from gcm and wrap it in a CryptoReadCloser. The only error
// expected here is when the key or iv is of invalid length.
func (cc *aesGCMContentCipher) DecryptContents(src io.ReadCloser) (io.ReadCloser, error) {
	reader := cc.Cipher.Decrypt(src)
	return &CryptoReadCloser{Body: src, Decrypter: reader}, nil
}
// GetCipherData returns cipher data
func (cc aesGCMContentCipher) GetCipherData() CipherData {
	return cc.CipherData
}
",CWE-326,94.0,0
"package s3crypto_test
import (
	""testing""
	""github.com/aws/aws-sdk-go/service/kms/kmsiface""
	""github.com/aws/aws-sdk-go/service/s3/s3crypto""
)
func TestAESGCMContentCipherBuilder(t *testing.T) {
	generator := mockGenerator{}
	if builder := s3crypto.AESGCMContentCipherBuilder(generator); builder == nil {
		t.Error(""expected non-nil value"")
	}
}
func TestAESGCMContentCipherNewEncryptor(t *testing.T) {
	generator := mockGenerator{}
	builder := s3crypto.AESGCMContentCipherBuilder(generator)
	cipher, err := builder.ContentCipher()
	if err != nil {
		t.Errorf(""expected no error, but received %v"", err)
	}
	if cipher == nil {
		t.Errorf(""expected non-nil vaue"")
	}
}
type mockKMS struct {
	kmsiface.KMSAPI
}
",CWE-326,34.0,0
"package s3crypto
import (
	""encoding/base64""
	""strconv""
)
// AESGCMNoPadding is the constant value that is used to specify
// the CEK algorithm consiting of AES GCM with no padding.
const AESGCMNoPadding = ""AES/GCM/NoPadding""
// AESCBC is the string constant that signifies the AES CBC algorithm cipher.
const AESCBC = ""AES/CBC""
func encodeMeta(reader hashReader, cd CipherData) (Envelope, error) {
	iv := base64.StdEncoding.EncodeToString(cd.IV)
	key := base64.StdEncoding.EncodeToString(cd.EncryptedKey)
	md5 := reader.GetValue()
	contentLength := reader.GetContentLength()
	md5Str := base64.StdEncoding.EncodeToString(md5)
	matdesc, err := cd.MaterialDescription.encodeDescription()
	if err != nil {
		return Envelope{}, err
	}
	return Envelope{
		CipherKey:             key,
		IV:                    iv,
		MatDesc:               string(matdesc),
		WrapAlg:               cd.WrapAlgorithm,
		CEKAlg:                cd.CEKAlgorithm,
		TagLen:                cd.TagLength,
		UnencryptedMD5:        md5Str,
		UnencryptedContentLen: strconv.FormatInt(contentLength, 10),
	}, nil
}
",CWE-326,39.0,0
"package s3crypto
import (
	""strings""
	""github.com/aws/aws-sdk-go/aws""
	""github.com/aws/aws-sdk-go/aws/client""
	""github.com/aws/aws-sdk-go/aws/request""
	""github.com/aws/aws-sdk-go/service/kms""
	""github.com/aws/aws-sdk-go/service/s3""
	""github.com/aws/aws-sdk-go/service/s3/s3iface""
)
// WrapEntry is builder that return a proper key decrypter and error
type WrapEntry func(Envelope) (CipherDataDecrypter, error)
// CEKEntry is a builder thatn returns a proper content decrypter and error
type CEKEntry func(CipherData) (ContentCipher, error)
// DecryptionClient is an S3 crypto client. The decryption client
// will handle all get object requests from Amazon S3.
// Supported key wrapping algorithms:
//	*AWS KMS
//
// Supported content ciphers:
//	* AES/GCM
//	* AES/CBC
//
// deprecated: See DecryptionClientV2
type DecryptionClient struct {
	S3Client s3iface.S3API
	// LoadStrategy is used to load the metadata either from the metadata of the object
	// or from a separate file in s3.
	//
	// Defaults to our default load strategy.
	LoadStrategy LoadStrategy
	WrapRegistry   map[string]WrapEntry
	CEKRegistry    map[string]CEKEntry
	PadderRegistry map[string]Padder
}
// NewDecryptionClient instantiates a new S3 crypto client
//
// Example:
//	sess := session.New()
//	svc := s3crypto.NewDecryptionClient(sess, func(svc *s3crypto.DecryptionClient{
//		// Custom client options here
//	}))
//
// deprecated: see NewDecryptionClientV2
func NewDecryptionClient(prov client.ConfigProvider, options ...func(*DecryptionClient)) *DecryptionClient {
	s3client := s3.New(prov)
	s3client.Handlers.Build.PushBack(func(r *request.Request) {
		request.AddToUserAgent(r, ""S3Crypto"")
	})
	client := &DecryptionClient{
		S3Client: s3client,
		LoadStrategy: defaultV2LoadStrategy{
			client: s3client,
		},
		WrapRegistry: map[string]WrapEntry{
			KMSWrap: (kmsKeyHandler{
				kms: kms.New(prov),
			}).decryptHandler,
		},
		CEKRegistry: map[string]CEKEntry{
			AESGCMNoPadding: newAESGCMContentCipher,
			strings.Join([]string{AESCBC, AESCBCPadder.Name()}, ""/""): newAESCBCContentCipher,
		},
		PadderRegistry: map[string]Padder{
			strings.Join([]string{AESCBC, AESCBCPadder.Name()}, ""/""): AESCBCPadder,
			""NoPadding"": NoPadder,
		},
	}
	for _, option := range options {
		option(client)
	}
	return client
}
// GetObjectRequest will make a request to s3 and retrieve the object. In this process
// decryption will be done. The SDK only supports V2 reads of KMS and GCM.
//
// Example:
//  sess := session.Must(session.NewSession())
//	svc := s3crypto.NewDecryptionClient(sess)
//	req, out := svc.GetObjectRequest(&s3.GetObjectInput {
//	  Key: aws.String(""testKey""),
//	  Bucket: aws.String(""testBucket""),
//	})
//	err := req.Send()
//
// deprecated: see DecryptionClientV2.GetObjectRequest
func (c *DecryptionClient) GetObjectRequest(input *s3.GetObjectInput) (*request.Request, *s3.GetObjectOutput) {
	return getObjectRequest(c.getClientOptions(), input)
}
// GetObject is a wrapper for GetObjectRequest
//
// deprecated: see DecryptionClientV2.GetObject
func (c *DecryptionClient) GetObject(input *s3.GetObjectInput) (*s3.GetObjectOutput, error) {
	return getObject(c.getClientOptions(), input)
}
// GetObjectWithContext is a wrapper for GetObjectRequest with the additional
// context, and request options support.
//
// GetObjectWithContext is the same as GetObject with the additional support for
// Context input parameters. The Context must not be nil. A nil Context will
// cause a panic. Use the Context to add deadlining, timeouts, etc. In the future
// this may create sub-contexts for individual underlying requests.
//
// deprecated: see DecryptionClientV2.GetObjectWithContext
func (c *DecryptionClient) GetObjectWithContext(ctx aws.Context, input *s3.GetObjectInput, opts ...request.Option) (*s3.GetObjectOutput, error) {
	return getObjectWithContext(c.getClientOptions(), ctx, input, opts...)
}
func (c *DecryptionClient) getClientOptions() DecryptionClientOptions {
	return DecryptionClientOptions{
		S3Client:       c.S3Client,
		LoadStrategy:   c.LoadStrategy,
		WrapRegistry:   c.WrapRegistry,
		CEKRegistry:    c.CEKRegistry,
		PadderRegistry: c.PadderRegistry,
	}
}
",CWE-326,131.0,0
"package s3crypto
import (
	""strings""
	""github.com/aws/aws-sdk-go/aws""
	""github.com/aws/aws-sdk-go/aws/client""
	""github.com/aws/aws-sdk-go/aws/request""
	""github.com/aws/aws-sdk-go/service/kms""
	""github.com/aws/aws-sdk-go/service/s3""
	""github.com/aws/aws-sdk-go/service/s3/s3iface""
)
// DecryptionClientV2 is an S3 crypto client. The decryption client
// will handle all get object requests from Amazon S3.
// Supported key wrapping algorithms:
//	* AWS KMS
//	* AWS KMS + Context
//
// Supported content ciphers:
//	* AES/GCM
//	* AES/CBC
type DecryptionClientV2 struct {
	options DecryptionClientOptions
}
// DecryptionClientOptions is the configuration options for DecryptionClientV2.
type DecryptionClientOptions struct {
	S3Client s3iface.S3API
	// LoadStrategy is used to load the metadata either from the metadata of the object
	// or from a separate file in s3.
	//
	// Defaults to our default load strategy.
	LoadStrategy LoadStrategy
	WrapRegistry   map[string]WrapEntry
	CEKRegistry    map[string]CEKEntry
	PadderRegistry map[string]Padder
}
// NewDecryptionClientV2 instantiates a new V2 S3 crypto client. The returned DecryptionClientV2 will be able to decrypt
// object encrypted by both the V1 and V2 clients.
//
// Example:
//	sess := session.Must(session.NewSession())
//	svc := s3crypto.NewDecryptionClientV2(sess, func(svc *s3crypto.DecryptionClientOptions{
//		// Custom client options here
//	}))
func NewDecryptionClientV2(prov client.ConfigProvider, options ...func(clientOptions *DecryptionClientOptions)) *DecryptionClientV2 {
	s3client := s3.New(prov)
	s3client.Handlers.Build.PushBack(func(r *request.Request) {
		request.AddToUserAgent(r, ""S3CryptoV2"")
	})
	kmsClient := kms.New(prov)
	clientOptions := &DecryptionClientOptions{
		S3Client: s3client,
		LoadStrategy: defaultV2LoadStrategy{
			client: s3client,
		},
		WrapRegistry: map[string]WrapEntry{
			KMSWrap:        NewKMSWrapEntry(kmsClient),
			KMSContextWrap: NewKMSContextWrapEntry(kmsClient),
		},
		CEKRegistry: map[string]CEKEntry{
			AESGCMNoPadding: newAESGCMContentCipher,
			strings.Join([]string{AESCBC, AESCBCPadder.Name()}, ""/""): newAESCBCContentCipher,
		},
		PadderRegistry: map[string]Padder{
			strings.Join([]string{AESCBC, AESCBCPadder.Name()}, ""/""): AESCBCPadder,
			""NoPadding"": NoPadder,
		},
	}
	for _, option := range options {
		option(clientOptions)
	}
	return &DecryptionClientV2{options: *clientOptions}
}
// GetObjectRequest will make a request to s3 and retrieve the object. In this process
// decryption will be done. The SDK only supports V2 reads of KMS and GCM.
//
// Example:
//  sess := session.Must(session.NewSession())
//	svc := s3crypto.NewDecryptionClientV2(sess)
//	req, out := svc.GetObjectRequest(&s3.GetObjectInput {
//	  Key: aws.String(""testKey""),
//	  Bucket: aws.String(""testBucket""),
//	})
//	err := req.Send()
func (c *DecryptionClientV2) GetObjectRequest(input *s3.GetObjectInput) (*request.Request, *s3.GetObjectOutput) {
	return getObjectRequest(c.options, input)
}
// GetObject is a wrapper for GetObjectRequest
func (c *DecryptionClientV2) GetObject(input *s3.GetObjectInput) (*s3.GetObjectOutput, error) {
	req, out := getObjectRequest(c.options, input)
	return out, req.Send()
}
// GetObjectWithContext is a wrapper for GetObjectRequest with the additional
// context, and request options support.
//
// GetObjectWithContext is the same as GetObject with the additional support for
// Context input parameters. The Context must not be nil. A nil Context will
// cause a panic. Use the Context to add deadlining, timeouts, etc. In the future
// this may create sub-contexts for individual underlying requests.
func (c *DecryptionClientV2) GetObjectWithContext(ctx aws.Context, input *s3.GetObjectInput, opts ...request.Option) (*s3.GetObjectOutput, error) {
	req, out := getObjectRequest(c.options, input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}
",CWE-326,116.0,0
"package s3crypto_test
import (
	""testing""
	""github.com/aws/aws-sdk-go/awstesting/unit""
	""github.com/aws/aws-sdk-go/service/kms""
	""github.com/aws/aws-sdk-go/service/s3/s3crypto""
)
func TestDecryptionClientV2_CheckDeprecatedFeatures(t *testing.T) {
	// AES/GCM/NoPadding with kms+context => allowed
	builder := s3crypto.AESGCMContentCipherBuilder(s3crypto.NewKMSContextKeyGenerator(kms.New(unit.Session), ""cmkID""))
	_, err := s3crypto.NewEncryptionClientV2(unit.Session, builder)
	if err != nil {
		t.Errorf(""expected no error, got %v"", err)
	}
	// AES/GCM/NoPadding with kms => not allowed
	builder = s3crypto.AESGCMContentCipherBuilder(s3crypto.NewKMSKeyGenerator(kms.New(unit.Session), ""cmkID""))
	_, err = s3crypto.NewEncryptionClientV2(unit.Session, builder)
	if err == nil {
		t.Error(""expected error, but got nil"")
	}
	// AES/CBC/PKCS5Padding with kms => not allowed
	builder = s3crypto.AESCBCContentCipherBuilder(s3crypto.NewKMSKeyGenerator(kms.New(unit.Session), ""cmkID""), s3crypto.NewPKCS7Padder(128))
	_, err = s3crypto.NewEncryptionClientV2(unit.Session, builder)
	if err == nil {
		t.Error(""expected error, but got nil"")
	}
	// AES/CBC/PKCS5Padding with kms+context => not allowed
	builder = s3crypto.AESCBCContentCipherBuilder(s3crypto.NewKMSContextKeyGenerator(kms.New(unit.Session), ""cmkID""), s3crypto.NewPKCS7Padder(128))
	_, err = s3crypto.NewEncryptionClientV2(unit.Session, builder)
	if err == nil {
		t.Error(""expected error, but got nil"")
	}
}
",CWE-326,40.0,0
"package s3crypto
import ""fmt""
var errDeprecatedCipherBuilder = fmt.Errorf(""attempted to use deprecated cipher builder"")
var errDeprecatedCipherDataGenerator = fmt.Errorf(""attempted to use deprecated cipher data generator"")
type deprecatedFeatures interface {
	isUsingDeprecatedFeatures() error
}
",CWE-326,11.0,0
"package s3crypto
import (
	""testing""
	""github.com/aws/aws-sdk-go/service/kms/kmsiface""
)
type mockKMS struct {
	kmsiface.KMSAPI
}
func TestAESGCMContentCipherBuilder_isUsingDeprecatedFeatures(t *testing.T) {
	builder := AESGCMContentCipherBuilder(NewKMSKeyGenerator(mockKMS{}, ""cmkID""))
	features, ok := builder.(deprecatedFeatures)
	if !ok {
		t.Errorf(""expected to implement deprecatedFeatures interface"")
	}
	err := features.isUsingDeprecatedFeatures()
	if err == nil {
		t.Errorf(""expected to recieve error for using deprecated features"")
	}
	builder = AESGCMContentCipherBuilder(NewKMSContextKeyGenerator(mockKMS{}, ""cmkID""))
	features, ok = builder.(deprecatedFeatures)
	if !ok {
		t.Errorf(""expected to implement deprecatedFeatures interface"")
	}
	err = features.isUsingDeprecatedFeatures()
	if err != nil {
		t.Errorf(""expected no error, got %v"", err)
	}
}
func TestAESCBCContentCipherBuilder_isUsingDeprecatedFeatures(t *testing.T) {
	builder := AESCBCContentCipherBuilder(nil, nil)
	features, ok := builder.(deprecatedFeatures)
	if !ok {
		t.Errorf(""expected to implement deprecatedFeatures interface"")
	}
	err := features.isUsingDeprecatedFeatures()
	if err == nil {
		t.Errorf(""expected to recieve error for using deprecated features"")
	}
}
",CWE-326,52.0,0
"package s3crypto
import (
	""github.com/aws/aws-sdk-go/aws""
	""github.com/aws/aws-sdk-go/aws/client""
	""github.com/aws/aws-sdk-go/aws/request""
	""github.com/aws/aws-sdk-go/service/s3""
	""github.com/aws/aws-sdk-go/service/s3/s3iface""
)
// DefaultMinFileSize is used to check whether we want to write to a temp file
// or store the data in memory.
const DefaultMinFileSize = 1024 * 512 * 5
// EncryptionClient is an S3 crypto client. By default the SDK will use Authentication mode which
// will use KMS for key wrapping and AES GCM for content encryption.
// AES GCM will load all data into memory. However, the rest of the content algorithms
// do not load the entire contents into memory.
//
// deprecated: See EncryptionClientV2
type EncryptionClient struct {
	S3Client             s3iface.S3API
	ContentCipherBuilder ContentCipherBuilder
	// SaveStrategy will dictate where the envelope is saved.
	//
	// Defaults to the object's metadata
	SaveStrategy SaveStrategy
	// TempFolderPath is used to store temp files when calling PutObject.
	// Temporary files are needed to compute the X-Amz-Content-Sha256 header.
	TempFolderPath string
	// MinFileSize is the minimum size for the content to write to a
	// temporary file instead of using memory.
	MinFileSize int64
}
// NewEncryptionClient instantiates a new S3 crypto client
//
// Example:
//	cmkID := ""arn:aws:kms:region:000000000000:key/00000000-0000-0000-0000-000000000000""
//  sess := session.Must(session.NewSession())
//	handler := s3crypto.NewKMSKeyGenerator(kms.New(sess), cmkID)
//	svc := s3crypto.NewEncryptionClient(sess, s3crypto.AESGCMContentCipherBuilder(handler))
//
// deprecated: See NewEncryptionClientV2
func NewEncryptionClient(prov client.ConfigProvider, builder ContentCipherBuilder, options ...func(*EncryptionClient)) *EncryptionClient {
	s3client := s3.New(prov)
	s3client.Handlers.Build.PushBack(func(r *request.Request) {
		request.AddToUserAgent(r, ""S3Crypto"")
	})
	client := &EncryptionClient{
		S3Client:             s3client,
		ContentCipherBuilder: builder,
		SaveStrategy:         HeaderV2SaveStrategy{},
		MinFileSize:          DefaultMinFileSize,
	}
	for _, option := range options {
		option(client)
	}
	return client
}
// PutObjectRequest creates a temp file to encrypt the contents into. It then streams
// that data to S3.
//
// Example:
//	svc := s3crypto.New(session.New(), s3crypto.AESGCMContentCipherBuilder(handler))
//	req, out := svc.PutObjectRequest(&s3.PutObjectInput {
//	  Key: aws.String(""testKey""),
//	  Bucket: aws.String(""testBucket""),
//	  Body: strings.NewReader(""test data""),
//	})
//	err := req.Send()
//
// deprecated: See EncryptionClientV2.PutObjectRequest
func (c *EncryptionClient) PutObjectRequest(input *s3.PutObjectInput) (*request.Request, *s3.PutObjectOutput) {
	return putObjectRequest(c.getClientOptions(), input)
}
// PutObject is a wrapper for PutObjectRequest
//
// deprecated: See EncryptionClientV2.PutObject
func (c *EncryptionClient) PutObject(input *s3.PutObjectInput) (*s3.PutObjectOutput, error) {
	return putObject(c.getClientOptions(), input)
}
// PutObjectWithContext is a wrapper for PutObjectRequest with the additional
// context, and request options support.
//
// PutObjectWithContext is the same as PutObject with the additional support for
// Context input parameters. The Context must not be nil. A nil Context will
// cause a panic. Use the Context to add deadlining, timeouts, etc. In the future
// this may create sub-contexts for individual underlying requests.
// PutObject is a wrapper for PutObjectRequest
//
// deprecated: See EncryptionClientV2.PutObjectWithContext
func (c *EncryptionClient) PutObjectWithContext(ctx aws.Context, input *s3.PutObjectInput, opts ...request.Option) (*s3.PutObjectOutput, error) {
	return putObjectWithContext(c.getClientOptions(), ctx, input, opts...)
}
func (c *EncryptionClient) getClientOptions() EncryptionClientOptions {
	return EncryptionClientOptions{
		S3Client:             c.S3Client,
		ContentCipherBuilder: c.ContentCipherBuilder,
		SaveStrategy:         c.SaveStrategy,
		TempFolderPath:       c.TempFolderPath,
		MinFileSize:          c.MinFileSize,
	}
}
",CWE-326,113.0,0
"package s3crypto
import (
	""github.com/aws/aws-sdk-go/aws""
	""github.com/aws/aws-sdk-go/aws/client""
	""github.com/aws/aws-sdk-go/aws/request""
	""github.com/aws/aws-sdk-go/service/s3""
	""github.com/aws/aws-sdk-go/service/s3/s3iface""
)
// EncryptionClientV2 is an S3 crypto client. By default the SDK will use Authentication mode which
// will use KMS for key wrapping and AES GCM for content encryption.
// AES GCM will load all data into memory. However, the rest of the content algorithms
// do not load the entire contents into memory.
type EncryptionClientV2 struct {
	options EncryptionClientOptions
}
// EncryptionClientOptions is the configuration options for EncryptionClientV2
type EncryptionClientOptions struct {
	S3Client             s3iface.S3API
	ContentCipherBuilder ContentCipherBuilder
	// SaveStrategy will dictate where the envelope is saved.
	//
	// Defaults to the object's metadata
	SaveStrategy SaveStrategy
	// TempFolderPath is used to store temp files when calling PutObject.
	// Temporary files are needed to compute the X-Amz-Content-Sha256 header.
	TempFolderPath string
	// MinFileSize is the minimum size for the content to write to a
	// temporary file instead of using memory.
	MinFileSize int64
}
// NewEncryptionClientV2 instantiates a new S3 crypto client. An error will be returned to the caller if the provided
// contentCipherBuilder has been deprecated, or if it uses other deprecated components.
//
// Example:
//	cmkID := ""arn:aws:kms:region:000000000000:key/00000000-0000-0000-0000-000000000000""
//  sess := session.Must(session.NewSession())
//	handler := s3crypto.NewKMSContextKeyGenerator(kms.New(sess), cmkID)
//	svc := s3crypto.NewEncryptionClientV2(sess, s3crypto.AESGCMContentCipherBuilder(handler))
func NewEncryptionClientV2(prov client.ConfigProvider, contentCipherBuilder ContentCipherBuilder, options ...func(clientOptions *EncryptionClientOptions),
) (
	client *EncryptionClientV2, err error,
) {
	s3client := s3.New(prov)
	s3client.Handlers.Build.PushBack(func(r *request.Request) {
		request.AddToUserAgent(r, ""S3CryptoV2"")
	})
	clientOptions := &EncryptionClientOptions{
		S3Client:             s3client,
		ContentCipherBuilder: contentCipherBuilder,
		SaveStrategy:         HeaderV2SaveStrategy{},
		MinFileSize:          DefaultMinFileSize,
	}
	for _, option := range options {
		option(clientOptions)
	}
	if feature, ok := contentCipherBuilder.(deprecatedFeatures); ok {
		if err := feature.isUsingDeprecatedFeatures(); err != nil {
			return nil, err
		}
	}
	client = &EncryptionClientV2{
		*clientOptions,
	}
	return client, err
}
// PutObjectRequest creates a temp file to encrypt the contents into. It then streams
// that data to S3.
//
// Example:
//  sess := session.Must(session.NewSession())
//	handler := s3crypto.NewKMSContextKeyGenerator(kms.New(sess), ""cmkID"")
//	svc := s3crypto.NewEncryptionClientV2(sess, s3crypto.AESGCMContentCipherBuilder(handler))
//	req, out := svc.PutObjectRequest(&s3.PutObjectInput {
//	  Key: aws.String(""testKey""),
//	  Bucket: aws.String(""testBucket""),
//	  Body: strings.NewReader(""test data""),
//	})
//	err := req.Send()
func (c *EncryptionClientV2) PutObjectRequest(input *s3.PutObjectInput) (*request.Request, *s3.PutObjectOutput) {
	return putObjectRequest(c.options, input)
}
// PutObject is a wrapper for PutObjectRequest
func (c *EncryptionClientV2) PutObject(input *s3.PutObjectInput) (*s3.PutObjectOutput, error) {
	return putObject(c.options, input)
}
// PutObjectWithContext is a wrapper for PutObjectRequest with the additional
// context, and request options support.
//
// PutObjectWithContext is the same as PutObject with the additional support for
// Context input parameters. The Context must not be nil. A nil Context will
// cause a panic. Use the Context to add deadlining, timeouts, etc. In the future
// this may create sub-contexts for individual underlying requests.
func (c *EncryptionClientV2) PutObjectWithContext(ctx aws.Context, input *s3.PutObjectInput, opts ...request.Option) (*s3.PutObjectOutput, error) {
	return putObjectWithContext(c.options, ctx, input, opts...)
}
",CWE-326,109.0,0
"package s3crypto
// DefaultInstructionKeySuffix is appended to the end of the instruction file key when
// grabbing or saving to S3
const DefaultInstructionKeySuffix = "".instruction""
const (
	metaHeader                     = ""x-amz-meta""
	keyV1Header                    = ""x-amz-key""
	keyV2Header                    = keyV1Header + ""-v2""
	ivHeader                       = ""x-amz-iv""
	matDescHeader                  = ""x-amz-matdesc""
	cekAlgorithmHeader             = ""x-amz-cek-alg""
	wrapAlgorithmHeader            = ""x-amz-wrap-alg""
	tagLengthHeader                = ""x-amz-tag-len""
	unencryptedMD5Header           = ""x-amz-unencrypted-content-md5""
	unencryptedContentLengthHeader = ""x-amz-unencrypted-content-length""
)
// Envelope encryption starts off by generating a random symmetric key using
// AES GCM. The SDK generates a random IV based off the encryption cipher
// chosen. The master key that was provided, whether by the user or KMS, will be used
// to encrypt the randomly generated symmetric key and base64 encode the iv. This will
// allow for decryption of that same data later.
type Envelope struct {
	// IV is the randomly generated IV base64 encoded.
	IV string `json:""x-amz-iv""`
	// CipherKey is the randomly generated cipher key.
	CipherKey string `json:""x-amz-key-v2""`
	// MaterialDesc is a description to distinguish from other envelopes.
	MatDesc               string `json:""x-amz-matdesc""`
	WrapAlg               string `json:""x-amz-wrap-alg""`
	CEKAlg                string `json:""x-amz-cek-alg""`
	TagLen                string `json:""x-amz-tag-len""`
	UnencryptedMD5        string `json:""-""`
	UnencryptedContentLen string `json:""x-amz-unencrypted-content-length""`
}
",CWE-326,38.0,0
"// +build integration,go1.14
package integration
import (
	""bytes""
	""crypto/rand""
	""flag""
	""io""
	""io/ioutil""
	""log""
	""os""
	""testing""
	""github.com/aws/aws-sdk-go/aws""
	""github.com/aws/aws-sdk-go/aws/session""
	""github.com/aws/aws-sdk-go/awstesting/integration""
	""github.com/aws/aws-sdk-go/service/kms""
	""github.com/aws/aws-sdk-go/service/kms/kmsiface""
	""github.com/aws/aws-sdk-go/service/s3""
	""github.com/aws/aws-sdk-go/service/s3/s3crypto""
	""github.com/aws/aws-sdk-go/service/s3/s3iface""
)
var config = &struct {
	Enabled  bool
	Region   string
	KMSKeyID string
	Bucket   string
	Session  *session.Session
	Clients  struct {
		KMS kmsiface.KMSAPI
		S3  s3iface.S3API
	}
}{}
func init() {
	flag.BoolVar(&config.Enabled, ""enable"", false, ""enable integration testing"")
	flag.StringVar(&config.Region, ""region"", ""us-west-2"", ""integration test region"")
	flag.StringVar(&config.KMSKeyID, ""kms-key-id"", """", ""KMS CMK Key ID"")
	flag.StringVar(&config.Bucket, ""bucket"", """", ""S3 Bucket Name"")
}
func TestMain(m *testing.M) {
	flag.Parse()
	if !config.Enabled {
		log.Println(""skipping s3crypto integration tests"")
		os.Exit(0)
	}
	if len(config.Bucket) == 0 {
		log.Fatal(""bucket name must be provided"")
	}
	if len(config.KMSKeyID) == 0 {
		log.Fatal(""kms cmk key id must be provided"")
	}
	config.Session = session.Must(session.NewSession(&aws.Config{Region: &config.Region}))
	config.Clients.KMS = kms.New(config.Session)
	config.Clients.S3 = s3.New(config.Session)
	m.Run()
}
func TestEncryptionV1_WithV2Interop(t *testing.T) {
	kmsKeyGenerator := s3crypto.NewKMSKeyGenerator(config.Clients.KMS, config.KMSKeyID)
	// 1020 is chosen here as it is not cleanly divisible by the AES-256 block size
	testData := make([]byte, 1020)
	_, err := rand.Read(testData)
	if err != nil {
		t.Fatalf(""failed to read random data: %v"", err)
	}
	v1DC := s3crypto.NewDecryptionClient(config.Session, func(client *s3crypto.DecryptionClient) {
		client.S3Client = config.Clients.S3
	})
	v2DC := s3crypto.NewDecryptionClientV2(config.Session, func(options *s3crypto.DecryptionClientOptions) {
		options.S3Client = config.Clients.S3
	})
	cases := map[string]s3crypto.ContentCipherBuilder{
		""AES/GCM/NoPadding"":    s3crypto.AESGCMContentCipherBuilder(kmsKeyGenerator),
		""AES/CBC/PKCS5Padding"": s3crypto.AESCBCContentCipherBuilder(kmsKeyGenerator, s3crypto.AESCBCPadder),
	}
	for name, ccb := range cases {
		t.Run(name, func(t *testing.T) {
			ec := s3crypto.NewEncryptionClient(config.Session, ccb, func(client *s3crypto.EncryptionClient) {
				client.S3Client = config.Clients.S3
			})
			id := integration.UniqueID()
			// PutObject with V1 Client
			putObject(t, ec, id, bytes.NewReader(testData))
			// Verify V1 Decryption Client
			getObjectAndCompare(t, v1DC, id, testData)
			// Verify V2 Decryption Client
			getObjectAndCompare(t, v2DC, id, testData)
		})
	}
}
func TestEncryptionV2(t *testing.T) {
	kmsKeyGenerator := s3crypto.NewKMSContextKeyGenerator(config.Clients.KMS, config.KMSKeyID)
	gcmContentCipherBuilder := s3crypto.AESGCMContentCipherBuilder(kmsKeyGenerator)
	ec, err := s3crypto.NewEncryptionClientV2(config.Session, gcmContentCipherBuilder, func(options *s3crypto.EncryptionClientOptions) {
		options.S3Client = config.Clients.S3
	})
	if err != nil {
		t.Fatalf(""failed to construct encryption client: %v"", err)
	}
	dc := s3crypto.NewDecryptionClientV2(config.Session, func(options *s3crypto.DecryptionClientOptions) {
		options.S3Client = config.Clients.S3
	})
	// 1020 is chosen here as it is not cleanly divisible by the AES-256 block size
	testData := make([]byte, 1020)
	_, err = rand.Read(testData)
	if err != nil {
		t.Fatalf(""failed to read random data: %v"", err)
	}
	keyId := integration.UniqueID()
	// Upload V2 Objects with Encryption Client
	putObject(t, ec, keyId, bytes.NewReader(testData))
	// Verify V2 Object with Decryption Client
	getObjectAndCompare(t, dc, keyId, testData)
}
type Encryptor interface {
	PutObject(input *s3.PutObjectInput) (*s3.PutObjectOutput, error)
}
func putObject(t *testing.T, client Encryptor, key string, reader io.ReadSeeker) {
	t.Helper()
	_, err := client.PutObject(&s3.PutObjectInput{
		Bucket: &config.Bucket,
		Key:    &key,
		Body:   reader,
	})
	if err != nil {
		t.Fatalf(""failed to upload object: %v"", err)
	}
	t.Cleanup(doKeyCleanup(key))
}
type Decryptor interface {
	GetObject(input *s3.GetObjectInput) (*s3.GetObjectOutput, error)
}
func getObjectAndCompare(t *testing.T, client Decryptor, key string, expected []byte) {
	t.Helper()
	output, err := client.GetObject(&s3.GetObjectInput{
		Bucket: &config.Bucket,
		Key:    &key,
	})
	if err != nil {
		t.Fatalf(""failed to get object: %v"", err)
	}
	actual, err := ioutil.ReadAll(output.Body)
	if err != nil {
		t.Fatalf(""failed to read body response: %v"", err)
	}
	if bytes.Compare(expected, actual) != 0 {
		t.Errorf(""expected bytes did not match actual"")
	}
}
func doKeyCleanup(key string) func() {
	return func() {
		_, err := config.Clients.S3.DeleteObject(&s3.DeleteObjectInput{
			Bucket: &config.Bucket,
			Key:    &key,
		})
		if err != nil {
			log.Printf(""failed to delete %s: %v"", key, err)
		}
	}
}
",CWE-326,188.0,0
"package s3crypto
import (
	""crypto/rand""
	""github.com/aws/aws-sdk-go/aws""
)
// CipherDataGenerator handles generating proper key and IVs of proper size for the
// content cipher. CipherDataGenerator will also encrypt the key and store it in
// the CipherData.
type CipherDataGenerator interface {
	GenerateCipherData(int, int) (CipherData, error)
}
// CipherDataGeneratorWithContext handles generating proper key and IVs of
// proper size for the content cipher. CipherDataGenerator will also encrypt
// the key and store it in the CipherData.
type CipherDataGeneratorWithContext interface {
	GenerateCipherDataWithContext(aws.Context, int, int) (CipherData, error)
}
// CipherDataGeneratorWithCEKAlg handles generating proper key and IVs of proper size for the
// content cipher. CipherDataGenerator will also encrypt the key and store it in
// the CipherData.
type CipherDataGeneratorWithCEKAlg interface {
	GenerateCipherDataWithCEKAlg(int, int, string) (CipherData, error)
	CipherDataGenerator // backwards comparability to plug into older interface
}
// CipherDataGeneratorWithCEKAlgWithContext handles generating proper key and IVs of
// proper size for the content cipher. CipherDataGenerator will also encrypt
// the key and store it in the CipherData.
type CipherDataGeneratorWithCEKAlgWithContext interface {
	GenerateCipherDataWithCEKAlgWithContext(aws.Context, int, int, string) (CipherData, error)
}
// CipherDataDecrypter is a handler to decrypt keys from the envelope.
type CipherDataDecrypter interface {
	DecryptKey([]byte) ([]byte, error)
}
// CipherDataDecrypterWithContext is a handler to decrypt keys from the envelope with request context.
type CipherDataDecrypterWithContext interface {
	DecryptKeyWithContext(aws.Context, []byte) ([]byte, error)
}
func generateBytes(n int) ([]byte, error) {
	b := make([]byte, n)
	_, err := rand.Read(b)
	if err != nil {
		return nil, err
	}
	return b, nil
}
",CWE-326,57.0,0
"package s3crypto
import (
	""testing""
)
func TestGenerateBytes(t *testing.T) {
	b, _ := generateBytes(5)
	if e, a := 5, len(b); e != a {
		t.Errorf(""expected %d, but received %d"", e, a)
	}
	b, _ = generateBytes(0)
	if e, a := 0, len(b); e != a {
		t.Errorf(""expected %d, but received %d"", e, a)
	}
	b, _ = generateBytes(1024)
	if e, a := 1024, len(b); e != a {
		t.Errorf(""expected %d, but received %d"", e, a)
	}
}
",CWE-326,21.0,0
"package s3crypto_test
import (
	""bytes""
	""fmt""
	""io/ioutil""
	""github.com/aws/aws-sdk-go/aws""
	""github.com/aws/aws-sdk-go/aws/session""
	""github.com/aws/aws-sdk-go/service/kms""
	""github.com/aws/aws-sdk-go/service/s3""
	""github.com/aws/aws-sdk-go/service/s3/s3crypto""
)
// ExampleNewEncryptionClientV2_migration00 provides a migration example for how users can migrate from the V1
// encryption client to the V2 encryption client. This example demonstrates how an application using  the `kms` key wrap
// algorithm with `AES/CBC/PKCS5Padding` can migrate their application to `kms+context` key wrapping with
// `AES/GCM/NoPadding` content encryption.
func ExampleNewEncryptionClientV2_migration00() {
	sess := session.Must(session.NewSession())
	kmsClient := kms.New(sess)
	cmkID := ""1234abcd-12ab-34cd-56ef-1234567890ab""
	// Usage of NewKMSKeyGenerator (kms) key wrapping algorithm must be migrated to NewKMSContextKeyGenerator (kms+context) key wrapping algorithm
	//
	// cipherDataGenerator := s3crypto.NewKMSKeyGenerator(kmsClient, cmkID)
	cipherDataGenerator := s3crypto.NewKMSContextKeyGenerator(kmsClient, cmkID)
	// Usage of AESCBCContentCipherBuilder (AES/CBC/PKCS5Padding) must be migrated to AESGCMContentCipherBuilder (AES/GCM/NoPadding)
	//
	// contentCipherBuilder := s3crypto.AESCBCContentCipherBuilder(cipherDataGenerator, s3crypto.AESCBCPadder)
	contentCipherBuilder := s3crypto.AESGCMContentCipherBuilder(cipherDataGenerator)
	// Construction of an encryption client should be done using NewEncryptionClientV2
	//
	// encryptionClient := s3crypto.NewEncryptionClient(sess, contentCipherBuilder)
	encryptionClient, err := s3crypto.NewEncryptionClientV2(sess, contentCipherBuilder)
	if err != nil {
		fmt.Printf(""failed to construct encryption client: %v"", err)
		return
	}
	_, err = encryptionClient.PutObject(&s3.PutObjectInput{
		Bucket: aws.String(""your_bucket""),
		Key:    aws.String(""your_key""),
		Body:   bytes.NewReader([]byte(""your content"")),
	})
	if err != nil {
		fmt.Printf(""put object error: %v\n"", err)
		return
	}
	fmt.Println(""put object completed"")
}
// ExampleNewEncryptionClientV2_migration01 provides a more advanced migration example for how users can
// migrate from the V1 encryption client to the V2 encryption client using more complex client construction.
func ExampleNewEncryptionClientV2_migration01() {
	sess := session.Must(session.NewSession())
	kmsClient := kms.New(sess)
	cmkID := ""1234abcd-12ab-34cd-56ef-1234567890ab""
	cipherDataGenerator := s3crypto.NewKMSContextKeyGenerator(kmsClient, cmkID)
	contentCipherBuilder := s3crypto.AESGCMContentCipherBuilder(cipherDataGenerator)
	// Overriding of the encryption client options is possible by passing in functional arguments that override the
	// provided EncryptionClientOptions.
	//
	// encryptionClient := s3crypto.NewEncryptionClient(cipherDataGenerator, contentCipherBuilder, func(o *s3crypto.EncryptionClient) {
	//	 o.S3Client = s3.New(sess, &aws.Config{Region: aws.String(""us-west-2"")}),
	// })
	encryptionClient, err := s3crypto.NewEncryptionClientV2(sess, contentCipherBuilder, func(o *s3crypto.EncryptionClientOptions) {
		o.S3Client = s3.New(sess, &aws.Config{Region: aws.String(""us-west-2"")})
	})
	if err != nil {
		fmt.Printf(""failed to construct encryption client: %v"", err)
		return
	}
	_, err = encryptionClient.PutObject(&s3.PutObjectInput{
		Bucket: aws.String(""your_bucket""),
		Key:    aws.String(""your_key""),
		Body:   bytes.NewReader([]byte(""your content"")),
	})
	if err != nil {
		fmt.Printf(""put object error: %v\n"", err)
		return
	}
	fmt.Println(""put object completed"")
}
// ExampleNewDecryptionClientV2_migration00 provides a migration example for how users can migrate
// from the V1 Decryption Clients to the V2 Decryption Clients.
func ExampleNewDecryptionClientV2_migration00() {
	sess := session.Must(session.NewSession())
	// Construction of an decryption client must be done using NewDecryptionClientV2
	// The V2 decryption client is able to decrypt object encrypted by the V1 client.
	//
	// decryptionClient := s3crypto.NewDecryptionClient(sess)
	decryptionClient := s3crypto.NewDecryptionClientV2(sess)
	getObject, err := decryptionClient.GetObject(&s3.GetObjectInput{
		Bucket: aws.String(""your_bucket""),
		Key:    aws.String(""your_key""),
	})
	if err != nil {
		fmt.Printf(""get object error: %v\n"", err)
		return
	}
	_, err = ioutil.ReadAll(getObject.Body)
	if err != nil {
		fmt.Printf(""error reading object: %v\n"", err)
	}
	fmt.Println(""get object completed"")
}
// ExampleNewDecryptionClientV2_migration01 provides a more advanced migration example for how users can
// migrate from the V1 decryption client to the V2 decryption client using more complex client construction.
func ExampleNewDecryptionClientV2_migration01() {
	sess := session.Must(session.NewSession())
	// Construction of an decryption client must be done using NewDecryptionClientV2
	// The V2 decryption client is able to decrypt object encrypted by the V1 client.
	//
	// decryptionClient := s3crypto.NewDecryptionClient(sess, func(o *s3crypto.DecryptionClient) {
	//	 o.S3Client = s3.New(sess, &aws.Config{Region: aws.String(""us-west-2"")})
	//})
	decryptionClient := s3crypto.NewDecryptionClientV2(sess, func(o *s3crypto.DecryptionClientOptions) {
		o.S3Client = s3.New(sess, &aws.Config{Region: aws.String(""us-west-2"")})
	})
	getObject, err := decryptionClient.GetObject(&s3.GetObjectInput{
		Bucket: aws.String(""your_bucket""),
		Key:    aws.String(""your_key""),
	})
	if err != nil {
		fmt.Printf(""get object error: %v\n"", err)
		return
	}
	_, err = ioutil.ReadAll(getObject.Body)
	if err != nil {
		fmt.Printf(""error reading object: %v\n"", err)
	}
	fmt.Println(""get object completed"")
}
",CWE-326,149.0,0
"package s3crypto_test
import (
	""bytes""
	""io""
	""io/ioutil""
	""github.com/aws/aws-sdk-go/service/s3/s3crypto""
)
type mockGenerator struct{}
func (m mockGenerator) GenerateCipherData(keySize, ivSize int) (s3crypto.CipherData, error) {
	cd := s3crypto.CipherData{
		Key: make([]byte, keySize),
		IV:  make([]byte, ivSize),
	}
	return cd, nil
}
func (m mockGenerator) EncryptKey(key []byte) ([]byte, error) {
	size := len(key)
	b := bytes.Repeat([]byte{1}, size)
	return b, nil
}
func (m mockGenerator) DecryptKey(key []byte) ([]byte, error) {
	return make([]byte, 16), nil
}
type mockCipherBuilder struct {
	generator s3crypto.CipherDataGenerator
}
func (builder mockCipherBuilder) ContentCipher() (s3crypto.ContentCipher, error) {
	cd, err := builder.generator.GenerateCipherData(32, 16)
	if err != nil {
		return nil, err
	}
	return &mockContentCipher{cd}, nil
}
type mockContentCipher struct {
	cd s3crypto.CipherData
}
func (cipher *mockContentCipher) GetCipherData() s3crypto.CipherData {
	return cipher.cd
}
func (cipher *mockContentCipher) EncryptContents(src io.Reader) (io.Reader, error) {
	b, err := ioutil.ReadAll(src)
	if err != nil {
		return nil, err
	}
	size := len(b)
	b = bytes.Repeat([]byte{1}, size)
	return bytes.NewReader(b), nil
}
func (cipher *mockContentCipher) DecryptContents(src io.ReadCloser) (io.ReadCloser, error) {
	b, err := ioutil.ReadAll(src)
	if err != nil {
		return nil, err
	}
	size := len(b)
	return ioutil.NopCloser(bytes.NewReader(make([]byte, size))), nil
}
",CWE-326,69.0,0
"package s3crypto
import (
	""bytes""
	""encoding/json""
	""io/ioutil""
	""net/http""
	""strings""
	""github.com/aws/aws-sdk-go/aws""
	""github.com/aws/aws-sdk-go/aws/awserr""
	""github.com/aws/aws-sdk-go/aws/request""
	""github.com/aws/aws-sdk-go/service/s3""
)
// SaveStrategy is how the data's metadata wants to be saved
type SaveStrategy interface {
	Save(Envelope, *request.Request) error
}
// S3SaveStrategy will save the metadata to a separate instruction file in S3
type S3SaveStrategy struct {
	Client                *s3.S3
	InstructionFileSuffix string
}
// Save will save the envelope contents to s3.
func (strat S3SaveStrategy) Save(env Envelope, req *request.Request) error {
	input := req.Params.(*s3.PutObjectInput)
	b, err := json.Marshal(env)
	if err != nil {
		return err
	}
	instInput := s3.PutObjectInput{
		Bucket: input.Bucket,
		Body:   bytes.NewReader(b),
	}
	if strat.InstructionFileSuffix == """" {
		instInput.Key = aws.String(*input.Key + DefaultInstructionKeySuffix)
	} else {
		instInput.Key = aws.String(*input.Key + strat.InstructionFileSuffix)
	}
	_, err = strat.Client.PutObject(&instInput)
	return err
}
// HeaderV2SaveStrategy will save the metadata of the crypto contents to the header of
// the object.
type HeaderV2SaveStrategy struct{}
// Save will save the envelope to the request's header.
func (strat HeaderV2SaveStrategy) Save(env Envelope, req *request.Request) error {
	input := req.Params.(*s3.PutObjectInput)
	if input.Metadata == nil {
		input.Metadata = map[string]*string{}
	}
	input.Metadata[http.CanonicalHeaderKey(keyV2Header)] = &env.CipherKey
	input.Metadata[http.CanonicalHeaderKey(ivHeader)] = &env.IV
	input.Metadata[http.CanonicalHeaderKey(matDescHeader)] = &env.MatDesc
	input.Metadata[http.CanonicalHeaderKey(wrapAlgorithmHeader)] = &env.WrapAlg
	input.Metadata[http.CanonicalHeaderKey(cekAlgorithmHeader)] = &env.CEKAlg
	input.Metadata[http.CanonicalHeaderKey(unencryptedContentLengthHeader)] = &env.UnencryptedContentLen
	if len(env.TagLen) > 0 {
		input.Metadata[http.CanonicalHeaderKey(tagLengthHeader)] = &env.TagLen
	}
	return nil
}
// LoadStrategy ...
type LoadStrategy interface {
	Load(*request.Request) (Envelope, error)
}
// S3LoadStrategy will load the instruction file from s3
type S3LoadStrategy struct {
	Client                *s3.S3
	InstructionFileSuffix string
}
// Load from a given instruction file suffix
func (load S3LoadStrategy) Load(req *request.Request) (Envelope, error) {
	env := Envelope{}
	if load.InstructionFileSuffix == """" {
		load.InstructionFileSuffix = DefaultInstructionKeySuffix
	}
	input := req.Params.(*s3.GetObjectInput)
	out, err := load.Client.GetObject(&s3.GetObjectInput{
		Key:    aws.String(strings.Join([]string{*input.Key, load.InstructionFileSuffix}, """")),
		Bucket: input.Bucket,
	})
	if err != nil {
		return env, err
	}
	b, err := ioutil.ReadAll(out.Body)
	if err != nil {
		return env, err
	}
	err = json.Unmarshal(b, &env)
	return env, err
}
// HeaderV2LoadStrategy will load the envelope from the metadata
type HeaderV2LoadStrategy struct{}
// Load from a given object's header
func (load HeaderV2LoadStrategy) Load(req *request.Request) (Envelope, error) {
	env := Envelope{}
	env.CipherKey = req.HTTPResponse.Header.Get(strings.Join([]string{metaHeader, keyV2Header}, ""-""))
	env.IV = req.HTTPResponse.Header.Get(strings.Join([]string{metaHeader, ivHeader}, ""-""))
	env.MatDesc = req.HTTPResponse.Header.Get(strings.Join([]string{metaHeader, matDescHeader}, ""-""))
	env.WrapAlg = req.HTTPResponse.Header.Get(strings.Join([]string{metaHeader, wrapAlgorithmHeader}, ""-""))
	env.CEKAlg = req.HTTPResponse.Header.Get(strings.Join([]string{metaHeader, cekAlgorithmHeader}, ""-""))
	env.TagLen = req.HTTPResponse.Header.Get(strings.Join([]string{metaHeader, tagLengthHeader}, ""-""))
	env.UnencryptedMD5 = req.HTTPResponse.Header.Get(strings.Join([]string{metaHeader, unencryptedMD5Header}, ""-""))
	env.UnencryptedContentLen = req.HTTPResponse.Header.Get(strings.Join([]string{metaHeader, unencryptedContentLengthHeader}, ""-""))
	return env, nil
}
type defaultV2LoadStrategy struct {
	client *s3.S3
	suffix string
}
func (load defaultV2LoadStrategy) Load(req *request.Request) (Envelope, error) {
	if value := req.HTTPResponse.Header.Get(strings.Join([]string{metaHeader, keyV2Header}, ""-"")); value != """" {
		strat := HeaderV2LoadStrategy{}
		return strat.Load(req)
	} else if value = req.HTTPResponse.Header.Get(strings.Join([]string{metaHeader, keyV1Header}, ""-"")); value != """" {
		return Envelope{}, awserr.New(""V1NotSupportedError"", ""The AWS SDK for Go does not support version 1"", nil)
	}
	strat := S3LoadStrategy{
		Client:                load.client,
		InstructionFileSuffix: load.suffix,
	}
	return strat.Load(req)
}
",CWE-326,145.0,0
"package s3crypto_test
import (
	""bytes""
	""encoding/json""
	""io/ioutil""
	""net/http""
	""reflect""
	""testing""
	""github.com/aws/aws-sdk-go/aws""
	""github.com/aws/aws-sdk-go/aws/request""
	""github.com/aws/aws-sdk-go/awstesting/unit""
	""github.com/aws/aws-sdk-go/service/s3""
	""github.com/aws/aws-sdk-go/service/s3/s3crypto""
)
func TestHeaderV2SaveStrategy(t *testing.T) {
	cases := []struct {
		env      s3crypto.Envelope
		expected map[string]*string
	}{
		{
			s3crypto.Envelope{
				CipherKey:             ""Foo"",
				IV:                    ""Bar"",
				MatDesc:               ""{}"",
				WrapAlg:               s3crypto.KMSWrap,
				CEKAlg:                s3crypto.AESGCMNoPadding,
				TagLen:                ""128"",
				UnencryptedMD5:        ""hello"",
				UnencryptedContentLen: ""0"",
			},
			map[string]*string{
				""X-Amz-Key-V2"":                     aws.String(""Foo""),
				""X-Amz-Iv"":                         aws.String(""Bar""),
				""X-Amz-Matdesc"":                    aws.String(""{}""),
				""X-Amz-Wrap-Alg"":                   aws.String(s3crypto.KMSWrap),
				""X-Amz-Cek-Alg"":                    aws.String(s3crypto.AESGCMNoPadding),
				""X-Amz-Tag-Len"":                    aws.String(""128""),
				""X-Amz-Unencrypted-Content-Length"": aws.String(""0""),
			},
		},
		{
			s3crypto.Envelope{
				CipherKey:             ""Foo"",
				IV:                    ""Bar"",
				MatDesc:               ""{}"",
				WrapAlg:               s3crypto.KMSWrap,
				CEKAlg:                s3crypto.AESGCMNoPadding,
				UnencryptedMD5:        ""hello"",
				UnencryptedContentLen: ""0"",
			},
			map[string]*string{
				""X-Amz-Key-V2"":                     aws.String(""Foo""),
				""X-Amz-Iv"":                         aws.String(""Bar""),
				""X-Amz-Matdesc"":                    aws.String(""{}""),
				""X-Amz-Wrap-Alg"":                   aws.String(s3crypto.KMSWrap),
				""X-Amz-Cek-Alg"":                    aws.String(s3crypto.AESGCMNoPadding),
				""X-Amz-Unencrypted-Content-Length"": aws.String(""0""),
			},
		},
	}
	for _, c := range cases {
		params := &s3.PutObjectInput{}
		req := &request.Request{
			Params: params,
		}
		strat := s3crypto.HeaderV2SaveStrategy{}
		err := strat.Save(c.env, req)
		if err != nil {
			t.Errorf(""expected no error, but received %v"", err)
		}
		if !reflect.DeepEqual(c.expected, params.Metadata) {
			t.Errorf(""expected %v, but received %v"", c.expected, params.Metadata)
		}
	}
}
func TestS3SaveStrategy(t *testing.T) {
	cases := []struct {
		env      s3crypto.Envelope
		expected s3crypto.Envelope
	}{
		{
			s3crypto.Envelope{
				CipherKey:             ""Foo"",
				IV:                    ""Bar"",
				MatDesc:               ""{}"",
				WrapAlg:               s3crypto.KMSWrap,
				CEKAlg:                s3crypto.AESGCMNoPadding,
				TagLen:                ""128"",
				UnencryptedMD5:        ""hello"",
				UnencryptedContentLen: ""0"",
			},
			s3crypto.Envelope{
				CipherKey:             ""Foo"",
				IV:                    ""Bar"",
				MatDesc:               ""{}"",
				WrapAlg:               s3crypto.KMSWrap,
				CEKAlg:                s3crypto.AESGCMNoPadding,
				TagLen:                ""128"",
				UnencryptedContentLen: ""0"",
			},
		},
		{
			s3crypto.Envelope{
				CipherKey:             ""Foo"",
				IV:                    ""Bar"",
				MatDesc:               ""{}"",
				WrapAlg:               s3crypto.KMSWrap,
				CEKAlg:                s3crypto.AESGCMNoPadding,
				UnencryptedMD5:        ""hello"",
				UnencryptedContentLen: ""0"",
			},
			s3crypto.Envelope{
				CipherKey:             ""Foo"",
				IV:                    ""Bar"",
				MatDesc:               ""{}"",
				WrapAlg:               s3crypto.KMSWrap,
				CEKAlg:                s3crypto.AESGCMNoPadding,
				UnencryptedContentLen: ""0"",
			},
		},
	}
	for _, c := range cases {
		params := &s3.PutObjectInput{
			Bucket: aws.String(""fooBucket""),
			Key:    aws.String(""barKey""),
		}
		req := &request.Request{
			Params: params,
		}
		client := s3.New(unit.Session)
		client.Handlers.Send.Clear()
		client.Handlers.Unmarshal.Clear()
		client.Handlers.UnmarshalMeta.Clear()
		client.Handlers.UnmarshalError.Clear()
		client.Handlers.Send.PushBack(func(r *request.Request) {
			bodyBytes, err := ioutil.ReadAll(r.Body)
			if err != nil {
				r.HTTPResponse = &http.Response{
					StatusCode: 500,
					Body:       ioutil.NopCloser(bytes.NewReader([]byte(err.Error()))),
				}
				return
			}
			var actual s3crypto.Envelope
			err = json.Unmarshal(bodyBytes, &actual)
			if err != nil {
				r.HTTPResponse = &http.Response{
					StatusCode: 500,
					Body:       ioutil.NopCloser(bytes.NewReader([]byte(err.Error()))),
				}
				return
			}
			if e, a := c.expected, actual; !reflect.DeepEqual(e, a) {
				t.Errorf(""expected %v, got %v"", e, a)
			}
			r.HTTPResponse = &http.Response{
				StatusCode: 200,
				Body:       ioutil.NopCloser(bytes.NewReader([]byte(""""))),
			}
		})
		strat := s3crypto.S3SaveStrategy{Client: client}
		err := strat.Save(c.env, req)
		if err != nil {
			t.Errorf(""expected no error, but received %v"", err)
		}
	}
}
",CWE-326,181.0,0
"package main
import (
	""flag""
	""log""
	""github.com/hoppscotch/proxyscotch/libproxy""
)
func main() {
	hostPtr := flag.String(""host"", ""localhost:9159"", ""the hostname that the server should listen on."")
	tokenPtr := flag.String(""token"", """", ""the Proxy Access Token used to restrict access to the server."")
	allowedOriginsPtr := flag.String(""allowed-origins"", ""*"", ""a comma separated list of allowed origins."")
	bannedOutputsPtr := flag.String(""banned-outputs"", """", ""a comma separated list of banned outputs."")
	bannedDestsPtr := flag.String(""banned-dests"", """", ""a comma separated list of banned proxy destinations."")
	flag.Parse()
	finished := make(chan bool)
	libproxy.Initialize(*tokenPtr, *hostPtr, *allowedOriginsPtr, *bannedOutputsPtr, *bannedDestsPtr, onProxyStateChangeServer, false, finished)
	<-finished
}
func onProxyStateChangeServer(status string, isListening bool) {
	log.Printf(""[ready=%v] %s"", isListening, status)
}
",CWE-918,28.0,0
"package api
import (
	""encoding/json""
	""fmt""
	""golang.org/x/exp/slices""
)
type SystemSettingName string
const (
	// SystemSettingAllowSignUpName is the key type of allow signup setting.
	SystemSettingAllowSignUpName SystemSettingName = ""allowSignUp""
	// SystemSettingAdditionalStyleName is the key type of additional style.
	SystemSettingAdditionalStyleName SystemSettingName = ""additionalStyle""
	// SystemSettingAdditionalScriptName is the key type of additional script.
	SystemSettingAdditionalScriptName SystemSettingName = ""additionalScript""
	// SystemSettingCustomizedProfileName is the key type of customized server profile.
	SystemSettingCustomizedProfileName SystemSettingName = ""customizedProfile""
)
// CustomizedProfile is the struct definition for SystemSettingCustomizedProfileName system setting item.
type CustomizedProfile struct {
	// Name is the server name, default is `memos`
	Name string `json:""name""`
	// IconURL is the url of icon image.
	IconURL string `json:""iconUrl""`
	// Description is the server description.
	Description string `json:""description""`
	// Locale is the server default locale.
	Locale string `json:""locale""`
	// Appearance is the server default appearance.
	Appearance string `json:""appearance""`
	// ExternalURL is the external url of server. e.g. https://usermemos.com
	ExternalURL string `json:""externalUrl""`
}
func (key SystemSettingName) String() string {
	switch key {
	case SystemSettingAllowSignUpName:
		return ""allowSignUp""
	case SystemSettingAdditionalStyleName:
		return ""additionalStyle""
	case SystemSettingAdditionalScriptName:
		return ""additionalScript""
	case SystemSettingCustomizedProfileName:
		return ""customizedProfile""
	}
	return """"
}
var (
	SystemSettingAllowSignUpValue = []bool{true, false}
)
type SystemSetting struct {
	Name SystemSettingName
	// Value is a JSON string with basic value
	Value       string
	Description string
}
type SystemSettingUpsert struct {
	Name        SystemSettingName `json:""name""`
	Value       string            `json:""value""`
	Description string            `json:""description""`
}
func (upsert SystemSettingUpsert) Validate() error {
	if upsert.Name == SystemSettingAllowSignUpName {
		value := false
		err := json.Unmarshal([]byte(upsert.Value), &value)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal system setting allow signup value"")
		}
		invalid := true
		for _, v := range SystemSettingAllowSignUpValue {
			if value == v {
				invalid = false
				break
			}
		}
		if invalid {
			return fmt.Errorf(""invalid system setting allow signup value"")
		}
	} else if upsert.Name == SystemSettingAdditionalStyleName {
		value := """"
		err := json.Unmarshal([]byte(upsert.Value), &value)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal system setting additional style value"")
		}
	} else if upsert.Name == SystemSettingAdditionalScriptName {
		value := """"
		err := json.Unmarshal([]byte(upsert.Value), &value)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal system setting additional script value"")
		}
	} else if upsert.Name == SystemSettingCustomizedProfileName {
		customizedProfile := CustomizedProfile{
			Name:        ""memos"",
			IconURL:     """",
			Description: """",
			Locale:      ""en"",
			Appearance:  ""system"",
			ExternalURL: """",
		}
		err := json.Unmarshal([]byte(upsert.Value), &customizedProfile)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal system setting customized profile value"")
		}
		if !slices.Contains(UserSettingLocaleValue, customizedProfile.Locale) {
			return fmt.Errorf(""invalid locale value"")
		}
		if !slices.Contains(UserSettingAppearanceValue, customizedProfile.Appearance) {
			return fmt.Errorf(""invalid appearance value"")
		}
	} else {
		return fmt.Errorf(""invalid system setting name"")
	}
	return nil
}
type SystemSettingFind struct {
	Name *SystemSettingName `json:""name""`
}
",CWE-311,129.0,0
"package api
import (
	""encoding/json""
	""fmt""
	""golang.org/x/exp/slices""
)
type UserSettingKey string
const (
	// UserSettingLocaleKey is the key type for user locale.
	UserSettingLocaleKey UserSettingKey = ""locale""
	// UserSettingAppearanceKey is the key type for user appearance.
	UserSettingAppearanceKey UserSettingKey = ""appearance""
	// UserSettingMemoVisibilityKey is the key type for user preference memo default visibility.
	UserSettingMemoVisibilityKey UserSettingKey = ""memoVisibility""
	// UserSettingMemoDisplayTsOptionKey is the key type for memo display ts option.
	UserSettingMemoDisplayTsOptionKey UserSettingKey = ""memoDisplayTsOption""
)
// String returns the string format of UserSettingKey type.
func (key UserSettingKey) String() string {
	switch key {
	case UserSettingLocaleKey:
		return ""locale""
	case UserSettingAppearanceKey:
		return ""appearance""
	case UserSettingMemoVisibilityKey:
		return ""memoVisibility""
	case UserSettingMemoDisplayTsOptionKey:
		return ""memoDisplayTsOption""
	}
	return """"
}
var (
	UserSettingLocaleValue                 = []string{""en"", ""zh"", ""vi"", ""fr"", ""nl"", ""sv"", ""de"", ""es""}
	UserSettingAppearanceValue             = []string{""system"", ""light"", ""dark""}
	UserSettingMemoVisibilityValue         = []Visibility{Private, Protected, Public}
	UserSettingMemoDisplayTsOptionKeyValue = []string{""created_ts"", ""updated_ts""}
)
type UserSetting struct {
	UserID int
	Key    UserSettingKey `json:""key""`
	// Value is a JSON string with basic value
	Value string `json:""value""`
}
type UserSettingUpsert struct {
	UserID int
	Key    UserSettingKey `json:""key""`
	Value  string         `json:""value""`
}
func (upsert UserSettingUpsert) Validate() error {
	if upsert.Key == UserSettingLocaleKey {
		localeValue := ""en""
		err := json.Unmarshal([]byte(upsert.Value), &localeValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting locale value"")
		}
		if !slices.Contains(UserSettingLocaleValue, localeValue) {
			return fmt.Errorf(""invalid user setting locale value"")
		}
	} else if upsert.Key == UserSettingAppearanceKey {
		appearanceValue := ""system""
		err := json.Unmarshal([]byte(upsert.Value), &appearanceValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting appearance value"")
		}
		if !slices.Contains(UserSettingAppearanceValue, appearanceValue) {
			return fmt.Errorf(""invalid user setting appearance value"")
		}
	} else if upsert.Key == UserSettingMemoVisibilityKey {
		memoVisibilityValue := Private
		err := json.Unmarshal([]byte(upsert.Value), &memoVisibilityValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting memo visibility value"")
		}
		if !slices.Contains(UserSettingMemoVisibilityValue, memoVisibilityValue) {
			return fmt.Errorf(""invalid user setting memo visibility value"")
		}
	} else if upsert.Key == UserSettingMemoDisplayTsOptionKey {
		memoDisplayTsOption := ""created_ts""
		err := json.Unmarshal([]byte(upsert.Value), &memoDisplayTsOption)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting memo display ts option"")
		}
		if !slices.Contains(UserSettingMemoDisplayTsOptionKeyValue, memoDisplayTsOption) {
			return fmt.Errorf(""invalid user setting memo display ts option value"")
		}
	} else {
		return fmt.Errorf(""invalid user setting key"")
	}
	return nil
}
type UserSettingFind struct {
	UserID int
	Key *UserSettingKey `json:""key""`
}
type UserSettingDelete struct {
	UserID int
}
",CWE-311,111.0,0
"module github.com/usememos/memos
go 1.19
require github.com/mattn/go-sqlite3 v1.14.9
require github.com/google/uuid v1.3.0
require (
	golang.org/x/crypto v0.0.0-20220722155217-630584e8d5aa
	golang.org/x/net v0.0.0-20220728030405-41545e8bf201
)
require github.com/labstack/echo/v4 v4.9.0
require (
	github.com/VictoriaMetrics/fastcache v1.10.0
	github.com/gorilla/feeds v1.1.1
	github.com/gorilla/securecookie v1.1.1
	github.com/gorilla/sessions v1.2.1
	github.com/labstack/echo-contrib v0.13.0
	github.com/stretchr/testify v1.8.1
)
require (
	github.com/bmizerany/assert v0.0.0-20160611221934-b7ed37b82869 // indirect
	github.com/cespare/xxhash/v2 v2.1.2 // indirect
	github.com/davecgh/go-spew v1.1.1 // indirect
	github.com/golang-jwt/jwt v3.2.2+incompatible // indirect
	github.com/golang/snappy v0.0.4 // indirect
	github.com/gorilla/context v1.1.1 // indirect
	github.com/kr/pretty v0.3.1 // indirect
	github.com/labstack/gommon v0.3.1 // indirect
	github.com/mattn/go-colorable v0.1.12 // indirect
	github.com/mattn/go-isatty v0.0.14 // indirect
	github.com/pmezard/go-difflib v1.0.0 // indirect
	github.com/segmentio/backo-go v1.0.1 // indirect
	github.com/valyala/bytebufferpool v1.0.0 // indirect
	github.com/valyala/fasttemplate v1.2.1 // indirect
	github.com/xtgo/uuid v0.0.0-20140804021211-a0b114877d4c // indirect
	golang.org/x/sys v0.1.0 // indirect
	golang.org/x/text v0.3.7 // indirect
	golang.org/x/time v0.0.0-20220722155302-e5dcc9cfc0b9 // indirect
	gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
)
require (
	github.com/segmentio/analytics-go v3.1.0+incompatible
	golang.org/x/exp v0.0.0-20221217163422-3c43f8badb15
)
",CWE-311,52.0,0
"github.com/VictoriaMetrics/fastcache v1.10.0 h1:5hDJnLsKLpnUEToub7ETuRu8RCkb40woBZAUiKonXzY=
github.com/VictoriaMetrics/fastcache v1.10.0/go.mod h1:tjiYeEfYXCqacuvYw/7UoDIeJaNxq6132xHICNP77w8=
github.com/allegro/bigcache v1.2.1-0.20190218064605-e24eb225f156 h1:eMwmnE/GDgah4HI848JfFxHt+iPb26b4zyfspmqY0/8=
github.com/allegro/bigcache v1.2.1-0.20190218064605-e24eb225f156/go.mod h1:Cb/ax3seSYIx7SuZdm2G2xzfwmv3TPSk2ucNfQESPXM=
github.com/bmizerany/assert v0.0.0-20160611221934-b7ed37b82869 h1:DDGfHa7BWjL4YnC6+E63dPcxHo2sUxDIu8g3QgEJdRY=
github.com/bmizerany/assert v0.0.0-20160611221934-b7ed37b82869/go.mod h1:Ekp36dRnpXw/yCqJaO+ZrUyxD+3VXMFFr56k5XYrpB4=
github.com/cespare/xxhash/v2 v2.1.2 h1:YRXhKfTDauu4ajMg1TPgFO5jnlC2HCbmLXMcTG5cbYE=
github.com/cespare/xxhash/v2 v2.1.2/go.mod h1:VGX0DQ3Q6kWi7AoAeZDth3/j3BFtOZR5XLFGgcrjCOs=
github.com/creack/pty v1.1.9/go.mod h1:oKZEueFk5CKHvIhNR5MUki03XCEU+Q6VDXinZuGJ33E=
github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/golang-jwt/jwt v3.2.2+incompatible h1:IfV12K8xAKAnZqdXVzCZ+TOjboZ2keLg81eXfW3O+oY=
github.com/golang-jwt/jwt v3.2.2+incompatible/go.mod h1:8pz2t5EyA70fFQQSrl6XZXzqecmYZeUEB8OUGHkxJ+I=
github.com/golang/snappy v0.0.4 h1:yAGX7huGHXlcLOEtBnF4w7FQwA26wojNCwOYAEhLjQM=
github.com/golang/snappy v0.0.4/go.mod h1:/XxbfmMg8lxefKM7IXC3fBNl/7bRcc72aCRzEWrmP2Q=
github.com/google/uuid v1.3.0 h1:t6JiXgmwXMjEs8VusXIJk2BXHsn+wx8BZdTaoZ5fu7I=
github.com/google/uuid v1.3.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
github.com/gorilla/context v1.1.1 h1:AWwleXJkX/nhcU9bZSnZoi3h/qGYqQAGhq6zZe/aQW8=
github.com/gorilla/context v1.1.1/go.mod h1:kBGZzfjB9CEq2AlWe17Uuf7NDRt0dE0s8S51q0aT7Yg=
github.com/gorilla/feeds v1.1.1 h1:HwKXxqzcRNg9to+BbvJog4+f3s/xzvtZXICcQGutYfY=
github.com/gorilla/feeds v1.1.1/go.mod h1:Nk0jZrvPFZX1OBe5NPiddPw7CfwF6Q9eqzaBbaightA=
github.com/gorilla/securecookie v1.1.1 h1:miw7JPhV+b/lAHSXz4qd/nN9jRiAFV5FwjeKyCS8BvQ=
github.com/gorilla/securecookie v1.1.1/go.mod h1:ra0sb63/xPlUeL+yeDciTfxMRAA+MP+HVt/4epWDjd4=
github.com/gorilla/sessions v1.2.1 h1:DHd3rPN5lE3Ts3D8rKkQ8x/0kqfeNmBAaiSi+o7FsgI=
github.com/gorilla/sessions v1.2.1/go.mod h1:dk2InVEVJ0sfLlnXv9EAgkf6ecYs/i80K/zI+bUmuGM=
github.com/kr/pretty v0.2.1/go.mod h1:ipq/a2n7PKx3OHsz4KJII5eveXtPO4qwEXGdVfWzfnI=
github.com/kr/pretty v0.3.1 h1:flRD4NNwYAUpkphVc1HcthR4KEIFJ65n8Mw5qdRn3LE=
github.com/kr/pretty v0.3.1/go.mod h1:hoEshYVHaxMs3cyo3Yncou5ZscifuDolrwPKZanG3xk=
github.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=
github.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=
github.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=
github.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=
github.com/labstack/echo-contrib v0.13.0 h1:bzSG0SpuZZd7BmJLvsWtPfU23W0Enh3K0tok3aENVKA=
github.com/labstack/echo-contrib v0.13.0/go.mod h1:IF9+MJu22ADOZEHD+bAV67XMIO3vNXUy7Naz/ABPHEs=
github.com/labstack/echo/v4 v4.9.0 h1:wPOF1CE6gvt/kmbMR4dGzWvHMPT+sAEUJOwOTtvITVY=
github.com/labstack/echo/v4 v4.9.0/go.mod h1:xkCDAdFCIf8jsFQ5NnbK7oqaF/yU1A1X20Ltm0OvSks=
github.com/labstack/gommon v0.3.1 h1:OomWaJXm7xR6L1HmEtGyQf26TEn7V6X88mktX9kee9o=
github.com/labstack/gommon v0.3.1/go.mod h1:uW6kP17uPlLJsD3ijUYn3/M5bAxtlZhMI6m3MFxTMTM=
github.com/mattn/go-colorable v0.1.11/go.mod h1:u5H1YNBxpqRaxsYJYSkiCWKzEfiAb1Gb520KVy5xxl4=
github.com/mattn/go-colorable v0.1.12 h1:jF+Du6AlPIjs2BiUiQlKOX0rt3SujHxPnksPKZbaA40=
github.com/mattn/go-colorable v0.1.12/go.mod h1:u5H1YNBxpqRaxsYJYSkiCWKzEfiAb1Gb520KVy5xxl4=
github.com/mattn/go-isatty v0.0.14 h1:yVuAays6BHfxijgZPzw+3Zlu5yQgKGP2/hcQbHb7S9Y=
github.com/mattn/go-isatty v0.0.14/go.mod h1:7GGIvUiUoEMVVmxf/4nioHXj79iQHKdU27kJ6hsGG94=
github.com/mattn/go-sqlite3 v1.14.9 h1:10HX2Td0ocZpYEjhilsuo6WWtUqttj2Kb0KtD86/KYA=
github.com/mattn/go-sqlite3 v1.14.9/go.mod h1:NyWgC/yNuGj7Q9rpYnZvas74GogHl5/Z4A/KQRfk6bU=
github.com/pkg/diff v0.0.0-20210226163009-20ebb0f2a09e/go.mod h1:pJLUxLENpZxwdsKMEsNbx1VGcRFpLqf3715MtcvvzbA=
github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/rogpeppe/go-internal v1.9.0 h1:73kH8U+JUqXU8lRuOHeVHaa/SZPifC7BkcraZVejAe8=
github.com/rogpeppe/go-internal v1.9.0/go.mod h1:WtVeX8xhTBvf0smdhujwtBcq4Qrzq/fJaraNFVN+nFs=
github.com/segmentio/analytics-go v3.1.0+incompatible h1:IyiOfUgQFVHvsykKKbdI7ZsH374uv3/DfZUo9+G0Z80=
github.com/segmentio/analytics-go v3.1.0+incompatible/go.mod h1:C7CYBtQWk4vRk2RyLu0qOcbHJ18E3F1HV2C/8JvKN48=
github.com/segmentio/backo-go v1.0.1 h1:68RQccglxZeyURy93ASB/2kc9QudzgIDexJ927N++y4=
github.com/segmentio/backo-go v1.0.1/go.mod h1:9/Rh6yILuLysoQnZ2oNooD2g7aBnvM7r/fNVxRNWfBc=
github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
github.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=
github.com/stretchr/objx v0.5.0/go.mod h1:Yh+to48EsGEfYuaHDzXPcE3xhTkx73EhmCGUpEOglKo=
github.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=
github.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=
github.com/stretchr/testify v1.8.1 h1:w7B6lhMri9wdJUVmEZPGGhZzrYTPvgJArz7wNPgYKsk=
github.com/stretchr/testify v1.8.1/go.mod h1:w2LPCIKwWwSfY2zedu0+kehJoqGctiVI29o6fzry7u4=
github.com/valyala/bytebufferpool v1.0.0 h1:GqA5TC/0021Y/b9FG4Oi9Mr3q7XYx6KllzawFIhcdPw=
github.com/valyala/bytebufferpool v1.0.0/go.mod h1:6bBcMArwyJ5K/AmCkWv1jt77kVWyCJ6HpOuEn7z0Csc=
github.com/valyala/fasttemplate v1.2.1 h1:TVEnxayobAdVkhQfrfes2IzOB6o+z4roRkPF52WA1u4=
github.com/valyala/fasttemplate v1.2.1/go.mod h1:KHLXt3tVN2HBp8eijSv/kGJopbvo7S+qRAEEKiv+SiQ=
github.com/xtgo/uuid v0.0.0-20140804021211-a0b114877d4c h1:3lbZUMbMiGUW/LMkfsEABsc5zNT9+b1CvsJx47JzJ8g=
github.com/xtgo/uuid v0.0.0-20140804021211-a0b114877d4c/go.mod h1:UrdRz5enIKZ63MEE3IF9l2/ebyx59GyGgPi+tICQdmM=
golang.org/x/crypto v0.0.0-20220722155217-630584e8d5aa h1:zuSxTR4o9y82ebqCUJYNGJbGPo6sKVl54f/TVDObg1c=
golang.org/x/crypto v0.0.0-20220722155217-630584e8d5aa/go.mod h1:IxCIyHEi3zRg3s0A5j5BB6A9Jmi73HwBIUl50j+osU4=
golang.org/x/exp v0.0.0-20221217163422-3c43f8badb15 h1:5oN1Pz/eDhCpbMbLstvIPa0b/BEQo6g6nwV3pLjfM6w=
golang.org/x/exp v0.0.0-20221217163422-3c43f8badb15/go.mod h1:CxIveKay+FTh1D0yPZemJVgC/95VzuuOLq5Qi4xnoYc=
golang.org/x/net v0.0.0-20220728030405-41545e8bf201 h1:bvOltf3SADAfG05iRml8lAB3qjoEX5RCyN4K6G5v3N0=
golang.org/x/net v0.0.0-20220728030405-41545e8bf201/go.mod h1:YDH+HFinaLZZlnHAfSS6ZXJJ9M9t4Dl22yv3iI2vPwk=
golang.org/x/sys v0.0.0-20210630005230-0f9fa26af87c/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20210927094055-39ccf1dd6fa6/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20211103235746-7861aae1554b/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220405052023-b1e9470b6e64/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.1.0 h1:kunALQeHf1/185U1i0GOB/fy1IPRDDpuoOOqRReG57U=
golang.org/x/sys v0.1.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/text v0.3.7 h1:olpwvP2KacW1ZWvsR7uQhoyTYvKAupfQrRGBFM352Gk=
golang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=
golang.org/x/time v0.0.0-20220722155302-e5dcc9cfc0b9 h1:ftMN5LMiBFjbzleLqtoBZk7KdJwhuybIU+FckUHgoyQ=
golang.org/x/time v0.0.0-20220722155302-e5dcc9cfc0b9/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c h1:Hei/4ADfdWqJk1ZMxUNpqntNwaWcugrBjAiHlqqRiVk=
gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c/go.mod h1:JHkPIbrfpd72SG/EVd6muEfDQjcINNoR0C8j2r3qZ4Q=
gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
gopkg.in/yaml.v3 v3.0.0-20210107192922-496545a6307b/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
",CWE-311,94.0,0
"package server
import (
	""fmt""
	""net/http""
	""strconv""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	""github.com/gorilla/sessions""
	""github.com/labstack/echo-contrib/session""
	""github.com/labstack/echo/v4""
)
var (
	userIDContextKey = ""user-id""
)
func getUserIDContextKey() string {
	return userIDContextKey
}
func setUserSession(ctx echo.Context, user *api.User) error {
	sess, _ := session.Get(""memos_session"", ctx)
	sess.Options = &sessions.Options{
		Path:     ""/"",
		MaxAge:   3600 * 24 * 30,
		HttpOnly: true,
		Secure:   true,
	}
	sess.Values[userIDContextKey] = user.ID
	err := sess.Save(ctx.Request(), ctx.Response())
	if err != nil {
		return fmt.Errorf(""failed to set session, err: %w"", err)
	}
	return nil
}
func removeUserSession(ctx echo.Context) error {
	sess, _ := session.Get(""memos_session"", ctx)
	sess.Options = &sessions.Options{
		Path:     ""/"",
		MaxAge:   0,
		HttpOnly: true,
	}
	sess.Values[userIDContextKey] = nil
	err := sess.Save(ctx.Request(), ctx.Response())
	if err != nil {
		return fmt.Errorf(""failed to set session, err: %w"", err)
	}
	return nil
}
func aclMiddleware(s *Server, next echo.HandlerFunc) echo.HandlerFunc {
	return func(c echo.Context) error {
		ctx := c.Request().Context()
		path := c.Path()
		// Skip auth.
		if common.HasPrefixes(path, ""/api/auth"") {
			return next(c)
		}
		{
			// If there is openId in query string and related user is found, then skip auth.
			openID := c.QueryParam(""openId"")
			if openID != """" {
				userFind := &api.UserFind{
					OpenID: &openID,
				}
				user, err := s.Store.FindUser(ctx, userFind)
				if err != nil && common.ErrorCode(err) != common.NotFound {
					return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find user by open_id"").SetInternal(err)
				}
				if user != nil {
					// Stores userID into context.
					c.Set(getUserIDContextKey(), user.ID)
					return next(c)
				}
			}
		}
		{
			sess, _ := session.Get(""memos_session"", c)
			userIDValue := sess.Values[userIDContextKey]
			if userIDValue != nil {
				userID, _ := strconv.Atoi(fmt.Sprintf(""%v"", userIDValue))
				userFind := &api.UserFind{
					ID: &userID,
				}
				user, err := s.Store.FindUser(ctx, userFind)
				if err != nil && common.ErrorCode(err) != common.NotFound {
					return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to find user by ID: %d"", userID)).SetInternal(err)
				}
				if user != nil {
					if user.RowStatus == api.Archived {
						return echo.NewHTTPError(http.StatusForbidden, fmt.Sprintf(""User has been archived with username %s"", user.Username))
					}
					c.Set(getUserIDContextKey(), userID)
				}
			}
		}
		if common.HasPrefixes(path, ""/api/ping"", ""/api/status"", ""/api/user/:id"", ""/api/memo/all"", ""/api/memo/:memoId"", ""/api/memo/amount"") && c.Request().Method == http.MethodGet {
			return next(c)
		}
		if common.HasPrefixes(path, ""/api/memo"", ""/api/tag"", ""/api/shortcut"") && c.Request().Method == http.MethodGet {
			if _, err := strconv.Atoi(c.QueryParam(""creatorId"")); err == nil {
				return next(c)
			}
		}
		userID := c.Get(getUserIDContextKey())
		if userID == nil {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		return next(c)
	}
}
",CWE-311,123.0,0
"package server
import (
	""encoding/json""
	""net/http""
	""os""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
)
func (s *Server) registerSystemRoutes(g *echo.Group) {
	g.GET(""/ping"", func(c echo.Context) error {
		data := s.Profile
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(data)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to compose system profile"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/status"", func(c echo.Context) error {
		ctx := c.Request().Context()
		hostUserType := api.Host
		hostUserFind := api.UserFind{
			Role: &hostUserType,
		}
		hostUser, err := s.Store.FindUser(ctx, &hostUserFind)
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find host user"").SetInternal(err)
		}
		if hostUser != nil {
			// data desensitize
			hostUser.OpenID = """"
		}
		systemStatus := api.SystemStatus{
			Host:             hostUser,
			Profile:          *s.Profile,
			DBSize:           0,
			AllowSignUp:      false,
			AdditionalStyle:  """",
			AdditionalScript: """",
			CustomizedProfile: api.CustomizedProfile{
				Name:        ""memos"",
				IconURL:     """",
				Description: """",
				Locale:      ""en"",
				Appearance:  ""system"",
				ExternalURL: """",
			},
		}
		systemSettingList, err := s.Store.FindSystemSettingList(ctx, &api.SystemSettingFind{})
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find system setting list"").SetInternal(err)
		}
		for _, systemSetting := range systemSettingList {
			var value interface{}
			err := json.Unmarshal([]byte(systemSetting.Value), &value)
			if err != nil {
				return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to unmarshal system setting"").SetInternal(err)
			}
			if systemSetting.Name == api.SystemSettingAllowSignUpName {
				systemStatus.AllowSignUp = value.(bool)
			} else if systemSetting.Name == api.SystemSettingAdditionalStyleName {
				systemStatus.AdditionalStyle = value.(string)
			} else if systemSetting.Name == api.SystemSettingAdditionalScriptName {
				systemStatus.AdditionalScript = value.(string)
			} else if systemSetting.Name == api.SystemSettingCustomizedProfileName {
				valueMap := value.(map[string]interface{})
				systemStatus.CustomizedProfile = api.CustomizedProfile{
					Name:        valueMap[""name""].(string),
					IconURL:     valueMap[""iconUrl""].(string),
					Description: valueMap[""description""].(string),
					Locale:      valueMap[""locale""].(string),
					Appearance:  valueMap[""appearance""].(string),
					ExternalURL: valueMap[""externalUrl""].(string),
				}
			}
		}
		userID, ok := c.Get(getUserIDContextKey()).(int)
		// Get database size for host user.
		if ok {
			user, err := s.Store.FindUser(ctx, &api.UserFind{
				ID: &userID,
			})
			if err != nil {
				return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find user"").SetInternal(err)
			}
			if user != nil && user.Role == api.Host {
				fi, err := os.Stat(s.Profile.DSN)
				if err != nil {
					return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to read database fileinfo"").SetInternal(err)
				}
				systemStatus.DBSize = fi.Size()
			}
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(systemStatus)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode system status response"").SetInternal(err)
		}
		return nil
	})
	g.POST(""/system/setting"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		user, err := s.Store.FindUser(ctx, &api.UserFind{
			ID: &userID,
		})
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find user"").SetInternal(err)
		}
		if user == nil {
			return echo.NewHTTPError(http.StatusNotFound, ""Current signin user not found"")
		} else if user.Role != api.Host {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Unauthorized"")
		}
		systemSettingUpsert := &api.SystemSettingUpsert{}
		if err := json.NewDecoder(c.Request().Body).Decode(systemSettingUpsert); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted post system setting request"").SetInternal(err)
		}
		if err := systemSettingUpsert.Validate(); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""system setting invalidate"").SetInternal(err)
		}
		systemSetting, err := s.Store.UpsertSystemSetting(ctx, systemSettingUpsert)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to upsert system setting"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name:   ""systemSetting updated"",
			Labels: map[string]string{""field"": string(systemSettingUpsert.Name)},
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(systemSetting)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode system setting response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/system/setting"", func(c echo.Context) error {
		ctx := c.Request().Context()
		systemSettingList, err := s.Store.FindSystemSettingList(ctx, &api.SystemSettingFind{})
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find system setting list"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(systemSettingList)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode system setting list response"").SetInternal(err)
		}
		return nil
	})
	g.POST(""/system/vacuum"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		user, err := s.Store.FindUser(ctx, &api.UserFind{
			ID: &userID,
		})
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find user"").SetInternal(err)
		}
		if user == nil || user.Role != api.Host {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Unauthorized"")
		}
		if err := s.Store.Vacuum(ctx); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to vacuum database"").SetInternal(err)
		}
		c.Response().WriteHeader(http.StatusOK)
		return nil
	})
}
",CWE-311,193.0,0
"package api
// Visibility is the type of a visibility.
type Visibility string
const (
	// Public is the PUBLIC visibility.
	Public Visibility = ""PUBLIC""
	// Protected is the PROTECTED visibility.
	Protected Visibility = ""PROTECTED""
	// Private is the PRIVATE visibility.
	Private Visibility = ""PRIVATE""
)
func (e Visibility) String() string {
	switch e {
	case Public:
		return ""PUBLIC""
	case Protected:
		return ""PROTECTED""
	case Private:
		return ""PRIVATE""
	}
	return ""PRIVATE""
}
type Memo struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatorID int       `json:""creatorId""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Content    string     `json:""content""`
	Visibility Visibility `json:""visibility""`
	Pinned     bool       `json:""pinned""`
	DisplayTs  int64      `json:""displayTs""`
	// Related fields
	Creator      *User       `json:""creator""`
	ResourceList []*Resource `json:""resourceList""`
}
type MemoCreate struct {
	// Standard fields
	CreatorID int
	// Domain specific fields
	Visibility Visibility `json:""visibility""`
	Content    string     `json:""content""`
	// Related fields
	ResourceIDList []int `json:""resourceIdList""`
}
type MemoPatch struct {
	ID int `json:""-""`
	// Standard fields
	CreatedTs *int64 `json:""createdTs""`
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Content    *string     `json:""content""`
	Visibility *Visibility `json:""visibility""`
	// Related fields
	ResourceIDList []int `json:""resourceIdList""`
}
type MemoFind struct {
	ID *int `json:""id""`
	// Standard fields
	RowStatus *RowStatus `json:""rowStatus""`
	CreatorID *int       `json:""creatorId""`
	// Domain specific fields
	Pinned         *bool
	ContentSearch  *string
	VisibilityList []Visibility
	// Pagination
	Limit  int
	Offset int
}
type MemoDelete struct {
	ID int
}
",CWE-284,95.0,0
"package api
// Visibility is the type of a visibility.
type Visibility string
const (
	// Public is the PUBLIC visibility.
	Public Visibility = ""PUBLIC""
	// Protected is the PROTECTED visibility.
	Protected Visibility = ""PROTECTED""
	// Private is the PRIVATE visibility.
	Private Visibility = ""PRIVATE""
)
func (e Visibility) String() string {
	switch e {
	case Public:
		return ""PUBLIC""
	case Protected:
		return ""PROTECTED""
	case Private:
		return ""PRIVATE""
	}
	return ""PRIVATE""
}
type Memo struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatorID int       `json:""creatorId""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Content    string     `json:""content""`
	Visibility Visibility `json:""visibility""`
	Pinned     bool       `json:""pinned""`
	DisplayTs  int64      `json:""displayTs""`
	// Related fields
	Creator      *User       `json:""creator""`
	ResourceList []*Resource `json:""resourceList""`
}
type MemoCreate struct {
	// Standard fields
	CreatorID int
	// Domain specific fields
	Visibility Visibility `json:""visibility""`
	Content    string     `json:""content""`
	// Related fields
	ResourceIDList []int `json:""resourceIdList""`
}
type MemoPatch struct {
	ID int `json:""-""`
	// Standard fields
	CreatedTs *int64 `json:""createdTs""`
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Content    *string     `json:""content""`
	Visibility *Visibility `json:""visibility""`
	// Related fields
	ResourceIDList []int `json:""resourceIdList""`
}
type MemoFind struct {
	ID *int `json:""id""`
	// Standard fields
	RowStatus *RowStatus `json:""rowStatus""`
	CreatorID *int       `json:""creatorId""`
	// Domain specific fields
	Pinned         *bool
	ContentSearch  *string
	VisibilityList []Visibility
	// Pagination
	Limit  int
	Offset int
}
type MemoDelete struct {
	ID int
}
",CWE-639,95.0,0
"package api
// Visibility is the type of a visibility.
type Visibility string
const (
	// Public is the PUBLIC visibility.
	Public Visibility = ""PUBLIC""
	// Protected is the PROTECTED visibility.
	Protected Visibility = ""PROTECTED""
	// Private is the PRIVATE visibility.
	Private Visibility = ""PRIVATE""
)
func (e Visibility) String() string {
	switch e {
	case Public:
		return ""PUBLIC""
	case Protected:
		return ""PROTECTED""
	case Private:
		return ""PRIVATE""
	}
	return ""PRIVATE""
}
type Memo struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatorID int       `json:""creatorId""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Content    string     `json:""content""`
	Visibility Visibility `json:""visibility""`
	Pinned     bool       `json:""pinned""`
	DisplayTs  int64      `json:""displayTs""`
	// Related fields
	Creator      *User       `json:""creator""`
	ResourceList []*Resource `json:""resourceList""`
}
type MemoCreate struct {
	// Standard fields
	CreatorID int
	// Domain specific fields
	Visibility Visibility `json:""visibility""`
	Content    string     `json:""content""`
	// Related fields
	ResourceIDList []int `json:""resourceIdList""`
}
type MemoPatch struct {
	ID int `json:""-""`
	// Standard fields
	CreatedTs *int64 `json:""createdTs""`
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Content    *string     `json:""content""`
	Visibility *Visibility `json:""visibility""`
	// Related fields
	ResourceIDList []int `json:""resourceIdList""`
}
type MemoFind struct {
	ID *int `json:""id""`
	// Standard fields
	RowStatus *RowStatus `json:""rowStatus""`
	CreatorID *int       `json:""creatorId""`
	// Domain specific fields
	Pinned         *bool
	ContentSearch  *string
	VisibilityList []Visibility
	// Pagination
	Limit  int
	Offset int
}
type MemoDelete struct {
	ID int
}
",CWE-269,95.0,0
"package api
// Visibility is the type of a visibility.
type Visibility string
const (
	// Public is the PUBLIC visibility.
	Public Visibility = ""PUBLIC""
	// Protected is the PROTECTED visibility.
	Protected Visibility = ""PROTECTED""
	// Private is the PRIVATE visibility.
	Private Visibility = ""PRIVATE""
)
func (e Visibility) String() string {
	switch e {
	case Public:
		return ""PUBLIC""
	case Protected:
		return ""PROTECTED""
	case Private:
		return ""PRIVATE""
	}
	return ""PRIVATE""
}
type Memo struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatorID int       `json:""creatorId""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Content    string     `json:""content""`
	Visibility Visibility `json:""visibility""`
	Pinned     bool       `json:""pinned""`
	DisplayTs  int64      `json:""displayTs""`
	// Related fields
	Creator      *User       `json:""creator""`
	ResourceList []*Resource `json:""resourceList""`
}
type MemoCreate struct {
	// Standard fields
	CreatorID int
	// Domain specific fields
	Visibility Visibility `json:""visibility""`
	Content    string     `json:""content""`
	// Related fields
	ResourceIDList []int `json:""resourceIdList""`
}
type MemoPatch struct {
	ID int `json:""-""`
	// Standard fields
	CreatedTs *int64 `json:""createdTs""`
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Content    *string     `json:""content""`
	Visibility *Visibility `json:""visibility""`
	// Related fields
	ResourceIDList []int `json:""resourceIdList""`
}
type MemoFind struct {
	ID *int `json:""id""`
	// Standard fields
	RowStatus *RowStatus `json:""rowStatus""`
	CreatorID *int       `json:""creatorId""`
	// Domain specific fields
	Pinned         *bool
	ContentSearch  *string
	VisibilityList []Visibility
	// Pagination
	Limit  int
	Offset int
}
type MemoDelete struct {
	ID int
}
",CWE-285,95.0,0
"package api
type Resource struct {
	ID int `json:""id""`
	// Standard fields
	CreatorID int   `json:""creatorId""`
	CreatedTs int64 `json:""createdTs""`
	UpdatedTs int64 `json:""updatedTs""`
	// Domain specific fields
	Filename string `json:""filename""`
	Blob     []byte `json:""-""`
	Type     string `json:""type""`
	Size     int64  `json:""size""`
	// Related fields
	LinkedMemoAmount int `json:""linkedMemoAmount""`
}
type ResourceCreate struct {
	// Standard fields
	CreatorID int
	// Domain specific fields
	Filename string `json:""filename""`
	Blob     []byte `json:""blob""`
	Type     string `json:""type""`
	Size     int64  `json:""size""`
}
type ResourceFind struct {
	ID *int `json:""id""`
	// Standard fields
	CreatorID *int `json:""creatorId""`
	// Domain specific fields
	Filename *string `json:""filename""`
	MemoID   *int
}
type ResourcePatch struct {
	ID int `json:""-""`
	// Standard fields
	UpdatedTs *int64
	// Domain specific fields
	Filename *string `json:""filename""`
}
type ResourceDelete struct {
	ID int
}
",CWE-284,56.0,0
"package api
type Resource struct {
	ID int `json:""id""`
	// Standard fields
	CreatorID int   `json:""creatorId""`
	CreatedTs int64 `json:""createdTs""`
	UpdatedTs int64 `json:""updatedTs""`
	// Domain specific fields
	Filename string `json:""filename""`
	Blob     []byte `json:""-""`
	Type     string `json:""type""`
	Size     int64  `json:""size""`
	// Related fields
	LinkedMemoAmount int `json:""linkedMemoAmount""`
}
type ResourceCreate struct {
	// Standard fields
	CreatorID int
	// Domain specific fields
	Filename string `json:""filename""`
	Blob     []byte `json:""blob""`
	Type     string `json:""type""`
	Size     int64  `json:""size""`
}
type ResourceFind struct {
	ID *int `json:""id""`
	// Standard fields
	CreatorID *int `json:""creatorId""`
	// Domain specific fields
	Filename *string `json:""filename""`
	MemoID   *int
}
type ResourcePatch struct {
	ID int `json:""-""`
	// Standard fields
	UpdatedTs *int64
	// Domain specific fields
	Filename *string `json:""filename""`
}
type ResourceDelete struct {
	ID int
}
",CWE-639,56.0,0
"package api
type Resource struct {
	ID int `json:""id""`
	// Standard fields
	CreatorID int   `json:""creatorId""`
	CreatedTs int64 `json:""createdTs""`
	UpdatedTs int64 `json:""updatedTs""`
	// Domain specific fields
	Filename string `json:""filename""`
	Blob     []byte `json:""-""`
	Type     string `json:""type""`
	Size     int64  `json:""size""`
	// Related fields
	LinkedMemoAmount int `json:""linkedMemoAmount""`
}
type ResourceCreate struct {
	// Standard fields
	CreatorID int
	// Domain specific fields
	Filename string `json:""filename""`
	Blob     []byte `json:""blob""`
	Type     string `json:""type""`
	Size     int64  `json:""size""`
}
type ResourceFind struct {
	ID *int `json:""id""`
	// Standard fields
	CreatorID *int `json:""creatorId""`
	// Domain specific fields
	Filename *string `json:""filename""`
	MemoID   *int
}
type ResourcePatch struct {
	ID int `json:""-""`
	// Standard fields
	UpdatedTs *int64
	// Domain specific fields
	Filename *string `json:""filename""`
}
type ResourceDelete struct {
	ID int
}
",CWE-269,56.0,0
"package api
type Resource struct {
	ID int `json:""id""`
	// Standard fields
	CreatorID int   `json:""creatorId""`
	CreatedTs int64 `json:""createdTs""`
	UpdatedTs int64 `json:""updatedTs""`
	// Domain specific fields
	Filename string `json:""filename""`
	Blob     []byte `json:""-""`
	Type     string `json:""type""`
	Size     int64  `json:""size""`
	// Related fields
	LinkedMemoAmount int `json:""linkedMemoAmount""`
}
type ResourceCreate struct {
	// Standard fields
	CreatorID int
	// Domain specific fields
	Filename string `json:""filename""`
	Blob     []byte `json:""blob""`
	Type     string `json:""type""`
	Size     int64  `json:""size""`
}
type ResourceFind struct {
	ID *int `json:""id""`
	// Standard fields
	CreatorID *int `json:""creatorId""`
	// Domain specific fields
	Filename *string `json:""filename""`
	MemoID   *int
}
type ResourcePatch struct {
	ID int `json:""-""`
	// Standard fields
	UpdatedTs *int64
	// Domain specific fields
	Filename *string `json:""filename""`
}
type ResourceDelete struct {
	ID int
}
",CWE-285,56.0,0
"package api
type Shortcut struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatorID int       `json:""creatorId""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Title   string `json:""title""`
	Payload string `json:""payload""`
}
type ShortcutCreate struct {
	// Standard fields
	CreatorID int
	// Domain specific fields
	Title   string `json:""title""`
	Payload string `json:""payload""`
}
type ShortcutPatch struct {
	ID int `json:""-""`
	// Standard fields
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Title   *string `json:""title""`
	Payload *string `json:""payload""`
}
type ShortcutFind struct {
	ID *int
	// Standard fields
	CreatorID *int
	// Domain specific fields
	Title *string `json:""title""`
}
type ShortcutDelete struct {
	ID *int
	// Standard fields
	CreatorID *int
}
",CWE-284,54.0,0
"package api
type Shortcut struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatorID int       `json:""creatorId""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Title   string `json:""title""`
	Payload string `json:""payload""`
}
type ShortcutCreate struct {
	// Standard fields
	CreatorID int
	// Domain specific fields
	Title   string `json:""title""`
	Payload string `json:""payload""`
}
type ShortcutPatch struct {
	ID int `json:""-""`
	// Standard fields
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Title   *string `json:""title""`
	Payload *string `json:""payload""`
}
type ShortcutFind struct {
	ID *int
	// Standard fields
	CreatorID *int
	// Domain specific fields
	Title *string `json:""title""`
}
type ShortcutDelete struct {
	ID *int
	// Standard fields
	CreatorID *int
}
",CWE-639,54.0,0
"package api
type Shortcut struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatorID int       `json:""creatorId""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Title   string `json:""title""`
	Payload string `json:""payload""`
}
type ShortcutCreate struct {
	// Standard fields
	CreatorID int
	// Domain specific fields
	Title   string `json:""title""`
	Payload string `json:""payload""`
}
type ShortcutPatch struct {
	ID int `json:""-""`
	// Standard fields
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Title   *string `json:""title""`
	Payload *string `json:""payload""`
}
type ShortcutFind struct {
	ID *int
	// Standard fields
	CreatorID *int
	// Domain specific fields
	Title *string `json:""title""`
}
type ShortcutDelete struct {
	ID *int
	// Standard fields
	CreatorID *int
}
",CWE-269,54.0,0
"package api
type Shortcut struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatorID int       `json:""creatorId""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Title   string `json:""title""`
	Payload string `json:""payload""`
}
type ShortcutCreate struct {
	// Standard fields
	CreatorID int
	// Domain specific fields
	Title   string `json:""title""`
	Payload string `json:""payload""`
}
type ShortcutPatch struct {
	ID int `json:""-""`
	// Standard fields
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Title   *string `json:""title""`
	Payload *string `json:""payload""`
}
type ShortcutFind struct {
	ID *int
	// Standard fields
	CreatorID *int
	// Domain specific fields
	Title *string `json:""title""`
}
type ShortcutDelete struct {
	ID *int
	// Standard fields
	CreatorID *int
}
",CWE-285,54.0,0
"package api
import (
	""fmt""
)
// Role is the type of a role.
type Role string
const (
	// Host is the HOST role.
	Host Role = ""HOST""
	// Admin is the ADMIN role.
	Admin Role = ""ADMIN""
	// NormalUser is the USER role.
	NormalUser Role = ""USER""
)
func (e Role) String() string {
	switch e {
	case Host:
		return ""HOST""
	case Admin:
		return ""ADMIN""
	case NormalUser:
		return ""USER""
	}
	return ""USER""
}
type User struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Username        string         `json:""username""`
	Role            Role           `json:""role""`
	Email           string         `json:""email""`
	Nickname        string         `json:""nickname""`
	PasswordHash    string         `json:""-""`
	OpenID          string         `json:""openId""`
	UserSettingList []*UserSetting `json:""userSettingList""`
}
type UserCreate struct {
	// Domain specific fields
	Username     string `json:""username""`
	Role         Role   `json:""role""`
	Email        string `json:""email""`
	Nickname     string `json:""nickname""`
	Password     string `json:""password""`
	PasswordHash string
	OpenID       string
}
func (create UserCreate) Validate() error {
	if len(create.Username) < 4 {
		return fmt.Errorf(""username is too short, minimum length is 4"")
	}
	if len(create.Password) < 4 {
		return fmt.Errorf(""password is too short, minimum length is 4"")
	}
	return nil
}
type UserPatch struct {
	ID int `json:""-""`
	// Standard fields
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Username     *string `json:""username""`
	Email        *string `json:""email""`
	Nickname     *string `json:""nickname""`
	Password     *string `json:""password""`
	ResetOpenID  *bool   `json:""resetOpenId""`
	PasswordHash *string
	OpenID       *string
}
type UserFind struct {
	ID *int `json:""id""`
	// Standard fields
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Username *string `json:""username""`
	Role     *Role
	Email    *string `json:""email""`
	Nickname *string `json:""nickname""`
	OpenID   *string
}
type UserDelete struct {
	ID int
}
",CWE-284,105.0,0
"package api
import (
	""fmt""
)
// Role is the type of a role.
type Role string
const (
	// Host is the HOST role.
	Host Role = ""HOST""
	// Admin is the ADMIN role.
	Admin Role = ""ADMIN""
	// NormalUser is the USER role.
	NormalUser Role = ""USER""
)
func (e Role) String() string {
	switch e {
	case Host:
		return ""HOST""
	case Admin:
		return ""ADMIN""
	case NormalUser:
		return ""USER""
	}
	return ""USER""
}
type User struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Username        string         `json:""username""`
	Role            Role           `json:""role""`
	Email           string         `json:""email""`
	Nickname        string         `json:""nickname""`
	PasswordHash    string         `json:""-""`
	OpenID          string         `json:""openId""`
	UserSettingList []*UserSetting `json:""userSettingList""`
}
type UserCreate struct {
	// Domain specific fields
	Username     string `json:""username""`
	Role         Role   `json:""role""`
	Email        string `json:""email""`
	Nickname     string `json:""nickname""`
	Password     string `json:""password""`
	PasswordHash string
	OpenID       string
}
func (create UserCreate) Validate() error {
	if len(create.Username) < 4 {
		return fmt.Errorf(""username is too short, minimum length is 4"")
	}
	if len(create.Password) < 4 {
		return fmt.Errorf(""password is too short, minimum length is 4"")
	}
	return nil
}
type UserPatch struct {
	ID int `json:""-""`
	// Standard fields
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Username     *string `json:""username""`
	Email        *string `json:""email""`
	Nickname     *string `json:""nickname""`
	Password     *string `json:""password""`
	ResetOpenID  *bool   `json:""resetOpenId""`
	PasswordHash *string
	OpenID       *string
}
type UserFind struct {
	ID *int `json:""id""`
	// Standard fields
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Username *string `json:""username""`
	Role     *Role
	Email    *string `json:""email""`
	Nickname *string `json:""nickname""`
	OpenID   *string
}
type UserDelete struct {
	ID int
}
",CWE-639,105.0,0
"package api
import (
	""fmt""
)
// Role is the type of a role.
type Role string
const (
	// Host is the HOST role.
	Host Role = ""HOST""
	// Admin is the ADMIN role.
	Admin Role = ""ADMIN""
	// NormalUser is the USER role.
	NormalUser Role = ""USER""
)
func (e Role) String() string {
	switch e {
	case Host:
		return ""HOST""
	case Admin:
		return ""ADMIN""
	case NormalUser:
		return ""USER""
	}
	return ""USER""
}
type User struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Username        string         `json:""username""`
	Role            Role           `json:""role""`
	Email           string         `json:""email""`
	Nickname        string         `json:""nickname""`
	PasswordHash    string         `json:""-""`
	OpenID          string         `json:""openId""`
	UserSettingList []*UserSetting `json:""userSettingList""`
}
type UserCreate struct {
	// Domain specific fields
	Username     string `json:""username""`
	Role         Role   `json:""role""`
	Email        string `json:""email""`
	Nickname     string `json:""nickname""`
	Password     string `json:""password""`
	PasswordHash string
	OpenID       string
}
func (create UserCreate) Validate() error {
	if len(create.Username) < 4 {
		return fmt.Errorf(""username is too short, minimum length is 4"")
	}
	if len(create.Password) < 4 {
		return fmt.Errorf(""password is too short, minimum length is 4"")
	}
	return nil
}
type UserPatch struct {
	ID int `json:""-""`
	// Standard fields
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Username     *string `json:""username""`
	Email        *string `json:""email""`
	Nickname     *string `json:""nickname""`
	Password     *string `json:""password""`
	ResetOpenID  *bool   `json:""resetOpenId""`
	PasswordHash *string
	OpenID       *string
}
type UserFind struct {
	ID *int `json:""id""`
	// Standard fields
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Username *string `json:""username""`
	Role     *Role
	Email    *string `json:""email""`
	Nickname *string `json:""nickname""`
	OpenID   *string
}
type UserDelete struct {
	ID int
}
",CWE-269,105.0,0
"package api
import (
	""fmt""
)
// Role is the type of a role.
type Role string
const (
	// Host is the HOST role.
	Host Role = ""HOST""
	// Admin is the ADMIN role.
	Admin Role = ""ADMIN""
	// NormalUser is the USER role.
	NormalUser Role = ""USER""
)
func (e Role) String() string {
	switch e {
	case Host:
		return ""HOST""
	case Admin:
		return ""ADMIN""
	case NormalUser:
		return ""USER""
	}
	return ""USER""
}
type User struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Username        string         `json:""username""`
	Role            Role           `json:""role""`
	Email           string         `json:""email""`
	Nickname        string         `json:""nickname""`
	PasswordHash    string         `json:""-""`
	OpenID          string         `json:""openId""`
	UserSettingList []*UserSetting `json:""userSettingList""`
}
type UserCreate struct {
	// Domain specific fields
	Username     string `json:""username""`
	Role         Role   `json:""role""`
	Email        string `json:""email""`
	Nickname     string `json:""nickname""`
	Password     string `json:""password""`
	PasswordHash string
	OpenID       string
}
func (create UserCreate) Validate() error {
	if len(create.Username) < 4 {
		return fmt.Errorf(""username is too short, minimum length is 4"")
	}
	if len(create.Password) < 4 {
		return fmt.Errorf(""password is too short, minimum length is 4"")
	}
	return nil
}
type UserPatch struct {
	ID int `json:""-""`
	// Standard fields
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Username     *string `json:""username""`
	Email        *string `json:""email""`
	Nickname     *string `json:""nickname""`
	Password     *string `json:""password""`
	ResetOpenID  *bool   `json:""resetOpenId""`
	PasswordHash *string
	OpenID       *string
}
type UserFind struct {
	ID *int `json:""id""`
	// Standard fields
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Username *string `json:""username""`
	Role     *Role
	Email    *string `json:""email""`
	Nickname *string `json:""nickname""`
	OpenID   *string
}
type UserDelete struct {
	ID int
}
",CWE-285,105.0,0
"package server
import (
	""fmt""
	""time""
	""github.com/usememos/memos/server/profile""
	""github.com/usememos/memos/store""
	""github.com/gorilla/securecookie""
	""github.com/gorilla/sessions""
	""github.com/labstack/echo-contrib/session""
	""github.com/labstack/echo/v4""
	""github.com/labstack/echo/v4/middleware""
)
type Server struct {
	e *echo.Echo
	Collector *MetricCollector
	Profile *profile.Profile
	Store *store.Store
}
func NewServer(profile *profile.Profile) *Server {
	e := echo.New()
	e.Debug = true
	e.HideBanner = true
	e.HidePort = true
	e.Use(middleware.LoggerWithConfig(middleware.LoggerConfig{
		Format: `{""time"":""${time_rfc3339}"",` +
			`""method"":""${method}"",""uri"":""${uri}"",` +
			`""status"":${status},""error"":""${error}""}` + ""\n"",
	}))
	e.Use(middleware.CORS())
	e.Use(middleware.TimeoutWithConfig(middleware.TimeoutConfig{
		Skipper:      middleware.DefaultSkipper,
		ErrorMessage: ""Request timeout"",
		Timeout:      30 * time.Second,
	}))
	e.Use(middleware.SecureWithConfig(middleware.SecureConfig{
		ContentSecurityPolicy: ""default-src 'self'"",
	}))
	embedFrontend(e)
	// In dev mode, set the const secret key to make signin session persistence.
	secret := []byte(""usememos"")
	if profile.Mode == ""prod"" {
		secret = securecookie.GenerateRandomKey(16)
	}
	e.Use(session.Middleware(sessions.NewCookieStore(secret)))
	s := &Server{
		e:       e,
		Profile: profile,
	}
	rootGroup := e.Group("""")
	s.registerRSSRoutes(rootGroup)
	webhookGroup := e.Group(""/h"")
	s.registerResourcePublicRoutes(webhookGroup)
	publicGroup := e.Group(""/o"")
	s.registerResourcePublicRoutes(publicGroup)
	s.registerGetterPublicRoutes(publicGroup)
	apiGroup := e.Group(""/api"")
	apiGroup.Use(func(next echo.HandlerFunc) echo.HandlerFunc {
		return aclMiddleware(s, next)
	})
	s.registerSystemRoutes(apiGroup)
	s.registerAuthRoutes(apiGroup)
	s.registerUserRoutes(apiGroup)
	s.registerMemoRoutes(apiGroup)
	s.registerShortcutRoutes(apiGroup)
	s.registerResourceRoutes(apiGroup)
	s.registerTagRoutes(apiGroup)
	return s
}
func (server *Server) Run() error {
	return server.e.Start(fmt.Sprintf("":%d"", server.Profile.Port))
}
",CWE-79,93.0,0
"package server
import (
	""encoding/json""
	""net/http""
	""os""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
)
func (s *Server) registerSystemRoutes(g *echo.Group) {
	g.GET(""/ping"", func(c echo.Context) error {
		data := s.Profile
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(data)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to compose system profile"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/status"", func(c echo.Context) error {
		ctx := c.Request().Context()
		hostUserType := api.Host
		hostUserFind := api.UserFind{
			Role: &hostUserType,
		}
		hostUser, err := s.Store.FindUser(ctx, &hostUserFind)
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find host user"").SetInternal(err)
		}
		if hostUser != nil {
			// data desensitize
			hostUser.OpenID = """"
			hostUser.Email = """"
		}
		systemStatus := api.SystemStatus{
			Host:             hostUser,
			Profile:          *s.Profile,
			DBSize:           0,
			AllowSignUp:      false,
			AdditionalStyle:  """",
			AdditionalScript: """",
			CustomizedProfile: api.CustomizedProfile{
				Name:        ""memos"",
				LogoURL:     """",
				Description: """",
				Locale:      ""en"",
				Appearance:  ""system"",
				ExternalURL: """",
			},
		}
		systemSettingList, err := s.Store.FindSystemSettingList(ctx, &api.SystemSettingFind{})
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find system setting list"").SetInternal(err)
		}
		for _, systemSetting := range systemSettingList {
			var value interface{}
			err := json.Unmarshal([]byte(systemSetting.Value), &value)
			if err != nil {
				return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to unmarshal system setting"").SetInternal(err)
			}
			if systemSetting.Name == api.SystemSettingAllowSignUpName {
				systemStatus.AllowSignUp = value.(bool)
			} else if systemSetting.Name == api.SystemSettingAdditionalStyleName {
				systemStatus.AdditionalStyle = value.(string)
			} else if systemSetting.Name == api.SystemSettingAdditionalScriptName {
				systemStatus.AdditionalScript = value.(string)
			} else if systemSetting.Name == api.SystemSettingCustomizedProfileName {
				valueMap := value.(map[string]interface{})
				systemStatus.CustomizedProfile = api.CustomizedProfile{
					Name:        valueMap[""name""].(string),
					LogoURL:     valueMap[""logoUrl""].(string),
					Description: valueMap[""description""].(string),
					Locale:      valueMap[""locale""].(string),
					Appearance:  valueMap[""appearance""].(string),
					ExternalURL: valueMap[""externalUrl""].(string),
				}
			}
		}
		userID, ok := c.Get(getUserIDContextKey()).(int)
		// Get database size for host user.
		if ok {
			user, err := s.Store.FindUser(ctx, &api.UserFind{
				ID: &userID,
			})
			if err != nil {
				return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find user"").SetInternal(err)
			}
			if user != nil && user.Role == api.Host {
				fi, err := os.Stat(s.Profile.DSN)
				if err != nil {
					return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to read database fileinfo"").SetInternal(err)
				}
				systemStatus.DBSize = fi.Size()
			}
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(systemStatus)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode system status response"").SetInternal(err)
		}
		return nil
	})
	g.POST(""/system/setting"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		user, err := s.Store.FindUser(ctx, &api.UserFind{
			ID: &userID,
		})
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find user"").SetInternal(err)
		}
		if user == nil {
			return echo.NewHTTPError(http.StatusNotFound, ""Current signin user not found"")
		} else if user.Role != api.Host {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Unauthorized"")
		}
		systemSettingUpsert := &api.SystemSettingUpsert{}
		if err := json.NewDecoder(c.Request().Body).Decode(systemSettingUpsert); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted post system setting request"").SetInternal(err)
		}
		if err := systemSettingUpsert.Validate(); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""system setting invalidate"").SetInternal(err)
		}
		systemSetting, err := s.Store.UpsertSystemSetting(ctx, systemSettingUpsert)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to upsert system setting"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name:   ""systemSetting updated"",
			Labels: map[string]string{""field"": string(systemSettingUpsert.Name)},
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(systemSetting)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode system setting response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/system/setting"", func(c echo.Context) error {
		ctx := c.Request().Context()
		systemSettingList, err := s.Store.FindSystemSettingList(ctx, &api.SystemSettingFind{})
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find system setting list"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(systemSettingList)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode system setting list response"").SetInternal(err)
		}
		return nil
	})
	g.POST(""/system/vacuum"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		user, err := s.Store.FindUser(ctx, &api.UserFind{
			ID: &userID,
		})
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find user"").SetInternal(err)
		}
		if user == nil || user.Role != api.Host {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Unauthorized"")
		}
		if err := s.Store.Vacuum(ctx); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to vacuum database"").SetInternal(err)
		}
		c.Response().WriteHeader(http.StatusOK)
		return nil
	})
}
",CWE-212,194.0,0
"package api
import (
	""fmt""
	""github.com/usememos/memos/common""
)
// Role is the type of a role.
type Role string
const (
	// Host is the HOST role.
	Host Role = ""HOST""
	// Admin is the ADMIN role.
	Admin Role = ""ADMIN""
	// NormalUser is the USER role.
	NormalUser Role = ""USER""
)
func (e Role) String() string {
	switch e {
	case Host:
		return ""HOST""
	case Admin:
		return ""ADMIN""
	case NormalUser:
		return ""USER""
	}
	return ""USER""
}
type User struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Username        string         `json:""username""`
	Role            Role           `json:""role""`
	Email           string         `json:""email""`
	Nickname        string         `json:""nickname""`
	PasswordHash    string         `json:""-""`
	OpenID          string         `json:""openId""`
	UserSettingList []*UserSetting `json:""userSettingList""`
}
type UserCreate struct {
	// Domain specific fields
	Username     string `json:""username""`
	Role         Role   `json:""role""`
	Email        string `json:""email""`
	Nickname     string `json:""nickname""`
	Password     string `json:""password""`
	PasswordHash string
	OpenID       string
}
func (create UserCreate) Validate() error {
	if len(create.Username) < 4 {
		return fmt.Errorf(""username is too short, minimum length is 4"")
	}
	if len(create.Username) > 32 {
		return fmt.Errorf(""username is too long, maximum length is 32"")
	}
	if len(create.Password) < 4 {
		return fmt.Errorf(""password is too short, minimum length is 4"")
	}
	if len(create.Nickname) > 64 {
		return fmt.Errorf(""nickname is too long, maximum length is 64"")
	}
	if create.Email != """" {
		if len(create.Email) > 256 {
			return fmt.Errorf(""email is too long, maximum length is 256"")
		}
		if common.ValidateEmail(create.Email) {
			return fmt.Errorf(""invalid email format"")
		}
	}
	return nil
}
type UserPatch struct {
	ID int `json:""-""`
	// Standard fields
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Username     *string `json:""username""`
	Email        *string `json:""email""`
	Nickname     *string `json:""nickname""`
	Password     *string `json:""password""`
	ResetOpenID  *bool   `json:""resetOpenId""`
	PasswordHash *string
	OpenID       *string
}
func (patch UserPatch) Validate() error {
	if patch.Username != nil && len(*patch.Username) < 4 {
		return fmt.Errorf(""username is too short, minimum length is 4"")
	}
	if patch.Username != nil && len(*patch.Username) > 32 {
		return fmt.Errorf(""username is too long, maximum length is 32"")
	}
	if patch.Password != nil && len(*patch.Password) < 4 {
		return fmt.Errorf(""password is too short, minimum length is 4"")
	}
	if patch.Nickname != nil && len(*patch.Nickname) > 64 {
		return fmt.Errorf(""nickname is too long, maximum length is 64"")
	}
	if patch.Email != nil {
		if len(*patch.Email) > 256 {
			return fmt.Errorf(""email is too long, maximum length is 256"")
		}
		if common.ValidateEmail(*patch.Email) {
			return fmt.Errorf(""invalid email format"")
		}
	}
	return nil
}
type UserFind struct {
	ID *int `json:""id""`
	// Standard fields
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Username *string `json:""username""`
	Role     *Role
	Email    *string `json:""email""`
	Nickname *string `json:""nickname""`
	OpenID   *string
}
type UserDelete struct {
	ID int
}
",CWE-400,146.0,0
"package api
// Visibility is the type of a visibility.
type Visibility string
const (
	// Public is the PUBLIC visibility.
	Public Visibility = ""PUBLIC""
	// Protected is the PROTECTED visibility.
	Protected Visibility = ""PROTECTED""
	// Private is the PRIVATE visibility.
	Private Visibility = ""PRIVATE""
)
func (e Visibility) String() string {
	switch e {
	case Public:
		return ""PUBLIC""
	case Protected:
		return ""PROTECTED""
	case Private:
		return ""PRIVATE""
	}
	return ""PRIVATE""
}
type Memo struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatorID int       `json:""creatorId""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Content    string     `json:""content""`
	Visibility Visibility `json:""visibility""`
	Pinned     bool       `json:""pinned""`
	DisplayTs  int64      `json:""displayTs""`
	// Related fields
	Creator      *User       `json:""creator""`
	ResourceList []*Resource `json:""resourceList""`
}
type MemoCreate struct {
	// Standard fields
	CreatorID int `json:""-""`
	// Domain specific fields
	Visibility Visibility `json:""visibility""`
	Content    string     `json:""content""`
	// Related fields
	ResourceIDList []int `json:""resourceIdList""`
}
type MemoPatch struct {
	ID int `json:""-""`
	// Standard fields
	CreatedTs *int64 `json:""createdTs""`
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Content    *string     `json:""content""`
	Visibility *Visibility `json:""visibility""`
	// Related fields
	ResourceIDList []int `json:""resourceIdList""`
}
type MemoFind struct {
	ID *int
	// Standard fields
	RowStatus *RowStatus
	CreatorID *int
	// Domain specific fields
	Pinned         *bool
	ContentSearch  *string
	VisibilityList []Visibility
	// Pagination
	Limit  int
	Offset int
}
type MemoDelete struct {
	ID int
}
",CWE-648,95.0,0
"package api
// Visibility is the type of a visibility.
type Visibility string
const (
	// Public is the PUBLIC visibility.
	Public Visibility = ""PUBLIC""
	// Protected is the PROTECTED visibility.
	Protected Visibility = ""PROTECTED""
	// Private is the PRIVATE visibility.
	Private Visibility = ""PRIVATE""
)
func (e Visibility) String() string {
	switch e {
	case Public:
		return ""PUBLIC""
	case Protected:
		return ""PROTECTED""
	case Private:
		return ""PRIVATE""
	}
	return ""PRIVATE""
}
type Memo struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatorID int       `json:""creatorId""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Content    string     `json:""content""`
	Visibility Visibility `json:""visibility""`
	Pinned     bool       `json:""pinned""`
	DisplayTs  int64      `json:""displayTs""`
	// Related fields
	Creator      *User       `json:""creator""`
	ResourceList []*Resource `json:""resourceList""`
}
type MemoCreate struct {
	// Standard fields
	CreatorID int `json:""-""`
	// Domain specific fields
	Visibility Visibility `json:""visibility""`
	Content    string     `json:""content""`
	// Related fields
	ResourceIDList []int `json:""resourceIdList""`
}
type MemoPatch struct {
	ID int `json:""-""`
	// Standard fields
	CreatedTs *int64 `json:""createdTs""`
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Content    *string     `json:""content""`
	Visibility *Visibility `json:""visibility""`
	// Related fields
	ResourceIDList []int `json:""resourceIdList""`
}
type MemoFind struct {
	ID *int
	// Standard fields
	RowStatus *RowStatus
	CreatorID *int
	// Domain specific fields
	Pinned         *bool
	ContentSearch  *string
	VisibilityList []Visibility
	// Pagination
	Limit  int
	Offset int
}
type MemoDelete struct {
	ID int
}
",CWE-307,95.0,0
"package api
// Visibility is the type of a visibility.
type Visibility string
const (
	// Public is the PUBLIC visibility.
	Public Visibility = ""PUBLIC""
	// Protected is the PROTECTED visibility.
	Protected Visibility = ""PROTECTED""
	// Private is the PRIVATE visibility.
	Private Visibility = ""PRIVATE""
)
func (e Visibility) String() string {
	switch e {
	case Public:
		return ""PUBLIC""
	case Protected:
		return ""PROTECTED""
	case Private:
		return ""PRIVATE""
	}
	return ""PRIVATE""
}
type Memo struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatorID int       `json:""creatorId""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Content    string     `json:""content""`
	Visibility Visibility `json:""visibility""`
	Pinned     bool       `json:""pinned""`
	DisplayTs  int64      `json:""displayTs""`
	// Related fields
	Creator      *User       `json:""creator""`
	ResourceList []*Resource `json:""resourceList""`
}
type MemoCreate struct {
	// Standard fields
	CreatorID int `json:""-""`
	// Domain specific fields
	Visibility Visibility `json:""visibility""`
	Content    string     `json:""content""`
	// Related fields
	ResourceIDList []int `json:""resourceIdList""`
}
type MemoPatch struct {
	ID int `json:""-""`
	// Standard fields
	CreatedTs *int64 `json:""createdTs""`
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Content    *string     `json:""content""`
	Visibility *Visibility `json:""visibility""`
	// Related fields
	ResourceIDList []int `json:""resourceIdList""`
}
type MemoFind struct {
	ID *int
	// Standard fields
	RowStatus *RowStatus
	CreatorID *int
	// Domain specific fields
	Pinned         *bool
	ContentSearch  *string
	VisibilityList []Visibility
	// Pagination
	Limit  int
	Offset int
}
type MemoDelete struct {
	ID int
}
",CWE-639,95.0,0
"package api
// Visibility is the type of a visibility.
type Visibility string
const (
	// Public is the PUBLIC visibility.
	Public Visibility = ""PUBLIC""
	// Protected is the PROTECTED visibility.
	Protected Visibility = ""PROTECTED""
	// Private is the PRIVATE visibility.
	Private Visibility = ""PRIVATE""
)
func (e Visibility) String() string {
	switch e {
	case Public:
		return ""PUBLIC""
	case Protected:
		return ""PROTECTED""
	case Private:
		return ""PRIVATE""
	}
	return ""PRIVATE""
}
type Memo struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatorID int       `json:""creatorId""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Content    string     `json:""content""`
	Visibility Visibility `json:""visibility""`
	Pinned     bool       `json:""pinned""`
	DisplayTs  int64      `json:""displayTs""`
	// Related fields
	Creator      *User       `json:""creator""`
	ResourceList []*Resource `json:""resourceList""`
}
type MemoCreate struct {
	// Standard fields
	CreatorID int `json:""-""`
	// Domain specific fields
	Visibility Visibility `json:""visibility""`
	Content    string     `json:""content""`
	// Related fields
	ResourceIDList []int `json:""resourceIdList""`
}
type MemoPatch struct {
	ID int `json:""-""`
	// Standard fields
	CreatedTs *int64 `json:""createdTs""`
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Content    *string     `json:""content""`
	Visibility *Visibility `json:""visibility""`
	// Related fields
	ResourceIDList []int `json:""resourceIdList""`
}
type MemoFind struct {
	ID *int
	// Standard fields
	RowStatus *RowStatus
	CreatorID *int
	// Domain specific fields
	Pinned         *bool
	ContentSearch  *string
	VisibilityList []Visibility
	// Pagination
	Limit  int
	Offset int
}
type MemoDelete struct {
	ID int
}
",CWE-940,95.0,0
"package api
// Visibility is the type of a visibility.
type Visibility string
const (
	// Public is the PUBLIC visibility.
	Public Visibility = ""PUBLIC""
	// Protected is the PROTECTED visibility.
	Protected Visibility = ""PROTECTED""
	// Private is the PRIVATE visibility.
	Private Visibility = ""PRIVATE""
)
func (e Visibility) String() string {
	switch e {
	case Public:
		return ""PUBLIC""
	case Protected:
		return ""PROTECTED""
	case Private:
		return ""PRIVATE""
	}
	return ""PRIVATE""
}
type Memo struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatorID int       `json:""creatorId""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Content    string     `json:""content""`
	Visibility Visibility `json:""visibility""`
	Pinned     bool       `json:""pinned""`
	DisplayTs  int64      `json:""displayTs""`
	// Related fields
	Creator      *User       `json:""creator""`
	ResourceList []*Resource `json:""resourceList""`
}
type MemoCreate struct {
	// Standard fields
	CreatorID int `json:""-""`
	// Domain specific fields
	Visibility Visibility `json:""visibility""`
	Content    string     `json:""content""`
	// Related fields
	ResourceIDList []int `json:""resourceIdList""`
}
type MemoPatch struct {
	ID int `json:""-""`
	// Standard fields
	CreatedTs *int64 `json:""createdTs""`
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Content    *string     `json:""content""`
	Visibility *Visibility `json:""visibility""`
	// Related fields
	ResourceIDList []int `json:""resourceIdList""`
}
type MemoFind struct {
	ID *int
	// Standard fields
	RowStatus *RowStatus
	CreatorID *int
	// Domain specific fields
	Pinned         *bool
	ContentSearch  *string
	VisibilityList []Visibility
	// Pagination
	Limit  int
	Offset int
}
type MemoDelete struct {
	ID int
}
",CWE-1220,95.0,0
"package api
// Visibility is the type of a visibility.
type Visibility string
const (
	// Public is the PUBLIC visibility.
	Public Visibility = ""PUBLIC""
	// Protected is the PROTECTED visibility.
	Protected Visibility = ""PROTECTED""
	// Private is the PRIVATE visibility.
	Private Visibility = ""PRIVATE""
)
func (e Visibility) String() string {
	switch e {
	case Public:
		return ""PUBLIC""
	case Protected:
		return ""PROTECTED""
	case Private:
		return ""PRIVATE""
	}
	return ""PRIVATE""
}
type Memo struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatorID int       `json:""creatorId""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Content    string     `json:""content""`
	Visibility Visibility `json:""visibility""`
	Pinned     bool       `json:""pinned""`
	DisplayTs  int64      `json:""displayTs""`
	// Related fields
	Creator      *User       `json:""creator""`
	ResourceList []*Resource `json:""resourceList""`
}
type MemoCreate struct {
	// Standard fields
	CreatorID int `json:""-""`
	// Domain specific fields
	Visibility Visibility `json:""visibility""`
	Content    string     `json:""content""`
	// Related fields
	ResourceIDList []int `json:""resourceIdList""`
}
type MemoPatch struct {
	ID int `json:""-""`
	// Standard fields
	CreatedTs *int64 `json:""createdTs""`
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Content    *string     `json:""content""`
	Visibility *Visibility `json:""visibility""`
	// Related fields
	ResourceIDList []int `json:""resourceIdList""`
}
type MemoFind struct {
	ID *int
	// Standard fields
	RowStatus *RowStatus
	CreatorID *int
	// Domain specific fields
	Pinned         *bool
	ContentSearch  *string
	VisibilityList []Visibility
	// Pagination
	Limit  int
	Offset int
}
type MemoDelete struct {
	ID int
}
",CWE-285,95.0,0
"package api
// Visibility is the type of a visibility.
type Visibility string
const (
	// Public is the PUBLIC visibility.
	Public Visibility = ""PUBLIC""
	// Protected is the PROTECTED visibility.
	Protected Visibility = ""PROTECTED""
	// Private is the PRIVATE visibility.
	Private Visibility = ""PRIVATE""
)
func (e Visibility) String() string {
	switch e {
	case Public:
		return ""PUBLIC""
	case Protected:
		return ""PROTECTED""
	case Private:
		return ""PRIVATE""
	}
	return ""PRIVATE""
}
type Memo struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatorID int       `json:""creatorId""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Content    string     `json:""content""`
	Visibility Visibility `json:""visibility""`
	Pinned     bool       `json:""pinned""`
	DisplayTs  int64      `json:""displayTs""`
	// Related fields
	Creator      *User       `json:""creator""`
	ResourceList []*Resource `json:""resourceList""`
}
type MemoCreate struct {
	// Standard fields
	CreatorID int `json:""-""`
	// Domain specific fields
	Visibility Visibility `json:""visibility""`
	Content    string     `json:""content""`
	// Related fields
	ResourceIDList []int `json:""resourceIdList""`
}
type MemoPatch struct {
	ID int `json:""-""`
	// Standard fields
	CreatedTs *int64 `json:""createdTs""`
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Content    *string     `json:""content""`
	Visibility *Visibility `json:""visibility""`
	// Related fields
	ResourceIDList []int `json:""resourceIdList""`
}
type MemoFind struct {
	ID *int
	// Standard fields
	RowStatus *RowStatus
	CreatorID *int
	// Domain specific fields
	Pinned         *bool
	ContentSearch  *string
	VisibilityList []Visibility
	// Pagination
	Limit  int
	Offset int
}
type MemoDelete struct {
	ID int
}
",CWE-284,95.0,0
"package api
// Visibility is the type of a visibility.
type Visibility string
const (
	// Public is the PUBLIC visibility.
	Public Visibility = ""PUBLIC""
	// Protected is the PROTECTED visibility.
	Protected Visibility = ""PROTECTED""
	// Private is the PRIVATE visibility.
	Private Visibility = ""PRIVATE""
)
func (e Visibility) String() string {
	switch e {
	case Public:
		return ""PUBLIC""
	case Protected:
		return ""PROTECTED""
	case Private:
		return ""PRIVATE""
	}
	return ""PRIVATE""
}
type Memo struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatorID int       `json:""creatorId""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Content    string     `json:""content""`
	Visibility Visibility `json:""visibility""`
	Pinned     bool       `json:""pinned""`
	DisplayTs  int64      `json:""displayTs""`
	// Related fields
	Creator      *User       `json:""creator""`
	ResourceList []*Resource `json:""resourceList""`
}
type MemoCreate struct {
	// Standard fields
	CreatorID int `json:""-""`
	// Domain specific fields
	Visibility Visibility `json:""visibility""`
	Content    string     `json:""content""`
	// Related fields
	ResourceIDList []int `json:""resourceIdList""`
}
type MemoPatch struct {
	ID int `json:""-""`
	// Standard fields
	CreatedTs *int64 `json:""createdTs""`
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Content    *string     `json:""content""`
	Visibility *Visibility `json:""visibility""`
	// Related fields
	ResourceIDList []int `json:""resourceIdList""`
}
type MemoFind struct {
	ID *int
	// Standard fields
	RowStatus *RowStatus
	CreatorID *int
	// Domain specific fields
	Pinned         *bool
	ContentSearch  *string
	VisibilityList []Visibility
	// Pagination
	Limit  int
	Offset int
}
type MemoDelete struct {
	ID int
}
",CWE-229,95.0,0
"package api
// Visibility is the type of a visibility.
type Visibility string
const (
	// Public is the PUBLIC visibility.
	Public Visibility = ""PUBLIC""
	// Protected is the PROTECTED visibility.
	Protected Visibility = ""PROTECTED""
	// Private is the PRIVATE visibility.
	Private Visibility = ""PRIVATE""
)
func (e Visibility) String() string {
	switch e {
	case Public:
		return ""PUBLIC""
	case Protected:
		return ""PROTECTED""
	case Private:
		return ""PRIVATE""
	}
	return ""PRIVATE""
}
type Memo struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatorID int       `json:""creatorId""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Content    string     `json:""content""`
	Visibility Visibility `json:""visibility""`
	Pinned     bool       `json:""pinned""`
	DisplayTs  int64      `json:""displayTs""`
	// Related fields
	Creator      *User       `json:""creator""`
	ResourceList []*Resource `json:""resourceList""`
}
type MemoCreate struct {
	// Standard fields
	CreatorID int `json:""-""`
	// Domain specific fields
	Visibility Visibility `json:""visibility""`
	Content    string     `json:""content""`
	// Related fields
	ResourceIDList []int `json:""resourceIdList""`
}
type MemoPatch struct {
	ID int `json:""-""`
	// Standard fields
	CreatedTs *int64 `json:""createdTs""`
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Content    *string     `json:""content""`
	Visibility *Visibility `json:""visibility""`
	// Related fields
	ResourceIDList []int `json:""resourceIdList""`
}
type MemoFind struct {
	ID *int
	// Standard fields
	RowStatus *RowStatus
	CreatorID *int
	// Domain specific fields
	Pinned         *bool
	ContentSearch  *string
	VisibilityList []Visibility
	// Pagination
	Limit  int
	Offset int
}
type MemoDelete struct {
	ID int
}
",CWE-280,95.0,0
"package api
type MemoOrganizer struct {
	ID int
	// Domain specific fields
	MemoID int
	UserID int
	Pinned bool
}
type MemoOrganizerUpsert struct {
	MemoID int  `json:""-""`
	UserID int  `json:""-""`
	Pinned bool `json:""pinned""`
}
type MemoOrganizerFind struct {
	MemoID int
	UserID int
}
type MemoOrganizerDelete struct {
	MemoID *int
	UserID *int
}
",CWE-648,27.0,0
"package api
type MemoOrganizer struct {
	ID int
	// Domain specific fields
	MemoID int
	UserID int
	Pinned bool
}
type MemoOrganizerUpsert struct {
	MemoID int  `json:""-""`
	UserID int  `json:""-""`
	Pinned bool `json:""pinned""`
}
type MemoOrganizerFind struct {
	MemoID int
	UserID int
}
type MemoOrganizerDelete struct {
	MemoID *int
	UserID *int
}
",CWE-307,27.0,0
"package api
type MemoOrganizer struct {
	ID int
	// Domain specific fields
	MemoID int
	UserID int
	Pinned bool
}
type MemoOrganizerUpsert struct {
	MemoID int  `json:""-""`
	UserID int  `json:""-""`
	Pinned bool `json:""pinned""`
}
type MemoOrganizerFind struct {
	MemoID int
	UserID int
}
type MemoOrganizerDelete struct {
	MemoID *int
	UserID *int
}
",CWE-639,27.0,0
"package api
type MemoOrganizer struct {
	ID int
	// Domain specific fields
	MemoID int
	UserID int
	Pinned bool
}
type MemoOrganizerUpsert struct {
	MemoID int  `json:""-""`
	UserID int  `json:""-""`
	Pinned bool `json:""pinned""`
}
type MemoOrganizerFind struct {
	MemoID int
	UserID int
}
type MemoOrganizerDelete struct {
	MemoID *int
	UserID *int
}
",CWE-940,27.0,0
"package api
type MemoOrganizer struct {
	ID int
	// Domain specific fields
	MemoID int
	UserID int
	Pinned bool
}
type MemoOrganizerUpsert struct {
	MemoID int  `json:""-""`
	UserID int  `json:""-""`
	Pinned bool `json:""pinned""`
}
type MemoOrganizerFind struct {
	MemoID int
	UserID int
}
type MemoOrganizerDelete struct {
	MemoID *int
	UserID *int
}
",CWE-1220,27.0,0
"package api
type MemoOrganizer struct {
	ID int
	// Domain specific fields
	MemoID int
	UserID int
	Pinned bool
}
type MemoOrganizerUpsert struct {
	MemoID int  `json:""-""`
	UserID int  `json:""-""`
	Pinned bool `json:""pinned""`
}
type MemoOrganizerFind struct {
	MemoID int
	UserID int
}
type MemoOrganizerDelete struct {
	MemoID *int
	UserID *int
}
",CWE-285,27.0,0
"package api
type MemoOrganizer struct {
	ID int
	// Domain specific fields
	MemoID int
	UserID int
	Pinned bool
}
type MemoOrganizerUpsert struct {
	MemoID int  `json:""-""`
	UserID int  `json:""-""`
	Pinned bool `json:""pinned""`
}
type MemoOrganizerFind struct {
	MemoID int
	UserID int
}
type MemoOrganizerDelete struct {
	MemoID *int
	UserID *int
}
",CWE-284,27.0,0
"package api
type MemoOrganizer struct {
	ID int
	// Domain specific fields
	MemoID int
	UserID int
	Pinned bool
}
type MemoOrganizerUpsert struct {
	MemoID int  `json:""-""`
	UserID int  `json:""-""`
	Pinned bool `json:""pinned""`
}
type MemoOrganizerFind struct {
	MemoID int
	UserID int
}
type MemoOrganizerDelete struct {
	MemoID *int
	UserID *int
}
",CWE-229,27.0,0
"package api
type MemoOrganizer struct {
	ID int
	// Domain specific fields
	MemoID int
	UserID int
	Pinned bool
}
type MemoOrganizerUpsert struct {
	MemoID int  `json:""-""`
	UserID int  `json:""-""`
	Pinned bool `json:""pinned""`
}
type MemoOrganizerFind struct {
	MemoID int
	UserID int
}
type MemoOrganizerDelete struct {
	MemoID *int
	UserID *int
}
",CWE-280,27.0,0
"package api
type MemoResource struct {
	MemoID     int
	ResourceID int
	CreatedTs  int64
	UpdatedTs  int64
}
type MemoResourceUpsert struct {
	MemoID     int `json:""-""`
	ResourceID int
	UpdatedTs  *int64
}
type MemoResourceFind struct {
	MemoID     *int
	ResourceID *int
}
type MemoResourceDelete struct {
	MemoID     *int
	ResourceID *int
}
",CWE-648,25.0,0
"package api
type MemoResource struct {
	MemoID     int
	ResourceID int
	CreatedTs  int64
	UpdatedTs  int64
}
type MemoResourceUpsert struct {
	MemoID     int `json:""-""`
	ResourceID int
	UpdatedTs  *int64
}
type MemoResourceFind struct {
	MemoID     *int
	ResourceID *int
}
type MemoResourceDelete struct {
	MemoID     *int
	ResourceID *int
}
",CWE-307,25.0,0
"package api
type MemoResource struct {
	MemoID     int
	ResourceID int
	CreatedTs  int64
	UpdatedTs  int64
}
type MemoResourceUpsert struct {
	MemoID     int `json:""-""`
	ResourceID int
	UpdatedTs  *int64
}
type MemoResourceFind struct {
	MemoID     *int
	ResourceID *int
}
type MemoResourceDelete struct {
	MemoID     *int
	ResourceID *int
}
",CWE-639,25.0,0
"package api
type MemoResource struct {
	MemoID     int
	ResourceID int
	CreatedTs  int64
	UpdatedTs  int64
}
type MemoResourceUpsert struct {
	MemoID     int `json:""-""`
	ResourceID int
	UpdatedTs  *int64
}
type MemoResourceFind struct {
	MemoID     *int
	ResourceID *int
}
type MemoResourceDelete struct {
	MemoID     *int
	ResourceID *int
}
",CWE-940,25.0,0
"package api
type MemoResource struct {
	MemoID     int
	ResourceID int
	CreatedTs  int64
	UpdatedTs  int64
}
type MemoResourceUpsert struct {
	MemoID     int `json:""-""`
	ResourceID int
	UpdatedTs  *int64
}
type MemoResourceFind struct {
	MemoID     *int
	ResourceID *int
}
type MemoResourceDelete struct {
	MemoID     *int
	ResourceID *int
}
",CWE-1220,25.0,0
"package api
type MemoResource struct {
	MemoID     int
	ResourceID int
	CreatedTs  int64
	UpdatedTs  int64
}
type MemoResourceUpsert struct {
	MemoID     int `json:""-""`
	ResourceID int
	UpdatedTs  *int64
}
type MemoResourceFind struct {
	MemoID     *int
	ResourceID *int
}
type MemoResourceDelete struct {
	MemoID     *int
	ResourceID *int
}
",CWE-285,25.0,0
"package api
type MemoResource struct {
	MemoID     int
	ResourceID int
	CreatedTs  int64
	UpdatedTs  int64
}
type MemoResourceUpsert struct {
	MemoID     int `json:""-""`
	ResourceID int
	UpdatedTs  *int64
}
type MemoResourceFind struct {
	MemoID     *int
	ResourceID *int
}
type MemoResourceDelete struct {
	MemoID     *int
	ResourceID *int
}
",CWE-284,25.0,0
"package api
type MemoResource struct {
	MemoID     int
	ResourceID int
	CreatedTs  int64
	UpdatedTs  int64
}
type MemoResourceUpsert struct {
	MemoID     int `json:""-""`
	ResourceID int
	UpdatedTs  *int64
}
type MemoResourceFind struct {
	MemoID     *int
	ResourceID *int
}
type MemoResourceDelete struct {
	MemoID     *int
	ResourceID *int
}
",CWE-229,25.0,0
"package api
type MemoResource struct {
	MemoID     int
	ResourceID int
	CreatedTs  int64
	UpdatedTs  int64
}
type MemoResourceUpsert struct {
	MemoID     int `json:""-""`
	ResourceID int
	UpdatedTs  *int64
}
type MemoResourceFind struct {
	MemoID     *int
	ResourceID *int
}
type MemoResourceDelete struct {
	MemoID     *int
	ResourceID *int
}
",CWE-280,25.0,0
"package api
type Resource struct {
	ID int `json:""id""`
	// Standard fields
	CreatorID int   `json:""creatorId""`
	CreatedTs int64 `json:""createdTs""`
	UpdatedTs int64 `json:""updatedTs""`
	// Domain specific fields
	Filename string `json:""filename""`
	Blob     []byte `json:""-""`
	Type     string `json:""type""`
	Size     int64  `json:""size""`
	// Related fields
	LinkedMemoAmount int `json:""linkedMemoAmount""`
}
type ResourceCreate struct {
	// Standard fields
	CreatorID int `json:""-""`
	// Domain specific fields
	Filename string `json:""filename""`
	Blob     []byte `json:""blob""`
	Type     string `json:""type""`
	Size     int64  `json:""size""`
}
type ResourceFind struct {
	ID *int `json:""id""`
	// Standard fields
	CreatorID *int `json:""creatorId""`
	// Domain specific fields
	Filename *string `json:""filename""`
	MemoID   *int
}
type ResourcePatch struct {
	ID int `json:""-""`
	// Standard fields
	UpdatedTs *int64
	// Domain specific fields
	Filename *string `json:""filename""`
}
type ResourceDelete struct {
	ID int
}
",CWE-648,56.0,0
"package api
type Resource struct {
	ID int `json:""id""`
	// Standard fields
	CreatorID int   `json:""creatorId""`
	CreatedTs int64 `json:""createdTs""`
	UpdatedTs int64 `json:""updatedTs""`
	// Domain specific fields
	Filename string `json:""filename""`
	Blob     []byte `json:""-""`
	Type     string `json:""type""`
	Size     int64  `json:""size""`
	// Related fields
	LinkedMemoAmount int `json:""linkedMemoAmount""`
}
type ResourceCreate struct {
	// Standard fields
	CreatorID int `json:""-""`
	// Domain specific fields
	Filename string `json:""filename""`
	Blob     []byte `json:""blob""`
	Type     string `json:""type""`
	Size     int64  `json:""size""`
}
type ResourceFind struct {
	ID *int `json:""id""`
	// Standard fields
	CreatorID *int `json:""creatorId""`
	// Domain specific fields
	Filename *string `json:""filename""`
	MemoID   *int
}
type ResourcePatch struct {
	ID int `json:""-""`
	// Standard fields
	UpdatedTs *int64
	// Domain specific fields
	Filename *string `json:""filename""`
}
type ResourceDelete struct {
	ID int
}
",CWE-307,56.0,0
"package api
type Resource struct {
	ID int `json:""id""`
	// Standard fields
	CreatorID int   `json:""creatorId""`
	CreatedTs int64 `json:""createdTs""`
	UpdatedTs int64 `json:""updatedTs""`
	// Domain specific fields
	Filename string `json:""filename""`
	Blob     []byte `json:""-""`
	Type     string `json:""type""`
	Size     int64  `json:""size""`
	// Related fields
	LinkedMemoAmount int `json:""linkedMemoAmount""`
}
type ResourceCreate struct {
	// Standard fields
	CreatorID int `json:""-""`
	// Domain specific fields
	Filename string `json:""filename""`
	Blob     []byte `json:""blob""`
	Type     string `json:""type""`
	Size     int64  `json:""size""`
}
type ResourceFind struct {
	ID *int `json:""id""`
	// Standard fields
	CreatorID *int `json:""creatorId""`
	// Domain specific fields
	Filename *string `json:""filename""`
	MemoID   *int
}
type ResourcePatch struct {
	ID int `json:""-""`
	// Standard fields
	UpdatedTs *int64
	// Domain specific fields
	Filename *string `json:""filename""`
}
type ResourceDelete struct {
	ID int
}
",CWE-639,56.0,0
"package api
type Resource struct {
	ID int `json:""id""`
	// Standard fields
	CreatorID int   `json:""creatorId""`
	CreatedTs int64 `json:""createdTs""`
	UpdatedTs int64 `json:""updatedTs""`
	// Domain specific fields
	Filename string `json:""filename""`
	Blob     []byte `json:""-""`
	Type     string `json:""type""`
	Size     int64  `json:""size""`
	// Related fields
	LinkedMemoAmount int `json:""linkedMemoAmount""`
}
type ResourceCreate struct {
	// Standard fields
	CreatorID int `json:""-""`
	// Domain specific fields
	Filename string `json:""filename""`
	Blob     []byte `json:""blob""`
	Type     string `json:""type""`
	Size     int64  `json:""size""`
}
type ResourceFind struct {
	ID *int `json:""id""`
	// Standard fields
	CreatorID *int `json:""creatorId""`
	// Domain specific fields
	Filename *string `json:""filename""`
	MemoID   *int
}
type ResourcePatch struct {
	ID int `json:""-""`
	// Standard fields
	UpdatedTs *int64
	// Domain specific fields
	Filename *string `json:""filename""`
}
type ResourceDelete struct {
	ID int
}
",CWE-940,56.0,0
"package api
type Resource struct {
	ID int `json:""id""`
	// Standard fields
	CreatorID int   `json:""creatorId""`
	CreatedTs int64 `json:""createdTs""`
	UpdatedTs int64 `json:""updatedTs""`
	// Domain specific fields
	Filename string `json:""filename""`
	Blob     []byte `json:""-""`
	Type     string `json:""type""`
	Size     int64  `json:""size""`
	// Related fields
	LinkedMemoAmount int `json:""linkedMemoAmount""`
}
type ResourceCreate struct {
	// Standard fields
	CreatorID int `json:""-""`
	// Domain specific fields
	Filename string `json:""filename""`
	Blob     []byte `json:""blob""`
	Type     string `json:""type""`
	Size     int64  `json:""size""`
}
type ResourceFind struct {
	ID *int `json:""id""`
	// Standard fields
	CreatorID *int `json:""creatorId""`
	// Domain specific fields
	Filename *string `json:""filename""`
	MemoID   *int
}
type ResourcePatch struct {
	ID int `json:""-""`
	// Standard fields
	UpdatedTs *int64
	// Domain specific fields
	Filename *string `json:""filename""`
}
type ResourceDelete struct {
	ID int
}
",CWE-1220,56.0,0
"package api
type Resource struct {
	ID int `json:""id""`
	// Standard fields
	CreatorID int   `json:""creatorId""`
	CreatedTs int64 `json:""createdTs""`
	UpdatedTs int64 `json:""updatedTs""`
	// Domain specific fields
	Filename string `json:""filename""`
	Blob     []byte `json:""-""`
	Type     string `json:""type""`
	Size     int64  `json:""size""`
	// Related fields
	LinkedMemoAmount int `json:""linkedMemoAmount""`
}
type ResourceCreate struct {
	// Standard fields
	CreatorID int `json:""-""`
	// Domain specific fields
	Filename string `json:""filename""`
	Blob     []byte `json:""blob""`
	Type     string `json:""type""`
	Size     int64  `json:""size""`
}
type ResourceFind struct {
	ID *int `json:""id""`
	// Standard fields
	CreatorID *int `json:""creatorId""`
	// Domain specific fields
	Filename *string `json:""filename""`
	MemoID   *int
}
type ResourcePatch struct {
	ID int `json:""-""`
	// Standard fields
	UpdatedTs *int64
	// Domain specific fields
	Filename *string `json:""filename""`
}
type ResourceDelete struct {
	ID int
}
",CWE-285,56.0,0
"package api
type Resource struct {
	ID int `json:""id""`
	// Standard fields
	CreatorID int   `json:""creatorId""`
	CreatedTs int64 `json:""createdTs""`
	UpdatedTs int64 `json:""updatedTs""`
	// Domain specific fields
	Filename string `json:""filename""`
	Blob     []byte `json:""-""`
	Type     string `json:""type""`
	Size     int64  `json:""size""`
	// Related fields
	LinkedMemoAmount int `json:""linkedMemoAmount""`
}
type ResourceCreate struct {
	// Standard fields
	CreatorID int `json:""-""`
	// Domain specific fields
	Filename string `json:""filename""`
	Blob     []byte `json:""blob""`
	Type     string `json:""type""`
	Size     int64  `json:""size""`
}
type ResourceFind struct {
	ID *int `json:""id""`
	// Standard fields
	CreatorID *int `json:""creatorId""`
	// Domain specific fields
	Filename *string `json:""filename""`
	MemoID   *int
}
type ResourcePatch struct {
	ID int `json:""-""`
	// Standard fields
	UpdatedTs *int64
	// Domain specific fields
	Filename *string `json:""filename""`
}
type ResourceDelete struct {
	ID int
}
",CWE-284,56.0,0
"package api
type Resource struct {
	ID int `json:""id""`
	// Standard fields
	CreatorID int   `json:""creatorId""`
	CreatedTs int64 `json:""createdTs""`
	UpdatedTs int64 `json:""updatedTs""`
	// Domain specific fields
	Filename string `json:""filename""`
	Blob     []byte `json:""-""`
	Type     string `json:""type""`
	Size     int64  `json:""size""`
	// Related fields
	LinkedMemoAmount int `json:""linkedMemoAmount""`
}
type ResourceCreate struct {
	// Standard fields
	CreatorID int `json:""-""`
	// Domain specific fields
	Filename string `json:""filename""`
	Blob     []byte `json:""blob""`
	Type     string `json:""type""`
	Size     int64  `json:""size""`
}
type ResourceFind struct {
	ID *int `json:""id""`
	// Standard fields
	CreatorID *int `json:""creatorId""`
	// Domain specific fields
	Filename *string `json:""filename""`
	MemoID   *int
}
type ResourcePatch struct {
	ID int `json:""-""`
	// Standard fields
	UpdatedTs *int64
	// Domain specific fields
	Filename *string `json:""filename""`
}
type ResourceDelete struct {
	ID int
}
",CWE-229,56.0,0
"package api
type Resource struct {
	ID int `json:""id""`
	// Standard fields
	CreatorID int   `json:""creatorId""`
	CreatedTs int64 `json:""createdTs""`
	UpdatedTs int64 `json:""updatedTs""`
	// Domain specific fields
	Filename string `json:""filename""`
	Blob     []byte `json:""-""`
	Type     string `json:""type""`
	Size     int64  `json:""size""`
	// Related fields
	LinkedMemoAmount int `json:""linkedMemoAmount""`
}
type ResourceCreate struct {
	// Standard fields
	CreatorID int `json:""-""`
	// Domain specific fields
	Filename string `json:""filename""`
	Blob     []byte `json:""blob""`
	Type     string `json:""type""`
	Size     int64  `json:""size""`
}
type ResourceFind struct {
	ID *int `json:""id""`
	// Standard fields
	CreatorID *int `json:""creatorId""`
	// Domain specific fields
	Filename *string `json:""filename""`
	MemoID   *int
}
type ResourcePatch struct {
	ID int `json:""-""`
	// Standard fields
	UpdatedTs *int64
	// Domain specific fields
	Filename *string `json:""filename""`
}
type ResourceDelete struct {
	ID int
}
",CWE-280,56.0,0
"package api
type Shortcut struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatorID int       `json:""creatorId""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Title   string `json:""title""`
	Payload string `json:""payload""`
}
type ShortcutCreate struct {
	// Standard fields
	CreatorID int `json:""-""`
	// Domain specific fields
	Title   string `json:""title""`
	Payload string `json:""payload""`
}
type ShortcutPatch struct {
	ID int `json:""-""`
	// Standard fields
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Title   *string `json:""title""`
	Payload *string `json:""payload""`
}
type ShortcutFind struct {
	ID *int
	// Standard fields
	CreatorID *int
	// Domain specific fields
	Title *string `json:""title""`
}
type ShortcutDelete struct {
	ID *int
	// Standard fields
	CreatorID *int
}
",CWE-648,54.0,0
"package api
type Shortcut struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatorID int       `json:""creatorId""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Title   string `json:""title""`
	Payload string `json:""payload""`
}
type ShortcutCreate struct {
	// Standard fields
	CreatorID int `json:""-""`
	// Domain specific fields
	Title   string `json:""title""`
	Payload string `json:""payload""`
}
type ShortcutPatch struct {
	ID int `json:""-""`
	// Standard fields
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Title   *string `json:""title""`
	Payload *string `json:""payload""`
}
type ShortcutFind struct {
	ID *int
	// Standard fields
	CreatorID *int
	// Domain specific fields
	Title *string `json:""title""`
}
type ShortcutDelete struct {
	ID *int
	// Standard fields
	CreatorID *int
}
",CWE-307,54.0,0
"package api
type Shortcut struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatorID int       `json:""creatorId""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Title   string `json:""title""`
	Payload string `json:""payload""`
}
type ShortcutCreate struct {
	// Standard fields
	CreatorID int `json:""-""`
	// Domain specific fields
	Title   string `json:""title""`
	Payload string `json:""payload""`
}
type ShortcutPatch struct {
	ID int `json:""-""`
	// Standard fields
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Title   *string `json:""title""`
	Payload *string `json:""payload""`
}
type ShortcutFind struct {
	ID *int
	// Standard fields
	CreatorID *int
	// Domain specific fields
	Title *string `json:""title""`
}
type ShortcutDelete struct {
	ID *int
	// Standard fields
	CreatorID *int
}
",CWE-639,54.0,0
"package api
type Shortcut struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatorID int       `json:""creatorId""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Title   string `json:""title""`
	Payload string `json:""payload""`
}
type ShortcutCreate struct {
	// Standard fields
	CreatorID int `json:""-""`
	// Domain specific fields
	Title   string `json:""title""`
	Payload string `json:""payload""`
}
type ShortcutPatch struct {
	ID int `json:""-""`
	// Standard fields
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Title   *string `json:""title""`
	Payload *string `json:""payload""`
}
type ShortcutFind struct {
	ID *int
	// Standard fields
	CreatorID *int
	// Domain specific fields
	Title *string `json:""title""`
}
type ShortcutDelete struct {
	ID *int
	// Standard fields
	CreatorID *int
}
",CWE-940,54.0,0
"package api
type Shortcut struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatorID int       `json:""creatorId""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Title   string `json:""title""`
	Payload string `json:""payload""`
}
type ShortcutCreate struct {
	// Standard fields
	CreatorID int `json:""-""`
	// Domain specific fields
	Title   string `json:""title""`
	Payload string `json:""payload""`
}
type ShortcutPatch struct {
	ID int `json:""-""`
	// Standard fields
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Title   *string `json:""title""`
	Payload *string `json:""payload""`
}
type ShortcutFind struct {
	ID *int
	// Standard fields
	CreatorID *int
	// Domain specific fields
	Title *string `json:""title""`
}
type ShortcutDelete struct {
	ID *int
	// Standard fields
	CreatorID *int
}
",CWE-1220,54.0,0
"package api
type Shortcut struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatorID int       `json:""creatorId""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Title   string `json:""title""`
	Payload string `json:""payload""`
}
type ShortcutCreate struct {
	// Standard fields
	CreatorID int `json:""-""`
	// Domain specific fields
	Title   string `json:""title""`
	Payload string `json:""payload""`
}
type ShortcutPatch struct {
	ID int `json:""-""`
	// Standard fields
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Title   *string `json:""title""`
	Payload *string `json:""payload""`
}
type ShortcutFind struct {
	ID *int
	// Standard fields
	CreatorID *int
	// Domain specific fields
	Title *string `json:""title""`
}
type ShortcutDelete struct {
	ID *int
	// Standard fields
	CreatorID *int
}
",CWE-285,54.0,0
"package api
type Shortcut struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatorID int       `json:""creatorId""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Title   string `json:""title""`
	Payload string `json:""payload""`
}
type ShortcutCreate struct {
	// Standard fields
	CreatorID int `json:""-""`
	// Domain specific fields
	Title   string `json:""title""`
	Payload string `json:""payload""`
}
type ShortcutPatch struct {
	ID int `json:""-""`
	// Standard fields
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Title   *string `json:""title""`
	Payload *string `json:""payload""`
}
type ShortcutFind struct {
	ID *int
	// Standard fields
	CreatorID *int
	// Domain specific fields
	Title *string `json:""title""`
}
type ShortcutDelete struct {
	ID *int
	// Standard fields
	CreatorID *int
}
",CWE-284,54.0,0
"package api
type Shortcut struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatorID int       `json:""creatorId""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Title   string `json:""title""`
	Payload string `json:""payload""`
}
type ShortcutCreate struct {
	// Standard fields
	CreatorID int `json:""-""`
	// Domain specific fields
	Title   string `json:""title""`
	Payload string `json:""payload""`
}
type ShortcutPatch struct {
	ID int `json:""-""`
	// Standard fields
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Title   *string `json:""title""`
	Payload *string `json:""payload""`
}
type ShortcutFind struct {
	ID *int
	// Standard fields
	CreatorID *int
	// Domain specific fields
	Title *string `json:""title""`
}
type ShortcutDelete struct {
	ID *int
	// Standard fields
	CreatorID *int
}
",CWE-229,54.0,0
"package api
type Shortcut struct {
	ID int `json:""id""`
	// Standard fields
	RowStatus RowStatus `json:""rowStatus""`
	CreatorID int       `json:""creatorId""`
	CreatedTs int64     `json:""createdTs""`
	UpdatedTs int64     `json:""updatedTs""`
	// Domain specific fields
	Title   string `json:""title""`
	Payload string `json:""payload""`
}
type ShortcutCreate struct {
	// Standard fields
	CreatorID int `json:""-""`
	// Domain specific fields
	Title   string `json:""title""`
	Payload string `json:""payload""`
}
type ShortcutPatch struct {
	ID int `json:""-""`
	// Standard fields
	UpdatedTs *int64
	RowStatus *RowStatus `json:""rowStatus""`
	// Domain specific fields
	Title   *string `json:""title""`
	Payload *string `json:""payload""`
}
type ShortcutFind struct {
	ID *int
	// Standard fields
	CreatorID *int
	// Domain specific fields
	Title *string `json:""title""`
}
type ShortcutDelete struct {
	ID *int
	// Standard fields
	CreatorID *int
}
",CWE-280,54.0,0
"package api
type Tag struct {
	Name      string
	CreatorID int
}
type TagUpsert struct {
	Name      string
	CreatorID int `json:""-""`
}
type TagFind struct {
	CreatorID int
}
type TagDelete struct {
	Name      string
	CreatorID int
}
",CWE-648,21.0,0
"package api
type Tag struct {
	Name      string
	CreatorID int
}
type TagUpsert struct {
	Name      string
	CreatorID int `json:""-""`
}
type TagFind struct {
	CreatorID int
}
type TagDelete struct {
	Name      string
	CreatorID int
}
",CWE-307,21.0,0
"package api
type Tag struct {
	Name      string
	CreatorID int
}
type TagUpsert struct {
	Name      string
	CreatorID int `json:""-""`
}
type TagFind struct {
	CreatorID int
}
type TagDelete struct {
	Name      string
	CreatorID int
}
",CWE-639,21.0,0
"package api
type Tag struct {
	Name      string
	CreatorID int
}
type TagUpsert struct {
	Name      string
	CreatorID int `json:""-""`
}
type TagFind struct {
	CreatorID int
}
type TagDelete struct {
	Name      string
	CreatorID int
}
",CWE-940,21.0,0
"package api
type Tag struct {
	Name      string
	CreatorID int
}
type TagUpsert struct {
	Name      string
	CreatorID int `json:""-""`
}
type TagFind struct {
	CreatorID int
}
type TagDelete struct {
	Name      string
	CreatorID int
}
",CWE-1220,21.0,0
"package api
type Tag struct {
	Name      string
	CreatorID int
}
type TagUpsert struct {
	Name      string
	CreatorID int `json:""-""`
}
type TagFind struct {
	CreatorID int
}
type TagDelete struct {
	Name      string
	CreatorID int
}
",CWE-285,21.0,0
"package api
type Tag struct {
	Name      string
	CreatorID int
}
type TagUpsert struct {
	Name      string
	CreatorID int `json:""-""`
}
type TagFind struct {
	CreatorID int
}
type TagDelete struct {
	Name      string
	CreatorID int
}
",CWE-284,21.0,0
"package api
type Tag struct {
	Name      string
	CreatorID int
}
type TagUpsert struct {
	Name      string
	CreatorID int `json:""-""`
}
type TagFind struct {
	CreatorID int
}
type TagDelete struct {
	Name      string
	CreatorID int
}
",CWE-229,21.0,0
"package api
type Tag struct {
	Name      string
	CreatorID int
}
type TagUpsert struct {
	Name      string
	CreatorID int `json:""-""`
}
type TagFind struct {
	CreatorID int
}
type TagDelete struct {
	Name      string
	CreatorID int
}
",CWE-280,21.0,0
"package api
import (
	""encoding/json""
	""fmt""
	""golang.org/x/exp/slices""
)
type UserSettingKey string
const (
	// UserSettingLocaleKey is the key type for user locale.
	UserSettingLocaleKey UserSettingKey = ""locale""
	// UserSettingAppearanceKey is the key type for user appearance.
	UserSettingAppearanceKey UserSettingKey = ""appearance""
	// UserSettingMemoVisibilityKey is the key type for user preference memo default visibility.
	UserSettingMemoVisibilityKey UserSettingKey = ""memoVisibility""
	// UserSettingMemoDisplayTsOptionKey is the key type for memo display ts option.
	UserSettingMemoDisplayTsOptionKey UserSettingKey = ""memoDisplayTsOption""
)
// String returns the string format of UserSettingKey type.
func (key UserSettingKey) String() string {
	switch key {
	case UserSettingLocaleKey:
		return ""locale""
	case UserSettingAppearanceKey:
		return ""appearance""
	case UserSettingMemoVisibilityKey:
		return ""memoVisibility""
	case UserSettingMemoDisplayTsOptionKey:
		return ""memoDisplayTsOption""
	}
	return """"
}
var (
	UserSettingLocaleValue                 = []string{""en"", ""zh"", ""vi"", ""fr"", ""nl"", ""sv"", ""de"", ""es"", ""uk""}
	UserSettingAppearanceValue             = []string{""system"", ""light"", ""dark""}
	UserSettingMemoVisibilityValue         = []Visibility{Private, Protected, Public}
	UserSettingMemoDisplayTsOptionKeyValue = []string{""created_ts"", ""updated_ts""}
)
type UserSetting struct {
	UserID int
	Key    UserSettingKey `json:""key""`
	// Value is a JSON string with basic value
	Value string `json:""value""`
}
type UserSettingUpsert struct {
	UserID int            `json:""-""`
	Key    UserSettingKey `json:""key""`
	Value  string         `json:""value""`
}
func (upsert UserSettingUpsert) Validate() error {
	if upsert.Key == UserSettingLocaleKey {
		localeValue := ""en""
		err := json.Unmarshal([]byte(upsert.Value), &localeValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting locale value"")
		}
		if !slices.Contains(UserSettingLocaleValue, localeValue) {
			return fmt.Errorf(""invalid user setting locale value"")
		}
	} else if upsert.Key == UserSettingAppearanceKey {
		appearanceValue := ""system""
		err := json.Unmarshal([]byte(upsert.Value), &appearanceValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting appearance value"")
		}
		if !slices.Contains(UserSettingAppearanceValue, appearanceValue) {
			return fmt.Errorf(""invalid user setting appearance value"")
		}
	} else if upsert.Key == UserSettingMemoVisibilityKey {
		memoVisibilityValue := Private
		err := json.Unmarshal([]byte(upsert.Value), &memoVisibilityValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting memo visibility value"")
		}
		if !slices.Contains(UserSettingMemoVisibilityValue, memoVisibilityValue) {
			return fmt.Errorf(""invalid user setting memo visibility value"")
		}
	} else if upsert.Key == UserSettingMemoDisplayTsOptionKey {
		memoDisplayTsOption := ""created_ts""
		err := json.Unmarshal([]byte(upsert.Value), &memoDisplayTsOption)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting memo display ts option"")
		}
		if !slices.Contains(UserSettingMemoDisplayTsOptionKeyValue, memoDisplayTsOption) {
			return fmt.Errorf(""invalid user setting memo display ts option value"")
		}
	} else {
		return fmt.Errorf(""invalid user setting key"")
	}
	return nil
}
type UserSettingFind struct {
	UserID int
	Key *UserSettingKey `json:""key""`
}
type UserSettingDelete struct {
	UserID int
}
",CWE-648,111.0,0
"package api
import (
	""encoding/json""
	""fmt""
	""golang.org/x/exp/slices""
)
type UserSettingKey string
const (
	// UserSettingLocaleKey is the key type for user locale.
	UserSettingLocaleKey UserSettingKey = ""locale""
	// UserSettingAppearanceKey is the key type for user appearance.
	UserSettingAppearanceKey UserSettingKey = ""appearance""
	// UserSettingMemoVisibilityKey is the key type for user preference memo default visibility.
	UserSettingMemoVisibilityKey UserSettingKey = ""memoVisibility""
	// UserSettingMemoDisplayTsOptionKey is the key type for memo display ts option.
	UserSettingMemoDisplayTsOptionKey UserSettingKey = ""memoDisplayTsOption""
)
// String returns the string format of UserSettingKey type.
func (key UserSettingKey) String() string {
	switch key {
	case UserSettingLocaleKey:
		return ""locale""
	case UserSettingAppearanceKey:
		return ""appearance""
	case UserSettingMemoVisibilityKey:
		return ""memoVisibility""
	case UserSettingMemoDisplayTsOptionKey:
		return ""memoDisplayTsOption""
	}
	return """"
}
var (
	UserSettingLocaleValue                 = []string{""en"", ""zh"", ""vi"", ""fr"", ""nl"", ""sv"", ""de"", ""es"", ""uk""}
	UserSettingAppearanceValue             = []string{""system"", ""light"", ""dark""}
	UserSettingMemoVisibilityValue         = []Visibility{Private, Protected, Public}
	UserSettingMemoDisplayTsOptionKeyValue = []string{""created_ts"", ""updated_ts""}
)
type UserSetting struct {
	UserID int
	Key    UserSettingKey `json:""key""`
	// Value is a JSON string with basic value
	Value string `json:""value""`
}
type UserSettingUpsert struct {
	UserID int            `json:""-""`
	Key    UserSettingKey `json:""key""`
	Value  string         `json:""value""`
}
func (upsert UserSettingUpsert) Validate() error {
	if upsert.Key == UserSettingLocaleKey {
		localeValue := ""en""
		err := json.Unmarshal([]byte(upsert.Value), &localeValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting locale value"")
		}
		if !slices.Contains(UserSettingLocaleValue, localeValue) {
			return fmt.Errorf(""invalid user setting locale value"")
		}
	} else if upsert.Key == UserSettingAppearanceKey {
		appearanceValue := ""system""
		err := json.Unmarshal([]byte(upsert.Value), &appearanceValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting appearance value"")
		}
		if !slices.Contains(UserSettingAppearanceValue, appearanceValue) {
			return fmt.Errorf(""invalid user setting appearance value"")
		}
	} else if upsert.Key == UserSettingMemoVisibilityKey {
		memoVisibilityValue := Private
		err := json.Unmarshal([]byte(upsert.Value), &memoVisibilityValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting memo visibility value"")
		}
		if !slices.Contains(UserSettingMemoVisibilityValue, memoVisibilityValue) {
			return fmt.Errorf(""invalid user setting memo visibility value"")
		}
	} else if upsert.Key == UserSettingMemoDisplayTsOptionKey {
		memoDisplayTsOption := ""created_ts""
		err := json.Unmarshal([]byte(upsert.Value), &memoDisplayTsOption)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting memo display ts option"")
		}
		if !slices.Contains(UserSettingMemoDisplayTsOptionKeyValue, memoDisplayTsOption) {
			return fmt.Errorf(""invalid user setting memo display ts option value"")
		}
	} else {
		return fmt.Errorf(""invalid user setting key"")
	}
	return nil
}
type UserSettingFind struct {
	UserID int
	Key *UserSettingKey `json:""key""`
}
type UserSettingDelete struct {
	UserID int
}
",CWE-307,111.0,0
"package api
import (
	""encoding/json""
	""fmt""
	""golang.org/x/exp/slices""
)
type UserSettingKey string
const (
	// UserSettingLocaleKey is the key type for user locale.
	UserSettingLocaleKey UserSettingKey = ""locale""
	// UserSettingAppearanceKey is the key type for user appearance.
	UserSettingAppearanceKey UserSettingKey = ""appearance""
	// UserSettingMemoVisibilityKey is the key type for user preference memo default visibility.
	UserSettingMemoVisibilityKey UserSettingKey = ""memoVisibility""
	// UserSettingMemoDisplayTsOptionKey is the key type for memo display ts option.
	UserSettingMemoDisplayTsOptionKey UserSettingKey = ""memoDisplayTsOption""
)
// String returns the string format of UserSettingKey type.
func (key UserSettingKey) String() string {
	switch key {
	case UserSettingLocaleKey:
		return ""locale""
	case UserSettingAppearanceKey:
		return ""appearance""
	case UserSettingMemoVisibilityKey:
		return ""memoVisibility""
	case UserSettingMemoDisplayTsOptionKey:
		return ""memoDisplayTsOption""
	}
	return """"
}
var (
	UserSettingLocaleValue                 = []string{""en"", ""zh"", ""vi"", ""fr"", ""nl"", ""sv"", ""de"", ""es"", ""uk""}
	UserSettingAppearanceValue             = []string{""system"", ""light"", ""dark""}
	UserSettingMemoVisibilityValue         = []Visibility{Private, Protected, Public}
	UserSettingMemoDisplayTsOptionKeyValue = []string{""created_ts"", ""updated_ts""}
)
type UserSetting struct {
	UserID int
	Key    UserSettingKey `json:""key""`
	// Value is a JSON string with basic value
	Value string `json:""value""`
}
type UserSettingUpsert struct {
	UserID int            `json:""-""`
	Key    UserSettingKey `json:""key""`
	Value  string         `json:""value""`
}
func (upsert UserSettingUpsert) Validate() error {
	if upsert.Key == UserSettingLocaleKey {
		localeValue := ""en""
		err := json.Unmarshal([]byte(upsert.Value), &localeValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting locale value"")
		}
		if !slices.Contains(UserSettingLocaleValue, localeValue) {
			return fmt.Errorf(""invalid user setting locale value"")
		}
	} else if upsert.Key == UserSettingAppearanceKey {
		appearanceValue := ""system""
		err := json.Unmarshal([]byte(upsert.Value), &appearanceValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting appearance value"")
		}
		if !slices.Contains(UserSettingAppearanceValue, appearanceValue) {
			return fmt.Errorf(""invalid user setting appearance value"")
		}
	} else if upsert.Key == UserSettingMemoVisibilityKey {
		memoVisibilityValue := Private
		err := json.Unmarshal([]byte(upsert.Value), &memoVisibilityValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting memo visibility value"")
		}
		if !slices.Contains(UserSettingMemoVisibilityValue, memoVisibilityValue) {
			return fmt.Errorf(""invalid user setting memo visibility value"")
		}
	} else if upsert.Key == UserSettingMemoDisplayTsOptionKey {
		memoDisplayTsOption := ""created_ts""
		err := json.Unmarshal([]byte(upsert.Value), &memoDisplayTsOption)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting memo display ts option"")
		}
		if !slices.Contains(UserSettingMemoDisplayTsOptionKeyValue, memoDisplayTsOption) {
			return fmt.Errorf(""invalid user setting memo display ts option value"")
		}
	} else {
		return fmt.Errorf(""invalid user setting key"")
	}
	return nil
}
type UserSettingFind struct {
	UserID int
	Key *UserSettingKey `json:""key""`
}
type UserSettingDelete struct {
	UserID int
}
",CWE-639,111.0,0
"package api
import (
	""encoding/json""
	""fmt""
	""golang.org/x/exp/slices""
)
type UserSettingKey string
const (
	// UserSettingLocaleKey is the key type for user locale.
	UserSettingLocaleKey UserSettingKey = ""locale""
	// UserSettingAppearanceKey is the key type for user appearance.
	UserSettingAppearanceKey UserSettingKey = ""appearance""
	// UserSettingMemoVisibilityKey is the key type for user preference memo default visibility.
	UserSettingMemoVisibilityKey UserSettingKey = ""memoVisibility""
	// UserSettingMemoDisplayTsOptionKey is the key type for memo display ts option.
	UserSettingMemoDisplayTsOptionKey UserSettingKey = ""memoDisplayTsOption""
)
// String returns the string format of UserSettingKey type.
func (key UserSettingKey) String() string {
	switch key {
	case UserSettingLocaleKey:
		return ""locale""
	case UserSettingAppearanceKey:
		return ""appearance""
	case UserSettingMemoVisibilityKey:
		return ""memoVisibility""
	case UserSettingMemoDisplayTsOptionKey:
		return ""memoDisplayTsOption""
	}
	return """"
}
var (
	UserSettingLocaleValue                 = []string{""en"", ""zh"", ""vi"", ""fr"", ""nl"", ""sv"", ""de"", ""es"", ""uk""}
	UserSettingAppearanceValue             = []string{""system"", ""light"", ""dark""}
	UserSettingMemoVisibilityValue         = []Visibility{Private, Protected, Public}
	UserSettingMemoDisplayTsOptionKeyValue = []string{""created_ts"", ""updated_ts""}
)
type UserSetting struct {
	UserID int
	Key    UserSettingKey `json:""key""`
	// Value is a JSON string with basic value
	Value string `json:""value""`
}
type UserSettingUpsert struct {
	UserID int            `json:""-""`
	Key    UserSettingKey `json:""key""`
	Value  string         `json:""value""`
}
func (upsert UserSettingUpsert) Validate() error {
	if upsert.Key == UserSettingLocaleKey {
		localeValue := ""en""
		err := json.Unmarshal([]byte(upsert.Value), &localeValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting locale value"")
		}
		if !slices.Contains(UserSettingLocaleValue, localeValue) {
			return fmt.Errorf(""invalid user setting locale value"")
		}
	} else if upsert.Key == UserSettingAppearanceKey {
		appearanceValue := ""system""
		err := json.Unmarshal([]byte(upsert.Value), &appearanceValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting appearance value"")
		}
		if !slices.Contains(UserSettingAppearanceValue, appearanceValue) {
			return fmt.Errorf(""invalid user setting appearance value"")
		}
	} else if upsert.Key == UserSettingMemoVisibilityKey {
		memoVisibilityValue := Private
		err := json.Unmarshal([]byte(upsert.Value), &memoVisibilityValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting memo visibility value"")
		}
		if !slices.Contains(UserSettingMemoVisibilityValue, memoVisibilityValue) {
			return fmt.Errorf(""invalid user setting memo visibility value"")
		}
	} else if upsert.Key == UserSettingMemoDisplayTsOptionKey {
		memoDisplayTsOption := ""created_ts""
		err := json.Unmarshal([]byte(upsert.Value), &memoDisplayTsOption)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting memo display ts option"")
		}
		if !slices.Contains(UserSettingMemoDisplayTsOptionKeyValue, memoDisplayTsOption) {
			return fmt.Errorf(""invalid user setting memo display ts option value"")
		}
	} else {
		return fmt.Errorf(""invalid user setting key"")
	}
	return nil
}
type UserSettingFind struct {
	UserID int
	Key *UserSettingKey `json:""key""`
}
type UserSettingDelete struct {
	UserID int
}
",CWE-940,111.0,0
"package api
import (
	""encoding/json""
	""fmt""
	""golang.org/x/exp/slices""
)
type UserSettingKey string
const (
	// UserSettingLocaleKey is the key type for user locale.
	UserSettingLocaleKey UserSettingKey = ""locale""
	// UserSettingAppearanceKey is the key type for user appearance.
	UserSettingAppearanceKey UserSettingKey = ""appearance""
	// UserSettingMemoVisibilityKey is the key type for user preference memo default visibility.
	UserSettingMemoVisibilityKey UserSettingKey = ""memoVisibility""
	// UserSettingMemoDisplayTsOptionKey is the key type for memo display ts option.
	UserSettingMemoDisplayTsOptionKey UserSettingKey = ""memoDisplayTsOption""
)
// String returns the string format of UserSettingKey type.
func (key UserSettingKey) String() string {
	switch key {
	case UserSettingLocaleKey:
		return ""locale""
	case UserSettingAppearanceKey:
		return ""appearance""
	case UserSettingMemoVisibilityKey:
		return ""memoVisibility""
	case UserSettingMemoDisplayTsOptionKey:
		return ""memoDisplayTsOption""
	}
	return """"
}
var (
	UserSettingLocaleValue                 = []string{""en"", ""zh"", ""vi"", ""fr"", ""nl"", ""sv"", ""de"", ""es"", ""uk""}
	UserSettingAppearanceValue             = []string{""system"", ""light"", ""dark""}
	UserSettingMemoVisibilityValue         = []Visibility{Private, Protected, Public}
	UserSettingMemoDisplayTsOptionKeyValue = []string{""created_ts"", ""updated_ts""}
)
type UserSetting struct {
	UserID int
	Key    UserSettingKey `json:""key""`
	// Value is a JSON string with basic value
	Value string `json:""value""`
}
type UserSettingUpsert struct {
	UserID int            `json:""-""`
	Key    UserSettingKey `json:""key""`
	Value  string         `json:""value""`
}
func (upsert UserSettingUpsert) Validate() error {
	if upsert.Key == UserSettingLocaleKey {
		localeValue := ""en""
		err := json.Unmarshal([]byte(upsert.Value), &localeValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting locale value"")
		}
		if !slices.Contains(UserSettingLocaleValue, localeValue) {
			return fmt.Errorf(""invalid user setting locale value"")
		}
	} else if upsert.Key == UserSettingAppearanceKey {
		appearanceValue := ""system""
		err := json.Unmarshal([]byte(upsert.Value), &appearanceValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting appearance value"")
		}
		if !slices.Contains(UserSettingAppearanceValue, appearanceValue) {
			return fmt.Errorf(""invalid user setting appearance value"")
		}
	} else if upsert.Key == UserSettingMemoVisibilityKey {
		memoVisibilityValue := Private
		err := json.Unmarshal([]byte(upsert.Value), &memoVisibilityValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting memo visibility value"")
		}
		if !slices.Contains(UserSettingMemoVisibilityValue, memoVisibilityValue) {
			return fmt.Errorf(""invalid user setting memo visibility value"")
		}
	} else if upsert.Key == UserSettingMemoDisplayTsOptionKey {
		memoDisplayTsOption := ""created_ts""
		err := json.Unmarshal([]byte(upsert.Value), &memoDisplayTsOption)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting memo display ts option"")
		}
		if !slices.Contains(UserSettingMemoDisplayTsOptionKeyValue, memoDisplayTsOption) {
			return fmt.Errorf(""invalid user setting memo display ts option value"")
		}
	} else {
		return fmt.Errorf(""invalid user setting key"")
	}
	return nil
}
type UserSettingFind struct {
	UserID int
	Key *UserSettingKey `json:""key""`
}
type UserSettingDelete struct {
	UserID int
}
",CWE-1220,111.0,0
"package api
import (
	""encoding/json""
	""fmt""
	""golang.org/x/exp/slices""
)
type UserSettingKey string
const (
	// UserSettingLocaleKey is the key type for user locale.
	UserSettingLocaleKey UserSettingKey = ""locale""
	// UserSettingAppearanceKey is the key type for user appearance.
	UserSettingAppearanceKey UserSettingKey = ""appearance""
	// UserSettingMemoVisibilityKey is the key type for user preference memo default visibility.
	UserSettingMemoVisibilityKey UserSettingKey = ""memoVisibility""
	// UserSettingMemoDisplayTsOptionKey is the key type for memo display ts option.
	UserSettingMemoDisplayTsOptionKey UserSettingKey = ""memoDisplayTsOption""
)
// String returns the string format of UserSettingKey type.
func (key UserSettingKey) String() string {
	switch key {
	case UserSettingLocaleKey:
		return ""locale""
	case UserSettingAppearanceKey:
		return ""appearance""
	case UserSettingMemoVisibilityKey:
		return ""memoVisibility""
	case UserSettingMemoDisplayTsOptionKey:
		return ""memoDisplayTsOption""
	}
	return """"
}
var (
	UserSettingLocaleValue                 = []string{""en"", ""zh"", ""vi"", ""fr"", ""nl"", ""sv"", ""de"", ""es"", ""uk""}
	UserSettingAppearanceValue             = []string{""system"", ""light"", ""dark""}
	UserSettingMemoVisibilityValue         = []Visibility{Private, Protected, Public}
	UserSettingMemoDisplayTsOptionKeyValue = []string{""created_ts"", ""updated_ts""}
)
type UserSetting struct {
	UserID int
	Key    UserSettingKey `json:""key""`
	// Value is a JSON string with basic value
	Value string `json:""value""`
}
type UserSettingUpsert struct {
	UserID int            `json:""-""`
	Key    UserSettingKey `json:""key""`
	Value  string         `json:""value""`
}
func (upsert UserSettingUpsert) Validate() error {
	if upsert.Key == UserSettingLocaleKey {
		localeValue := ""en""
		err := json.Unmarshal([]byte(upsert.Value), &localeValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting locale value"")
		}
		if !slices.Contains(UserSettingLocaleValue, localeValue) {
			return fmt.Errorf(""invalid user setting locale value"")
		}
	} else if upsert.Key == UserSettingAppearanceKey {
		appearanceValue := ""system""
		err := json.Unmarshal([]byte(upsert.Value), &appearanceValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting appearance value"")
		}
		if !slices.Contains(UserSettingAppearanceValue, appearanceValue) {
			return fmt.Errorf(""invalid user setting appearance value"")
		}
	} else if upsert.Key == UserSettingMemoVisibilityKey {
		memoVisibilityValue := Private
		err := json.Unmarshal([]byte(upsert.Value), &memoVisibilityValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting memo visibility value"")
		}
		if !slices.Contains(UserSettingMemoVisibilityValue, memoVisibilityValue) {
			return fmt.Errorf(""invalid user setting memo visibility value"")
		}
	} else if upsert.Key == UserSettingMemoDisplayTsOptionKey {
		memoDisplayTsOption := ""created_ts""
		err := json.Unmarshal([]byte(upsert.Value), &memoDisplayTsOption)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting memo display ts option"")
		}
		if !slices.Contains(UserSettingMemoDisplayTsOptionKeyValue, memoDisplayTsOption) {
			return fmt.Errorf(""invalid user setting memo display ts option value"")
		}
	} else {
		return fmt.Errorf(""invalid user setting key"")
	}
	return nil
}
type UserSettingFind struct {
	UserID int
	Key *UserSettingKey `json:""key""`
}
type UserSettingDelete struct {
	UserID int
}
",CWE-285,111.0,0
"package api
import (
	""encoding/json""
	""fmt""
	""golang.org/x/exp/slices""
)
type UserSettingKey string
const (
	// UserSettingLocaleKey is the key type for user locale.
	UserSettingLocaleKey UserSettingKey = ""locale""
	// UserSettingAppearanceKey is the key type for user appearance.
	UserSettingAppearanceKey UserSettingKey = ""appearance""
	// UserSettingMemoVisibilityKey is the key type for user preference memo default visibility.
	UserSettingMemoVisibilityKey UserSettingKey = ""memoVisibility""
	// UserSettingMemoDisplayTsOptionKey is the key type for memo display ts option.
	UserSettingMemoDisplayTsOptionKey UserSettingKey = ""memoDisplayTsOption""
)
// String returns the string format of UserSettingKey type.
func (key UserSettingKey) String() string {
	switch key {
	case UserSettingLocaleKey:
		return ""locale""
	case UserSettingAppearanceKey:
		return ""appearance""
	case UserSettingMemoVisibilityKey:
		return ""memoVisibility""
	case UserSettingMemoDisplayTsOptionKey:
		return ""memoDisplayTsOption""
	}
	return """"
}
var (
	UserSettingLocaleValue                 = []string{""en"", ""zh"", ""vi"", ""fr"", ""nl"", ""sv"", ""de"", ""es"", ""uk""}
	UserSettingAppearanceValue             = []string{""system"", ""light"", ""dark""}
	UserSettingMemoVisibilityValue         = []Visibility{Private, Protected, Public}
	UserSettingMemoDisplayTsOptionKeyValue = []string{""created_ts"", ""updated_ts""}
)
type UserSetting struct {
	UserID int
	Key    UserSettingKey `json:""key""`
	// Value is a JSON string with basic value
	Value string `json:""value""`
}
type UserSettingUpsert struct {
	UserID int            `json:""-""`
	Key    UserSettingKey `json:""key""`
	Value  string         `json:""value""`
}
func (upsert UserSettingUpsert) Validate() error {
	if upsert.Key == UserSettingLocaleKey {
		localeValue := ""en""
		err := json.Unmarshal([]byte(upsert.Value), &localeValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting locale value"")
		}
		if !slices.Contains(UserSettingLocaleValue, localeValue) {
			return fmt.Errorf(""invalid user setting locale value"")
		}
	} else if upsert.Key == UserSettingAppearanceKey {
		appearanceValue := ""system""
		err := json.Unmarshal([]byte(upsert.Value), &appearanceValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting appearance value"")
		}
		if !slices.Contains(UserSettingAppearanceValue, appearanceValue) {
			return fmt.Errorf(""invalid user setting appearance value"")
		}
	} else if upsert.Key == UserSettingMemoVisibilityKey {
		memoVisibilityValue := Private
		err := json.Unmarshal([]byte(upsert.Value), &memoVisibilityValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting memo visibility value"")
		}
		if !slices.Contains(UserSettingMemoVisibilityValue, memoVisibilityValue) {
			return fmt.Errorf(""invalid user setting memo visibility value"")
		}
	} else if upsert.Key == UserSettingMemoDisplayTsOptionKey {
		memoDisplayTsOption := ""created_ts""
		err := json.Unmarshal([]byte(upsert.Value), &memoDisplayTsOption)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting memo display ts option"")
		}
		if !slices.Contains(UserSettingMemoDisplayTsOptionKeyValue, memoDisplayTsOption) {
			return fmt.Errorf(""invalid user setting memo display ts option value"")
		}
	} else {
		return fmt.Errorf(""invalid user setting key"")
	}
	return nil
}
type UserSettingFind struct {
	UserID int
	Key *UserSettingKey `json:""key""`
}
type UserSettingDelete struct {
	UserID int
}
",CWE-284,111.0,0
"package api
import (
	""encoding/json""
	""fmt""
	""golang.org/x/exp/slices""
)
type UserSettingKey string
const (
	// UserSettingLocaleKey is the key type for user locale.
	UserSettingLocaleKey UserSettingKey = ""locale""
	// UserSettingAppearanceKey is the key type for user appearance.
	UserSettingAppearanceKey UserSettingKey = ""appearance""
	// UserSettingMemoVisibilityKey is the key type for user preference memo default visibility.
	UserSettingMemoVisibilityKey UserSettingKey = ""memoVisibility""
	// UserSettingMemoDisplayTsOptionKey is the key type for memo display ts option.
	UserSettingMemoDisplayTsOptionKey UserSettingKey = ""memoDisplayTsOption""
)
// String returns the string format of UserSettingKey type.
func (key UserSettingKey) String() string {
	switch key {
	case UserSettingLocaleKey:
		return ""locale""
	case UserSettingAppearanceKey:
		return ""appearance""
	case UserSettingMemoVisibilityKey:
		return ""memoVisibility""
	case UserSettingMemoDisplayTsOptionKey:
		return ""memoDisplayTsOption""
	}
	return """"
}
var (
	UserSettingLocaleValue                 = []string{""en"", ""zh"", ""vi"", ""fr"", ""nl"", ""sv"", ""de"", ""es"", ""uk""}
	UserSettingAppearanceValue             = []string{""system"", ""light"", ""dark""}
	UserSettingMemoVisibilityValue         = []Visibility{Private, Protected, Public}
	UserSettingMemoDisplayTsOptionKeyValue = []string{""created_ts"", ""updated_ts""}
)
type UserSetting struct {
	UserID int
	Key    UserSettingKey `json:""key""`
	// Value is a JSON string with basic value
	Value string `json:""value""`
}
type UserSettingUpsert struct {
	UserID int            `json:""-""`
	Key    UserSettingKey `json:""key""`
	Value  string         `json:""value""`
}
func (upsert UserSettingUpsert) Validate() error {
	if upsert.Key == UserSettingLocaleKey {
		localeValue := ""en""
		err := json.Unmarshal([]byte(upsert.Value), &localeValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting locale value"")
		}
		if !slices.Contains(UserSettingLocaleValue, localeValue) {
			return fmt.Errorf(""invalid user setting locale value"")
		}
	} else if upsert.Key == UserSettingAppearanceKey {
		appearanceValue := ""system""
		err := json.Unmarshal([]byte(upsert.Value), &appearanceValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting appearance value"")
		}
		if !slices.Contains(UserSettingAppearanceValue, appearanceValue) {
			return fmt.Errorf(""invalid user setting appearance value"")
		}
	} else if upsert.Key == UserSettingMemoVisibilityKey {
		memoVisibilityValue := Private
		err := json.Unmarshal([]byte(upsert.Value), &memoVisibilityValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting memo visibility value"")
		}
		if !slices.Contains(UserSettingMemoVisibilityValue, memoVisibilityValue) {
			return fmt.Errorf(""invalid user setting memo visibility value"")
		}
	} else if upsert.Key == UserSettingMemoDisplayTsOptionKey {
		memoDisplayTsOption := ""created_ts""
		err := json.Unmarshal([]byte(upsert.Value), &memoDisplayTsOption)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting memo display ts option"")
		}
		if !slices.Contains(UserSettingMemoDisplayTsOptionKeyValue, memoDisplayTsOption) {
			return fmt.Errorf(""invalid user setting memo display ts option value"")
		}
	} else {
		return fmt.Errorf(""invalid user setting key"")
	}
	return nil
}
type UserSettingFind struct {
	UserID int
	Key *UserSettingKey `json:""key""`
}
type UserSettingDelete struct {
	UserID int
}
",CWE-229,111.0,0
"package api
import (
	""encoding/json""
	""fmt""
	""golang.org/x/exp/slices""
)
type UserSettingKey string
const (
	// UserSettingLocaleKey is the key type for user locale.
	UserSettingLocaleKey UserSettingKey = ""locale""
	// UserSettingAppearanceKey is the key type for user appearance.
	UserSettingAppearanceKey UserSettingKey = ""appearance""
	// UserSettingMemoVisibilityKey is the key type for user preference memo default visibility.
	UserSettingMemoVisibilityKey UserSettingKey = ""memoVisibility""
	// UserSettingMemoDisplayTsOptionKey is the key type for memo display ts option.
	UserSettingMemoDisplayTsOptionKey UserSettingKey = ""memoDisplayTsOption""
)
// String returns the string format of UserSettingKey type.
func (key UserSettingKey) String() string {
	switch key {
	case UserSettingLocaleKey:
		return ""locale""
	case UserSettingAppearanceKey:
		return ""appearance""
	case UserSettingMemoVisibilityKey:
		return ""memoVisibility""
	case UserSettingMemoDisplayTsOptionKey:
		return ""memoDisplayTsOption""
	}
	return """"
}
var (
	UserSettingLocaleValue                 = []string{""en"", ""zh"", ""vi"", ""fr"", ""nl"", ""sv"", ""de"", ""es"", ""uk""}
	UserSettingAppearanceValue             = []string{""system"", ""light"", ""dark""}
	UserSettingMemoVisibilityValue         = []Visibility{Private, Protected, Public}
	UserSettingMemoDisplayTsOptionKeyValue = []string{""created_ts"", ""updated_ts""}
)
type UserSetting struct {
	UserID int
	Key    UserSettingKey `json:""key""`
	// Value is a JSON string with basic value
	Value string `json:""value""`
}
type UserSettingUpsert struct {
	UserID int            `json:""-""`
	Key    UserSettingKey `json:""key""`
	Value  string         `json:""value""`
}
func (upsert UserSettingUpsert) Validate() error {
	if upsert.Key == UserSettingLocaleKey {
		localeValue := ""en""
		err := json.Unmarshal([]byte(upsert.Value), &localeValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting locale value"")
		}
		if !slices.Contains(UserSettingLocaleValue, localeValue) {
			return fmt.Errorf(""invalid user setting locale value"")
		}
	} else if upsert.Key == UserSettingAppearanceKey {
		appearanceValue := ""system""
		err := json.Unmarshal([]byte(upsert.Value), &appearanceValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting appearance value"")
		}
		if !slices.Contains(UserSettingAppearanceValue, appearanceValue) {
			return fmt.Errorf(""invalid user setting appearance value"")
		}
	} else if upsert.Key == UserSettingMemoVisibilityKey {
		memoVisibilityValue := Private
		err := json.Unmarshal([]byte(upsert.Value), &memoVisibilityValue)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting memo visibility value"")
		}
		if !slices.Contains(UserSettingMemoVisibilityValue, memoVisibilityValue) {
			return fmt.Errorf(""invalid user setting memo visibility value"")
		}
	} else if upsert.Key == UserSettingMemoDisplayTsOptionKey {
		memoDisplayTsOption := ""created_ts""
		err := json.Unmarshal([]byte(upsert.Value), &memoDisplayTsOption)
		if err != nil {
			return fmt.Errorf(""failed to unmarshal user setting memo display ts option"")
		}
		if !slices.Contains(UserSettingMemoDisplayTsOptionKeyValue, memoDisplayTsOption) {
			return fmt.Errorf(""invalid user setting memo display ts option value"")
		}
	} else {
		return fmt.Errorf(""invalid user setting key"")
	}
	return nil
}
type UserSettingFind struct {
	UserID int
	Key *UserSettingKey `json:""key""`
}
type UserSettingDelete struct {
	UserID int
}
",CWE-280,111.0,0
"package server
import (
	""encoding/json""
	""fmt""
	""net/http""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
	""golang.org/x/crypto/bcrypt""
)
func (s *Server) registerAuthRoutes(g *echo.Group) {
	g.POST(""/auth/signin"", func(c echo.Context) error {
		ctx := c.Request().Context()
		signin := &api.Signin{}
		if err := json.NewDecoder(c.Request().Body).Decode(signin); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted signin request"").SetInternal(err)
		}
		userFind := &api.UserFind{
			Username: &signin.Username,
		}
		user, err := s.Store.FindUser(ctx, userFind)
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to find user by username %s"", signin.Username)).SetInternal(err)
		}
		if user == nil {
			return echo.NewHTTPError(http.StatusUnauthorized, fmt.Sprintf(""User not found with username %s"", signin.Username))
		} else if user.RowStatus == api.Archived {
			return echo.NewHTTPError(http.StatusForbidden, fmt.Sprintf(""User has been archived with username %s"", signin.Username))
		}
		// Compare the stored hashed password, with the hashed version of the password that was received.
		if err := bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(signin.Password)); err != nil {
			// If the two passwords don't match, return a 401 status.
			return echo.NewHTTPError(http.StatusUnauthorized, ""Incorrect password"").SetInternal(err)
		}
		if err = setUserSession(c, user); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to set signin session"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""user signed in"",
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(user)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode user response"").SetInternal(err)
		}
		return nil
	})
	g.POST(""/auth/logout"", func(c echo.Context) error {
		ctx := c.Request().Context()
		err := removeUserSession(c)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to set logout session"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""user logout"",
		})
		c.Response().WriteHeader(http.StatusOK)
		return nil
	})
	g.POST(""/auth/signup"", func(c echo.Context) error {
		ctx := c.Request().Context()
		signup := &api.Signup{}
		if err := json.NewDecoder(c.Request().Body).Decode(signup); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted signup request"").SetInternal(err)
		}
		hostUserType := api.Host
		hostUserFind := api.UserFind{
			Role: &hostUserType,
		}
		hostUser, err := s.Store.FindUser(ctx, &hostUserFind)
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find host user"").SetInternal(err)
		}
		if signup.Role == api.Host && hostUser != nil {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Site Host existed, please contact the site host to signin account firstly"").SetInternal(err)
		}
		systemSettingAllowSignUpName := api.SystemSettingAllowSignUpName
		allowSignUpSetting, err := s.Store.FindSystemSetting(ctx, &api.SystemSettingFind{
			Name: &systemSettingAllowSignUpName,
		})
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find system setting"").SetInternal(err)
		}
		allowSignUpSettingValue := false
		if allowSignUpSetting != nil {
			err = json.Unmarshal([]byte(allowSignUpSetting.Value), &allowSignUpSettingValue)
			if err != nil {
				return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to unmarshal system setting allow signup"").SetInternal(err)
			}
		}
		if !allowSignUpSettingValue && hostUser != nil {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Site Host existed, please contact the site host to signin account firstly"").SetInternal(err)
		}
		userCreate := &api.UserCreate{
			Username: signup.Username,
			Role:     api.Role(signup.Role),
			Nickname: signup.Username,
			Password: signup.Password,
			OpenID:   common.GenUUID(),
		}
		if err := userCreate.Validate(); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Invalid user create format"").SetInternal(err)
		}
		passwordHash, err := bcrypt.GenerateFromPassword([]byte(signup.Password), bcrypt.DefaultCost)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to generate password hash"").SetInternal(err)
		}
		userCreate.PasswordHash = string(passwordHash)
		user, err := s.Store.CreateUser(ctx, userCreate)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to create user"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""user signed up"",
		})
		err = setUserSession(c, user)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to set signup session"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(user)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode created user response"").SetInternal(err)
		}
		return nil
	})
}
",CWE-648,147.0,0
"package server
import (
	""encoding/json""
	""fmt""
	""net/http""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
	""golang.org/x/crypto/bcrypt""
)
func (s *Server) registerAuthRoutes(g *echo.Group) {
	g.POST(""/auth/signin"", func(c echo.Context) error {
		ctx := c.Request().Context()
		signin := &api.Signin{}
		if err := json.NewDecoder(c.Request().Body).Decode(signin); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted signin request"").SetInternal(err)
		}
		userFind := &api.UserFind{
			Username: &signin.Username,
		}
		user, err := s.Store.FindUser(ctx, userFind)
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to find user by username %s"", signin.Username)).SetInternal(err)
		}
		if user == nil {
			return echo.NewHTTPError(http.StatusUnauthorized, fmt.Sprintf(""User not found with username %s"", signin.Username))
		} else if user.RowStatus == api.Archived {
			return echo.NewHTTPError(http.StatusForbidden, fmt.Sprintf(""User has been archived with username %s"", signin.Username))
		}
		// Compare the stored hashed password, with the hashed version of the password that was received.
		if err := bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(signin.Password)); err != nil {
			// If the two passwords don't match, return a 401 status.
			return echo.NewHTTPError(http.StatusUnauthorized, ""Incorrect password"").SetInternal(err)
		}
		if err = setUserSession(c, user); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to set signin session"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""user signed in"",
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(user)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode user response"").SetInternal(err)
		}
		return nil
	})
	g.POST(""/auth/logout"", func(c echo.Context) error {
		ctx := c.Request().Context()
		err := removeUserSession(c)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to set logout session"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""user logout"",
		})
		c.Response().WriteHeader(http.StatusOK)
		return nil
	})
	g.POST(""/auth/signup"", func(c echo.Context) error {
		ctx := c.Request().Context()
		signup := &api.Signup{}
		if err := json.NewDecoder(c.Request().Body).Decode(signup); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted signup request"").SetInternal(err)
		}
		hostUserType := api.Host
		hostUserFind := api.UserFind{
			Role: &hostUserType,
		}
		hostUser, err := s.Store.FindUser(ctx, &hostUserFind)
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find host user"").SetInternal(err)
		}
		if signup.Role == api.Host && hostUser != nil {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Site Host existed, please contact the site host to signin account firstly"").SetInternal(err)
		}
		systemSettingAllowSignUpName := api.SystemSettingAllowSignUpName
		allowSignUpSetting, err := s.Store.FindSystemSetting(ctx, &api.SystemSettingFind{
			Name: &systemSettingAllowSignUpName,
		})
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find system setting"").SetInternal(err)
		}
		allowSignUpSettingValue := false
		if allowSignUpSetting != nil {
			err = json.Unmarshal([]byte(allowSignUpSetting.Value), &allowSignUpSettingValue)
			if err != nil {
				return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to unmarshal system setting allow signup"").SetInternal(err)
			}
		}
		if !allowSignUpSettingValue && hostUser != nil {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Site Host existed, please contact the site host to signin account firstly"").SetInternal(err)
		}
		userCreate := &api.UserCreate{
			Username: signup.Username,
			Role:     api.Role(signup.Role),
			Nickname: signup.Username,
			Password: signup.Password,
			OpenID:   common.GenUUID(),
		}
		if err := userCreate.Validate(); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Invalid user create format"").SetInternal(err)
		}
		passwordHash, err := bcrypt.GenerateFromPassword([]byte(signup.Password), bcrypt.DefaultCost)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to generate password hash"").SetInternal(err)
		}
		userCreate.PasswordHash = string(passwordHash)
		user, err := s.Store.CreateUser(ctx, userCreate)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to create user"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""user signed up"",
		})
		err = setUserSession(c, user)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to set signup session"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(user)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode created user response"").SetInternal(err)
		}
		return nil
	})
}
",CWE-307,147.0,0
"package server
import (
	""encoding/json""
	""fmt""
	""net/http""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
	""golang.org/x/crypto/bcrypt""
)
func (s *Server) registerAuthRoutes(g *echo.Group) {
	g.POST(""/auth/signin"", func(c echo.Context) error {
		ctx := c.Request().Context()
		signin := &api.Signin{}
		if err := json.NewDecoder(c.Request().Body).Decode(signin); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted signin request"").SetInternal(err)
		}
		userFind := &api.UserFind{
			Username: &signin.Username,
		}
		user, err := s.Store.FindUser(ctx, userFind)
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to find user by username %s"", signin.Username)).SetInternal(err)
		}
		if user == nil {
			return echo.NewHTTPError(http.StatusUnauthorized, fmt.Sprintf(""User not found with username %s"", signin.Username))
		} else if user.RowStatus == api.Archived {
			return echo.NewHTTPError(http.StatusForbidden, fmt.Sprintf(""User has been archived with username %s"", signin.Username))
		}
		// Compare the stored hashed password, with the hashed version of the password that was received.
		if err := bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(signin.Password)); err != nil {
			// If the two passwords don't match, return a 401 status.
			return echo.NewHTTPError(http.StatusUnauthorized, ""Incorrect password"").SetInternal(err)
		}
		if err = setUserSession(c, user); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to set signin session"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""user signed in"",
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(user)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode user response"").SetInternal(err)
		}
		return nil
	})
	g.POST(""/auth/logout"", func(c echo.Context) error {
		ctx := c.Request().Context()
		err := removeUserSession(c)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to set logout session"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""user logout"",
		})
		c.Response().WriteHeader(http.StatusOK)
		return nil
	})
	g.POST(""/auth/signup"", func(c echo.Context) error {
		ctx := c.Request().Context()
		signup := &api.Signup{}
		if err := json.NewDecoder(c.Request().Body).Decode(signup); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted signup request"").SetInternal(err)
		}
		hostUserType := api.Host
		hostUserFind := api.UserFind{
			Role: &hostUserType,
		}
		hostUser, err := s.Store.FindUser(ctx, &hostUserFind)
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find host user"").SetInternal(err)
		}
		if signup.Role == api.Host && hostUser != nil {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Site Host existed, please contact the site host to signin account firstly"").SetInternal(err)
		}
		systemSettingAllowSignUpName := api.SystemSettingAllowSignUpName
		allowSignUpSetting, err := s.Store.FindSystemSetting(ctx, &api.SystemSettingFind{
			Name: &systemSettingAllowSignUpName,
		})
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find system setting"").SetInternal(err)
		}
		allowSignUpSettingValue := false
		if allowSignUpSetting != nil {
			err = json.Unmarshal([]byte(allowSignUpSetting.Value), &allowSignUpSettingValue)
			if err != nil {
				return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to unmarshal system setting allow signup"").SetInternal(err)
			}
		}
		if !allowSignUpSettingValue && hostUser != nil {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Site Host existed, please contact the site host to signin account firstly"").SetInternal(err)
		}
		userCreate := &api.UserCreate{
			Username: signup.Username,
			Role:     api.Role(signup.Role),
			Nickname: signup.Username,
			Password: signup.Password,
			OpenID:   common.GenUUID(),
		}
		if err := userCreate.Validate(); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Invalid user create format"").SetInternal(err)
		}
		passwordHash, err := bcrypt.GenerateFromPassword([]byte(signup.Password), bcrypt.DefaultCost)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to generate password hash"").SetInternal(err)
		}
		userCreate.PasswordHash = string(passwordHash)
		user, err := s.Store.CreateUser(ctx, userCreate)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to create user"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""user signed up"",
		})
		err = setUserSession(c, user)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to set signup session"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(user)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode created user response"").SetInternal(err)
		}
		return nil
	})
}
",CWE-639,147.0,0
"package server
import (
	""encoding/json""
	""fmt""
	""net/http""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
	""golang.org/x/crypto/bcrypt""
)
func (s *Server) registerAuthRoutes(g *echo.Group) {
	g.POST(""/auth/signin"", func(c echo.Context) error {
		ctx := c.Request().Context()
		signin := &api.Signin{}
		if err := json.NewDecoder(c.Request().Body).Decode(signin); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted signin request"").SetInternal(err)
		}
		userFind := &api.UserFind{
			Username: &signin.Username,
		}
		user, err := s.Store.FindUser(ctx, userFind)
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to find user by username %s"", signin.Username)).SetInternal(err)
		}
		if user == nil {
			return echo.NewHTTPError(http.StatusUnauthorized, fmt.Sprintf(""User not found with username %s"", signin.Username))
		} else if user.RowStatus == api.Archived {
			return echo.NewHTTPError(http.StatusForbidden, fmt.Sprintf(""User has been archived with username %s"", signin.Username))
		}
		// Compare the stored hashed password, with the hashed version of the password that was received.
		if err := bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(signin.Password)); err != nil {
			// If the two passwords don't match, return a 401 status.
			return echo.NewHTTPError(http.StatusUnauthorized, ""Incorrect password"").SetInternal(err)
		}
		if err = setUserSession(c, user); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to set signin session"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""user signed in"",
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(user)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode user response"").SetInternal(err)
		}
		return nil
	})
	g.POST(""/auth/logout"", func(c echo.Context) error {
		ctx := c.Request().Context()
		err := removeUserSession(c)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to set logout session"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""user logout"",
		})
		c.Response().WriteHeader(http.StatusOK)
		return nil
	})
	g.POST(""/auth/signup"", func(c echo.Context) error {
		ctx := c.Request().Context()
		signup := &api.Signup{}
		if err := json.NewDecoder(c.Request().Body).Decode(signup); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted signup request"").SetInternal(err)
		}
		hostUserType := api.Host
		hostUserFind := api.UserFind{
			Role: &hostUserType,
		}
		hostUser, err := s.Store.FindUser(ctx, &hostUserFind)
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find host user"").SetInternal(err)
		}
		if signup.Role == api.Host && hostUser != nil {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Site Host existed, please contact the site host to signin account firstly"").SetInternal(err)
		}
		systemSettingAllowSignUpName := api.SystemSettingAllowSignUpName
		allowSignUpSetting, err := s.Store.FindSystemSetting(ctx, &api.SystemSettingFind{
			Name: &systemSettingAllowSignUpName,
		})
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find system setting"").SetInternal(err)
		}
		allowSignUpSettingValue := false
		if allowSignUpSetting != nil {
			err = json.Unmarshal([]byte(allowSignUpSetting.Value), &allowSignUpSettingValue)
			if err != nil {
				return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to unmarshal system setting allow signup"").SetInternal(err)
			}
		}
		if !allowSignUpSettingValue && hostUser != nil {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Site Host existed, please contact the site host to signin account firstly"").SetInternal(err)
		}
		userCreate := &api.UserCreate{
			Username: signup.Username,
			Role:     api.Role(signup.Role),
			Nickname: signup.Username,
			Password: signup.Password,
			OpenID:   common.GenUUID(),
		}
		if err := userCreate.Validate(); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Invalid user create format"").SetInternal(err)
		}
		passwordHash, err := bcrypt.GenerateFromPassword([]byte(signup.Password), bcrypt.DefaultCost)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to generate password hash"").SetInternal(err)
		}
		userCreate.PasswordHash = string(passwordHash)
		user, err := s.Store.CreateUser(ctx, userCreate)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to create user"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""user signed up"",
		})
		err = setUserSession(c, user)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to set signup session"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(user)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode created user response"").SetInternal(err)
		}
		return nil
	})
}
",CWE-940,147.0,0
"package server
import (
	""encoding/json""
	""fmt""
	""net/http""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
	""golang.org/x/crypto/bcrypt""
)
func (s *Server) registerAuthRoutes(g *echo.Group) {
	g.POST(""/auth/signin"", func(c echo.Context) error {
		ctx := c.Request().Context()
		signin := &api.Signin{}
		if err := json.NewDecoder(c.Request().Body).Decode(signin); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted signin request"").SetInternal(err)
		}
		userFind := &api.UserFind{
			Username: &signin.Username,
		}
		user, err := s.Store.FindUser(ctx, userFind)
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to find user by username %s"", signin.Username)).SetInternal(err)
		}
		if user == nil {
			return echo.NewHTTPError(http.StatusUnauthorized, fmt.Sprintf(""User not found with username %s"", signin.Username))
		} else if user.RowStatus == api.Archived {
			return echo.NewHTTPError(http.StatusForbidden, fmt.Sprintf(""User has been archived with username %s"", signin.Username))
		}
		// Compare the stored hashed password, with the hashed version of the password that was received.
		if err := bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(signin.Password)); err != nil {
			// If the two passwords don't match, return a 401 status.
			return echo.NewHTTPError(http.StatusUnauthorized, ""Incorrect password"").SetInternal(err)
		}
		if err = setUserSession(c, user); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to set signin session"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""user signed in"",
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(user)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode user response"").SetInternal(err)
		}
		return nil
	})
	g.POST(""/auth/logout"", func(c echo.Context) error {
		ctx := c.Request().Context()
		err := removeUserSession(c)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to set logout session"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""user logout"",
		})
		c.Response().WriteHeader(http.StatusOK)
		return nil
	})
	g.POST(""/auth/signup"", func(c echo.Context) error {
		ctx := c.Request().Context()
		signup := &api.Signup{}
		if err := json.NewDecoder(c.Request().Body).Decode(signup); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted signup request"").SetInternal(err)
		}
		hostUserType := api.Host
		hostUserFind := api.UserFind{
			Role: &hostUserType,
		}
		hostUser, err := s.Store.FindUser(ctx, &hostUserFind)
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find host user"").SetInternal(err)
		}
		if signup.Role == api.Host && hostUser != nil {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Site Host existed, please contact the site host to signin account firstly"").SetInternal(err)
		}
		systemSettingAllowSignUpName := api.SystemSettingAllowSignUpName
		allowSignUpSetting, err := s.Store.FindSystemSetting(ctx, &api.SystemSettingFind{
			Name: &systemSettingAllowSignUpName,
		})
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find system setting"").SetInternal(err)
		}
		allowSignUpSettingValue := false
		if allowSignUpSetting != nil {
			err = json.Unmarshal([]byte(allowSignUpSetting.Value), &allowSignUpSettingValue)
			if err != nil {
				return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to unmarshal system setting allow signup"").SetInternal(err)
			}
		}
		if !allowSignUpSettingValue && hostUser != nil {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Site Host existed, please contact the site host to signin account firstly"").SetInternal(err)
		}
		userCreate := &api.UserCreate{
			Username: signup.Username,
			Role:     api.Role(signup.Role),
			Nickname: signup.Username,
			Password: signup.Password,
			OpenID:   common.GenUUID(),
		}
		if err := userCreate.Validate(); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Invalid user create format"").SetInternal(err)
		}
		passwordHash, err := bcrypt.GenerateFromPassword([]byte(signup.Password), bcrypt.DefaultCost)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to generate password hash"").SetInternal(err)
		}
		userCreate.PasswordHash = string(passwordHash)
		user, err := s.Store.CreateUser(ctx, userCreate)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to create user"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""user signed up"",
		})
		err = setUserSession(c, user)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to set signup session"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(user)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode created user response"").SetInternal(err)
		}
		return nil
	})
}
",CWE-1220,147.0,0
"package server
import (
	""encoding/json""
	""fmt""
	""net/http""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
	""golang.org/x/crypto/bcrypt""
)
func (s *Server) registerAuthRoutes(g *echo.Group) {
	g.POST(""/auth/signin"", func(c echo.Context) error {
		ctx := c.Request().Context()
		signin := &api.Signin{}
		if err := json.NewDecoder(c.Request().Body).Decode(signin); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted signin request"").SetInternal(err)
		}
		userFind := &api.UserFind{
			Username: &signin.Username,
		}
		user, err := s.Store.FindUser(ctx, userFind)
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to find user by username %s"", signin.Username)).SetInternal(err)
		}
		if user == nil {
			return echo.NewHTTPError(http.StatusUnauthorized, fmt.Sprintf(""User not found with username %s"", signin.Username))
		} else if user.RowStatus == api.Archived {
			return echo.NewHTTPError(http.StatusForbidden, fmt.Sprintf(""User has been archived with username %s"", signin.Username))
		}
		// Compare the stored hashed password, with the hashed version of the password that was received.
		if err := bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(signin.Password)); err != nil {
			// If the two passwords don't match, return a 401 status.
			return echo.NewHTTPError(http.StatusUnauthorized, ""Incorrect password"").SetInternal(err)
		}
		if err = setUserSession(c, user); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to set signin session"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""user signed in"",
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(user)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode user response"").SetInternal(err)
		}
		return nil
	})
	g.POST(""/auth/logout"", func(c echo.Context) error {
		ctx := c.Request().Context()
		err := removeUserSession(c)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to set logout session"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""user logout"",
		})
		c.Response().WriteHeader(http.StatusOK)
		return nil
	})
	g.POST(""/auth/signup"", func(c echo.Context) error {
		ctx := c.Request().Context()
		signup := &api.Signup{}
		if err := json.NewDecoder(c.Request().Body).Decode(signup); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted signup request"").SetInternal(err)
		}
		hostUserType := api.Host
		hostUserFind := api.UserFind{
			Role: &hostUserType,
		}
		hostUser, err := s.Store.FindUser(ctx, &hostUserFind)
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find host user"").SetInternal(err)
		}
		if signup.Role == api.Host && hostUser != nil {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Site Host existed, please contact the site host to signin account firstly"").SetInternal(err)
		}
		systemSettingAllowSignUpName := api.SystemSettingAllowSignUpName
		allowSignUpSetting, err := s.Store.FindSystemSetting(ctx, &api.SystemSettingFind{
			Name: &systemSettingAllowSignUpName,
		})
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find system setting"").SetInternal(err)
		}
		allowSignUpSettingValue := false
		if allowSignUpSetting != nil {
			err = json.Unmarshal([]byte(allowSignUpSetting.Value), &allowSignUpSettingValue)
			if err != nil {
				return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to unmarshal system setting allow signup"").SetInternal(err)
			}
		}
		if !allowSignUpSettingValue && hostUser != nil {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Site Host existed, please contact the site host to signin account firstly"").SetInternal(err)
		}
		userCreate := &api.UserCreate{
			Username: signup.Username,
			Role:     api.Role(signup.Role),
			Nickname: signup.Username,
			Password: signup.Password,
			OpenID:   common.GenUUID(),
		}
		if err := userCreate.Validate(); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Invalid user create format"").SetInternal(err)
		}
		passwordHash, err := bcrypt.GenerateFromPassword([]byte(signup.Password), bcrypt.DefaultCost)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to generate password hash"").SetInternal(err)
		}
		userCreate.PasswordHash = string(passwordHash)
		user, err := s.Store.CreateUser(ctx, userCreate)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to create user"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""user signed up"",
		})
		err = setUserSession(c, user)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to set signup session"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(user)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode created user response"").SetInternal(err)
		}
		return nil
	})
}
",CWE-285,147.0,0
"package server
import (
	""encoding/json""
	""fmt""
	""net/http""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
	""golang.org/x/crypto/bcrypt""
)
func (s *Server) registerAuthRoutes(g *echo.Group) {
	g.POST(""/auth/signin"", func(c echo.Context) error {
		ctx := c.Request().Context()
		signin := &api.Signin{}
		if err := json.NewDecoder(c.Request().Body).Decode(signin); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted signin request"").SetInternal(err)
		}
		userFind := &api.UserFind{
			Username: &signin.Username,
		}
		user, err := s.Store.FindUser(ctx, userFind)
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to find user by username %s"", signin.Username)).SetInternal(err)
		}
		if user == nil {
			return echo.NewHTTPError(http.StatusUnauthorized, fmt.Sprintf(""User not found with username %s"", signin.Username))
		} else if user.RowStatus == api.Archived {
			return echo.NewHTTPError(http.StatusForbidden, fmt.Sprintf(""User has been archived with username %s"", signin.Username))
		}
		// Compare the stored hashed password, with the hashed version of the password that was received.
		if err := bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(signin.Password)); err != nil {
			// If the two passwords don't match, return a 401 status.
			return echo.NewHTTPError(http.StatusUnauthorized, ""Incorrect password"").SetInternal(err)
		}
		if err = setUserSession(c, user); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to set signin session"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""user signed in"",
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(user)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode user response"").SetInternal(err)
		}
		return nil
	})
	g.POST(""/auth/logout"", func(c echo.Context) error {
		ctx := c.Request().Context()
		err := removeUserSession(c)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to set logout session"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""user logout"",
		})
		c.Response().WriteHeader(http.StatusOK)
		return nil
	})
	g.POST(""/auth/signup"", func(c echo.Context) error {
		ctx := c.Request().Context()
		signup := &api.Signup{}
		if err := json.NewDecoder(c.Request().Body).Decode(signup); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted signup request"").SetInternal(err)
		}
		hostUserType := api.Host
		hostUserFind := api.UserFind{
			Role: &hostUserType,
		}
		hostUser, err := s.Store.FindUser(ctx, &hostUserFind)
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find host user"").SetInternal(err)
		}
		if signup.Role == api.Host && hostUser != nil {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Site Host existed, please contact the site host to signin account firstly"").SetInternal(err)
		}
		systemSettingAllowSignUpName := api.SystemSettingAllowSignUpName
		allowSignUpSetting, err := s.Store.FindSystemSetting(ctx, &api.SystemSettingFind{
			Name: &systemSettingAllowSignUpName,
		})
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find system setting"").SetInternal(err)
		}
		allowSignUpSettingValue := false
		if allowSignUpSetting != nil {
			err = json.Unmarshal([]byte(allowSignUpSetting.Value), &allowSignUpSettingValue)
			if err != nil {
				return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to unmarshal system setting allow signup"").SetInternal(err)
			}
		}
		if !allowSignUpSettingValue && hostUser != nil {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Site Host existed, please contact the site host to signin account firstly"").SetInternal(err)
		}
		userCreate := &api.UserCreate{
			Username: signup.Username,
			Role:     api.Role(signup.Role),
			Nickname: signup.Username,
			Password: signup.Password,
			OpenID:   common.GenUUID(),
		}
		if err := userCreate.Validate(); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Invalid user create format"").SetInternal(err)
		}
		passwordHash, err := bcrypt.GenerateFromPassword([]byte(signup.Password), bcrypt.DefaultCost)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to generate password hash"").SetInternal(err)
		}
		userCreate.PasswordHash = string(passwordHash)
		user, err := s.Store.CreateUser(ctx, userCreate)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to create user"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""user signed up"",
		})
		err = setUserSession(c, user)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to set signup session"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(user)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode created user response"").SetInternal(err)
		}
		return nil
	})
}
",CWE-284,147.0,0
"package server
import (
	""encoding/json""
	""fmt""
	""net/http""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
	""golang.org/x/crypto/bcrypt""
)
func (s *Server) registerAuthRoutes(g *echo.Group) {
	g.POST(""/auth/signin"", func(c echo.Context) error {
		ctx := c.Request().Context()
		signin := &api.Signin{}
		if err := json.NewDecoder(c.Request().Body).Decode(signin); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted signin request"").SetInternal(err)
		}
		userFind := &api.UserFind{
			Username: &signin.Username,
		}
		user, err := s.Store.FindUser(ctx, userFind)
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to find user by username %s"", signin.Username)).SetInternal(err)
		}
		if user == nil {
			return echo.NewHTTPError(http.StatusUnauthorized, fmt.Sprintf(""User not found with username %s"", signin.Username))
		} else if user.RowStatus == api.Archived {
			return echo.NewHTTPError(http.StatusForbidden, fmt.Sprintf(""User has been archived with username %s"", signin.Username))
		}
		// Compare the stored hashed password, with the hashed version of the password that was received.
		if err := bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(signin.Password)); err != nil {
			// If the two passwords don't match, return a 401 status.
			return echo.NewHTTPError(http.StatusUnauthorized, ""Incorrect password"").SetInternal(err)
		}
		if err = setUserSession(c, user); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to set signin session"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""user signed in"",
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(user)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode user response"").SetInternal(err)
		}
		return nil
	})
	g.POST(""/auth/logout"", func(c echo.Context) error {
		ctx := c.Request().Context()
		err := removeUserSession(c)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to set logout session"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""user logout"",
		})
		c.Response().WriteHeader(http.StatusOK)
		return nil
	})
	g.POST(""/auth/signup"", func(c echo.Context) error {
		ctx := c.Request().Context()
		signup := &api.Signup{}
		if err := json.NewDecoder(c.Request().Body).Decode(signup); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted signup request"").SetInternal(err)
		}
		hostUserType := api.Host
		hostUserFind := api.UserFind{
			Role: &hostUserType,
		}
		hostUser, err := s.Store.FindUser(ctx, &hostUserFind)
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find host user"").SetInternal(err)
		}
		if signup.Role == api.Host && hostUser != nil {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Site Host existed, please contact the site host to signin account firstly"").SetInternal(err)
		}
		systemSettingAllowSignUpName := api.SystemSettingAllowSignUpName
		allowSignUpSetting, err := s.Store.FindSystemSetting(ctx, &api.SystemSettingFind{
			Name: &systemSettingAllowSignUpName,
		})
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find system setting"").SetInternal(err)
		}
		allowSignUpSettingValue := false
		if allowSignUpSetting != nil {
			err = json.Unmarshal([]byte(allowSignUpSetting.Value), &allowSignUpSettingValue)
			if err != nil {
				return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to unmarshal system setting allow signup"").SetInternal(err)
			}
		}
		if !allowSignUpSettingValue && hostUser != nil {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Site Host existed, please contact the site host to signin account firstly"").SetInternal(err)
		}
		userCreate := &api.UserCreate{
			Username: signup.Username,
			Role:     api.Role(signup.Role),
			Nickname: signup.Username,
			Password: signup.Password,
			OpenID:   common.GenUUID(),
		}
		if err := userCreate.Validate(); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Invalid user create format"").SetInternal(err)
		}
		passwordHash, err := bcrypt.GenerateFromPassword([]byte(signup.Password), bcrypt.DefaultCost)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to generate password hash"").SetInternal(err)
		}
		userCreate.PasswordHash = string(passwordHash)
		user, err := s.Store.CreateUser(ctx, userCreate)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to create user"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""user signed up"",
		})
		err = setUserSession(c, user)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to set signup session"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(user)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode created user response"").SetInternal(err)
		}
		return nil
	})
}
",CWE-229,147.0,0
"package server
import (
	""encoding/json""
	""fmt""
	""net/http""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
	""golang.org/x/crypto/bcrypt""
)
func (s *Server) registerAuthRoutes(g *echo.Group) {
	g.POST(""/auth/signin"", func(c echo.Context) error {
		ctx := c.Request().Context()
		signin := &api.Signin{}
		if err := json.NewDecoder(c.Request().Body).Decode(signin); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted signin request"").SetInternal(err)
		}
		userFind := &api.UserFind{
			Username: &signin.Username,
		}
		user, err := s.Store.FindUser(ctx, userFind)
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to find user by username %s"", signin.Username)).SetInternal(err)
		}
		if user == nil {
			return echo.NewHTTPError(http.StatusUnauthorized, fmt.Sprintf(""User not found with username %s"", signin.Username))
		} else if user.RowStatus == api.Archived {
			return echo.NewHTTPError(http.StatusForbidden, fmt.Sprintf(""User has been archived with username %s"", signin.Username))
		}
		// Compare the stored hashed password, with the hashed version of the password that was received.
		if err := bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(signin.Password)); err != nil {
			// If the two passwords don't match, return a 401 status.
			return echo.NewHTTPError(http.StatusUnauthorized, ""Incorrect password"").SetInternal(err)
		}
		if err = setUserSession(c, user); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to set signin session"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""user signed in"",
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(user)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode user response"").SetInternal(err)
		}
		return nil
	})
	g.POST(""/auth/logout"", func(c echo.Context) error {
		ctx := c.Request().Context()
		err := removeUserSession(c)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to set logout session"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""user logout"",
		})
		c.Response().WriteHeader(http.StatusOK)
		return nil
	})
	g.POST(""/auth/signup"", func(c echo.Context) error {
		ctx := c.Request().Context()
		signup := &api.Signup{}
		if err := json.NewDecoder(c.Request().Body).Decode(signup); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted signup request"").SetInternal(err)
		}
		hostUserType := api.Host
		hostUserFind := api.UserFind{
			Role: &hostUserType,
		}
		hostUser, err := s.Store.FindUser(ctx, &hostUserFind)
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find host user"").SetInternal(err)
		}
		if signup.Role == api.Host && hostUser != nil {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Site Host existed, please contact the site host to signin account firstly"").SetInternal(err)
		}
		systemSettingAllowSignUpName := api.SystemSettingAllowSignUpName
		allowSignUpSetting, err := s.Store.FindSystemSetting(ctx, &api.SystemSettingFind{
			Name: &systemSettingAllowSignUpName,
		})
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find system setting"").SetInternal(err)
		}
		allowSignUpSettingValue := false
		if allowSignUpSetting != nil {
			err = json.Unmarshal([]byte(allowSignUpSetting.Value), &allowSignUpSettingValue)
			if err != nil {
				return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to unmarshal system setting allow signup"").SetInternal(err)
			}
		}
		if !allowSignUpSettingValue && hostUser != nil {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Site Host existed, please contact the site host to signin account firstly"").SetInternal(err)
		}
		userCreate := &api.UserCreate{
			Username: signup.Username,
			Role:     api.Role(signup.Role),
			Nickname: signup.Username,
			Password: signup.Password,
			OpenID:   common.GenUUID(),
		}
		if err := userCreate.Validate(); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Invalid user create format"").SetInternal(err)
		}
		passwordHash, err := bcrypt.GenerateFromPassword([]byte(signup.Password), bcrypt.DefaultCost)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to generate password hash"").SetInternal(err)
		}
		userCreate.PasswordHash = string(passwordHash)
		user, err := s.Store.CreateUser(ctx, userCreate)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to create user"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""user signed up"",
		})
		err = setUserSession(c, user)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to set signup session"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(user)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode created user response"").SetInternal(err)
		}
		return nil
	})
}
",CWE-280,147.0,0
"package server
import (
	""encoding/json""
	""fmt""
	""net/http""
	""strconv""
	""time""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
)
func (s *Server) registerShortcutRoutes(g *echo.Group) {
	g.POST(""/shortcut"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		shortcutCreate := &api.ShortcutCreate{}
		if err := json.NewDecoder(c.Request().Body).Decode(shortcutCreate); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted post shortcut request"").SetInternal(err)
		}
		shortcutCreate.CreatorID = userID
		shortcut, err := s.Store.CreateShortcut(ctx, shortcutCreate)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to create shortcut"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""shortcut created"",
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut response"").SetInternal(err)
		}
		return nil
	})
	g.PATCH(""/shortcut/:shortcutId"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		shortcutID, err := strconv.Atoi(c.Param(""shortcutId""))
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(""ID is not a number: %s"", c.Param(""shortcutId""))).SetInternal(err)
		}
		shortcutFind := &api.ShortcutFind{
			ID: &shortcutID,
		}
		shortcut, err := s.Store.FindShortcut(ctx, shortcutFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find shortcut"").SetInternal(err)
		}
		if shortcut.CreatorID != userID {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Unauthorized"")
		}
		currentTs := time.Now().Unix()
		shortcutPatch := &api.ShortcutPatch{
			UpdatedTs: &currentTs,
		}
		if err := json.NewDecoder(c.Request().Body).Decode(shortcutPatch); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted patch shortcut request"").SetInternal(err)
		}
		shortcutPatch.ID = shortcutID
		shortcut, err = s.Store.PatchShortcut(ctx, shortcutPatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to patch shortcut"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/shortcut"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusBadRequest, ""Missing user id to find shortcut"")
		}
		shortcutFind := &api.ShortcutFind{
			CreatorID: &userID,
		}
		list, err := s.Store.FindShortcutList(ctx, shortcutFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to fetch shortcut list"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(list)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut list response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/shortcut/:shortcutId"", func(c echo.Context) error {
		ctx := c.Request().Context()
		shortcutID, err := strconv.Atoi(c.Param(""shortcutId""))
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(""ID is not a number: %s"", c.Param(""shortcutId""))).SetInternal(err)
		}
		shortcutFind := &api.ShortcutFind{
			ID: &shortcutID,
		}
		shortcut, err := s.Store.FindShortcut(ctx, shortcutFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to fetch shortcut by ID %d"", *shortcutFind.ID)).SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut response"").SetInternal(err)
		}
		return nil
	})
	g.DELETE(""/shortcut/:shortcutId"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		shortcutID, err := strconv.Atoi(c.Param(""shortcutId""))
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(""ID is not a number: %s"", c.Param(""shortcutId""))).SetInternal(err)
		}
		shortcutFind := &api.ShortcutFind{
			ID: &shortcutID,
		}
		shortcut, err := s.Store.FindShortcut(ctx, shortcutFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find shortcut"").SetInternal(err)
		}
		if shortcut.CreatorID != userID {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Unauthorized"")
		}
		shortcutDelete := &api.ShortcutDelete{
			ID: &shortcutID,
		}
		if err := s.Store.DeleteShortcut(ctx, shortcutDelete); err != nil {
			if common.ErrorCode(err) == common.NotFound {
				return echo.NewHTTPError(http.StatusNotFound, fmt.Sprintf(""Shortcut ID not found: %d"", shortcutID))
			}
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to delete shortcut"").SetInternal(err)
		}
		return c.JSON(http.StatusOK, true)
	})
}
",CWE-648,167.0,0
"package server
import (
	""encoding/json""
	""fmt""
	""net/http""
	""strconv""
	""time""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
)
func (s *Server) registerShortcutRoutes(g *echo.Group) {
	g.POST(""/shortcut"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		shortcutCreate := &api.ShortcutCreate{}
		if err := json.NewDecoder(c.Request().Body).Decode(shortcutCreate); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted post shortcut request"").SetInternal(err)
		}
		shortcutCreate.CreatorID = userID
		shortcut, err := s.Store.CreateShortcut(ctx, shortcutCreate)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to create shortcut"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""shortcut created"",
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut response"").SetInternal(err)
		}
		return nil
	})
	g.PATCH(""/shortcut/:shortcutId"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		shortcutID, err := strconv.Atoi(c.Param(""shortcutId""))
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(""ID is not a number: %s"", c.Param(""shortcutId""))).SetInternal(err)
		}
		shortcutFind := &api.ShortcutFind{
			ID: &shortcutID,
		}
		shortcut, err := s.Store.FindShortcut(ctx, shortcutFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find shortcut"").SetInternal(err)
		}
		if shortcut.CreatorID != userID {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Unauthorized"")
		}
		currentTs := time.Now().Unix()
		shortcutPatch := &api.ShortcutPatch{
			UpdatedTs: &currentTs,
		}
		if err := json.NewDecoder(c.Request().Body).Decode(shortcutPatch); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted patch shortcut request"").SetInternal(err)
		}
		shortcutPatch.ID = shortcutID
		shortcut, err = s.Store.PatchShortcut(ctx, shortcutPatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to patch shortcut"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/shortcut"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusBadRequest, ""Missing user id to find shortcut"")
		}
		shortcutFind := &api.ShortcutFind{
			CreatorID: &userID,
		}
		list, err := s.Store.FindShortcutList(ctx, shortcutFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to fetch shortcut list"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(list)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut list response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/shortcut/:shortcutId"", func(c echo.Context) error {
		ctx := c.Request().Context()
		shortcutID, err := strconv.Atoi(c.Param(""shortcutId""))
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(""ID is not a number: %s"", c.Param(""shortcutId""))).SetInternal(err)
		}
		shortcutFind := &api.ShortcutFind{
			ID: &shortcutID,
		}
		shortcut, err := s.Store.FindShortcut(ctx, shortcutFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to fetch shortcut by ID %d"", *shortcutFind.ID)).SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut response"").SetInternal(err)
		}
		return nil
	})
	g.DELETE(""/shortcut/:shortcutId"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		shortcutID, err := strconv.Atoi(c.Param(""shortcutId""))
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(""ID is not a number: %s"", c.Param(""shortcutId""))).SetInternal(err)
		}
		shortcutFind := &api.ShortcutFind{
			ID: &shortcutID,
		}
		shortcut, err := s.Store.FindShortcut(ctx, shortcutFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find shortcut"").SetInternal(err)
		}
		if shortcut.CreatorID != userID {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Unauthorized"")
		}
		shortcutDelete := &api.ShortcutDelete{
			ID: &shortcutID,
		}
		if err := s.Store.DeleteShortcut(ctx, shortcutDelete); err != nil {
			if common.ErrorCode(err) == common.NotFound {
				return echo.NewHTTPError(http.StatusNotFound, fmt.Sprintf(""Shortcut ID not found: %d"", shortcutID))
			}
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to delete shortcut"").SetInternal(err)
		}
		return c.JSON(http.StatusOK, true)
	})
}
",CWE-307,167.0,0
"package server
import (
	""encoding/json""
	""fmt""
	""net/http""
	""strconv""
	""time""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
)
func (s *Server) registerShortcutRoutes(g *echo.Group) {
	g.POST(""/shortcut"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		shortcutCreate := &api.ShortcutCreate{}
		if err := json.NewDecoder(c.Request().Body).Decode(shortcutCreate); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted post shortcut request"").SetInternal(err)
		}
		shortcutCreate.CreatorID = userID
		shortcut, err := s.Store.CreateShortcut(ctx, shortcutCreate)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to create shortcut"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""shortcut created"",
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut response"").SetInternal(err)
		}
		return nil
	})
	g.PATCH(""/shortcut/:shortcutId"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		shortcutID, err := strconv.Atoi(c.Param(""shortcutId""))
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(""ID is not a number: %s"", c.Param(""shortcutId""))).SetInternal(err)
		}
		shortcutFind := &api.ShortcutFind{
			ID: &shortcutID,
		}
		shortcut, err := s.Store.FindShortcut(ctx, shortcutFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find shortcut"").SetInternal(err)
		}
		if shortcut.CreatorID != userID {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Unauthorized"")
		}
		currentTs := time.Now().Unix()
		shortcutPatch := &api.ShortcutPatch{
			UpdatedTs: &currentTs,
		}
		if err := json.NewDecoder(c.Request().Body).Decode(shortcutPatch); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted patch shortcut request"").SetInternal(err)
		}
		shortcutPatch.ID = shortcutID
		shortcut, err = s.Store.PatchShortcut(ctx, shortcutPatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to patch shortcut"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/shortcut"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusBadRequest, ""Missing user id to find shortcut"")
		}
		shortcutFind := &api.ShortcutFind{
			CreatorID: &userID,
		}
		list, err := s.Store.FindShortcutList(ctx, shortcutFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to fetch shortcut list"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(list)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut list response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/shortcut/:shortcutId"", func(c echo.Context) error {
		ctx := c.Request().Context()
		shortcutID, err := strconv.Atoi(c.Param(""shortcutId""))
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(""ID is not a number: %s"", c.Param(""shortcutId""))).SetInternal(err)
		}
		shortcutFind := &api.ShortcutFind{
			ID: &shortcutID,
		}
		shortcut, err := s.Store.FindShortcut(ctx, shortcutFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to fetch shortcut by ID %d"", *shortcutFind.ID)).SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut response"").SetInternal(err)
		}
		return nil
	})
	g.DELETE(""/shortcut/:shortcutId"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		shortcutID, err := strconv.Atoi(c.Param(""shortcutId""))
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(""ID is not a number: %s"", c.Param(""shortcutId""))).SetInternal(err)
		}
		shortcutFind := &api.ShortcutFind{
			ID: &shortcutID,
		}
		shortcut, err := s.Store.FindShortcut(ctx, shortcutFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find shortcut"").SetInternal(err)
		}
		if shortcut.CreatorID != userID {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Unauthorized"")
		}
		shortcutDelete := &api.ShortcutDelete{
			ID: &shortcutID,
		}
		if err := s.Store.DeleteShortcut(ctx, shortcutDelete); err != nil {
			if common.ErrorCode(err) == common.NotFound {
				return echo.NewHTTPError(http.StatusNotFound, fmt.Sprintf(""Shortcut ID not found: %d"", shortcutID))
			}
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to delete shortcut"").SetInternal(err)
		}
		return c.JSON(http.StatusOK, true)
	})
}
",CWE-639,167.0,0
"package server
import (
	""encoding/json""
	""fmt""
	""net/http""
	""strconv""
	""time""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
)
func (s *Server) registerShortcutRoutes(g *echo.Group) {
	g.POST(""/shortcut"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		shortcutCreate := &api.ShortcutCreate{}
		if err := json.NewDecoder(c.Request().Body).Decode(shortcutCreate); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted post shortcut request"").SetInternal(err)
		}
		shortcutCreate.CreatorID = userID
		shortcut, err := s.Store.CreateShortcut(ctx, shortcutCreate)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to create shortcut"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""shortcut created"",
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut response"").SetInternal(err)
		}
		return nil
	})
	g.PATCH(""/shortcut/:shortcutId"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		shortcutID, err := strconv.Atoi(c.Param(""shortcutId""))
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(""ID is not a number: %s"", c.Param(""shortcutId""))).SetInternal(err)
		}
		shortcutFind := &api.ShortcutFind{
			ID: &shortcutID,
		}
		shortcut, err := s.Store.FindShortcut(ctx, shortcutFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find shortcut"").SetInternal(err)
		}
		if shortcut.CreatorID != userID {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Unauthorized"")
		}
		currentTs := time.Now().Unix()
		shortcutPatch := &api.ShortcutPatch{
			UpdatedTs: &currentTs,
		}
		if err := json.NewDecoder(c.Request().Body).Decode(shortcutPatch); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted patch shortcut request"").SetInternal(err)
		}
		shortcutPatch.ID = shortcutID
		shortcut, err = s.Store.PatchShortcut(ctx, shortcutPatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to patch shortcut"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/shortcut"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusBadRequest, ""Missing user id to find shortcut"")
		}
		shortcutFind := &api.ShortcutFind{
			CreatorID: &userID,
		}
		list, err := s.Store.FindShortcutList(ctx, shortcutFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to fetch shortcut list"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(list)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut list response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/shortcut/:shortcutId"", func(c echo.Context) error {
		ctx := c.Request().Context()
		shortcutID, err := strconv.Atoi(c.Param(""shortcutId""))
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(""ID is not a number: %s"", c.Param(""shortcutId""))).SetInternal(err)
		}
		shortcutFind := &api.ShortcutFind{
			ID: &shortcutID,
		}
		shortcut, err := s.Store.FindShortcut(ctx, shortcutFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to fetch shortcut by ID %d"", *shortcutFind.ID)).SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut response"").SetInternal(err)
		}
		return nil
	})
	g.DELETE(""/shortcut/:shortcutId"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		shortcutID, err := strconv.Atoi(c.Param(""shortcutId""))
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(""ID is not a number: %s"", c.Param(""shortcutId""))).SetInternal(err)
		}
		shortcutFind := &api.ShortcutFind{
			ID: &shortcutID,
		}
		shortcut, err := s.Store.FindShortcut(ctx, shortcutFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find shortcut"").SetInternal(err)
		}
		if shortcut.CreatorID != userID {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Unauthorized"")
		}
		shortcutDelete := &api.ShortcutDelete{
			ID: &shortcutID,
		}
		if err := s.Store.DeleteShortcut(ctx, shortcutDelete); err != nil {
			if common.ErrorCode(err) == common.NotFound {
				return echo.NewHTTPError(http.StatusNotFound, fmt.Sprintf(""Shortcut ID not found: %d"", shortcutID))
			}
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to delete shortcut"").SetInternal(err)
		}
		return c.JSON(http.StatusOK, true)
	})
}
",CWE-940,167.0,0
"package server
import (
	""encoding/json""
	""fmt""
	""net/http""
	""strconv""
	""time""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
)
func (s *Server) registerShortcutRoutes(g *echo.Group) {
	g.POST(""/shortcut"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		shortcutCreate := &api.ShortcutCreate{}
		if err := json.NewDecoder(c.Request().Body).Decode(shortcutCreate); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted post shortcut request"").SetInternal(err)
		}
		shortcutCreate.CreatorID = userID
		shortcut, err := s.Store.CreateShortcut(ctx, shortcutCreate)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to create shortcut"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""shortcut created"",
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut response"").SetInternal(err)
		}
		return nil
	})
	g.PATCH(""/shortcut/:shortcutId"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		shortcutID, err := strconv.Atoi(c.Param(""shortcutId""))
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(""ID is not a number: %s"", c.Param(""shortcutId""))).SetInternal(err)
		}
		shortcutFind := &api.ShortcutFind{
			ID: &shortcutID,
		}
		shortcut, err := s.Store.FindShortcut(ctx, shortcutFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find shortcut"").SetInternal(err)
		}
		if shortcut.CreatorID != userID {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Unauthorized"")
		}
		currentTs := time.Now().Unix()
		shortcutPatch := &api.ShortcutPatch{
			UpdatedTs: &currentTs,
		}
		if err := json.NewDecoder(c.Request().Body).Decode(shortcutPatch); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted patch shortcut request"").SetInternal(err)
		}
		shortcutPatch.ID = shortcutID
		shortcut, err = s.Store.PatchShortcut(ctx, shortcutPatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to patch shortcut"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/shortcut"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusBadRequest, ""Missing user id to find shortcut"")
		}
		shortcutFind := &api.ShortcutFind{
			CreatorID: &userID,
		}
		list, err := s.Store.FindShortcutList(ctx, shortcutFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to fetch shortcut list"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(list)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut list response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/shortcut/:shortcutId"", func(c echo.Context) error {
		ctx := c.Request().Context()
		shortcutID, err := strconv.Atoi(c.Param(""shortcutId""))
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(""ID is not a number: %s"", c.Param(""shortcutId""))).SetInternal(err)
		}
		shortcutFind := &api.ShortcutFind{
			ID: &shortcutID,
		}
		shortcut, err := s.Store.FindShortcut(ctx, shortcutFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to fetch shortcut by ID %d"", *shortcutFind.ID)).SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut response"").SetInternal(err)
		}
		return nil
	})
	g.DELETE(""/shortcut/:shortcutId"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		shortcutID, err := strconv.Atoi(c.Param(""shortcutId""))
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(""ID is not a number: %s"", c.Param(""shortcutId""))).SetInternal(err)
		}
		shortcutFind := &api.ShortcutFind{
			ID: &shortcutID,
		}
		shortcut, err := s.Store.FindShortcut(ctx, shortcutFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find shortcut"").SetInternal(err)
		}
		if shortcut.CreatorID != userID {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Unauthorized"")
		}
		shortcutDelete := &api.ShortcutDelete{
			ID: &shortcutID,
		}
		if err := s.Store.DeleteShortcut(ctx, shortcutDelete); err != nil {
			if common.ErrorCode(err) == common.NotFound {
				return echo.NewHTTPError(http.StatusNotFound, fmt.Sprintf(""Shortcut ID not found: %d"", shortcutID))
			}
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to delete shortcut"").SetInternal(err)
		}
		return c.JSON(http.StatusOK, true)
	})
}
",CWE-1220,167.0,0
"package server
import (
	""encoding/json""
	""fmt""
	""net/http""
	""strconv""
	""time""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
)
func (s *Server) registerShortcutRoutes(g *echo.Group) {
	g.POST(""/shortcut"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		shortcutCreate := &api.ShortcutCreate{}
		if err := json.NewDecoder(c.Request().Body).Decode(shortcutCreate); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted post shortcut request"").SetInternal(err)
		}
		shortcutCreate.CreatorID = userID
		shortcut, err := s.Store.CreateShortcut(ctx, shortcutCreate)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to create shortcut"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""shortcut created"",
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut response"").SetInternal(err)
		}
		return nil
	})
	g.PATCH(""/shortcut/:shortcutId"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		shortcutID, err := strconv.Atoi(c.Param(""shortcutId""))
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(""ID is not a number: %s"", c.Param(""shortcutId""))).SetInternal(err)
		}
		shortcutFind := &api.ShortcutFind{
			ID: &shortcutID,
		}
		shortcut, err := s.Store.FindShortcut(ctx, shortcutFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find shortcut"").SetInternal(err)
		}
		if shortcut.CreatorID != userID {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Unauthorized"")
		}
		currentTs := time.Now().Unix()
		shortcutPatch := &api.ShortcutPatch{
			UpdatedTs: &currentTs,
		}
		if err := json.NewDecoder(c.Request().Body).Decode(shortcutPatch); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted patch shortcut request"").SetInternal(err)
		}
		shortcutPatch.ID = shortcutID
		shortcut, err = s.Store.PatchShortcut(ctx, shortcutPatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to patch shortcut"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/shortcut"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusBadRequest, ""Missing user id to find shortcut"")
		}
		shortcutFind := &api.ShortcutFind{
			CreatorID: &userID,
		}
		list, err := s.Store.FindShortcutList(ctx, shortcutFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to fetch shortcut list"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(list)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut list response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/shortcut/:shortcutId"", func(c echo.Context) error {
		ctx := c.Request().Context()
		shortcutID, err := strconv.Atoi(c.Param(""shortcutId""))
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(""ID is not a number: %s"", c.Param(""shortcutId""))).SetInternal(err)
		}
		shortcutFind := &api.ShortcutFind{
			ID: &shortcutID,
		}
		shortcut, err := s.Store.FindShortcut(ctx, shortcutFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to fetch shortcut by ID %d"", *shortcutFind.ID)).SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut response"").SetInternal(err)
		}
		return nil
	})
	g.DELETE(""/shortcut/:shortcutId"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		shortcutID, err := strconv.Atoi(c.Param(""shortcutId""))
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(""ID is not a number: %s"", c.Param(""shortcutId""))).SetInternal(err)
		}
		shortcutFind := &api.ShortcutFind{
			ID: &shortcutID,
		}
		shortcut, err := s.Store.FindShortcut(ctx, shortcutFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find shortcut"").SetInternal(err)
		}
		if shortcut.CreatorID != userID {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Unauthorized"")
		}
		shortcutDelete := &api.ShortcutDelete{
			ID: &shortcutID,
		}
		if err := s.Store.DeleteShortcut(ctx, shortcutDelete); err != nil {
			if common.ErrorCode(err) == common.NotFound {
				return echo.NewHTTPError(http.StatusNotFound, fmt.Sprintf(""Shortcut ID not found: %d"", shortcutID))
			}
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to delete shortcut"").SetInternal(err)
		}
		return c.JSON(http.StatusOK, true)
	})
}
",CWE-285,167.0,0
"package server
import (
	""encoding/json""
	""fmt""
	""net/http""
	""strconv""
	""time""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
)
func (s *Server) registerShortcutRoutes(g *echo.Group) {
	g.POST(""/shortcut"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		shortcutCreate := &api.ShortcutCreate{}
		if err := json.NewDecoder(c.Request().Body).Decode(shortcutCreate); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted post shortcut request"").SetInternal(err)
		}
		shortcutCreate.CreatorID = userID
		shortcut, err := s.Store.CreateShortcut(ctx, shortcutCreate)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to create shortcut"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""shortcut created"",
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut response"").SetInternal(err)
		}
		return nil
	})
	g.PATCH(""/shortcut/:shortcutId"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		shortcutID, err := strconv.Atoi(c.Param(""shortcutId""))
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(""ID is not a number: %s"", c.Param(""shortcutId""))).SetInternal(err)
		}
		shortcutFind := &api.ShortcutFind{
			ID: &shortcutID,
		}
		shortcut, err := s.Store.FindShortcut(ctx, shortcutFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find shortcut"").SetInternal(err)
		}
		if shortcut.CreatorID != userID {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Unauthorized"")
		}
		currentTs := time.Now().Unix()
		shortcutPatch := &api.ShortcutPatch{
			UpdatedTs: &currentTs,
		}
		if err := json.NewDecoder(c.Request().Body).Decode(shortcutPatch); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted patch shortcut request"").SetInternal(err)
		}
		shortcutPatch.ID = shortcutID
		shortcut, err = s.Store.PatchShortcut(ctx, shortcutPatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to patch shortcut"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/shortcut"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusBadRequest, ""Missing user id to find shortcut"")
		}
		shortcutFind := &api.ShortcutFind{
			CreatorID: &userID,
		}
		list, err := s.Store.FindShortcutList(ctx, shortcutFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to fetch shortcut list"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(list)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut list response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/shortcut/:shortcutId"", func(c echo.Context) error {
		ctx := c.Request().Context()
		shortcutID, err := strconv.Atoi(c.Param(""shortcutId""))
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(""ID is not a number: %s"", c.Param(""shortcutId""))).SetInternal(err)
		}
		shortcutFind := &api.ShortcutFind{
			ID: &shortcutID,
		}
		shortcut, err := s.Store.FindShortcut(ctx, shortcutFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to fetch shortcut by ID %d"", *shortcutFind.ID)).SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut response"").SetInternal(err)
		}
		return nil
	})
	g.DELETE(""/shortcut/:shortcutId"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		shortcutID, err := strconv.Atoi(c.Param(""shortcutId""))
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(""ID is not a number: %s"", c.Param(""shortcutId""))).SetInternal(err)
		}
		shortcutFind := &api.ShortcutFind{
			ID: &shortcutID,
		}
		shortcut, err := s.Store.FindShortcut(ctx, shortcutFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find shortcut"").SetInternal(err)
		}
		if shortcut.CreatorID != userID {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Unauthorized"")
		}
		shortcutDelete := &api.ShortcutDelete{
			ID: &shortcutID,
		}
		if err := s.Store.DeleteShortcut(ctx, shortcutDelete); err != nil {
			if common.ErrorCode(err) == common.NotFound {
				return echo.NewHTTPError(http.StatusNotFound, fmt.Sprintf(""Shortcut ID not found: %d"", shortcutID))
			}
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to delete shortcut"").SetInternal(err)
		}
		return c.JSON(http.StatusOK, true)
	})
}
",CWE-284,167.0,0
"package server
import (
	""encoding/json""
	""fmt""
	""net/http""
	""strconv""
	""time""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
)
func (s *Server) registerShortcutRoutes(g *echo.Group) {
	g.POST(""/shortcut"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		shortcutCreate := &api.ShortcutCreate{}
		if err := json.NewDecoder(c.Request().Body).Decode(shortcutCreate); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted post shortcut request"").SetInternal(err)
		}
		shortcutCreate.CreatorID = userID
		shortcut, err := s.Store.CreateShortcut(ctx, shortcutCreate)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to create shortcut"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""shortcut created"",
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut response"").SetInternal(err)
		}
		return nil
	})
	g.PATCH(""/shortcut/:shortcutId"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		shortcutID, err := strconv.Atoi(c.Param(""shortcutId""))
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(""ID is not a number: %s"", c.Param(""shortcutId""))).SetInternal(err)
		}
		shortcutFind := &api.ShortcutFind{
			ID: &shortcutID,
		}
		shortcut, err := s.Store.FindShortcut(ctx, shortcutFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find shortcut"").SetInternal(err)
		}
		if shortcut.CreatorID != userID {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Unauthorized"")
		}
		currentTs := time.Now().Unix()
		shortcutPatch := &api.ShortcutPatch{
			UpdatedTs: &currentTs,
		}
		if err := json.NewDecoder(c.Request().Body).Decode(shortcutPatch); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted patch shortcut request"").SetInternal(err)
		}
		shortcutPatch.ID = shortcutID
		shortcut, err = s.Store.PatchShortcut(ctx, shortcutPatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to patch shortcut"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/shortcut"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusBadRequest, ""Missing user id to find shortcut"")
		}
		shortcutFind := &api.ShortcutFind{
			CreatorID: &userID,
		}
		list, err := s.Store.FindShortcutList(ctx, shortcutFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to fetch shortcut list"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(list)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut list response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/shortcut/:shortcutId"", func(c echo.Context) error {
		ctx := c.Request().Context()
		shortcutID, err := strconv.Atoi(c.Param(""shortcutId""))
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(""ID is not a number: %s"", c.Param(""shortcutId""))).SetInternal(err)
		}
		shortcutFind := &api.ShortcutFind{
			ID: &shortcutID,
		}
		shortcut, err := s.Store.FindShortcut(ctx, shortcutFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to fetch shortcut by ID %d"", *shortcutFind.ID)).SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut response"").SetInternal(err)
		}
		return nil
	})
	g.DELETE(""/shortcut/:shortcutId"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		shortcutID, err := strconv.Atoi(c.Param(""shortcutId""))
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(""ID is not a number: %s"", c.Param(""shortcutId""))).SetInternal(err)
		}
		shortcutFind := &api.ShortcutFind{
			ID: &shortcutID,
		}
		shortcut, err := s.Store.FindShortcut(ctx, shortcutFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find shortcut"").SetInternal(err)
		}
		if shortcut.CreatorID != userID {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Unauthorized"")
		}
		shortcutDelete := &api.ShortcutDelete{
			ID: &shortcutID,
		}
		if err := s.Store.DeleteShortcut(ctx, shortcutDelete); err != nil {
			if common.ErrorCode(err) == common.NotFound {
				return echo.NewHTTPError(http.StatusNotFound, fmt.Sprintf(""Shortcut ID not found: %d"", shortcutID))
			}
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to delete shortcut"").SetInternal(err)
		}
		return c.JSON(http.StatusOK, true)
	})
}
",CWE-229,167.0,0
"package server
import (
	""encoding/json""
	""fmt""
	""net/http""
	""strconv""
	""time""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
)
func (s *Server) registerShortcutRoutes(g *echo.Group) {
	g.POST(""/shortcut"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		shortcutCreate := &api.ShortcutCreate{}
		if err := json.NewDecoder(c.Request().Body).Decode(shortcutCreate); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted post shortcut request"").SetInternal(err)
		}
		shortcutCreate.CreatorID = userID
		shortcut, err := s.Store.CreateShortcut(ctx, shortcutCreate)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to create shortcut"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""shortcut created"",
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut response"").SetInternal(err)
		}
		return nil
	})
	g.PATCH(""/shortcut/:shortcutId"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		shortcutID, err := strconv.Atoi(c.Param(""shortcutId""))
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(""ID is not a number: %s"", c.Param(""shortcutId""))).SetInternal(err)
		}
		shortcutFind := &api.ShortcutFind{
			ID: &shortcutID,
		}
		shortcut, err := s.Store.FindShortcut(ctx, shortcutFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find shortcut"").SetInternal(err)
		}
		if shortcut.CreatorID != userID {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Unauthorized"")
		}
		currentTs := time.Now().Unix()
		shortcutPatch := &api.ShortcutPatch{
			UpdatedTs: &currentTs,
		}
		if err := json.NewDecoder(c.Request().Body).Decode(shortcutPatch); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted patch shortcut request"").SetInternal(err)
		}
		shortcutPatch.ID = shortcutID
		shortcut, err = s.Store.PatchShortcut(ctx, shortcutPatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to patch shortcut"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/shortcut"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusBadRequest, ""Missing user id to find shortcut"")
		}
		shortcutFind := &api.ShortcutFind{
			CreatorID: &userID,
		}
		list, err := s.Store.FindShortcutList(ctx, shortcutFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to fetch shortcut list"").SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(list)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut list response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/shortcut/:shortcutId"", func(c echo.Context) error {
		ctx := c.Request().Context()
		shortcutID, err := strconv.Atoi(c.Param(""shortcutId""))
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(""ID is not a number: %s"", c.Param(""shortcutId""))).SetInternal(err)
		}
		shortcutFind := &api.ShortcutFind{
			ID: &shortcutID,
		}
		shortcut, err := s.Store.FindShortcut(ctx, shortcutFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to fetch shortcut by ID %d"", *shortcutFind.ID)).SetInternal(err)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(shortcut)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode shortcut response"").SetInternal(err)
		}
		return nil
	})
	g.DELETE(""/shortcut/:shortcutId"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		shortcutID, err := strconv.Atoi(c.Param(""shortcutId""))
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf(""ID is not a number: %s"", c.Param(""shortcutId""))).SetInternal(err)
		}
		shortcutFind := &api.ShortcutFind{
			ID: &shortcutID,
		}
		shortcut, err := s.Store.FindShortcut(ctx, shortcutFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find shortcut"").SetInternal(err)
		}
		if shortcut.CreatorID != userID {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Unauthorized"")
		}
		shortcutDelete := &api.ShortcutDelete{
			ID: &shortcutID,
		}
		if err := s.Store.DeleteShortcut(ctx, shortcutDelete); err != nil {
			if common.ErrorCode(err) == common.NotFound {
				return echo.NewHTTPError(http.StatusNotFound, fmt.Sprintf(""Shortcut ID not found: %d"", shortcutID))
			}
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to delete shortcut"").SetInternal(err)
		}
		return c.JSON(http.StatusOK, true)
	})
}
",CWE-280,167.0,0
"package server
import (
	""encoding/json""
	""fmt""
	""net/http""
	""regexp""
	""sort""
	""strconv""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
)
func (s *Server) registerTagRoutes(g *echo.Group) {
	g.POST(""/tag"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		tagUpsert := &api.TagUpsert{}
		if err := json.NewDecoder(c.Request().Body).Decode(tagUpsert); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted post tag request"").SetInternal(err)
		}
		if tagUpsert.Name == """" {
			return echo.NewHTTPError(http.StatusBadRequest, ""Tag name shouldn't be empty"")
		}
		tagUpsert.CreatorID = userID
		tag, err := s.Store.UpsertTag(ctx, tagUpsert)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to upsert tag"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""tag created"",
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tag.Name)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode tag response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/tag"", func(c echo.Context) error {
		ctx := c.Request().Context()
		tagFind := &api.TagFind{}
		if userID, err := strconv.Atoi(c.QueryParam(""creatorId"")); err == nil {
			tagFind.CreatorID = userID
		}
		if tagFind.CreatorID == 0 {
			currentUserID, ok := c.Get(getUserIDContextKey()).(int)
			if !ok {
				return echo.NewHTTPError(http.StatusBadRequest, ""Missing user id to find tag"")
			}
			tagFind.CreatorID = currentUserID
		}
		tagList, err := s.Store.FindTagList(ctx, tagFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find tag list"").SetInternal(err)
		}
		tagNameList := []string{}
		for _, tag := range tagList {
			tagNameList = append(tagNameList, tag.Name)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tagNameList)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode tags response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/tag/suggestion"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusBadRequest, ""Missing user session"")
		}
		contentSearch := ""
		normalRowStatus := api.Normal
		memoFind := api.MemoFind{
			CreatorID:     &userID,
			ContentSearch: &contentSearch,
			RowStatus:     &normalRowStatus,
		}
		memoList, err := s.Store.FindMemoList(ctx, &memoFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find memo list"").SetInternal(err)
		}
		tagMapSet := make(map[string]bool)
		for _, memo := range memoList {
			for _, tag := range findTagListFromMemoContent(memo.Content) {
				tagMapSet[tag] = true
			}
		}
		tagList := []string{}
		for tag := range tagMapSet {
			tagList = append(tagList, tag)
		}
		sort.Strings(tagList)
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tagList)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode tags response"").SetInternal(err)
		}
		return nil
	})
	g.DELETE(""/tag/:tagName"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		tagName := c.Param(""tagName"")
		if tagName == """" {
			return echo.NewHTTPError(http.StatusBadRequest, ""Tag name cannot be empty"")
		}
		tagDelete := &api.TagDelete{
			Name:      tagName,
			CreatorID: userID,
		}
		if err := s.Store.DeleteTag(ctx, tagDelete); err != nil {
			if common.ErrorCode(err) == common.NotFound {
				return echo.NewHTTPError(http.StatusNotFound, fmt.Sprintf(""Tag name not found: %s"", tagName))
			}
			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to delete tag name: %v"", tagName)).SetInternal(err)
		}
		return c.JSON(http.StatusOK, true)
	})
}
var tagRegexp = regexp.MustCompile(`
func findTagListFromMemoContent(memoContent string) []string {
	tagMapSet := make(map[string]bool)
	matches := tagRegexp.FindAllStringSubmatch(memoContent, -1)
	for _, v := range matches {
		tagName := v[1]
		tagMapSet[tagName] = true
	}
	tagList := []string{}
	for tag := range tagMapSet {
		tagList = append(tagList, tag)
	}
	sort.Strings(tagList)
	return tagList
}
",CWE-648,164.0,0
"package server
import (
	""encoding/json""
	""fmt""
	""net/http""
	""regexp""
	""sort""
	""strconv""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
)
func (s *Server) registerTagRoutes(g *echo.Group) {
	g.POST(""/tag"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		tagUpsert := &api.TagUpsert{}
		if err := json.NewDecoder(c.Request().Body).Decode(tagUpsert); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted post tag request"").SetInternal(err)
		}
		if tagUpsert.Name == """" {
			return echo.NewHTTPError(http.StatusBadRequest, ""Tag name shouldn't be empty"")
		}
		tagUpsert.CreatorID = userID
		tag, err := s.Store.UpsertTag(ctx, tagUpsert)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to upsert tag"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""tag created"",
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tag.Name)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode tag response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/tag"", func(c echo.Context) error {
		ctx := c.Request().Context()
		tagFind := &api.TagFind{}
		if userID, err := strconv.Atoi(c.QueryParam(""creatorId"")); err == nil {
			tagFind.CreatorID = userID
		}
		if tagFind.CreatorID == 0 {
			currentUserID, ok := c.Get(getUserIDContextKey()).(int)
			if !ok {
				return echo.NewHTTPError(http.StatusBadRequest, ""Missing user id to find tag"")
			}
			tagFind.CreatorID = currentUserID
		}
		tagList, err := s.Store.FindTagList(ctx, tagFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find tag list"").SetInternal(err)
		}
		tagNameList := []string{}
		for _, tag := range tagList {
			tagNameList = append(tagNameList, tag.Name)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tagNameList)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode tags response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/tag/suggestion"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusBadRequest, ""Missing user session"")
		}
		contentSearch := ""
		normalRowStatus := api.Normal
		memoFind := api.MemoFind{
			CreatorID:     &userID,
			ContentSearch: &contentSearch,
			RowStatus:     &normalRowStatus,
		}
		memoList, err := s.Store.FindMemoList(ctx, &memoFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find memo list"").SetInternal(err)
		}
		tagMapSet := make(map[string]bool)
		for _, memo := range memoList {
			for _, tag := range findTagListFromMemoContent(memo.Content) {
				tagMapSet[tag] = true
			}
		}
		tagList := []string{}
		for tag := range tagMapSet {
			tagList = append(tagList, tag)
		}
		sort.Strings(tagList)
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tagList)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode tags response"").SetInternal(err)
		}
		return nil
	})
	g.DELETE(""/tag/:tagName"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		tagName := c.Param(""tagName"")
		if tagName == """" {
			return echo.NewHTTPError(http.StatusBadRequest, ""Tag name cannot be empty"")
		}
		tagDelete := &api.TagDelete{
			Name:      tagName,
			CreatorID: userID,
		}
		if err := s.Store.DeleteTag(ctx, tagDelete); err != nil {
			if common.ErrorCode(err) == common.NotFound {
				return echo.NewHTTPError(http.StatusNotFound, fmt.Sprintf(""Tag name not found: %s"", tagName))
			}
			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to delete tag name: %v"", tagName)).SetInternal(err)
		}
		return c.JSON(http.StatusOK, true)
	})
}
var tagRegexp = regexp.MustCompile(`
func findTagListFromMemoContent(memoContent string) []string {
	tagMapSet := make(map[string]bool)
	matches := tagRegexp.FindAllStringSubmatch(memoContent, -1)
	for _, v := range matches {
		tagName := v[1]
		tagMapSet[tagName] = true
	}
	tagList := []string{}
	for tag := range tagMapSet {
		tagList = append(tagList, tag)
	}
	sort.Strings(tagList)
	return tagList
}
",CWE-307,164.0,0
"package server
import (
	""encoding/json""
	""fmt""
	""net/http""
	""regexp""
	""sort""
	""strconv""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
)
func (s *Server) registerTagRoutes(g *echo.Group) {
	g.POST(""/tag"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		tagUpsert := &api.TagUpsert{}
		if err := json.NewDecoder(c.Request().Body).Decode(tagUpsert); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted post tag request"").SetInternal(err)
		}
		if tagUpsert.Name == """" {
			return echo.NewHTTPError(http.StatusBadRequest, ""Tag name shouldn't be empty"")
		}
		tagUpsert.CreatorID = userID
		tag, err := s.Store.UpsertTag(ctx, tagUpsert)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to upsert tag"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""tag created"",
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tag.Name)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode tag response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/tag"", func(c echo.Context) error {
		ctx := c.Request().Context()
		tagFind := &api.TagFind{}
		if userID, err := strconv.Atoi(c.QueryParam(""creatorId"")); err == nil {
			tagFind.CreatorID = userID
		}
		if tagFind.CreatorID == 0 {
			currentUserID, ok := c.Get(getUserIDContextKey()).(int)
			if !ok {
				return echo.NewHTTPError(http.StatusBadRequest, ""Missing user id to find tag"")
			}
			tagFind.CreatorID = currentUserID
		}
		tagList, err := s.Store.FindTagList(ctx, tagFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find tag list"").SetInternal(err)
		}
		tagNameList := []string{}
		for _, tag := range tagList {
			tagNameList = append(tagNameList, tag.Name)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tagNameList)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode tags response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/tag/suggestion"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusBadRequest, ""Missing user session"")
		}
		contentSearch := ""
		normalRowStatus := api.Normal
		memoFind := api.MemoFind{
			CreatorID:     &userID,
			ContentSearch: &contentSearch,
			RowStatus:     &normalRowStatus,
		}
		memoList, err := s.Store.FindMemoList(ctx, &memoFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find memo list"").SetInternal(err)
		}
		tagMapSet := make(map[string]bool)
		for _, memo := range memoList {
			for _, tag := range findTagListFromMemoContent(memo.Content) {
				tagMapSet[tag] = true
			}
		}
		tagList := []string{}
		for tag := range tagMapSet {
			tagList = append(tagList, tag)
		}
		sort.Strings(tagList)
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tagList)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode tags response"").SetInternal(err)
		}
		return nil
	})
	g.DELETE(""/tag/:tagName"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		tagName := c.Param(""tagName"")
		if tagName == """" {
			return echo.NewHTTPError(http.StatusBadRequest, ""Tag name cannot be empty"")
		}
		tagDelete := &api.TagDelete{
			Name:      tagName,
			CreatorID: userID,
		}
		if err := s.Store.DeleteTag(ctx, tagDelete); err != nil {
			if common.ErrorCode(err) == common.NotFound {
				return echo.NewHTTPError(http.StatusNotFound, fmt.Sprintf(""Tag name not found: %s"", tagName))
			}
			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to delete tag name: %v"", tagName)).SetInternal(err)
		}
		return c.JSON(http.StatusOK, true)
	})
}
var tagRegexp = regexp.MustCompile(`
func findTagListFromMemoContent(memoContent string) []string {
	tagMapSet := make(map[string]bool)
	matches := tagRegexp.FindAllStringSubmatch(memoContent, -1)
	for _, v := range matches {
		tagName := v[1]
		tagMapSet[tagName] = true
	}
	tagList := []string{}
	for tag := range tagMapSet {
		tagList = append(tagList, tag)
	}
	sort.Strings(tagList)
	return tagList
}
",CWE-639,164.0,0
"package server
import (
	""encoding/json""
	""fmt""
	""net/http""
	""regexp""
	""sort""
	""strconv""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
)
func (s *Server) registerTagRoutes(g *echo.Group) {
	g.POST(""/tag"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		tagUpsert := &api.TagUpsert{}
		if err := json.NewDecoder(c.Request().Body).Decode(tagUpsert); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted post tag request"").SetInternal(err)
		}
		if tagUpsert.Name == """" {
			return echo.NewHTTPError(http.StatusBadRequest, ""Tag name shouldn't be empty"")
		}
		tagUpsert.CreatorID = userID
		tag, err := s.Store.UpsertTag(ctx, tagUpsert)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to upsert tag"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""tag created"",
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tag.Name)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode tag response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/tag"", func(c echo.Context) error {
		ctx := c.Request().Context()
		tagFind := &api.TagFind{}
		if userID, err := strconv.Atoi(c.QueryParam(""creatorId"")); err == nil {
			tagFind.CreatorID = userID
		}
		if tagFind.CreatorID == 0 {
			currentUserID, ok := c.Get(getUserIDContextKey()).(int)
			if !ok {
				return echo.NewHTTPError(http.StatusBadRequest, ""Missing user id to find tag"")
			}
			tagFind.CreatorID = currentUserID
		}
		tagList, err := s.Store.FindTagList(ctx, tagFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find tag list"").SetInternal(err)
		}
		tagNameList := []string{}
		for _, tag := range tagList {
			tagNameList = append(tagNameList, tag.Name)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tagNameList)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode tags response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/tag/suggestion"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusBadRequest, ""Missing user session"")
		}
		contentSearch := ""
		normalRowStatus := api.Normal
		memoFind := api.MemoFind{
			CreatorID:     &userID,
			ContentSearch: &contentSearch,
			RowStatus:     &normalRowStatus,
		}
		memoList, err := s.Store.FindMemoList(ctx, &memoFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find memo list"").SetInternal(err)
		}
		tagMapSet := make(map[string]bool)
		for _, memo := range memoList {
			for _, tag := range findTagListFromMemoContent(memo.Content) {
				tagMapSet[tag] = true
			}
		}
		tagList := []string{}
		for tag := range tagMapSet {
			tagList = append(tagList, tag)
		}
		sort.Strings(tagList)
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tagList)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode tags response"").SetInternal(err)
		}
		return nil
	})
	g.DELETE(""/tag/:tagName"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		tagName := c.Param(""tagName"")
		if tagName == """" {
			return echo.NewHTTPError(http.StatusBadRequest, ""Tag name cannot be empty"")
		}
		tagDelete := &api.TagDelete{
			Name:      tagName,
			CreatorID: userID,
		}
		if err := s.Store.DeleteTag(ctx, tagDelete); err != nil {
			if common.ErrorCode(err) == common.NotFound {
				return echo.NewHTTPError(http.StatusNotFound, fmt.Sprintf(""Tag name not found: %s"", tagName))
			}
			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to delete tag name: %v"", tagName)).SetInternal(err)
		}
		return c.JSON(http.StatusOK, true)
	})
}
var tagRegexp = regexp.MustCompile(`
func findTagListFromMemoContent(memoContent string) []string {
	tagMapSet := make(map[string]bool)
	matches := tagRegexp.FindAllStringSubmatch(memoContent, -1)
	for _, v := range matches {
		tagName := v[1]
		tagMapSet[tagName] = true
	}
	tagList := []string{}
	for tag := range tagMapSet {
		tagList = append(tagList, tag)
	}
	sort.Strings(tagList)
	return tagList
}
",CWE-940,164.0,0
"package server
import (
	""encoding/json""
	""fmt""
	""net/http""
	""regexp""
	""sort""
	""strconv""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
)
func (s *Server) registerTagRoutes(g *echo.Group) {
	g.POST(""/tag"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		tagUpsert := &api.TagUpsert{}
		if err := json.NewDecoder(c.Request().Body).Decode(tagUpsert); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted post tag request"").SetInternal(err)
		}
		if tagUpsert.Name == """" {
			return echo.NewHTTPError(http.StatusBadRequest, ""Tag name shouldn't be empty"")
		}
		tagUpsert.CreatorID = userID
		tag, err := s.Store.UpsertTag(ctx, tagUpsert)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to upsert tag"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""tag created"",
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tag.Name)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode tag response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/tag"", func(c echo.Context) error {
		ctx := c.Request().Context()
		tagFind := &api.TagFind{}
		if userID, err := strconv.Atoi(c.QueryParam(""creatorId"")); err == nil {
			tagFind.CreatorID = userID
		}
		if tagFind.CreatorID == 0 {
			currentUserID, ok := c.Get(getUserIDContextKey()).(int)
			if !ok {
				return echo.NewHTTPError(http.StatusBadRequest, ""Missing user id to find tag"")
			}
			tagFind.CreatorID = currentUserID
		}
		tagList, err := s.Store.FindTagList(ctx, tagFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find tag list"").SetInternal(err)
		}
		tagNameList := []string{}
		for _, tag := range tagList {
			tagNameList = append(tagNameList, tag.Name)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tagNameList)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode tags response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/tag/suggestion"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusBadRequest, ""Missing user session"")
		}
		contentSearch := ""
		normalRowStatus := api.Normal
		memoFind := api.MemoFind{
			CreatorID:     &userID,
			ContentSearch: &contentSearch,
			RowStatus:     &normalRowStatus,
		}
		memoList, err := s.Store.FindMemoList(ctx, &memoFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find memo list"").SetInternal(err)
		}
		tagMapSet := make(map[string]bool)
		for _, memo := range memoList {
			for _, tag := range findTagListFromMemoContent(memo.Content) {
				tagMapSet[tag] = true
			}
		}
		tagList := []string{}
		for tag := range tagMapSet {
			tagList = append(tagList, tag)
		}
		sort.Strings(tagList)
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tagList)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode tags response"").SetInternal(err)
		}
		return nil
	})
	g.DELETE(""/tag/:tagName"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		tagName := c.Param(""tagName"")
		if tagName == """" {
			return echo.NewHTTPError(http.StatusBadRequest, ""Tag name cannot be empty"")
		}
		tagDelete := &api.TagDelete{
			Name:      tagName,
			CreatorID: userID,
		}
		if err := s.Store.DeleteTag(ctx, tagDelete); err != nil {
			if common.ErrorCode(err) == common.NotFound {
				return echo.NewHTTPError(http.StatusNotFound, fmt.Sprintf(""Tag name not found: %s"", tagName))
			}
			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to delete tag name: %v"", tagName)).SetInternal(err)
		}
		return c.JSON(http.StatusOK, true)
	})
}
var tagRegexp = regexp.MustCompile(`
func findTagListFromMemoContent(memoContent string) []string {
	tagMapSet := make(map[string]bool)
	matches := tagRegexp.FindAllStringSubmatch(memoContent, -1)
	for _, v := range matches {
		tagName := v[1]
		tagMapSet[tagName] = true
	}
	tagList := []string{}
	for tag := range tagMapSet {
		tagList = append(tagList, tag)
	}
	sort.Strings(tagList)
	return tagList
}
",CWE-1220,164.0,0
"package server
import (
	""encoding/json""
	""fmt""
	""net/http""
	""regexp""
	""sort""
	""strconv""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
)
func (s *Server) registerTagRoutes(g *echo.Group) {
	g.POST(""/tag"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		tagUpsert := &api.TagUpsert{}
		if err := json.NewDecoder(c.Request().Body).Decode(tagUpsert); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted post tag request"").SetInternal(err)
		}
		if tagUpsert.Name == """" {
			return echo.NewHTTPError(http.StatusBadRequest, ""Tag name shouldn't be empty"")
		}
		tagUpsert.CreatorID = userID
		tag, err := s.Store.UpsertTag(ctx, tagUpsert)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to upsert tag"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""tag created"",
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tag.Name)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode tag response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/tag"", func(c echo.Context) error {
		ctx := c.Request().Context()
		tagFind := &api.TagFind{}
		if userID, err := strconv.Atoi(c.QueryParam(""creatorId"")); err == nil {
			tagFind.CreatorID = userID
		}
		if tagFind.CreatorID == 0 {
			currentUserID, ok := c.Get(getUserIDContextKey()).(int)
			if !ok {
				return echo.NewHTTPError(http.StatusBadRequest, ""Missing user id to find tag"")
			}
			tagFind.CreatorID = currentUserID
		}
		tagList, err := s.Store.FindTagList(ctx, tagFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find tag list"").SetInternal(err)
		}
		tagNameList := []string{}
		for _, tag := range tagList {
			tagNameList = append(tagNameList, tag.Name)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tagNameList)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode tags response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/tag/suggestion"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusBadRequest, ""Missing user session"")
		}
		contentSearch := ""
		normalRowStatus := api.Normal
		memoFind := api.MemoFind{
			CreatorID:     &userID,
			ContentSearch: &contentSearch,
			RowStatus:     &normalRowStatus,
		}
		memoList, err := s.Store.FindMemoList(ctx, &memoFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find memo list"").SetInternal(err)
		}
		tagMapSet := make(map[string]bool)
		for _, memo := range memoList {
			for _, tag := range findTagListFromMemoContent(memo.Content) {
				tagMapSet[tag] = true
			}
		}
		tagList := []string{}
		for tag := range tagMapSet {
			tagList = append(tagList, tag)
		}
		sort.Strings(tagList)
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tagList)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode tags response"").SetInternal(err)
		}
		return nil
	})
	g.DELETE(""/tag/:tagName"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		tagName := c.Param(""tagName"")
		if tagName == """" {
			return echo.NewHTTPError(http.StatusBadRequest, ""Tag name cannot be empty"")
		}
		tagDelete := &api.TagDelete{
			Name:      tagName,
			CreatorID: userID,
		}
		if err := s.Store.DeleteTag(ctx, tagDelete); err != nil {
			if common.ErrorCode(err) == common.NotFound {
				return echo.NewHTTPError(http.StatusNotFound, fmt.Sprintf(""Tag name not found: %s"", tagName))
			}
			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to delete tag name: %v"", tagName)).SetInternal(err)
		}
		return c.JSON(http.StatusOK, true)
	})
}
var tagRegexp = regexp.MustCompile(`
func findTagListFromMemoContent(memoContent string) []string {
	tagMapSet := make(map[string]bool)
	matches := tagRegexp.FindAllStringSubmatch(memoContent, -1)
	for _, v := range matches {
		tagName := v[1]
		tagMapSet[tagName] = true
	}
	tagList := []string{}
	for tag := range tagMapSet {
		tagList = append(tagList, tag)
	}
	sort.Strings(tagList)
	return tagList
}
",CWE-285,164.0,0
"package server
import (
	""encoding/json""
	""fmt""
	""net/http""
	""regexp""
	""sort""
	""strconv""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
)
func (s *Server) registerTagRoutes(g *echo.Group) {
	g.POST(""/tag"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		tagUpsert := &api.TagUpsert{}
		if err := json.NewDecoder(c.Request().Body).Decode(tagUpsert); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted post tag request"").SetInternal(err)
		}
		if tagUpsert.Name == """" {
			return echo.NewHTTPError(http.StatusBadRequest, ""Tag name shouldn't be empty"")
		}
		tagUpsert.CreatorID = userID
		tag, err := s.Store.UpsertTag(ctx, tagUpsert)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to upsert tag"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""tag created"",
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tag.Name)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode tag response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/tag"", func(c echo.Context) error {
		ctx := c.Request().Context()
		tagFind := &api.TagFind{}
		if userID, err := strconv.Atoi(c.QueryParam(""creatorId"")); err == nil {
			tagFind.CreatorID = userID
		}
		if tagFind.CreatorID == 0 {
			currentUserID, ok := c.Get(getUserIDContextKey()).(int)
			if !ok {
				return echo.NewHTTPError(http.StatusBadRequest, ""Missing user id to find tag"")
			}
			tagFind.CreatorID = currentUserID
		}
		tagList, err := s.Store.FindTagList(ctx, tagFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find tag list"").SetInternal(err)
		}
		tagNameList := []string{}
		for _, tag := range tagList {
			tagNameList = append(tagNameList, tag.Name)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tagNameList)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode tags response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/tag/suggestion"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusBadRequest, ""Missing user session"")
		}
		contentSearch := ""
		normalRowStatus := api.Normal
		memoFind := api.MemoFind{
			CreatorID:     &userID,
			ContentSearch: &contentSearch,
			RowStatus:     &normalRowStatus,
		}
		memoList, err := s.Store.FindMemoList(ctx, &memoFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find memo list"").SetInternal(err)
		}
		tagMapSet := make(map[string]bool)
		for _, memo := range memoList {
			for _, tag := range findTagListFromMemoContent(memo.Content) {
				tagMapSet[tag] = true
			}
		}
		tagList := []string{}
		for tag := range tagMapSet {
			tagList = append(tagList, tag)
		}
		sort.Strings(tagList)
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tagList)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode tags response"").SetInternal(err)
		}
		return nil
	})
	g.DELETE(""/tag/:tagName"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		tagName := c.Param(""tagName"")
		if tagName == """" {
			return echo.NewHTTPError(http.StatusBadRequest, ""Tag name cannot be empty"")
		}
		tagDelete := &api.TagDelete{
			Name:      tagName,
			CreatorID: userID,
		}
		if err := s.Store.DeleteTag(ctx, tagDelete); err != nil {
			if common.ErrorCode(err) == common.NotFound {
				return echo.NewHTTPError(http.StatusNotFound, fmt.Sprintf(""Tag name not found: %s"", tagName))
			}
			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to delete tag name: %v"", tagName)).SetInternal(err)
		}
		return c.JSON(http.StatusOK, true)
	})
}
var tagRegexp = regexp.MustCompile(`
func findTagListFromMemoContent(memoContent string) []string {
	tagMapSet := make(map[string]bool)
	matches := tagRegexp.FindAllStringSubmatch(memoContent, -1)
	for _, v := range matches {
		tagName := v[1]
		tagMapSet[tagName] = true
	}
	tagList := []string{}
	for tag := range tagMapSet {
		tagList = append(tagList, tag)
	}
	sort.Strings(tagList)
	return tagList
}
",CWE-284,164.0,0
"package server
import (
	""encoding/json""
	""fmt""
	""net/http""
	""regexp""
	""sort""
	""strconv""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
)
func (s *Server) registerTagRoutes(g *echo.Group) {
	g.POST(""/tag"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		tagUpsert := &api.TagUpsert{}
		if err := json.NewDecoder(c.Request().Body).Decode(tagUpsert); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted post tag request"").SetInternal(err)
		}
		if tagUpsert.Name == """" {
			return echo.NewHTTPError(http.StatusBadRequest, ""Tag name shouldn't be empty"")
		}
		tagUpsert.CreatorID = userID
		tag, err := s.Store.UpsertTag(ctx, tagUpsert)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to upsert tag"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""tag created"",
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tag.Name)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode tag response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/tag"", func(c echo.Context) error {
		ctx := c.Request().Context()
		tagFind := &api.TagFind{}
		if userID, err := strconv.Atoi(c.QueryParam(""creatorId"")); err == nil {
			tagFind.CreatorID = userID
		}
		if tagFind.CreatorID == 0 {
			currentUserID, ok := c.Get(getUserIDContextKey()).(int)
			if !ok {
				return echo.NewHTTPError(http.StatusBadRequest, ""Missing user id to find tag"")
			}
			tagFind.CreatorID = currentUserID
		}
		tagList, err := s.Store.FindTagList(ctx, tagFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find tag list"").SetInternal(err)
		}
		tagNameList := []string{}
		for _, tag := range tagList {
			tagNameList = append(tagNameList, tag.Name)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tagNameList)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode tags response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/tag/suggestion"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusBadRequest, ""Missing user session"")
		}
		contentSearch := ""
		normalRowStatus := api.Normal
		memoFind := api.MemoFind{
			CreatorID:     &userID,
			ContentSearch: &contentSearch,
			RowStatus:     &normalRowStatus,
		}
		memoList, err := s.Store.FindMemoList(ctx, &memoFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find memo list"").SetInternal(err)
		}
		tagMapSet := make(map[string]bool)
		for _, memo := range memoList {
			for _, tag := range findTagListFromMemoContent(memo.Content) {
				tagMapSet[tag] = true
			}
		}
		tagList := []string{}
		for tag := range tagMapSet {
			tagList = append(tagList, tag)
		}
		sort.Strings(tagList)
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tagList)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode tags response"").SetInternal(err)
		}
		return nil
	})
	g.DELETE(""/tag/:tagName"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		tagName := c.Param(""tagName"")
		if tagName == """" {
			return echo.NewHTTPError(http.StatusBadRequest, ""Tag name cannot be empty"")
		}
		tagDelete := &api.TagDelete{
			Name:      tagName,
			CreatorID: userID,
		}
		if err := s.Store.DeleteTag(ctx, tagDelete); err != nil {
			if common.ErrorCode(err) == common.NotFound {
				return echo.NewHTTPError(http.StatusNotFound, fmt.Sprintf(""Tag name not found: %s"", tagName))
			}
			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to delete tag name: %v"", tagName)).SetInternal(err)
		}
		return c.JSON(http.StatusOK, true)
	})
}
var tagRegexp = regexp.MustCompile(`
func findTagListFromMemoContent(memoContent string) []string {
	tagMapSet := make(map[string]bool)
	matches := tagRegexp.FindAllStringSubmatch(memoContent, -1)
	for _, v := range matches {
		tagName := v[1]
		tagMapSet[tagName] = true
	}
	tagList := []string{}
	for tag := range tagMapSet {
		tagList = append(tagList, tag)
	}
	sort.Strings(tagList)
	return tagList
}
",CWE-229,164.0,0
"package server
import (
	""encoding/json""
	""fmt""
	""net/http""
	""regexp""
	""sort""
	""strconv""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/labstack/echo/v4""
)
func (s *Server) registerTagRoutes(g *echo.Group) {
	g.POST(""/tag"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		tagUpsert := &api.TagUpsert{}
		if err := json.NewDecoder(c.Request().Body).Decode(tagUpsert); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, ""Malformatted post tag request"").SetInternal(err)
		}
		if tagUpsert.Name == """" {
			return echo.NewHTTPError(http.StatusBadRequest, ""Tag name shouldn't be empty"")
		}
		tagUpsert.CreatorID = userID
		tag, err := s.Store.UpsertTag(ctx, tagUpsert)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to upsert tag"").SetInternal(err)
		}
		s.Collector.Collect(ctx, &metric.Metric{
			Name: ""tag created"",
		})
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tag.Name)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode tag response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/tag"", func(c echo.Context) error {
		ctx := c.Request().Context()
		tagFind := &api.TagFind{}
		if userID, err := strconv.Atoi(c.QueryParam(""creatorId"")); err == nil {
			tagFind.CreatorID = userID
		}
		if tagFind.CreatorID == 0 {
			currentUserID, ok := c.Get(getUserIDContextKey()).(int)
			if !ok {
				return echo.NewHTTPError(http.StatusBadRequest, ""Missing user id to find tag"")
			}
			tagFind.CreatorID = currentUserID
		}
		tagList, err := s.Store.FindTagList(ctx, tagFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find tag list"").SetInternal(err)
		}
		tagNameList := []string{}
		for _, tag := range tagList {
			tagNameList = append(tagNameList, tag.Name)
		}
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tagNameList)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode tags response"").SetInternal(err)
		}
		return nil
	})
	g.GET(""/tag/suggestion"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusBadRequest, ""Missing user session"")
		}
		contentSearch := ""
		normalRowStatus := api.Normal
		memoFind := api.MemoFind{
			CreatorID:     &userID,
			ContentSearch: &contentSearch,
			RowStatus:     &normalRowStatus,
		}
		memoList, err := s.Store.FindMemoList(ctx, &memoFind)
		if err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find memo list"").SetInternal(err)
		}
		tagMapSet := make(map[string]bool)
		for _, memo := range memoList {
			for _, tag := range findTagListFromMemoContent(memo.Content) {
				tagMapSet[tag] = true
			}
		}
		tagList := []string{}
		for tag := range tagMapSet {
			tagList = append(tagList, tag)
		}
		sort.Strings(tagList)
		c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
		if err := json.NewEncoder(c.Response().Writer).Encode(composeResponse(tagList)); err != nil {
			return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to encode tags response"").SetInternal(err)
		}
		return nil
	})
	g.DELETE(""/tag/:tagName"", func(c echo.Context) error {
		ctx := c.Request().Context()
		userID, ok := c.Get(getUserIDContextKey()).(int)
		if !ok {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		tagName := c.Param(""tagName"")
		if tagName == """" {
			return echo.NewHTTPError(http.StatusBadRequest, ""Tag name cannot be empty"")
		}
		tagDelete := &api.TagDelete{
			Name:      tagName,
			CreatorID: userID,
		}
		if err := s.Store.DeleteTag(ctx, tagDelete); err != nil {
			if common.ErrorCode(err) == common.NotFound {
				return echo.NewHTTPError(http.StatusNotFound, fmt.Sprintf(""Tag name not found: %s"", tagName))
			}
			return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to delete tag name: %v"", tagName)).SetInternal(err)
		}
		return c.JSON(http.StatusOK, true)
	})
}
var tagRegexp = regexp.MustCompile(`
func findTagListFromMemoContent(memoContent string) []string {
	tagMapSet := make(map[string]bool)
	matches := tagRegexp.FindAllStringSubmatch(memoContent, -1)
	for _, v := range matches {
		tagName := v[1]
		tagMapSet[tagName] = true
	}
	tagList := []string{}
	for tag := range tagMapSet {
		tagList = append(tagList, tag)
	}
	sort.Strings(tagList)
	return tagList
}
",CWE-280,164.0,0
"package server
import (
	""fmt""
	""net/http""
	""strconv""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	""github.com/gorilla/sessions""
	""github.com/labstack/echo-contrib/session""
	""github.com/labstack/echo/v4""
)
var (
	userIDContextKey = ""user-id""
)
func getUserIDContextKey() string {
	return userIDContextKey
}
func setUserSession(ctx echo.Context, user *api.User) error {
	sess, _ := session.Get(""memos_session"", ctx)
	sess.Options = &sessions.Options{
		Path:     ""/"",
		MaxAge:   3600 * 24 * 30,
		HttpOnly: true,
		SameSite: http.SameSiteStrictMode,
	}
	sess.Values[userIDContextKey] = user.ID
	err := sess.Save(ctx.Request(), ctx.Response())
	if err != nil {
		return fmt.Errorf(""failed to set session, err: %w"", err)
	}
	return nil
}
func removeUserSession(ctx echo.Context) error {
	sess, _ := session.Get(""memos_session"", ctx)
	sess.Options = &sessions.Options{
		Path:     ""/"",
		MaxAge:   0,
		HttpOnly: true,
	}
	sess.Values[userIDContextKey] = nil
	err := sess.Save(ctx.Request(), ctx.Response())
	if err != nil {
		return fmt.Errorf(""failed to set session, err: %w"", err)
	}
	return nil
}
func aclMiddleware(s *Server, next echo.HandlerFunc) echo.HandlerFunc {
	return func(c echo.Context) error {
		ctx := c.Request().Context()
		path := c.Path()
		// Skip auth.
		if common.HasPrefixes(path, ""/api/auth"") {
			return next(c)
		}
		{
			// If there is openId in query string and related user is found, then skip auth.
			openID := c.QueryParam(""openId"")
			if openID != """" {
				userFind := &api.UserFind{
					OpenID: &openID,
				}
				user, err := s.Store.FindUser(ctx, userFind)
				if err != nil && common.ErrorCode(err) != common.NotFound {
					return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find user by open_id"").SetInternal(err)
				}
				if user != nil {
					// Stores userID into context.
					c.Set(getUserIDContextKey(), user.ID)
					return next(c)
				}
			}
		}
		{
			sess, _ := session.Get(""memos_session"", c)
			userIDValue := sess.Values[userIDContextKey]
			if userIDValue != nil {
				userID, _ := strconv.Atoi(fmt.Sprintf(""%v"", userIDValue))
				userFind := &api.UserFind{
					ID: &userID,
				}
				user, err := s.Store.FindUser(ctx, userFind)
				if err != nil && common.ErrorCode(err) != common.NotFound {
					return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to find user by ID: %d"", userID)).SetInternal(err)
				}
				if user != nil {
					if user.RowStatus == api.Archived {
						return echo.NewHTTPError(http.StatusForbidden, fmt.Sprintf(""User has been archived with username %s"", user.Username))
					}
					c.Set(getUserIDContextKey(), userID)
				}
			}
		}
		if common.HasPrefixes(path, ""/api/ping"", ""/api/status"", ""/api/user/:id"", ""/api/memo/all"", ""/api/memo/:memoId"", ""/api/memo/amount"") && c.Request().Method == http.MethodGet {
			return next(c)
		}
		if common.HasPrefixes(path, ""/api/memo"", ""/api/tag"", ""/api/shortcut"") && c.Request().Method == http.MethodGet {
			if _, err := strconv.Atoi(c.QueryParam(""creatorId"")); err == nil {
				return next(c)
			}
		}
		userID := c.Get(getUserIDContextKey())
		if userID == nil {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		return next(c)
	}
}
",CWE-352,123.0,0
"package server
import (
	""fmt""
	""net/http""
	""strconv""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	""github.com/gorilla/sessions""
	""github.com/labstack/echo-contrib/session""
	""github.com/labstack/echo/v4""
)
var (
	userIDContextKey = ""user-id""
)
func getUserIDContextKey() string {
	return userIDContextKey
}
func setUserSession(ctx echo.Context, user *api.User) error {
	sess, _ := session.Get(""memos_session"", ctx)
	sess.Options = &sessions.Options{
		Path:     ""/"",
		MaxAge:   3600 * 24 * 30,
		HttpOnly: true,
		SameSite: http.SameSiteStrictMode,
	}
	sess.Values[userIDContextKey] = user.ID
	err := sess.Save(ctx.Request(), ctx.Response())
	if err != nil {
		return fmt.Errorf(""failed to set session, err: %w"", err)
	}
	return nil
}
func removeUserSession(ctx echo.Context) error {
	sess, _ := session.Get(""memos_session"", ctx)
	sess.Options = &sessions.Options{
		Path:     ""/"",
		MaxAge:   0,
		HttpOnly: true,
	}
	sess.Values[userIDContextKey] = nil
	err := sess.Save(ctx.Request(), ctx.Response())
	if err != nil {
		return fmt.Errorf(""failed to set session, err: %w"", err)
	}
	return nil
}
func aclMiddleware(s *Server, next echo.HandlerFunc) echo.HandlerFunc {
	return func(c echo.Context) error {
		ctx := c.Request().Context()
		path := c.Path()
		// Skip auth.
		if common.HasPrefixes(path, ""/api/auth"") {
			return next(c)
		}
		{
			// If there is openId in query string and related user is found, then skip auth.
			openID := c.QueryParam(""openId"")
			if openID != """" {
				userFind := &api.UserFind{
					OpenID: &openID,
				}
				user, err := s.Store.FindUser(ctx, userFind)
				if err != nil && common.ErrorCode(err) != common.NotFound {
					return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find user by open_id"").SetInternal(err)
				}
				if user != nil {
					// Stores userID into context.
					c.Set(getUserIDContextKey(), user.ID)
					return next(c)
				}
			}
		}
		{
			sess, _ := session.Get(""memos_session"", c)
			userIDValue := sess.Values[userIDContextKey]
			if userIDValue != nil {
				userID, _ := strconv.Atoi(fmt.Sprintf(""%v"", userIDValue))
				userFind := &api.UserFind{
					ID: &userID,
				}
				user, err := s.Store.FindUser(ctx, userFind)
				if err != nil && common.ErrorCode(err) != common.NotFound {
					return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to find user by ID: %d"", userID)).SetInternal(err)
				}
				if user != nil {
					if user.RowStatus == api.Archived {
						return echo.NewHTTPError(http.StatusForbidden, fmt.Sprintf(""User has been archived with username %s"", user.Username))
					}
					c.Set(getUserIDContextKey(), userID)
				}
			}
		}
		if common.HasPrefixes(path, ""/api/ping"", ""/api/status"", ""/api/user/:id"", ""/api/memo/all"", ""/api/memo/:memoId"", ""/api/memo/amount"") && c.Request().Method == http.MethodGet {
			return next(c)
		}
		if common.HasPrefixes(path, ""/api/memo"", ""/api/tag"", ""/api/shortcut"") && c.Request().Method == http.MethodGet {
			if _, err := strconv.Atoi(c.QueryParam(""creatorId"")); err == nil {
				return next(c)
			}
		}
		userID := c.Get(getUserIDContextKey())
		if userID == nil {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		return next(c)
	}
}
",CWE-941,123.0,0
"package server
import (
	""fmt""
	""net/http""
	""strconv""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
	""github.com/gorilla/sessions""
	""github.com/labstack/echo-contrib/session""
	""github.com/labstack/echo/v4""
)
var (
	userIDContextKey = ""user-id""
)
func getUserIDContextKey() string {
	return userIDContextKey
}
func setUserSession(ctx echo.Context, user *api.User) error {
	sess, _ := session.Get(""memos_session"", ctx)
	sess.Options = &sessions.Options{
		Path:     ""/"",
		MaxAge:   3600 * 24 * 30,
		HttpOnly: true,
		SameSite: http.SameSiteStrictMode,
	}
	sess.Values[userIDContextKey] = user.ID
	err := sess.Save(ctx.Request(), ctx.Response())
	if err != nil {
		return fmt.Errorf(""failed to set session, err: %w"", err)
	}
	return nil
}
func removeUserSession(ctx echo.Context) error {
	sess, _ := session.Get(""memos_session"", ctx)
	sess.Options = &sessions.Options{
		Path:     ""/"",
		MaxAge:   0,
		HttpOnly: true,
	}
	sess.Values[userIDContextKey] = nil
	err := sess.Save(ctx.Request(), ctx.Response())
	if err != nil {
		return fmt.Errorf(""failed to set session, err: %w"", err)
	}
	return nil
}
func aclMiddleware(s *Server, next echo.HandlerFunc) echo.HandlerFunc {
	return func(c echo.Context) error {
		ctx := c.Request().Context()
		path := c.Path()
		// Skip auth.
		if common.HasPrefixes(path, ""/api/auth"") {
			return next(c)
		}
		{
			// If there is openId in query string and related user is found, then skip auth.
			openID := c.QueryParam(""openId"")
			if openID != """" {
				userFind := &api.UserFind{
					OpenID: &openID,
				}
				user, err := s.Store.FindUser(ctx, userFind)
				if err != nil && common.ErrorCode(err) != common.NotFound {
					return echo.NewHTTPError(http.StatusInternalServerError, ""Failed to find user by open_id"").SetInternal(err)
				}
				if user != nil {
					// Stores userID into context.
					c.Set(getUserIDContextKey(), user.ID)
					return next(c)
				}
			}
		}
		{
			sess, _ := session.Get(""memos_session"", c)
			userIDValue := sess.Values[userIDContextKey]
			if userIDValue != nil {
				userID, _ := strconv.Atoi(fmt.Sprintf(""%v"", userIDValue))
				userFind := &api.UserFind{
					ID: &userID,
				}
				user, err := s.Store.FindUser(ctx, userFind)
				if err != nil && common.ErrorCode(err) != common.NotFound {
					return echo.NewHTTPError(http.StatusInternalServerError, fmt.Sprintf(""Failed to find user by ID: %d"", userID)).SetInternal(err)
				}
				if user != nil {
					if user.RowStatus == api.Archived {
						return echo.NewHTTPError(http.StatusForbidden, fmt.Sprintf(""User has been archived with username %s"", user.Username))
					}
					c.Set(getUserIDContextKey(), userID)
				}
			}
		}
		if common.HasPrefixes(path, ""/api/ping"", ""/api/status"", ""/api/user/:id"", ""/api/memo/all"", ""/api/memo/:memoId"", ""/api/memo/amount"") && c.Request().Method == http.MethodGet {
			return next(c)
		}
		if common.HasPrefixes(path, ""/api/memo"", ""/api/tag"", ""/api/shortcut"") && c.Request().Method == http.MethodGet {
			if _, err := strconv.Atoi(c.QueryParam(""creatorId"")); err == nil {
				return next(c)
			}
		}
		userID := c.Get(getUserIDContextKey())
		if userID == nil {
			return echo.NewHTTPError(http.StatusUnauthorized, ""Missing user in session"")
		}
		return next(c)
	}
}
",CWE-940,123.0,0
"package server
import (
	""fmt""
	""time""
	""github.com/usememos/memos/server/profile""
	""github.com/usememos/memos/store""
	""github.com/gorilla/securecookie""
	""github.com/gorilla/sessions""
	""github.com/labstack/echo-contrib/session""
	""github.com/labstack/echo/v4""
	""github.com/labstack/echo/v4/middleware""
)
type Server struct {
	e *echo.Echo
	Collector *MetricCollector
	Profile *profile.Profile
	Store *store.Store
}
func NewServer(profile *profile.Profile) *Server {
	e := echo.New()
	e.Debug = true
	e.HideBanner = true
	e.HidePort = true
	e.Use(middleware.LoggerWithConfig(middleware.LoggerConfig{
		Format: `{""time"":""${time_rfc3339}"",` +
			`""method"":""${method}"",""uri"":""${uri}"",` +
			`""status"":${status},""error"":""${error}""}` + ""\n"",
	}))
	e.Use(middleware.CSRFWithConfig(middleware.CSRFConfig{
		TokenLookup: ""cookie:_csrf"",
	}))
	e.Use(middleware.CORS())
	e.Use(middleware.TimeoutWithConfig(middleware.TimeoutConfig{
		Skipper:      middleware.DefaultSkipper,
		ErrorMessage: ""Request timeout"",
		Timeout:      30 * time.Second,
	}))
	embedFrontend(e)
	// In dev mode, set the const secret key to make signin session persistence.
	secret := []byte(""usememos"")
	if profile.Mode == ""prod"" {
		secret = securecookie.GenerateRandomKey(16)
	}
	e.Use(session.Middleware(sessions.NewCookieStore(secret)))
	s := &Server{
		e:       e,
		Profile: profile,
	}
	rootGroup := e.Group("""")
	s.registerRSSRoutes(rootGroup)
	webhookGroup := e.Group(""/h"")
	s.registerResourcePublicRoutes(webhookGroup)
	publicGroup := e.Group(""/o"")
	s.registerResourcePublicRoutes(publicGroup)
	s.registerGetterPublicRoutes(publicGroup)
	apiGroup := e.Group(""/api"")
	apiGroup.Use(func(next echo.HandlerFunc) echo.HandlerFunc {
		return aclMiddleware(s, next)
	})
	s.registerSystemRoutes(apiGroup)
	s.registerAuthRoutes(apiGroup)
	s.registerUserRoutes(apiGroup)
	s.registerMemoRoutes(apiGroup)
	s.registerShortcutRoutes(apiGroup)
	s.registerResourceRoutes(apiGroup)
	s.registerTagRoutes(apiGroup)
	return s
}
func (server *Server) Run() error {
	return server.e.Start(fmt.Sprintf("":%d"", server.Profile.Port))
}
",CWE-352,93.0,0
"package server
import (
	""fmt""
	""time""
	""github.com/usememos/memos/server/profile""
	""github.com/usememos/memos/store""
	""github.com/gorilla/securecookie""
	""github.com/gorilla/sessions""
	""github.com/labstack/echo-contrib/session""
	""github.com/labstack/echo/v4""
	""github.com/labstack/echo/v4/middleware""
)
type Server struct {
	e *echo.Echo
	Collector *MetricCollector
	Profile *profile.Profile
	Store *store.Store
}
func NewServer(profile *profile.Profile) *Server {
	e := echo.New()
	e.Debug = true
	e.HideBanner = true
	e.HidePort = true
	e.Use(middleware.LoggerWithConfig(middleware.LoggerConfig{
		Format: `{""time"":""${time_rfc3339}"",` +
			`""method"":""${method}"",""uri"":""${uri}"",` +
			`""status"":${status},""error"":""${error}""}` + ""\n"",
	}))
	e.Use(middleware.CSRFWithConfig(middleware.CSRFConfig{
		TokenLookup: ""cookie:_csrf"",
	}))
	e.Use(middleware.CORS())
	e.Use(middleware.TimeoutWithConfig(middleware.TimeoutConfig{
		Skipper:      middleware.DefaultSkipper,
		ErrorMessage: ""Request timeout"",
		Timeout:      30 * time.Second,
	}))
	embedFrontend(e)
	// In dev mode, set the const secret key to make signin session persistence.
	secret := []byte(""usememos"")
	if profile.Mode == ""prod"" {
		secret = securecookie.GenerateRandomKey(16)
	}
	e.Use(session.Middleware(sessions.NewCookieStore(secret)))
	s := &Server{
		e:       e,
		Profile: profile,
	}
	rootGroup := e.Group("""")
	s.registerRSSRoutes(rootGroup)
	webhookGroup := e.Group(""/h"")
	s.registerResourcePublicRoutes(webhookGroup)
	publicGroup := e.Group(""/o"")
	s.registerResourcePublicRoutes(publicGroup)
	s.registerGetterPublicRoutes(publicGroup)
	apiGroup := e.Group(""/api"")
	apiGroup.Use(func(next echo.HandlerFunc) echo.HandlerFunc {
		return aclMiddleware(s, next)
	})
	s.registerSystemRoutes(apiGroup)
	s.registerAuthRoutes(apiGroup)
	s.registerUserRoutes(apiGroup)
	s.registerMemoRoutes(apiGroup)
	s.registerShortcutRoutes(apiGroup)
	s.registerResourceRoutes(apiGroup)
	s.registerTagRoutes(apiGroup)
	return s
}
func (server *Server) Run() error {
	return server.e.Start(fmt.Sprintf("":%d"", server.Profile.Port))
}
",CWE-941,93.0,0
"package server
import (
	""fmt""
	""time""
	""github.com/usememos/memos/server/profile""
	""github.com/usememos/memos/store""
	""github.com/gorilla/securecookie""
	""github.com/gorilla/sessions""
	""github.com/labstack/echo-contrib/session""
	""github.com/labstack/echo/v4""
	""github.com/labstack/echo/v4/middleware""
)
type Server struct {
	e *echo.Echo
	Collector *MetricCollector
	Profile *profile.Profile
	Store *store.Store
}
func NewServer(profile *profile.Profile) *Server {
	e := echo.New()
	e.Debug = true
	e.HideBanner = true
	e.HidePort = true
	e.Use(middleware.LoggerWithConfig(middleware.LoggerConfig{
		Format: `{""time"":""${time_rfc3339}"",` +
			`""method"":""${method}"",""uri"":""${uri}"",` +
			`""status"":${status},""error"":""${error}""}` + ""\n"",
	}))
	e.Use(middleware.CSRFWithConfig(middleware.CSRFConfig{
		TokenLookup: ""cookie:_csrf"",
	}))
	e.Use(middleware.CORS())
	e.Use(middleware.TimeoutWithConfig(middleware.TimeoutConfig{
		Skipper:      middleware.DefaultSkipper,
		ErrorMessage: ""Request timeout"",
		Timeout:      30 * time.Second,
	}))
	embedFrontend(e)
	// In dev mode, set the const secret key to make signin session persistence.
	secret := []byte(""usememos"")
	if profile.Mode == ""prod"" {
		secret = securecookie.GenerateRandomKey(16)
	}
	e.Use(session.Middleware(sessions.NewCookieStore(secret)))
	s := &Server{
		e:       e,
		Profile: profile,
	}
	rootGroup := e.Group("""")
	s.registerRSSRoutes(rootGroup)
	webhookGroup := e.Group(""/h"")
	s.registerResourcePublicRoutes(webhookGroup)
	publicGroup := e.Group(""/o"")
	s.registerResourcePublicRoutes(publicGroup)
	s.registerGetterPublicRoutes(publicGroup)
	apiGroup := e.Group(""/api"")
	apiGroup.Use(func(next echo.HandlerFunc) echo.HandlerFunc {
		return aclMiddleware(s, next)
	})
	s.registerSystemRoutes(apiGroup)
	s.registerAuthRoutes(apiGroup)
	s.registerUserRoutes(apiGroup)
	s.registerMemoRoutes(apiGroup)
	s.registerShortcutRoutes(apiGroup)
	s.registerResourceRoutes(apiGroup)
	s.registerTagRoutes(apiGroup)
	return s
}
func (server *Server) Run() error {
	return server.e.Start(fmt.Sprintf("":%d"", server.Profile.Port))
}
",CWE-940,93.0,0
"package server
import (
	""net/http""
	""github.com/labstack/echo/v4""
	""github.com/usememos/memos/api""
	""github.com/usememos/memos/common""
)
type response struct {
	Data interface{} `json:""data""`
}
func composeResponse(data interface{}) response {
	return response{
		Data: data,
	}
}
func DefaultGetRequestSkipper(c echo.Context) bool {
	return c.Request().Method == http.MethodGet
}
func (server *Server) DefaultAuthSkipper(c echo.Context) bool {
	ctx := c.Request().Context()
	path := c.Path()
	// Skip auth.
	if common.HasPrefixes(path, ""/api/auth"") {
		return true
	}
	// If there is openId in query string and related user is found, then skip auth.
	openID := c.QueryParam(""openId"")
	if openID != """" {
		userFind := &api.UserFind{
			OpenID: &openID,
		}
		user, err := server.Store.FindUser(ctx, userFind)
		if err != nil && common.ErrorCode(err) != common.NotFound {
			return false
		}
		if user != nil {
			// Stores userID into context.
			c.Set(getUserIDContextKey(), user.ID)
			return true
		}
	}
	return false
}
",CWE-79,53.0,0
"package server
import (
	""context""
	""encoding/json""
	""fmt""
	""time""
	""github.com/pkg/errors""
	""github.com/usememos/memos/api""
	metric ""github.com/usememos/memos/plugin/metrics""
	""github.com/usememos/memos/server/profile""
	""github.com/usememos/memos/store""
	""github.com/usememos/memos/store/db""
	""github.com/gorilla/sessions""
	""github.com/labstack/echo-contrib/session""
	""github.com/labstack/echo/v4""
	""github.com/labstack/echo/v4/middleware""
)
type Server struct {
	e *echo.Echo
	ID        string
	Profile   *profile.Profile
	Store     *store.Store
	Collector *MetricCollector
}
func NewServer(ctx context.Context, profile *profile.Profile) (*Server, error) {
	e := echo.New()
	e.Debug = true
	e.HideBanner = true
	e.HidePort = true
	s := &Server{
		e:       e,
		Profile: profile,
	}
	db := db.NewDB(profile)
	if err := db.Open(ctx); err != nil {
		return nil, errors.Wrap(err, ""cannot open db"")
	}
	storeInstance := store.New(db.DBInstance, profile)
	s.Store = storeInstance
	e.Use(middleware.LoggerWithConfig(middleware.LoggerConfig{
		Format: `{""time"":""${time_rfc3339}"",` +
			`""method"":""${method}"",""uri"":""${uri}"",` +
			`""status"":${status},""error"":""${error}""}` + ""\n"",
	}))
	e.Use(middleware.Gzip())
	e.Use(middleware.CSRFWithConfig(middleware.CSRFConfig{
		Skipper: func(c echo.Context) bool {
			return s.DefaultAuthSkipper(c)
		},
		TokenLookup: ""cookie:_csrf"",
	}))
	e.Use(middleware.CORS())
	e.Use(middleware.SecureWithConfig(middleware.SecureConfig{
		Skipper:            DefaultGetRequestSkipper,
		XSSProtection:      ""1; mode=block"",
		ContentTypeNosniff: ""nosniff"",
		XFrameOptions:      ""SAMEORIGIN"",
		HSTSPreloadEnabled: false,
	}))
	e.Use(middleware.TimeoutWithConfig(middleware.TimeoutConfig{
		Skipper:      middleware.DefaultSkipper,
		ErrorMessage: ""Request timeout"",
		Timeout:      30 * time.Second,
	}))
	serverID, err := s.getSystemServerID(ctx)
	if err != nil {
		return nil, err
	}
	s.ID = serverID
	secretSessionName := ""usememos""
	if profile.Mode == ""prod"" {
		secretSessionName, err = s.getSystemSecretSessionName(ctx)
		if err != nil {
			return nil, err
		}
	}
	e.Use(session.Middleware(sessions.NewCookieStore([]byte(secretSessionName))))
	embedFrontend(e)
	// Register MetricCollector to server.
	s.registerMetricCollector()
	rootGroup := e.Group("""")
	s.registerRSSRoutes(rootGroup)
	webhookGroup := e.Group(""/h"")
	s.registerResourcePublicRoutes(webhookGroup)
	publicGroup := e.Group(""/o"")
	s.registerResourcePublicRoutes(publicGroup)
	registerGetterPublicRoutes(publicGroup)
	apiGroup := e.Group(""/api"")
	apiGroup.Use(func(next echo.HandlerFunc) echo.HandlerFunc {
		return aclMiddleware(s, next)
	})
	s.registerSystemRoutes(apiGroup)
	s.registerAuthRoutes(apiGroup)
	s.registerUserRoutes(apiGroup)
	s.registerMemoRoutes(apiGroup)
	s.registerShortcutRoutes(apiGroup)
	s.registerResourceRoutes(apiGroup)
	s.registerTagRoutes(apiGroup)
	return s, nil
}
func (s *Server) Run(ctx context.Context) error {
	if err := s.createServerStartActivity(ctx); err != nil {
		return errors.Wrap(err, ""failed to create activity"")
	}
	s.Collector.Identify(ctx)
	return s.e.Start(fmt.Sprintf("":%d"", s.Profile.Port))
}
func (s *Server) createServerStartActivity(ctx context.Context) error {
	payload := api.ActivityServerStartPayload{
		ServerID: s.ID,
		Profile:  s.Profile,
	}
	payloadStr, err := json.Marshal(payload)
	if err != nil {
		return errors.Wrap(err, ""failed to marshal activity payload"")
	}
	activity, err := s.Store.CreateActivity(ctx, &api.ActivityCreate{
		CreatorID: api.UnknownID,
		Type:      api.ActivityServerStart,
		Level:     api.ActivityInfo,
		Payload:   string(payloadStr),
	})
	s.Collector.Collect(ctx, &metric.Metric{
		Name: string(activity.Type),
	})
	return err
}
",CWE-79,154.0,0
"package version
import (
	""strconv""
	""strings""
)
// Version is the service current released version.
// Semantic versioning: https://semver.org/
var Version = ""0.10.0""
// DevVersion is the service current development version.
var DevVersion = ""0.10.0""
func GetCurrentVersion(mode string) string {
	if mode == ""dev"" {
		return DevVersion
	}
	return Version
}
func GetMinorVersion(version string) string {
	versionList := strings.Split(version, ""."")
	if len(versionList) < 3 {
		return """"
	}
	return versionList[0] + ""."" + versionList[1]
}
func GetSchemaVersion(version string) string {
	minorVersion := GetMinorVersion(version)
	return minorVersion + "".0""
}
// convSemanticVersionToInt converts version string to int.
func convSemanticVersionToInt(version string) int {
	versionList := strings.Split(version, ""."")
	if len(versionList) < 3 {
		return 0
	}
	major, err := strconv.Atoi(versionList[0])
	if err != nil {
		return 0
	}
	minor, err := strconv.Atoi(versionList[1])
	if err != nil {
		return 0
	}
	patch, err := strconv.Atoi(versionList[2])
	if err != nil {
		return 0
	}
	return major*10000 + minor*100 + patch
}
// IsVersionGreaterThanOrEqualTo returns true if version is greater than or equal to target.
func IsVersionGreaterOrEqualThan(version, target string) bool {
	return convSemanticVersionToInt(version) >= convSemanticVersionToInt(target)
}
// IsVersionGreaterThan returns true if version is greater than target.
func IsVersionGreaterThan(version, target string) bool {
	return convSemanticVersionToInt(version) > convSemanticVersionToInt(target)
}
",CWE-79,67.0,0
"package version
import ""testing""
func TestIsVersionGreaterOrEqualThan(t *testing.T) {
	tests := []struct {
		version string
		target  string
		want    bool
	}{
		{
			version: ""0.9.1"",
			target:  ""0.9.1"",
			want:    true,
		},
		{
			version: ""0.10.0"",
			target:  ""0.9.1"",
			want:    true,
		},
		{
			version: ""0.9.0"",
			target:  ""0.9.1"",
			want:    false,
		},
	}
	for _, test := range tests {
		result := IsVersionGreaterOrEqualThan(test.version, test.target)
		if result != test.want {
			t.Errorf(""got result %v, want %v."", result, test.want)
		}
	}
}
",CWE-79,34.0,0
"module github.com/usememos/memos
go 1.21
require (
	github.com/aws/aws-sdk-go-v2 v1.17.4
	github.com/aws/aws-sdk-go-v2/config v1.18.12
	github.com/aws/aws-sdk-go-v2/credentials v1.13.12
	github.com/aws/aws-sdk-go-v2/feature/s3/manager v1.11.51
	github.com/aws/aws-sdk-go-v2/service/s3 v1.30.3
	github.com/disintegration/imaging v1.6.2
	github.com/google/cel-go v0.17.1
	github.com/google/uuid v1.3.0
	github.com/gorilla/feeds v1.1.1
	github.com/grpc-ecosystem/grpc-gateway/v2 v2.16.2
	github.com/improbable-eng/grpc-web v0.15.0
	github.com/labstack/echo/v4 v4.11.1
	github.com/microcosm-cc/bluemonday v1.0.25
	github.com/pkg/errors v0.9.1
	github.com/spf13/cobra v1.6.1
	github.com/spf13/viper v1.15.0
	github.com/stretchr/testify v1.8.4
	github.com/swaggo/echo-swagger v1.4.0
	github.com/swaggo/swag v1.16.1
	github.com/yuin/goldmark v1.5.4
	go.uber.org/zap v1.24.0
	golang.org/x/crypto v0.13.0
	golang.org/x/exp v0.0.0-20230111222715-75897c7a292a
	golang.org/x/mod v0.12.0
	golang.org/x/net v0.15.0
	golang.org/x/oauth2 v0.10.0
	google.golang.org/genproto/googleapis/api v0.0.0-20230726155614-23370e0ffb3e
	google.golang.org/grpc v1.57.0
	modernc.org/sqlite v1.24.0
)
require (
	github.com/KyleBanks/depth v1.2.1 // indirect
	github.com/antlr/antlr4/runtime/Go/antlr/v4 v4.0.0-20230305170008-8188dc5388df // indirect
	github.com/aymerick/douceur v0.2.0 // indirect
	github.com/cenkalti/backoff/v4 v4.1.1 // indirect
	github.com/desertbit/timer v0.0.0-20180107155436-c41aec40b27f // indirect
	github.com/dustin/go-humanize v1.0.1 // indirect
	github.com/go-openapi/jsonpointer v0.20.0 // indirect
	github.com/go-openapi/jsonreference v0.20.2 // indirect
	github.com/go-openapi/spec v0.20.9 // indirect
	github.com/go-openapi/swag v0.22.4 // indirect
	github.com/gorilla/css v1.0.0 // indirect
	github.com/josharian/intern v1.0.0 // indirect
	github.com/kballard/go-shellquote v0.0.0-20180428030007-95032a82bc51 // indirect
	github.com/klauspost/compress v1.11.7 // indirect
	github.com/mailru/easyjson v0.7.7 // indirect
	github.com/remyoudompheng/bigfft v0.0.0-20230129092748-24d4a6f8daec // indirect
	github.com/rogpeppe/go-internal v1.9.0 // indirect
	github.com/rs/cors v1.7.0 // indirect
	github.com/stoewer/go-strcase v1.2.0 // indirect
	github.com/swaggo/files/v2 v2.0.0 // indirect
	golang.org/x/image v0.7.0 // indirect
	golang.org/x/tools v0.11.1 // indirect
	google.golang.org/genproto v0.0.0-20230706204954-ccb25ca9f130 // indirect
	google.golang.org/genproto/googleapis/rpc v0.0.0-20230726155614-23370e0ffb3e // indirect
	lukechampine.com/uint128 v1.2.0 // indirect
	modernc.org/cc/v3 v3.40.0 // indirect
	modernc.org/ccgo/v3 v3.16.13 // indirect
	modernc.org/libc v1.22.5 // indirect
	modernc.org/mathutil v1.5.0 // indirect
	modernc.org/memory v1.5.0 // indirect
	modernc.org/opt v0.1.3 // indirect
	modernc.org/strutil v1.1.3 // indirect
	modernc.org/token v1.0.1 // indirect
	nhooyr.io/websocket v1.8.6 // indirect
)
require (
	github.com/aws/aws-sdk-go-v2/aws/protocol/eventstream v1.4.10 // indirect
	github.com/aws/aws-sdk-go-v2/feature/ec2/imds v1.12.22 // indirect
	github.com/aws/aws-sdk-go-v2/internal/configsources v1.1.28 // indirect
	github.com/aws/aws-sdk-go-v2/internal/endpoints/v2 v2.4.22 // indirect
	github.com/aws/aws-sdk-go-v2/internal/ini v1.3.29 // indirect
	github.com/aws/aws-sdk-go-v2/internal/v4a v1.0.20 // indirect
	github.com/aws/aws-sdk-go-v2/service/internal/accept-encoding v1.9.11 // indirect
	github.com/aws/aws-sdk-go-v2/service/internal/checksum v1.1.23 // indirect
	github.com/aws/aws-sdk-go-v2/service/internal/presigned-url v1.9.22 // indirect
	github.com/aws/aws-sdk-go-v2/service/internal/s3shared v1.13.22 // indirect
	github.com/aws/aws-sdk-go-v2/service/sso v1.12.1 // indirect
	github.com/aws/aws-sdk-go-v2/service/ssooidc v1.14.1 // indirect
	github.com/aws/aws-sdk-go-v2/service/sts v1.18.3 // indirect
	github.com/aws/smithy-go v1.13.5 // indirect
	github.com/davecgh/go-spew v1.1.1 // indirect
	github.com/fsnotify/fsnotify v1.6.0 // indirect
	github.com/golang-jwt/jwt v3.2.2+incompatible // indirect
	github.com/golang-jwt/jwt/v4 v4.5.0
	github.com/golang/protobuf v1.5.3 // indirect
	github.com/hashicorp/hcl v1.0.0 // indirect
	github.com/inconshreveable/mousetrap v1.0.1 // indirect
	github.com/jmespath/go-jmespath v0.4.0 // indirect
	github.com/labstack/gommon v0.4.0 // indirect
	github.com/magiconair/properties v1.8.7 // indirect
	github.com/mattn/go-colorable v0.1.13 // indirect
	github.com/mattn/go-isatty v0.0.19 // indirect
	github.com/mitchellh/mapstructure v1.5.0 // indirect
	github.com/pelletier/go-toml/v2 v2.0.6 // indirect
	github.com/pmezard/go-difflib v1.0.0 // indirect
	github.com/spf13/afero v1.9.3 // indirect
	github.com/spf13/cast v1.5.0 // indirect
	github.com/spf13/jwalterweatherman v1.1.0 // indirect
	github.com/spf13/pflag v1.0.5 // indirect
	github.com/subosito/gotenv v1.4.2 // indirect
	github.com/valyala/bytebufferpool v1.0.0 // indirect
	github.com/valyala/fasttemplate v1.2.2 // indirect
	go.uber.org/atomic v1.9.0 // indirect
	go.uber.org/multierr v1.8.0 // indirect
	golang.org/x/sys v0.12.0 // indirect
	golang.org/x/text v0.13.0 // indirect
	golang.org/x/time v0.3.0 // indirect
	google.golang.org/appengine v1.6.7 // indirect
	google.golang.org/protobuf v1.31.0
	gopkg.in/ini.v1 v1.67.0 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
)
",CWE-352,121.0,0
"package getter
import (
	""errors""
	""io""
	""net/http""
	""net/url""
	""strings""
	""github.com/microcosm-cc/bluemonday""
)
type Image struct {
	Blob      []byte
	Mediatype string
}
func GetImage(urlStr string) (*Image, error) {
	if _, err := url.Parse(urlStr); err != nil {
		return nil, err
	}
	response, err := http.Get(urlStr)
	if err != nil {
		return nil, err
	}
	defer response.Body.Close()
	mediatype, err := getMediatype(response)
	if err != nil {
		return nil, err
	}
	if !strings.HasPrefix(mediatype, ""image/"") {
		return nil, errors.New(""Wrong image mediatype"")
	}
	bodyBytes, err := io.ReadAll(response.Body)
	if err != nil {
		return nil, err
	}
	bodyBytes, err = SanitizeContent(bodyBytes)
	if err != nil {
		return nil, err
	}
	image := &Image{
		Blob:      bodyBytes,
		Mediatype: mediatype,
	}
	return image, nil
}
func SanitizeContent(content []byte) ([]byte, error) {
	bodyString := string(content)
	bm := bluemonday.UGCPolicy()
	return []byte(bm.Sanitize(bodyString)), nil
}
",CWE-352,60.0,0
"package client
import (
	""errors""
	""fmt""
)
var (
	ErrNoRootKeys       = errors.New(""tuf: no root keys found in local meta store"")
	ErrInsufficientKeys = errors.New(""tuf: insufficient keys to meet threshold"")
	ErrNoLocalSnapshot  = errors.New(""tuf: no snapshot stored locally"")
)
type ErrMissingRemoteMetadata struct {
	Name string
}
func (e ErrMissingRemoteMetadata) Error() string {
	return fmt.Sprintf(""tuf: missing remote metadata %s"", e.Name)
}
type ErrDownloadFailed struct {
	File string
	Err  error
}
func (e ErrDownloadFailed) Error() string {
	return fmt.Sprintf(""tuf: failed to download %s: %s"", e.File, e.Err)
}
type ErrDecodeFailed struct {
	File string
	Err  error
}
func (e ErrDecodeFailed) Error() string {
	return fmt.Sprintf(""tuf: failed to decode %s: %s"", e.File, e.Err)
}
type ErrMaxDelegations struct {
	Target          string
	MaxDelegations  int
	SnapshotVersion int64
}
func (e ErrMaxDelegations) Error() string {
	return fmt.Sprintf(""tuf: max delegation of %d reached searching for %s with snapshot version %d"", e.MaxDelegations, e.Target, e.SnapshotVersion)
}
type ErrNotFound struct {
	File string
}
func (e ErrNotFound) Error() string {
	return fmt.Sprintf(""tuf: file not found: %s"", e.File)
}
func IsNotFound(err error) bool {
	_, ok := err.(ErrNotFound)
	return ok
}
type ErrWrongSize struct {
	File     string
	Actual   int64
	Expected int64
}
func (e ErrWrongSize) Error() string {
	return fmt.Sprintf(""tuf: unexpected file size: %s (expected %d bytes, got %d bytes)"", e.File, e.Expected, e.Actual)
}
type ErrUnknownTarget struct {
	Name            string
	SnapshotVersion int64
}
func (e ErrUnknownTarget) Error() string {
	return fmt.Sprintf(""tuf: unknown target file: %s with snapshot version %d"", e.Name, e.SnapshotVersion)
}
type ErrMetaTooLarge struct {
	Name    string
	Size    int64
	MaxSize int64
}
func (e ErrMetaTooLarge) Error() string {
	return fmt.Sprintf(""tuf: %s size %d bytes greater than maximum %d bytes"", e.Name, e.Size, e.MaxSize)
}
type ErrInvalidURL struct {
	URL string
}
func (e ErrInvalidURL) Error() string {
	return fmt.Sprintf(""tuf: invalid repository URL %s"", e.URL)
}
type ErrRoleNotInSnapshot struct {
	Role            string
	SnapshotVersion int64
}
func (e ErrRoleNotInSnapshot) Error() string {
	return fmt.Sprintf(""tuf: role %s not in snapshot version %d"", e.Role, e.SnapshotVersion)
}
",CWE-354,108.0,0
"package main
import (
	""io""
	""io/ioutil""
	""os""
	""github.com/flynn/go-docopt""
	tuf ""github.com/theupdateframework/go-tuf/client""
	""github.com/theupdateframework/go-tuf/util""
)
func init() {
	register(""get"", cmdGet, `
usage: tuf-client get [-s|--store=<path>] <url> <target>
Options:
  -s <path>    The path to the local file store [default: tuf.db]
Get a target from the repository.
  `)
}
type tmpFile struct {
	*os.File
}
func (t *tmpFile) Delete() error {
	t.Close()
	return os.Remove(t.Name())
}
func cmdGet(args *docopt.Args, client *tuf.Client) error {
	if _, err := client.Update(); err != nil {
		return err
	}
	target := util.NormalizeTarget(args.String[""<target>""])
	file, err := ioutil.TempFile("""", ""go-tuf"")
	if err != nil {
		return err
	}
	tmp := tmpFile{file}
	if err := client.Download(target, &tmp); err != nil {
		return err
	}
	defer tmp.Delete()
	if _, err := tmp.Seek(0, io.SeekStart); err != nil {
		return err
	}
	_, err = io.Copy(os.Stdout, file)
	return err
}
",CWE-354,53.0,0
"package main
import (
	""fmt""
	""os""
	""text/tabwriter""
	""github.com/dustin/go-humanize""
	""github.com/flynn/go-docopt""
	tuf ""github.com/theupdateframework/go-tuf/client""
)
func init() {
	register(""list"", cmdList, `
usage: tuf-client list [-s|--store=<path>] <url>
Options:
  -s <path>    The path to the local file store [default: tuf.db]
List available target files.
  `)
}
func cmdList(args *docopt.Args, client *tuf.Client) error {
	if _, err := client.Update(); err != nil {
		return err
	}
	targets, err := client.Targets()
	if err != nil {
		return err
	}
	w := tabwriter.NewWriter(os.Stdout, 1, 2, 2, ' ', 0)
	defer w.Flush()
	fmt.Fprintln(w, ""PATH\tSIZE"")
	for path, meta := range targets {
		fmt.Fprintf(w, ""%s\t%s\n"", path, humanize.Bytes(uint64(meta.Length)))
	}
	return nil
}
",CWE-354,40.0,0
"package verify
import (
	""errors""
	""fmt""
	""time""
)
var (
	ErrMissingKey           = errors.New(""tuf: missing key"")
	ErrNoSignatures         = errors.New(""tuf: data has no signatures"")
	ErrInvalid              = errors.New(""tuf: signature verification failed"")
	ErrWrongMethod          = errors.New(""tuf: invalid signature type"")
	ErrWrongMetaType        = errors.New(""tuf: meta file has wrong type"")
	ErrExists               = errors.New(""tuf: key already in db"")
	ErrInvalidKey           = errors.New(""tuf: invalid key"")
	ErrInvalidRole          = errors.New(""tuf: invalid role"")
	ErrInvalidDelegatedRole = errors.New(""tuf: invalid delegated role"")
	ErrInvalidKeyID         = errors.New(""tuf: invalid key id"")
	ErrInvalidThreshold     = errors.New(""tuf: invalid role threshold"")
	ErrMissingTargetFile    = errors.New(""tuf: missing previously listed targets metadata file"")
)
type ErrWrongID struct{}
func (ErrWrongID) Error() string {
	return ""tuf: key id mismatch""
}
type ErrUnknownRole struct {
	Role string
}
func (e ErrUnknownRole) Error() string {
	return fmt.Sprintf(""tuf: unknown role %q"", e.Role)
}
type ErrExpired struct {
	Expired time.Time
}
func (e ErrExpired) Error() string {
	return fmt.Sprintf(""expired at %s"", e.Expired)
}
type ErrLowVersion struct {
	Actual  int64
	Current int64
}
func (e ErrLowVersion) Error() string {
	return fmt.Sprintf(""version %d is lower than current version %d"", e.Actual, e.Current)
}
type ErrWrongVersion struct {
	Given    int64
	Expected int64
}
func (e ErrWrongVersion) Error() string {
	return fmt.Sprintf(""version %d does not match the expected version %d"", e.Given, e.Expected)
}
type ErrRoleThreshold struct {
	Expected int
	Actual   int
}
func (e ErrRoleThreshold) Error() string {
	return ""tuf: valid signatures did not meet threshold""
}
",CWE-354,72.0,0
"package verify
import (
	""encoding/json""
	""strings""
	""time""
	""github.com/secure-systems-lab/go-securesystemslib/cjson""
	""github.com/theupdateframework/go-tuf/data""
	""github.com/theupdateframework/go-tuf/internal/roles""
)
type signedMeta struct {
	Type    string    `json:""_type""`
	Expires time.Time `json:""expires""`
	Version int64     `json:""version""`
}
func (db *DB) VerifyIgnoreExpiredCheck(s *data.Signed, role string, minVersion int64) error {
	if err := db.VerifySignatures(s, role); err != nil {
		return err
	}
	sm := &signedMeta{}
	if err := json.Unmarshal(s.Signed, sm); err != nil {
		return err
	}
	if roles.IsTopLevelRole(role) {
		// Top-level roles can only sign metadata of the same type (e.g. snapshot
		// metadata must be signed by the snapshot role).
		if !strings.EqualFold(sm.Type, role) {
			return ErrWrongMetaType
		}
	} else {
		// Delegated (non-top-level) roles may only sign targets metadata.
		if strings.ToLower(sm.Type) != ""targets"" {
			return ErrWrongMetaType
		}
	}
	if sm.Version < minVersion {
		return ErrLowVersion{sm.Version, minVersion}
	}
	return nil
}
func (db *DB) Verify(s *data.Signed, role string, minVersion int64) error {
	// Verify signatures and versions
	err := db.VerifyIgnoreExpiredCheck(s, role, minVersion)
	if err != nil {
		return err
	}
	sm := &signedMeta{}
	if err := json.Unmarshal(s.Signed, sm); err != nil {
		return err
	}
	// Verify expiration
	if IsExpired(sm.Expires) {
		return ErrExpired{sm.Expires}
	}
	return nil
}
var IsExpired = func(t time.Time) bool {
	return time.Until(t) <= 0
}
func (db *DB) VerifySignatures(s *data.Signed, role string) error {
	if len(s.Signatures) == 0 {
		return ErrNoSignatures
	}
	roleData := db.GetRole(role)
	if roleData == nil {
		return ErrUnknownRole{role}
	}
	var decoded map[string]interface{}
	if err := json.Unmarshal(s.Signed, &decoded); err != nil {
		return err
	}
	msg, err := cjson.EncodeCanonical(decoded)
	if err != nil {
		return err
	}
	// Verify that a threshold of keys signed the data. Since keys can have
	// multiple key ids, we need to protect against multiple attached
	// signatures that just differ on the key id.
	seen := make(map[string]struct{})
	valid := 0
	for _, sig := range s.Signatures {
		if !roleData.ValidKey(sig.KeyID) {
			continue
		}
		verifier, err := db.GetVerifier(sig.KeyID)
		if err != nil {
			continue
		}
		if err := verifier.Verify(msg, sig.Signature); err != nil {
			return ErrInvalid
		}
		// Only consider this key valid if we haven't seen any of it's
		// key ids before.
		if _, ok := seen[sig.KeyID]; !ok {
			for _, id := range verifier.MarshalPublicKey().IDs() {
				seen[id] = struct{}{}
			}
			valid++
		}
	}
	if valid < roleData.Threshold {
		return ErrRoleThreshold{roleData.Threshold, valid}
	}
	return nil
}
func (db *DB) Unmarshal(b []byte, v interface{}, role string, minVersion int64) error {
	s := &data.Signed{}
	if err := json.Unmarshal(b, s); err != nil {
		return err
	}
	if err := db.Verify(s, role, minVersion); err != nil {
		return err
	}
	return json.Unmarshal(s.Signed, v)
}
// UnmarshalExpired is exactly like Unmarshal except ignores expired timestamp error.
func (db *DB) UnmarshalIgnoreExpired(b []byte, v interface{}, role string, minVersion int64) error {
	s := &data.Signed{}
	if err := json.Unmarshal(b, s); err != nil {
		return err
	}
	// Note: If verification fails, then we wont attempt to unmarshal
	// unless when verification error is errExpired.
	verifyErr := db.Verify(s, role, minVersion)
	if verifyErr != nil {
		if _, ok := verifyErr.(ErrExpired); !ok {
			return verifyErr
		}
	}
	return json.Unmarshal(s.Signed, v)
}
func (db *DB) UnmarshalTrusted(b []byte, v interface{}, role string) error {
	s := &data.Signed{}
	if err := json.Unmarshal(b, s); err != nil {
		return err
	}
	if err := db.VerifySignatures(s, role); err != nil {
		return err
	}
	return json.Unmarshal(s.Signed, v)
}
",CWE-354,165.0,0
"package getter
import ""net/url""
// RedactURL is a port of url.Redacted from the standard library,
// which is like url.String but replaces any password with ""xxxxx"".
// Only the password in u.URL is redacted. This allows the library
// to maintain compatibility with go1.14.
func RedactURL(u *url.URL) string {
	if u == nil {
		return """"
	}
	ru := *u
	if _, has := ru.User.Password(); has {
		ru.User = url.UserPassword(ru.User.Username(), ""redacted"")
	}
	q := ru.Query()
	if q.Get(""sshkey"") != """" {
		q.Set(""sshkey"", ""redacted"")
		ru.RawQuery = q.Encode()
	}
	return ru.String()
}
",CWE-532,25.0,0
"package getter
import (
	""net/url""
	""testing""
)
func TestRedactURL(t *testing.T) {
	cases := []struct {
		name string
		url  *url.URL
		want string
	}{
		{
			name: ""non-blank Password"",
			url: &url.URL{
				Scheme: ""http"",
				Host:   ""host.tld"",
				Path:   ""this:that"",
				User:   url.UserPassword(""user"", ""password""),
			},
			want: ""http://user:redacted@host.tld/this:that"",
		},
		{
			name: ""blank Password"",
			url: &url.URL{
				Scheme: ""http"",
				Host:   ""host.tld"",
				Path:   ""this:that"",
				User:   url.User(""user""),
			},
			want: ""http://user@host.tld/this:that"",
		},
		{
			name: ""nil User"",
			url: &url.URL{
				Scheme: ""http"",
				Host:   ""host.tld"",
				Path:   ""this:that"",
				User:   url.UserPassword("""", ""password""),
			},
			want: ""http://:redacted@host.tld/this:that"",
		},
		{
			name: ""blank Username, blank Password"",
			url: &url.URL{
				Scheme: ""http"",
				Host:   ""host.tld"",
				Path:   ""this:that"",
			},
			want: ""http://host.tld/this:that"",
		},
		{
			name: ""empty URL"",
			url:  &url.URL{},
			want: """",
		},
		{
			name: ""nil URL"",
			url:  nil,
			want: """",
		},
		{
			name: ""non-blank SSH key in URL query parameter"",
			url: &url.URL{
				Scheme:   ""ssh"",
				User:     url.User(""git""),
				Host:     ""github.com"",
				Path:     ""hashicorp/go-getter-test-private.git"",
				RawQuery: ""sshkey=LS0tLS1CRUdJTiBPUE"",
			},
			want: ""ssh://git@github.com/hashicorp/go-getter-test-private.git?sshkey=redacted"",
		},
		{
			name: ""blank SSH key in URL query parameter"",
			url: &url.URL{
				Scheme:   ""ssh"",
				User:     url.User(""git""),
				Host:     ""github.com"",
				Path:     ""hashicorp/go-getter-test-private.git"",
				RawQuery: ""sshkey="",
			},
			want: ""ssh://git@github.com/hashicorp/go-getter-test-private.git?sshkey="",
		},
	}
	for _, tt := range cases {
		t := t
		t.Run(tt.name, func(t *testing.T) {
			if g, w := RedactURL(tt.url), tt.want; g != w {
				t.Fatalf(""got: %q\nwant: %q"", g, w)
			}
		})
	}
}
",CWE-532,96.0,0
"{
	""name"": ""froxlor/froxlor"",
	""description"": ""The server administration software for your needs. Developed by experienced server administrators, this panel simplifies the effort of managing your hosting platform."",
	""keywords"": [
		""server"",
		""administration"",
		""php""
	],
	""homepage"": ""https://www.froxlor.org"",
	""license"": ""GPL-2.0-or-later"",
	""authors"": [
		{
			""name"": ""Michael Kaufmann"",
			""email"": ""team@froxlor.org"",
			""role"": ""Lead Developer""
		}
	],
	""support"": {
		""email"": ""team@froxlor.org"",
		""issues"": ""https://github.com/Froxlor/Froxlor/issues"",
		""forum"": ""https://forum.froxlor.org/"",
		""source"": ""https://github.com/Froxlor/Froxlor"",
		""docs"": ""https://docs.froxlor.org/"",
		""chat"": ""https://discord.froxlor.org/""
	},
	""funding"": [
		{
			""type"": ""github"",
			""url"": ""https://github.com/sponsors/d00p""
		}
	],
	""require"": {
		""php"": ""^7.4 || ^8.0"",
		""ext-session"": ""*"",
		""ext-ctype"": ""*"",
		""ext-pdo"": ""*"",
		""ext-pdo_mysql"": ""*"",
		""ext-simplexml"": ""*"",
		""ext-xml"": ""*"",
		""ext-filter"": ""*"",
		""ext-posix"": ""*"",
		""ext-mbstring"": ""*"",
		""ext-curl"": ""*"",
		""ext-json"": ""*"",
		""ext-openssl"": ""*"",
		""ext-fileinfo"": ""*"",
		""ext-gmp"": ""*"",
		""ext-gd"": ""*"",
		""ext-gnupg"": ""*"",
		""phpmailer/phpmailer"": ""~6.0"",
		""monolog/monolog"": ""^1.24"",
		""robthree/twofactorauth"": ""^1.6"",
		""froxlor/idna-convert-legacy"": ""^2.1"",
		""voku/anti-xss"": ""^4.1"",
		""twig/twig"": ""^3.3"",
		""symfony/console"": ""^5.4"",
		""pear/net_dns2"": ""^1.5"",
		""amnuts/opcache-gui"": ""^3.4"",
		""league/commonmark"": ""^2.4""
    },
	""require-dev"": {
		""phpunit/phpunit"": ""^9"",
		""ext-pcntl"": ""*"",
		""phpcompatibility/php-compatibility"": ""*"",
		""squizlabs/php_codesniffer"": ""*"",
		""pdepend/pdepend"": ""^2.9"",
		""sebastian/phpcpd"": ""^6.0"",
		""phploc/phploc"": ""^7.0"",
		""phpmd/phpmd"": ""^2.10"",
		""phpunit/php-timer"" : ""^5"",
		""phpstan/phpstan"": ""^1.8""
	},
	""suggest"": {
		""ext-bcmath"": ""*"",
		""ext-zip"": ""*"",
		""ext-apcu"": ""*"",
		""ext-readline"": ""*""
	},
	""autoload"": {
		""psr-4"": {
			""Froxlor\\"": [
				""lib/Froxlor""
			]
		}
	},
	""scripts"": {
		""post-install-cmd"": ""if [ -f ./vendor/bin/phpcs ]; then \""vendor/bin/phpcs\"" --config-set installed_paths vendor/phpcompatibility/php-compatibility ; fi"",
		""post-update-cmd"" : ""if [ -f ./vendor/bin/phpcs ]; then \""vendor/bin/phpcs\"" --config-set installed_paths vendor/phpcompatibility/php-compatibility ; fi""
	}
}
",CWE-79,91.0,0
"// Copyright 2019 PingCAP, Inc.
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package common_test
import (
	""context""
	""encoding/base64""
	""encoding/json""
	""fmt""
	""io""
	""net/http""
	""net/http/httptest""
	""testing""
	""time""
	""github.com/DATA-DOG/go-sqlmock""
	""github.com/go-sql-driver/mysql""
	""github.com/pingcap/errors""
	""github.com/pingcap/failpoint""
	""github.com/pingcap/tidb/br/pkg/lightning/common""
	""github.com/pingcap/tidb/br/pkg/lightning/log""
	""github.com/stretchr/testify/assert""
	""github.com/stretchr/testify/require""
)
func TestDirNotExist(t *testing.T) {
	require.True(t, common.IsDirExists("".""))
	require.False(t, common.IsDirExists(""not-exists""))
}
func TestGetJSON(t *testing.T) {
	type TestPayload struct {
		Username string `json:""username""`
		Password string `json:""password""`
	}
	request := TestPayload{
		Username: ""lightning"",
		Password: ""lightning-ctl"",
	}
	ctx := context.Background()
	// Mock success response
	handle := func(res http.ResponseWriter, _ *http.Request) {
		res.WriteHeader(http.StatusOK)
		err := json.NewEncoder(res).Encode(request)
		require.NoError(t, err)
	}
	testServer := httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
		handle(res, req)
	}))
	defer testServer.Close()
	client := &http.Client{Timeout: time.Second}
	response := TestPayload{}
	err := common.GetJSON(ctx, client, ""http://not-exists"", &response)
	require.Error(t, err)
	err = common.GetJSON(ctx, client, testServer.URL, &response)
	require.NoError(t, err)
	require.Equal(t, request, response)
	// Mock `StatusNoContent` response
	handle = func(res http.ResponseWriter, _ *http.Request) {
		res.WriteHeader(http.StatusNoContent)
	}
	err = common.GetJSON(ctx, client, testServer.URL, &response)
	require.Error(t, err)
	require.Regexp(t, "".*http status code != 200.*"", err.Error())
}
func TestConnect(t *testing.T) {
	plainPsw := ""dQAUoDiyb1ucWZk7""
	require.NoError(t, failpoint.Enable(
		""github.com/pingcap/tidb/br/pkg/lightning/common/MustMySQLPassword"",
		fmt.Sprintf(""return(\""%s\"")"", plainPsw)))
	defer func() {
		require.NoError(t, failpoint.Disable(""github.com/pingcap/tidb/br/pkg/lightning/common/MustMySQLPassword""))
	}()
	param := common.MySQLConnectParam{
		Host:             ""127.0.0.1"",
		Port:             4000,
		User:             ""root"",
		Password:         plainPsw,
		SQLMode:          ""strict"",
		MaxAllowedPacket: 1234,
	}
	_, err := param.Connect()
	require.NoError(t, err)
	param.Password = base64.StdEncoding.EncodeToString([]byte(plainPsw))
	_, err = param.Connect()
	require.NoError(t, err)
}
func TestIsContextCanceledError(t *testing.T) {
	require.True(t, common.IsContextCanceledError(context.Canceled))
	require.False(t, common.IsContextCanceledError(io.EOF))
}
func TestUniqueTable(t *testing.T) {
	tableName := common.UniqueTable(""test"", ""t1"")
	require.Equal(t, ""`test`.`t1`"", tableName)
	tableName = common.UniqueTable(""test"", ""t`1"")
	require.Equal(t, ""`test`.`t``1`"", tableName)
}
func TestSQLWithRetry(t *testing.T) {
	db, mock, err := sqlmock.New()
	require.NoError(t, err)
	defer db.Close()
	sqlWithRetry := &common.SQLWithRetry{
		DB:     db,
		Logger: log.L(),
	}
	aValue := new(int)
	// retry defaultMaxRetry times and still failed
	for i := 0; i < 3; i++ {
		mock.ExpectQuery(""select a from test.t1"").WillReturnError(errors.Annotate(mysql.ErrInvalidConn, ""mock error""))
	}
	err = sqlWithRetry.QueryRow(context.Background(), """", ""select a from test.t1"", aValue)
	require.Regexp(t, "".*mock error"", err.Error())
	// meet unretryable error and will return directly
	mock.ExpectQuery(""select a from test.t1"").WillReturnError(context.Canceled)
	err = sqlWithRetry.QueryRow(context.Background(), """", ""select a from test.t1"", aValue)
	require.Regexp(t, "".*context canceled"", err.Error())
	// query success
	rows := sqlmock.NewRows([]string{""a""}).AddRow(""1"")
	mock.ExpectQuery(""select a from test.t1"").WillReturnRows(rows)
	err = sqlWithRetry.QueryRow(context.Background(), """", ""select a from test.t1"", aValue)
	require.NoError(t, err)
	require.Equal(t, 1, *aValue)
	// test Exec
	mock.ExpectExec(""delete from"").WillReturnError(context.Canceled)
	err = sqlWithRetry.Exec(context.Background(), """", ""delete from test.t1 where id = ?"", 2)
	require.Regexp(t, "".*context canceled"", err.Error())
	mock.ExpectExec(""delete from"").WillReturnResult(sqlmock.NewResult(0, 1))
	err = sqlWithRetry.Exec(context.Background(), """", ""delete from test.t1 where id = ?"", 2)
	require.NoError(t, err)
	require.Nil(t, mock.ExpectationsWereMet())
}
func TestStringSliceEqual(t *testing.T) {
	assert.True(t, common.StringSliceEqual(nil, nil))
	assert.True(t, common.StringSliceEqual(nil, []string{}))
	assert.False(t, common.StringSliceEqual(nil, []string{""a""}))
	assert.False(t, common.StringSliceEqual([]string{""a""}, nil))
	assert.True(t, common.StringSliceEqual([]string{""a""}, []string{""a""}))
	assert.False(t, common.StringSliceEqual([]string{""a""}, []string{""b""}))
	assert.True(t, common.StringSliceEqual([]string{""a"", ""b"", ""c""}, []string{""a"", ""b"", ""c""}))
	assert.False(t, common.StringSliceEqual([]string{""a""}, []string{""a"", ""b"", ""c""}))
	assert.False(t, common.StringSliceEqual([]string{""a"", ""b"", ""c""}, []string{""a"", ""b""}))
	assert.False(t, common.StringSliceEqual([]string{""a"", ""x"", ""y""}, []string{""a"", ""y"", ""x""}))
}
func TestInterpolateMySQLString(t *testing.T) {
	assert.Equal(t, ""'123'"", common.InterpolateMySQLString(""123""))
	assert.Equal(t, ""'1''23'"", common.InterpolateMySQLString(""1'23""))
	assert.Equal(t, ""'1''2''''3'"", common.InterpolateMySQLString(""1'2''3""))
}
",CWE-134,182.0,0
"// Copyright 2021 PingCAP, Inc. Licensed under Apache-2.0.
package main
import (
	""context""
	""database/sql""
	""fmt""
	""net""
	""os""
	""strconv""
	_ ""github.com/go-sql-driver/mysql""
	""github.com/pingcap/errors""
	""github.com/spf13/cobra""
	""golang.org/x/sync/errgroup""
)
const (
	flagDatabase = ""database""
	flagTable    = ""table""
	flagPort     = ""port""
	flagWorker   = ""worker""
)
var rootCmd *cobra.Command
func main() {
	rootCmd = &cobra.Command{}
	rootCmd.Flags().StringP(flagDatabase, ""B"", ""s3"", ""Database to import"")
	rootCmd.Flags().StringP(flagTable, ""T"", ""t"", ""Table to import"")
	rootCmd.Flags().IntP(flagPort, ""P"", 4000, ""TCP/IP port to connect to"")
	rootCmd.Flags().IntP(flagWorker, ""w"", 16, ""Workers to import synchronously"")
	rootCmd.RunE = func(cmd *cobra.Command, args []string) error {
		database, err := cmd.Flags().GetString(flagDatabase)
		if err != nil {
			return errors.Trace(err)
		}
		table, err := cmd.Flags().GetString(flagTable)
		if err != nil {
			return errors.Trace(err)
		}
		port, err := cmd.Flags().GetInt(flagPort)
		if err != nil {
			return errors.Trace(err)
		}
		worker, err := cmd.Flags().GetInt(flagWorker)
		if err != nil {
			return errors.Trace(err)
		}
		dsn := fmt.Sprintf(""%s:%s@tcp(%s)/%s?charset=utf8mb4"", ""root"", """", net.JoinHostPort(""127.0.0.1"", strconv.Itoa(port)), database)
		db, err := sql.Open(""mysql"", dsn)
		if err != nil {
			return errors.Trace(err)
		}
		tableTemp := `CREATE TABLE IF NOT EXISTS %s (
	   a VARCHAR(11)
)`
		_, err = db.Exec(fmt.Sprintf(tableTemp, table))
		if err != nil {
			return errors.Trace(err)
		}
		query := fmt.Sprintf(""insert into %s values('aaaaaaaaaa')"", table) // nolint:gosec
		for i := 1; i < 10000; i++ {
			query += "",('aaaaaaaaaa')""
		}
		ch := make(chan struct{}, worker)
		for i := 0; i < worker; i++ {
			ch <- struct{}{}
		}
		var eg *errgroup.Group
		ctx, cancel := context.WithCancel(context.Background())
		defer cancel()
		eg, ctx = errgroup.WithContext(ctx)
		for i := 0; i < 500; i++ {
			if ctx.Err() != nil {
				break
			}
			<-ch
			eg.Go(func() error {
				_, err := db.ExecContext(ctx, query)
				if err != nil {
					cancel()
					return errors.Trace(err)
				}
				ch <- struct{}{}
				return nil
			})
		}
		return eg.Wait()
	}
	if err := rootCmd.Execute(); err != nil {
		fmt.Printf(""fail to import data, err: %v"", err)
		os.Exit(2)
	}
}
",CWE-134,102.0,0
"/*
Copyright IBM Corp. 2017 All Rights Reserved.
SPDX-License-Identifier: Apache-2.0
*/
package cluster
import (
	""context""
	""io""
	""time""
	""github.com/hyperledger/fabric-protos-go/orderer""
	""github.com/hyperledger/fabric/common/flogging""
	""github.com/hyperledger/fabric/common/util""
	""github.com/pkg/errors""
	""go.uber.org/zap""
	""google.golang.org/grpc""
)
//go:generate mockery -dir . -name Dispatcher -case underscore -output ./mocks/
// Dispatcher dispatches requests
type Dispatcher interface {
	DispatchSubmit(ctx context.Context, request *orderer.SubmitRequest) error
	DispatchConsensus(ctx context.Context, request *orderer.ConsensusRequest) error
}
//go:generate mockery -dir . -name StepStream -case underscore -output ./mocks/
// StepStream defines the gRPC stream for sending
// transactions, and receiving corresponding responses
type StepStream interface {
	Send(response *orderer.StepResponse) error
	Recv() (*orderer.StepRequest, error)
	grpc.ServerStream
}
// Service defines the raft Service
type Service struct {
	StreamCountReporter              *StreamCountReporter
	Dispatcher                       Dispatcher
	Logger                           *flogging.FabricLogger
	StepLogger                       *flogging.FabricLogger
	MinimumExpirationWarningInterval time.Duration
	CertExpWarningThreshold          time.Duration
}
// Step passes an implementation-specific message to another cluster member.
func (s *Service) Step(stream orderer.Cluster_StepServer) error {
	s.StreamCountReporter.Increment()
	defer s.StreamCountReporter.Decrement()
	addr := util.ExtractRemoteAddress(stream.Context())
	commonName := commonNameFromContext(stream.Context())
	exp := s.initializeExpirationCheck(stream, addr, commonName)
	s.Logger.Debugf(""Connection from %s(%s)"", commonName, addr)
	defer s.Logger.Debugf(""Closing connection from %s(%s)"", commonName, addr)
	for {
		err := s.handleMessage(stream, addr, exp)
		if err == io.EOF {
			s.Logger.Debugf(""%s(%s) disconnected"", commonName, addr)
			return nil
		}
		if err != nil {
			return err
		}
		// Else, no error occurred, so we continue to the next iteration
	}
}
func (s *Service) handleMessage(stream StepStream, addr string, exp *certificateExpirationCheck) error {
	request, err := stream.Recv()
	if err == io.EOF {
		return err
	}
	if err != nil {
		s.Logger.Warningf(""Stream read from %s failed: %v"", addr, err)
		return err
	}
	exp.checkExpiration(time.Now(), extractChannel(request))
	if s.StepLogger.IsEnabledFor(zap.DebugLevel) {
		nodeName := commonNameFromContext(stream.Context())
		s.StepLogger.Debugf(""Received message from %s(%s): %v"", nodeName, addr, requestAsString(request))
	}
	if submitReq := request.GetSubmitRequest(); submitReq != nil {
		nodeName := commonNameFromContext(stream.Context())
		s.Logger.Debugf(""Received message from %s(%s): %v"", nodeName, addr, requestAsString(request))
		return s.handleSubmit(submitReq, stream, addr)
	} else if consensusReq := request.GetConsensusRequest(); consensusReq != nil {
		return s.Dispatcher.DispatchConsensus(stream.Context(), request.GetConsensusRequest())
	}
	return errors.Errorf(""message is neither a Submit nor a Consensus request"")
}
func (s *Service) handleSubmit(request *orderer.SubmitRequest, stream StepStream, addr string) error {
	err := s.Dispatcher.DispatchSubmit(stream.Context(), request)
	if err != nil {
		s.Logger.Warningf(""Handling of Submit() from %s failed: %v"", addr, err)
		return err
	}
	return err
}
func (s *Service) initializeExpirationCheck(stream orderer.Cluster_StepServer, endpoint, nodeName string) *certificateExpirationCheck {
	return &certificateExpirationCheck{
		minimumExpirationWarningInterval: s.MinimumExpirationWarningInterval,
		expirationWarningThreshold:       s.CertExpWarningThreshold,
		expiresAt:                        expiresAt(stream),
		endpoint:                         endpoint,
		nodeName:                         nodeName,
		alert: func(template string, args ...interface{}) {
			s.Logger.Warningf(template, args...)
		},
	}
}
func expiresAt(stream orderer.Cluster_StepServer) time.Time {
	cert := util.ExtractCertificateFromContext(stream.Context())
	if cert == nil {
		return time.Time{}
	}
	return cert.NotAfter
}
func extractChannel(msg *orderer.StepRequest) string {
	if consReq := msg.GetConsensusRequest(); consReq != nil {
		return consReq.Channel
	}
	if submitReq := msg.GetSubmitRequest(); submitReq != nil {
		return submitReq.Channel
	}
	return """"
}
",CWE-20,142.0,0
"package authzserver
import (
	""context""
	""crypto/rand""
	""fmt""
	""net/http""
	""net/http/httptest""
	""testing""
	config2 ""github.com/flyteorg/flytestdlib/config""
	""github.com/flyteorg/flyteadmin/auth""
	""github.com/stretchr/testify/mock""
	""github.com/flyteorg/flyteadmin/auth/interfaces/mocks""
	""github.com/flyteorg/flyteadmin/auth/config""
	""github.com/ory/fosite""
	""github.com/stretchr/testify/assert""
)
func TestAuthEndpoint(t *testing.T) {
	t.Run(""Success"", func(t *testing.T) {
		originalURL := ""http://localhost:8088/oauth2/authorize?client_id=my-client&redirect_uri=http%3A%2F%2Flocalhost%3A3846%2Fcallback&response_type=code&scope=photos+openid+offline&state=some-random-state-foobar&nonce=some-random-nonce&code_challenge=p0v_UR0KrXl4--BpxM2BQa7qIW5k3k4WauBhjmkVQw8&code_challenge_method=S256""
		req := httptest.NewRequest(http.MethodGet, originalURL, nil)
		w := httptest.NewRecorder()
		authCtx := &mocks.AuthenticationContext{}
		oauth2Provider := &mocks.OAuth2Provider{}
		oauth2Provider.OnNewAuthorizeRequest(req.Context(), req).Return(fosite.NewAuthorizeRequest(), nil)
		authCtx.OnOAuth2Provider().Return(oauth2Provider)
		cookieManager := &mocks.CookieHandler{}
		cookieManager.OnSetAuthCodeCookie(req.Context(), w, originalURL).Return(nil)
		authCtx.OnCookieManager().Return(cookieManager)
		authEndpoint(authCtx, w, req)
		assert.Equal(t, http.StatusTemporaryRedirect, w.Code)
	})
	t.Run(""Fail to write cookie"", func(t *testing.T) {
		originalURL := ""http://localhost:8088/oauth2/authorize?client_id=my-client&redirect_uri=http%3A%2F%2Flocalhost%3A3846%2Fcallback&response_type=code&scope=photos+openid+offline&state=some-random-state-foobar&nonce=some-random-nonce&code_challenge=p0v_UR0KrXl4--BpxM2BQa7qIW5k3k4WauBhjmkVQw8&code_challenge_method=S256""
		req := httptest.NewRequest(http.MethodGet, originalURL, nil)
		w := httptest.NewRecorder()
		authCtx := &mocks.AuthenticationContext{}
		oauth2Provider := &mocks.OAuth2Provider{}
		requester := fosite.NewAuthorizeRequest()
		oauth2Provider.OnNewAuthorizeRequest(req.Context(), req).Return(requester, nil)
		oauth2Provider.On(""WriteAuthorizeError"", w, requester, mock.Anything).Run(func(args mock.Arguments) {
			rw := args.Get(0).(http.ResponseWriter)
			rw.WriteHeader(http.StatusForbidden)
		})
		authCtx.OnOAuth2Provider().Return(oauth2Provider)
		cookieManager := &mocks.CookieHandler{}
		cookieManager.OnSetAuthCodeCookie(req.Context(), w, originalURL).Return(fmt.Errorf(""failure injection""))
		authCtx.OnCookieManager().Return(cookieManager)
		authEndpoint(authCtx, w, req)
		assert.Equal(t, http.StatusForbidden, w.Code)
	})
}
//func TestAuthCallbackEndpoint(t *testing.T) {
//	originalURL := ""http://localhost:8088/oauth2/authorize?client_id=my-client&redirect_uri=http%3A%2F%2Flocalhost%3A3846%2Fcallback&response_type=code&scope=photos+openid+offline&state=some-random-state-foobar&nonce=some-random-nonce&code_challenge=p0v_UR0KrXl4--BpxM2BQa7qIW5k3k4WauBhjmkVQw8&code_challenge_method=S256""
//	req := httptest.NewRequest(http.MethodGet, originalURL, nil)
//	w := httptest.NewRecorder()
//
//	authCtx := &mocks.AuthenticationContext{}
//
//	oauth2Provider := &mocks.OAuth2Provider{}
//	requester := fosite.NewAuthorizeRequest()
//	oauth2Provider.OnNewAuthorizeRequest(req.Context(), req).Return(requester, nil)
//	oauth2Provider.On(""WriteAuthorizeError"", w, requester, mock.Anything).Run(func(args mock.Arguments) {
//		rw := args.Get(0).(http.ResponseWriter)
//		rw.WriteHeader(http.StatusForbidden)
//	})
//
//	authCtx.OnOAuth2Provider().Return(oauth2Provider)
//
//	cookieManager := &mocks.CookieHandler{}
//	cookieManager.OnSetAuthCodeCookie(req.Context(), w, originalURL).Return(nil)
//	cookieManager.OnRetrieveTokenValues(req.Context(), req).Return(sampleIDToken, """", """", nil)
//	cookieManager.OnRetrieveUserInfo(req.Context(), req).Return(&service.UserInfoResponse{Subject: ""abc""}, nil)
//	authCtx.OnCookieManager().Return(cookieManager)
//
//	authCtx.OnOptions().Return(&config.Config{
//		UserAuth: config.UserAuthConfig{
//			OpenID: config.OpenIDOptions{
//				//ClientID: ""http://localhost"",
//			},
//		},
//	})
//
//	ctx, cancel := context.WithCancel(context.Background())
//	defer cancel()
//
//	var issuer string
//	hf := func(w http.ResponseWriter, r *http.Request) {
//		if r.URL.Path == ""/.well-known/openid-configuration"" {
//			w.Header().Set(""Content-Type"", ""application/json"")
//			io.WriteString(w, strings.ReplaceAll(`{
//				""issuer"": ""ISSUER"",
//				""authorization_endpoint"": ""https://example.com/auth"",
//				""token_endpoint"": ""https://example.com/token"",
//				""jwks_uri"": ""ISSUER/keys"",
//				""id_token_signing_alg_values_supported"": [""RS256""]
//			}`, ""ISSUER"", issuer))
//			return
//		} else if r.URL.Path == ""/keys"" {
//			w.Header().Set(""Content-Type"", ""application/json"")
//			io.WriteString(w, `{""keys"":[{""kty"":""RSA"",""alg"":""RS256"",""kid"":""Z6dmZ_TXhduw-jUBZ6uEEzvnh-jhNO0YhemB7qa_LOc"",""use"":""sig"",""e"":""AQAB"",""n"":""jyMcudBiz7XqeDIvxfMlmG4fvAUU7cl3R4iSIv_ahHanCcVRvqcXOsIknwn7i4rOUjP6MlH45uIYsaj6MuLYgoaIbC-Z823Tu4asoC-rGbpZgf-bMcJLxtZVBNsSagr_M0n8xA1oogHRF1LGRiD93wNr2b9OkKVbWnyNdASk5_xui024nVzakm2-RAEyaC048nHfnjVBvwo4BdJVDgBEK03fbkBCyuaZyE1ZQF545MTbD4keCv58prSCmbDRJgRk48FzaFnQeYTho-pUxXxM9pvhMykeI62WZ7diDfIc9isOpv6ALFOHgKy7Ihhve6pLIylLRTnn2qhHFkGPtU3djQ""}]}`)
//			return
//		}
//
//		http.NotFound(w, r)
//		return
//
//	}
//
//	s := httptest.NewServer(http.HandlerFunc(hf))
//	defer s.Close()
//
//	issuer = s.URL
//	mockOidcProvider, err := oidc.NewProvider(ctx, issuer)
//	if !assert.NoError(t, err) {
//		t.FailNow()
//	}
//
//	authCtx.OnOidcProvider().Return(mockOidcProvider)
//
//	authCallbackEndpoint(authCtx, w, req)
//	assert.Equal(t, http.StatusTemporaryRedirect, w.Code)
//}
func TestGetIssuer(t *testing.T) {
	t.Run(""SelfAuthServerIssuer wins"", func(t *testing.T) {
		issuer := GetIssuer(context.Background(), nil, &config.Config{
			AppAuth: config.OAuth2Options{
				SelfAuthServer: config.AuthorizationServer{
					Issuer: ""my_issuer"",
				},
			},
			AuthorizedURIs: []config2.URL{{URL: *config.MustParseURL(""http://localhost/"")}},
		})
		assert.Equal(t, ""my_issuer"", issuer)
	})
	t.Run(""Fallback to http public uri"", func(t *testing.T) {
		issuer := GetIssuer(context.Background(), nil, &config.Config{
			AuthorizedURIs: []config2.URL{{URL: *config.MustParseURL(""http://localhost/"")}},
		})
		assert.Equal(t, ""http://localhost/"", issuer)
	})
}
func TestEncryptDecrypt(t *testing.T) {
	cookieHashKey := [auth.SymmetricKeyLength]byte{}
	_, err := rand.Read(cookieHashKey[:])
	assert.NoError(t, err)
	input := ""hello world""
	encrypted, err := encryptString(input, cookieHashKey)
	assert.NoError(t, err)
	decrypted, err := decryptString(encrypted, cookieHashKey)
	assert.NoError(t, err)
	assert.Equal(t, input, decrypted)
	assert.NotEqual(t, input, encrypted)
}
",CWE-613,178.0,0
"package authzserver
import (
	""context""
	""encoding/json""
	""fmt""
	jwtgo ""github.com/golang-jwt/jwt/v4""
	""io/ioutil""
	""mime""
	""net/http""
	""net/url""
	""strings""
	""k8s.io/apimachinery/pkg/util/sets""
	""github.com/flyteorg/flytestdlib/config""
	""github.com/coreos/go-oidc""
	authConfig ""github.com/flyteorg/flyteadmin/auth/config""
	""github.com/flyteorg/flyteadmin/auth/interfaces""
	""github.com/flyteorg/flyteidl/gen/pb-go/flyteidl/service""
	""golang.org/x/oauth2""
)
// ResourceServer authorizes access requests issued by an external Authorization Server.
type ResourceServer struct {
	signatureVerifier oidc.KeySet
	allowedAudience   []string
}
func (r ResourceServer) ValidateAccessToken(ctx context.Context, expectedAudience, tokenStr string) (interfaces.IdentityContext, error) {
	_, err := r.signatureVerifier.VerifySignature(ctx, tokenStr)
	if err != nil {
		return nil, err
	}
	t, _, err := jwtgo.NewParser().ParseUnverified(tokenStr, jwtgo.MapClaims{})
	if err != nil {
		return nil, fmt.Errorf(""failed to parse token: %v"", err)
	}
	if err = t.Claims.Valid(); err != nil {
		return nil, fmt.Errorf(""failed to validate token: %v"", err)
	}
	return verifyClaims(sets.NewString(append(r.allowedAudience, expectedAudience)...), t.Claims.(jwtgo.MapClaims))
}
func doRequest(ctx context.Context, req *http.Request) (*http.Response, error) {
	client := http.DefaultClient
	if c, ok := ctx.Value(oauth2.HTTPClient).(*http.Client); ok {
		client = c
	}
	return client.Do(req.WithContext(ctx))
}
func unmarshalResp(r *http.Response, body []byte, v interface{}) error {
	err := json.Unmarshal(body, &v)
	if err == nil {
		return nil
	}
	ct := r.Header.Get(""Content-Type"")
	mediaType, _, parseErr := mime.ParseMediaType(ct)
	if parseErr == nil && mediaType == ""application/json"" {
		return fmt.Errorf(""got Content-Type = application/json, but could not unmarshal as JSON: %v"", err)
	}
	return fmt.Errorf(""expected Content-Type = application/json, got %q: %v"", ct, err)
}
func getJwksForIssuer(ctx context.Context, issuerBaseURL url.URL, customMetadataURL url.URL) (keySet oidc.KeySet, err error) {
	issuerBaseURL.Path = strings.TrimSuffix(issuerBaseURL.Path, ""/"") + ""/""
	var wellKnown *url.URL
	if len(customMetadataURL.String()) > 0 {
		wellKnown = issuerBaseURL.ResolveReference(&customMetadataURL)
	} else {
		wellKnown = issuerBaseURL.ResolveReference(oauth2MetadataEndpoint)
	}
	req, err := http.NewRequest(http.MethodGet, wellKnown.String(), nil)
	if err != nil {
		return nil, err
	}
	resp, err := doRequest(ctx, req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf(""unable to read response body: %v"", err)
	}
	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf(""%s: %s"", resp.Status, body)
	}
	p := &service.OAuth2MetadataResponse{}
	err = unmarshalResp(resp, body, &p)
	if err != nil {
		return nil, fmt.Errorf(""failed to decode provider discovery object: %v"", err)
	}
	return oidc.NewRemoteKeySet(ctx, p.JwksUri), nil
}
// NewOAuth2ResourceServer initializes a new OAuth2ResourceServer.
func NewOAuth2ResourceServer(ctx context.Context, cfg authConfig.ExternalAuthorizationServer, fallbackBaseURL config.URL) (ResourceServer, error) {
	u := cfg.BaseURL
	if len(u.String()) == 0 {
		u = fallbackBaseURL
	}
	verifier, err := getJwksForIssuer(ctx, u.URL, cfg.MetadataEndpointURL.URL)
	if err != nil {
		return ResourceServer{}, err
	}
	return ResourceServer{
		signatureVerifier: verifier,
		allowedAudience:   cfg.AllowedAudience,
	}, nil
}
",CWE-613,126.0,0
"package impl
import (
	""context""
	""fmt""
	""github.com/flyteorg/flyteidl/gen/pb-go/flyteidl/admin""
	""github.com/flyteorg/flyteidl/gen/pb-go/flyteidl/service""
	""github.com/flyteorg/flyteadmin/pkg/clusterresource/interfaces""
	""github.com/flyteorg/flyteadmin/pkg/common""
	""github.com/flyteorg/flyteadmin/pkg/repositories/models""
)
// Implementation of an interfaces.FlyteAdminDataProvider which fetches data using a flyteadmin service client
type serviceAdminProvider struct {
	adminClient service.AdminServiceClient
}
func (p serviceAdminProvider) GetClusterResourceAttributes(ctx context.Context, project, domain string) (*admin.ClusterResourceAttributes, error) {
	resource, err := p.adminClient.GetProjectDomainAttributes(ctx, &admin.ProjectDomainAttributesGetRequest{
		Project:      project,
		Domain:       domain,
		ResourceType: admin.MatchableResource_CLUSTER_RESOURCE,
	})
	if err != nil {
		return nil, err
	}
	if resource != nil && resource.Attributes != nil && resource.Attributes.MatchingAttributes != nil &&
		resource.Attributes.MatchingAttributes.GetClusterResourceAttributes() != nil {
		return resource.Attributes.MatchingAttributes.GetClusterResourceAttributes(), nil
	}
	return nil, NewMissingEntityError(""cluster resource attributes"")
}
var activeProjectsFilter = fmt.Sprintf(""ne(state,%d)"", admin.Project_ARCHIVED)
var descCreatedAtSortParam = admin.Sort{
	Direction: admin.Sort_DESCENDING,
	Key:       ""created_at"",
}
var descCreatedAtSortDBParam, _ = common.NewSortParameter(&descCreatedAtSortParam, models.ProjectColumns)
func (p serviceAdminProvider) GetProjects(ctx context.Context) (*admin.Projects, error) {
	projects := make([]*admin.Project, 0)
	listReq := &admin.ProjectListRequest{
		Limit:   100,
		Filters: activeProjectsFilter,
		// Prefer to sync projects most newly created to ensure their resources get created first when other resources exist.
		SortBy: &descCreatedAtSortParam,
	}
	// Iterate through all pages of projects
	for {
		projectResp, err := p.adminClient.ListProjects(ctx, listReq)
		if err != nil {
			return nil, err
		}
		projects = append(projects, projectResp.Projects...)
		if len(projectResp.Token) == 0 {
			break
		}
		listReq.Token = projectResp.Token
	}
	return &admin.Projects{
		Projects: projects,
	}, nil
}
func NewAdminServiceDataProvider(
	adminClient service.AdminServiceClient) interfaces.FlyteAdminDataProvider {
	return &serviceAdminProvider{
		adminClient: adminClient,
	}
}
",CWE-89,77.0,0
"package impl
import (
	""github.com/flyteorg/flyteadmin/pkg/errors""
	""google.golang.org/grpc/codes""
)
func NewMissingEntityError(entity string) error {
	return errors.NewFlyteAdminErrorf(codes.NotFound, ""Failed to find [%s]"", entity)
}
",CWE-89,11.0,0
"package common
import (
	""fmt""
	""k8s.io/apimachinery/pkg/util/sets""
	""github.com/flyteorg/flyteadmin/pkg/errors""
	""github.com/flyteorg/flyteidl/gen/pb-go/flyteidl/admin""
	""google.golang.org/grpc/codes""
)
const gormDescending = ""%s desc""
const gormAscending = ""%s asc""
type SortParameter interface {
	GetGormOrderExpr() string
}
type sortParamImpl struct {
	gormOrderExpression string
}
func (s *sortParamImpl) GetGormOrderExpr() string {
	return s.gormOrderExpression
}
func NewSortParameter(sort *admin.Sort, allowed sets.String) (SortParameter, error) {
	if sort == nil {
		return nil, nil
	}
	key := sort.Key
	if !allowed.Has(key) {
		return nil, errors.NewFlyteAdminErrorf(codes.InvalidArgument, ""invalid sort key '%s'"", key)
	}
	var gormOrderExpression string
	switch sort.Direction {
	case admin.Sort_DESCENDING:
		gormOrderExpression = fmt.Sprintf(gormDescending, key)
	case admin.Sort_ASCENDING:
		gormOrderExpression = fmt.Sprintf(gormAscending, key)
	default:
		return nil, errors.NewFlyteAdminErrorf(codes.InvalidArgument, ""invalid sort order specified: %v"", sort)
	}
	return &sortParamImpl{
		gormOrderExpression: gormOrderExpression,
	}, nil
}
",CWE-89,50.0,0
"package common
import (
	""testing""
	""k8s.io/apimachinery/pkg/util/sets""
	""github.com/flyteorg/flyteidl/gen/pb-go/flyteidl/admin""
	""github.com/stretchr/testify/assert""
)
func TestSortParameter_Nil(t *testing.T) {
	sortParameter, err := NewSortParameter(nil, nil)
	assert.NoError(t, err)
	assert.Nil(t, sortParameter)
}
func TestSortParameter_InvalidSortKey(t *testing.T) {
	_, err := NewSortParameter(&admin.Sort{
		Direction: admin.Sort_ASCENDING,
		Key:       ""wrong"",
	}, sets.NewString(""name""))
	assert.EqualError(t, err, ""invalid sort key 'wrong'"")
}
func TestSortParameter_InvalidSortDirection(t *testing.T) {
	_, err := NewSortParameter(&admin.Sort{
		Direction: 2,
		Key:       ""name"",
	}, sets.NewString(""name""))
	assert.EqualError(t, err, `invalid sort order specified: key:""name"" direction:2 `)
}
func TestSortParameter_Ascending(t *testing.T) {
	sortParameter, err := NewSortParameter(&admin.Sort{
		Direction: admin.Sort_ASCENDING,
		Key:       ""name"",
	}, sets.NewString(""name""))
	assert.NoError(t, err)
	assert.Equal(t, ""name asc"", sortParameter.GetGormOrderExpr())
}
func TestSortParameter_Descending(t *testing.T) {
	sortParameter, err := NewSortParameter(&admin.Sort{
		Direction: admin.Sort_DESCENDING,
		Key:       ""project"",
	}, sets.NewString(""project""))
	assert.NoError(t, err)
	assert.Equal(t, ""project desc"", sortParameter.GetGormOrderExpr())
}
",CWE-89,56.0,0
"package impl
import (
	""context""
	""strconv""
	""github.com/flyteorg/flyteidl/gen/pb-go/flyteidl/admin""
	""github.com/flyteorg/flyteidl/gen/pb-go/flyteidl/core""
	""github.com/flyteorg/flytestdlib/contextutils""
	""github.com/flyteorg/flytestdlib/logger""
	""github.com/flyteorg/flytestdlib/promutils""
	""google.golang.org/grpc/codes""
	""github.com/flyteorg/flyteadmin/pkg/common""
	""github.com/flyteorg/flyteadmin/pkg/errors""
	""github.com/flyteorg/flyteadmin/pkg/manager/impl/util""
	""github.com/flyteorg/flyteadmin/pkg/manager/impl/validation""
	""github.com/flyteorg/flyteadmin/pkg/manager/interfaces""
	repoInterfaces ""github.com/flyteorg/flyteadmin/pkg/repositories/interfaces""
	""github.com/flyteorg/flyteadmin/pkg/repositories/models""
	""github.com/flyteorg/flyteadmin/pkg/repositories/transformers""
	runtimeInterfaces ""github.com/flyteorg/flyteadmin/pkg/runtime/interfaces""
)
type DescriptionEntityMetrics struct {
	Scope promutils.Scope
}
type DescriptionEntityManager struct {
	db      repoInterfaces.Repository
	config  runtimeInterfaces.Configuration
	metrics DescriptionEntityMetrics
}
func (d *DescriptionEntityManager) GetDescriptionEntity(ctx context.Context, request admin.ObjectGetRequest) (
	*admin.DescriptionEntity, error) {
	if err := validation.ValidateDescriptionEntityGetRequest(request); err != nil {
		logger.Errorf(ctx, ""invalid request [%+v]: %v"", request, err)
		return nil, err
	}
	ctx = contextutils.WithProjectDomain(ctx, request.Id.Project, request.Id.Domain)
	return util.GetDescriptionEntity(ctx, d.db, *request.Id)
}
func (d *DescriptionEntityManager) ListDescriptionEntity(ctx context.Context, request admin.DescriptionEntityListRequest) (*admin.DescriptionEntityList, error) {
	// Check required fields
	if err := validation.ValidateDescriptionEntityListRequest(request); err != nil {
		return nil, err
	}
	ctx = contextutils.WithProjectDomain(ctx, request.Id.Project, request.Id.Domain)
	if request.ResourceType == core.ResourceType_WORKFLOW {
		ctx = contextutils.WithWorkflowID(ctx, request.Id.Name)
	} else {
		ctx = contextutils.WithTaskID(ctx, request.Id.Name)
	}
	filters, err := util.GetDbFilters(util.FilterSpec{
		Project:        request.Id.Project,
		Domain:         request.Id.Domain,
		Name:           request.Id.Name,
		RequestFilters: request.Filters,
	}, common.ResourceTypeToEntity[request.ResourceType])
	if err != nil {
		logger.Error(ctx, ""failed to get database filter"")
		return nil, err
	}
	sortParameter, err := common.NewSortParameter(request.SortBy, models.DescriptionEntityColumns)
	if err != nil {
		return nil, err
	}
	offset, err := validation.ValidateToken(request.Token)
	if err != nil {
		return nil, errors.NewFlyteAdminErrorf(codes.InvalidArgument,
			""invalid pagination token %s for ListWorkflows"", request.Token)
	}
	listDescriptionEntitiesInput := repoInterfaces.ListResourceInput{
		Limit:         int(request.Limit),
		Offset:        offset,
		InlineFilters: filters,
		SortParameter: sortParameter,
	}
	output, err := d.db.DescriptionEntityRepo().List(ctx, listDescriptionEntitiesInput)
	if err != nil {
		logger.Debugf(ctx, ""Failed to list workflows with [%+v] with err %v"", request.Id, err)
		return nil, err
	}
	descriptionEntityList, err := transformers.FromDescriptionEntityModels(output.Entities)
	if err != nil {
		logger.Errorf(ctx,
			""Failed to transform workflow models [%+v] with err: %v"", output.Entities, err)
		return nil, err
	}
	var token string
	if len(output.Entities) == int(request.Limit) {
		token = strconv.Itoa(offset + len(output.Entities))
	}
	return &admin.DescriptionEntityList{
		DescriptionEntities: descriptionEntityList,
		Token:               token,
	}, nil
}
func NewDescriptionEntityManager(
	db repoInterfaces.Repository,
	config runtimeInterfaces.Configuration,
	scope promutils.Scope) interfaces.DescriptionEntityInterface {
	metrics := DescriptionEntityMetrics{
		Scope: scope,
	}
	return &DescriptionEntityManager{
		db:      db,
		config:  config,
		metrics: metrics,
	}
}
",CWE-89,120.0,0
"package impl
import (
	""context""
	""strconv""
	""strings""
	""github.com/flyteorg/flyteidl/gen/pb-go/flyteidl/admin""
	""github.com/flyteorg/flyteidl/gen/pb-go/flyteidl/core""
	""github.com/flyteorg/flytestdlib/contextutils""
	""github.com/flyteorg/flytestdlib/logger""
	""github.com/flyteorg/flytestdlib/promutils""
	""google.golang.org/grpc/codes""
	""github.com/flyteorg/flyteadmin/pkg/common""
	""github.com/flyteorg/flyteadmin/pkg/errors""
	""github.com/flyteorg/flyteadmin/pkg/manager/impl/util""
	""github.com/flyteorg/flyteadmin/pkg/manager/impl/validation""
	""github.com/flyteorg/flyteadmin/pkg/manager/interfaces""
	repoInterfaces ""github.com/flyteorg/flyteadmin/pkg/repositories/interfaces""
	""github.com/flyteorg/flyteadmin/pkg/repositories/models""
	""github.com/flyteorg/flyteadmin/pkg/repositories/transformers""
	runtimeInterfaces ""github.com/flyteorg/flyteadmin/pkg/runtime/interfaces""
)
const state = ""state""
// System-generated workflows are meant to be hidden from the user by default. Therefore we always only show
// workflow-type named entities that have been user generated only.
var nonSystemGeneratedWorkflowsFilter, _ = common.NewSingleValueFilter(
	common.NamedEntityMetadata, common.NotEqual, state, admin.NamedEntityState_SYSTEM_GENERATED)
var defaultWorkflowsFilter, _ = common.NewWithDefaultValueFilter(
	strconv.Itoa(int(admin.NamedEntityState_NAMED_ENTITY_ACTIVE)), nonSystemGeneratedWorkflowsFilter)
type NamedEntityMetrics struct {
	Scope promutils.Scope
}
type NamedEntityManager struct {
	db      repoInterfaces.Repository
	config  runtimeInterfaces.Configuration
	metrics NamedEntityMetrics
}
func (m *NamedEntityManager) UpdateNamedEntity(ctx context.Context, request admin.NamedEntityUpdateRequest) (
	*admin.NamedEntityUpdateResponse, error) {
	if err := validation.ValidateNamedEntityUpdateRequest(request); err != nil {
		logger.Debugf(ctx, ""invalid request [%+v]: %v"", request, err)
		return nil, err
	}
	ctx = contextutils.WithProjectDomain(ctx, request.Id.Project, request.Id.Domain)
	// Ensure entity exists before trying to update it
	_, err := util.GetNamedEntity(ctx, m.db, request.ResourceType, *request.Id)
	if err != nil {
		return nil, err
	}
	metadataModel := transformers.CreateNamedEntityModel(&request)
	err = m.db.NamedEntityRepo().Update(ctx, metadataModel)
	if err != nil {
		logger.Debugf(ctx, ""Failed to update named_entity for [%+v] with err %v"", request.Id, err)
		return nil, err
	}
	return &admin.NamedEntityUpdateResponse{}, nil
}
func (m *NamedEntityManager) GetNamedEntity(ctx context.Context, request admin.NamedEntityGetRequest) (
	*admin.NamedEntity, error) {
	if err := validation.ValidateNamedEntityGetRequest(request); err != nil {
		logger.Debugf(ctx, ""invalid request [%+v]: %v"", request, err)
		return nil, err
	}
	ctx = contextutils.WithProjectDomain(ctx, request.Id.Project, request.Id.Domain)
	return util.GetNamedEntity(ctx, m.db, request.ResourceType, *request.Id)
}
func (m *NamedEntityManager) getQueryFilters(referenceEntity core.ResourceType, requestFilters string) ([]common.InlineFilter, error) {
	filters := make([]common.InlineFilter, 0)
	if referenceEntity == core.ResourceType_WORKFLOW {
		filters = append(filters, defaultWorkflowsFilter)
	}
	if len(requestFilters) == 0 {
		return filters, nil
	}
	additionalFilters, err := util.ParseFilters(requestFilters, common.NamedEntity)
	if err != nil {
		return nil, err
	}
	for _, filter := range additionalFilters {
		if strings.Contains(filter.GetField(), state) {
			filterWithDefaultValue, err := common.NewWithDefaultValueFilter(
				strconv.Itoa(int(admin.NamedEntityState_NAMED_ENTITY_ACTIVE)), filter)
			if err != nil {
				return nil, err
			}
			filters = append(filters, filterWithDefaultValue)
		} else {
			filters = append(filters, filter)
		}
	}
	return filters, nil
}
func (m *NamedEntityManager) ListNamedEntities(ctx context.Context, request admin.NamedEntityListRequest) (
	*admin.NamedEntityList, error) {
	if err := validation.ValidateNamedEntityListRequest(request); err != nil {
		logger.Debugf(ctx, ""invalid request [%+v]: %v"", request, err)
		return nil, err
	}
	ctx = contextutils.WithProjectDomain(ctx, request.Project, request.Domain)
	// HACK: In order to filter by state (if requested) - we need to amend the filter to use COALESCE
	// e.g. eq(state, 1) becomes 'WHERE (COALESCE(state, 0) = '1')' since not every NamedEntity necessarily
	// has an entry, and therefore the default state value '0' (active), should be assumed.
	filters, err := m.getQueryFilters(request.ResourceType, request.Filters)
	if err != nil {
		return nil, err
	}
	sortParameter, err := common.NewSortParameter(request.SortBy, models.NamedEntityColumns)
	if err != nil {
		return nil, err
	}
	offset, err := validation.ValidateToken(request.Token)
	if err != nil {
		return nil, errors.NewFlyteAdminErrorf(codes.InvalidArgument,
			""invalid pagination token %s for ListNamedEntities"", request.Token)
	}
	listInput := repoInterfaces.ListNamedEntityInput{
		ListResourceInput: repoInterfaces.ListResourceInput{
			Limit:         int(request.Limit),
			Offset:        offset,
			InlineFilters: filters,
			SortParameter: sortParameter,
		},
		Project:      request.Project,
		Domain:       request.Domain,
		ResourceType: request.ResourceType,
	}
	output, err := m.db.NamedEntityRepo().List(ctx, listInput)
	if err != nil {
		logger.Debugf(ctx, ""Failed to list named entities of type: %s with project: %s, domain: %s. Returned error was: %v"",
			request.ResourceType, request.Project, request.Domain, err)
		return nil, err
	}
	var token string
	if len(output.Entities) == int(request.Limit) {
		token = strconv.Itoa(offset + len(output.Entities))
	}
	entities := transformers.FromNamedEntityModels(output.Entities)
	return &admin.NamedEntityList{
		Entities: entities,
		Token:    token,
	}, nil
}
func NewNamedEntityManager(
	db repoInterfaces.Repository,
	config runtimeInterfaces.Configuration,
	scope promutils.Scope) interfaces.NamedEntityInterface {
	metrics := NamedEntityMetrics{
		Scope: scope,
	}
	return &NamedEntityManager{
		db:      db,
		config:  config,
		metrics: metrics,
	}
}
",CWE-89,177.0,0
"package impl
import (
	""context""
	""strconv""
	""github.com/flyteorg/flyteidl/gen/pb-go/flyteidl/admin""
	""google.golang.org/grpc/codes""
	""github.com/flyteorg/flyteadmin/pkg/common""
	""github.com/flyteorg/flyteadmin/pkg/errors""
	""github.com/flyteorg/flyteadmin/pkg/manager/impl/util""
	""github.com/flyteorg/flyteadmin/pkg/manager/impl/validation""
	""github.com/flyteorg/flyteadmin/pkg/manager/interfaces""
	repoInterfaces ""github.com/flyteorg/flyteadmin/pkg/repositories/interfaces""
	""github.com/flyteorg/flyteadmin/pkg/repositories/models""
	""github.com/flyteorg/flyteadmin/pkg/repositories/transformers""
	runtimeInterfaces ""github.com/flyteorg/flyteadmin/pkg/runtime/interfaces""
)
type ProjectManager struct {
	db     repoInterfaces.Repository
	config runtimeInterfaces.Configuration
}
var alphabeticalSortParam, _ = common.NewSortParameter(&admin.Sort{
	Direction: admin.Sort_ASCENDING,
	Key:       ""identifier"",
}, models.ProjectColumns)
func (m *ProjectManager) CreateProject(ctx context.Context, request admin.ProjectRegisterRequest) (
	*admin.ProjectRegisterResponse, error) {
	if err := validation.ValidateProjectRegisterRequest(request); err != nil {
		return nil, err
	}
	projectModel := transformers.CreateProjectModel(request.Project)
	err := m.db.ProjectRepo().Create(ctx, projectModel)
	if err != nil {
		return nil, err
	}
	return &admin.ProjectRegisterResponse{}, nil
}
func (m *ProjectManager) getDomains() []*admin.Domain {
	configDomains := m.config.ApplicationConfiguration().GetDomainsConfig()
	var domains = make([]*admin.Domain, len(*configDomains))
	for index, configDomain := range *configDomains {
		domains[index] = &admin.Domain{
			Id:   configDomain.ID,
			Name: configDomain.Name,
		}
	}
	return domains
}
func (m *ProjectManager) ListProjects(ctx context.Context, request admin.ProjectListRequest) (*admin.Projects, error) {
	spec := util.FilterSpec{
		RequestFilters: request.Filters,
	}
	filters, err := util.GetDbFilters(spec, common.Project)
	if err != nil {
		return nil, err
	}
	sortParameter, err := common.NewSortParameter(request.SortBy, models.ProjectColumns)
	if err != nil {
		return nil, err
	}
	if sortParameter == nil {
		sortParameter = alphabeticalSortParam
	}
	offset, err := validation.ValidateToken(request.Token)
	if err != nil {
		return nil, errors.NewFlyteAdminErrorf(codes.InvalidArgument,
			""invalid pagination token %s for ListProjects"", request.Token)
	}
	// And finally, query the database
	listProjectsInput := repoInterfaces.ListResourceInput{
		Limit:         int(request.Limit),
		Offset:        offset,
		InlineFilters: filters,
		SortParameter: sortParameter,
	}
	projectModels, err := m.db.ProjectRepo().List(ctx, listProjectsInput)
	if err != nil {
		return nil, err
	}
	projects := transformers.FromProjectModels(projectModels, m.getDomains())
	var token string
	if len(projects) == int(request.Limit) {
		token = strconv.Itoa(offset + len(projects))
	}
	return &admin.Projects{
		Projects: projects,
		Token:    token,
	}, nil
}
func (m *ProjectManager) UpdateProject(ctx context.Context, projectUpdate admin.Project) (*admin.ProjectUpdateResponse, error) {
	var response admin.ProjectUpdateResponse
	projectRepo := m.db.ProjectRepo()
	// Fetch the existing project if exists. If not, return err and do not update.
	_, err := projectRepo.Get(ctx, projectUpdate.Id)
	if err != nil {
		return nil, err
	}
	// Run validation on the request and return err if validation does not succeed.
	if err := validation.ValidateProject(projectUpdate); err != nil {
		return nil, err
	}
	// Transform the provided project into a model and apply to the DB.
	projectUpdateModel := transformers.CreateProjectModel(&projectUpdate)
	err = projectRepo.UpdateProject(ctx, projectUpdateModel)
	if err != nil {
		return nil, err
	}
	return &response, nil
}
func NewProjectManager(db repoInterfaces.Repository, config runtimeInterfaces.Configuration) interfaces.ProjectInterface {
	return &ProjectManager{
		db:     db,
		config: config,
	}
}
",CWE-89,136.0,0
"package impl
import (
	""context""
	""strconv""
	""github.com/flyteorg/flyteidl/gen/pb-go/flyteidl/admin""
	""github.com/flyteorg/flyteidl/gen/pb-go/flyteidl/core""
	""github.com/flyteorg/flytestdlib/contextutils""
	""github.com/flyteorg/flytestdlib/logger""
	""github.com/flyteorg/flytestdlib/promutils""
	""github.com/flyteorg/flytestdlib/promutils/labeled""
	""google.golang.org/grpc/codes""
	""github.com/flyteorg/flyteadmin/pkg/common""
	""github.com/flyteorg/flyteadmin/pkg/errors""
	""github.com/flyteorg/flyteadmin/pkg/manager/impl/util""
	""github.com/flyteorg/flyteadmin/pkg/manager/impl/validation""
	""github.com/flyteorg/flyteadmin/pkg/manager/interfaces""
	repoInterfaces ""github.com/flyteorg/flyteadmin/pkg/repositories/interfaces""
	""github.com/flyteorg/flyteadmin/pkg/repositories/models""
	""github.com/flyteorg/flyteadmin/pkg/repositories/transformers""
)
type signalMetrics struct {
	Scope promutils.Scope
	Set   labeled.Counter
}
type SignalManager struct {
	db      repoInterfaces.Repository
	metrics signalMetrics
}
func getSignalContext(ctx context.Context, identifier *core.SignalIdentifier) context.Context {
	ctx = contextutils.WithProjectDomain(ctx, identifier.ExecutionId.Project, identifier.ExecutionId.Domain)
	ctx = contextutils.WithWorkflowID(ctx, identifier.ExecutionId.Name)
	return contextutils.WithSignalID(ctx, identifier.SignalId)
}
func (s *SignalManager) GetOrCreateSignal(ctx context.Context, request admin.SignalGetOrCreateRequest) (*admin.Signal, error) {
	if err := validation.ValidateSignalGetOrCreateRequest(ctx, request); err != nil {
		logger.Debugf(ctx, ""invalid request [%+v]: %v"", request, err)
		return nil, err
	}
	ctx = getSignalContext(ctx, request.Id)
	signalModel, err := transformers.CreateSignalModel(request.Id, request.Type, nil)
	if err != nil {
		logger.Errorf(ctx, ""Failed to transform signal with id [%+v] and type [+%v] with err: %v"", request.Id, request.Type, err)
		return nil, err
	}
	err = s.db.SignalRepo().GetOrCreate(ctx, &signalModel)
	if err != nil {
		return nil, err
	}
	signal, err := transformers.FromSignalModel(signalModel)
	if err != nil {
		logger.Errorf(ctx, ""Failed to transform signal model [%+v] with err: %v"", signalModel, err)
		return nil, err
	}
	return &signal, nil
}
func (s *SignalManager) ListSignals(ctx context.Context, request admin.SignalListRequest) (*admin.SignalList, error) {
	if err := validation.ValidateSignalListRequest(ctx, request); err != nil {
		logger.Debugf(ctx, ""ListSignals request [%+v] is invalid: %v"", request, err)
		return nil, err
	}
	ctx = getExecutionContext(ctx, request.WorkflowExecutionId)
	identifierFilters, err := util.GetWorkflowExecutionIdentifierFilters(ctx, *request.WorkflowExecutionId)
	if err != nil {
		return nil, err
	}
	filters, err := util.AddRequestFilters(request.Filters, common.Signal, identifierFilters)
	if err != nil {
		return nil, err
	}
	sortParameter, err := common.NewSortParameter(request.SortBy, models.SignalColumns)
	if err != nil {
		return nil, err
	}
	offset, err := validation.ValidateToken(request.Token)
	if err != nil {
		return nil, errors.NewFlyteAdminErrorf(codes.InvalidArgument,
			""invalid pagination token %s for ListSignals"", request.Token)
	}
	signalModelList, err := s.db.SignalRepo().List(ctx, repoInterfaces.ListResourceInput{
		InlineFilters: filters,
		Offset:        offset,
		Limit:         int(request.Limit),
		SortParameter: sortParameter,
	})
	if err != nil {
		logger.Debugf(ctx, ""Failed to list signals with request [%+v] with err %v"",
			request, err)
		return nil, err
	}
	signalList, err := transformers.FromSignalModels(signalModelList)
	if err != nil {
		logger.Debugf(ctx, ""failed to transform signal models for request [%+v] with err: %v"", request, err)
		return nil, err
	}
	var token string
	if len(signalList) == int(request.Limit) {
		token = strconv.Itoa(offset + len(signalList))
	}
	return &admin.SignalList{
		Signals: signalList,
		Token:   token,
	}, nil
}
func (s *SignalManager) SetSignal(ctx context.Context, request admin.SignalSetRequest) (*admin.SignalSetResponse, error) {
	if err := validation.ValidateSignalSetRequest(ctx, s.db, request); err != nil {
		return nil, err
	}
	ctx = getSignalContext(ctx, request.Id)
	signalModel, err := transformers.CreateSignalModel(request.Id, nil, request.Value)
	if err != nil {
		logger.Errorf(ctx, ""Failed to transform signal with id [%+v] and value [+%v] with err: %v"", request.Id, request.Value, err)
		return nil, err
	}
	err = s.db.SignalRepo().Update(ctx, signalModel.SignalKey, signalModel.Value)
	if err != nil {
		return nil, err
	}
	s.metrics.Set.Inc(ctx)
	return &admin.SignalSetResponse{}, nil
}
func NewSignalManager(
	db repoInterfaces.Repository,
	scope promutils.Scope) interfaces.SignalInterface {
	metrics := signalMetrics{
		Scope: scope,
		Set:   labeled.NewCounter(""num_set"", ""count of set signals"", scope),
	}
	return &SignalManager{
		db:      db,
		metrics: metrics,
	}
}
",CWE-89,157.0,0
"package gormimpl
import (
	""fmt""
	""sync""
	""google.golang.org/grpc/codes""
	""gorm.io/gorm""
	""gorm.io/gorm/schema""
	""k8s.io/apimachinery/pkg/util/sets""
	""github.com/flyteorg/flyteadmin/pkg/common""
	adminErrors ""github.com/flyteorg/flyteadmin/pkg/errors""
	""github.com/flyteorg/flyteadmin/pkg/repositories/errors""
	""github.com/flyteorg/flyteadmin/pkg/repositories/interfaces""
)
const Project = ""project""
const Domain = ""domain""
const Name = ""name""
const Version = ""version""
const Description = ""description""
const ResourceType = ""resource_type""
const State = ""state""
const ID = ""id""
const executionTableName = ""executions""
const namedEntityMetadataTableName = ""named_entity_metadata""
const nodeExecutionTableName = ""node_executions""
const taskExecutionTableName = ""task_executions""
const taskTableName = ""tasks""
const workflowTableName = ""workflows""
const descriptionEntityTableName = ""description_entities""
const AdminTagsTableName = ""admin_tags""
const executionAdminTagsTableName = ""execution_admin_tags""
const limit = ""limit""
const filters = ""filters""
var identifierGroupBy = fmt.Sprintf(""%s, %s, %s"", Project, Domain, Name)
var entityToTableName = map[common.Entity]string{
	common.Execution:           ""executions"",
	common.LaunchPlan:          ""launch_plans"",
	common.NodeExecution:       ""node_executions"",
	common.NodeExecutionEvent:  ""node_execution_events"",
	common.Task:                ""tasks"",
	common.TaskExecution:       ""task_executions"",
	common.Workflow:            ""workflows"",
	common.NamedEntity:         ""entities"",
	common.NamedEntityMetadata: ""named_entity_metadata"",
	common.Signal:              ""signals"",
	common.AdminTag:            ""admin_tags"",
	common.ExecutionAdminTag:   ""execution_admin_tags"",
}
var innerJoinExecToNodeExec = fmt.Sprintf(
	""INNER JOIN %s ON %s.execution_project = %s.execution_project AND ""+
		""%s.execution_domain = %s.execution_domain AND %s.execution_name = %s.execution_name"",
	executionTableName, nodeExecutionTableName, executionTableName, nodeExecutionTableName, executionTableName,
	nodeExecutionTableName, executionTableName)
var innerJoinNodeExecToTaskExec = fmt.Sprintf(
	""INNER JOIN %s ON %s.node_id = %s.node_id AND %s.execution_project = %s.execution_project AND ""+
		""%s.execution_domain = %s.execution_domain AND %s.execution_name = %s.execution_name"",
	nodeExecutionTableName, taskExecutionTableName, nodeExecutionTableName, taskExecutionTableName,
	nodeExecutionTableName, taskExecutionTableName, nodeExecutionTableName, taskExecutionTableName,
	nodeExecutionTableName)
// Because dynamic tasks do NOT necessarily register static task definitions, we use a left join to not exclude
// dynamic tasks from list queries.
var leftJoinTaskToTaskExec = fmt.Sprintf(
	""LEFT JOIN %s ON %s.project = %s.project AND %s.domain = %s.domain AND %s.name = %s.name AND ""+
		""%s.version = %s.version"",
	taskTableName, taskExecutionTableName, taskTableName, taskExecutionTableName, taskTableName,
	taskExecutionTableName, taskTableName, taskExecutionTableName, taskTableName)
// Validates there are no missing but required parameters in ListResourceInput
func ValidateListInput(input interfaces.ListResourceInput) adminErrors.FlyteAdminError {
	if input.Limit == 0 {
		return errors.GetInvalidInputError(limit)
	}
	if len(input.InlineFilters) == 0 {
		return errors.GetInvalidInputError(filters)
	}
	return nil
}
func applyFilters(tx *gorm.DB, inlineFilters []common.InlineFilter, mapFilters []common.MapFilter) (*gorm.DB, error) {
	for _, filter := range inlineFilters {
		gormQueryExpr, err := filter.GetGormQueryExpr()
		if err != nil {
			return nil, errors.GetInvalidInputError(err.Error())
		}
		tx = tx.Where(gormQueryExpr.Query, gormQueryExpr.Args)
	}
	for _, mapFilter := range mapFilters {
		tx = tx.Where(mapFilter.GetFilter())
	}
	return tx, nil
}
func applyScopedFilters(tx *gorm.DB, inlineFilters []common.InlineFilter, mapFilters []common.MapFilter) (*gorm.DB, error) {
	for _, filter := range inlineFilters {
		tableName, ok := entityToTableName[filter.GetEntity()]
		if !ok {
			return nil, adminErrors.NewFlyteAdminErrorf(codes.InvalidArgument,
				""unrecognized entity in filter expression: %v"", filter.GetEntity())
		}
		gormQueryExpr, err := filter.GetGormJoinTableQueryExpr(tableName)
		if err != nil {
			return nil, err
		}
		tx = tx.Where(gormQueryExpr.Query, gormQueryExpr.Args)
	}
	for _, mapFilter := range mapFilters {
		tx = tx.Where(mapFilter.GetFilter())
	}
	return tx, nil
}
func modelColumns(v any) sets.String {
	s, err := schema.Parse(v, &sync.Map{}, schema.NamingStrategy{})
	if err != nil {
		panic(err)
	}
	return sets.NewString(s.DBNames...)
}
",CWE-89,129.0,0
"package gormimpl
import (
	""context""
	""github.com/flyteorg/flyteidl/gen/pb-go/flyteidl/core""
	""github.com/flyteorg/flytestdlib/promutils""
	""gorm.io/gorm""
	""github.com/flyteorg/flyteadmin/pkg/common""
	flyteAdminDbErrors ""github.com/flyteorg/flyteadmin/pkg/repositories/errors""
	""github.com/flyteorg/flyteadmin/pkg/repositories/interfaces""
	""github.com/flyteorg/flyteadmin/pkg/repositories/models""
)
// DescriptionEntityRepo Implementation of DescriptionEntityRepoInterface.
type DescriptionEntityRepo struct {
	db               *gorm.DB
	errorTransformer flyteAdminDbErrors.ErrorTransformer
	metrics          gormMetrics
}
func (r *DescriptionEntityRepo) Get(ctx context.Context, input interfaces.GetDescriptionEntityInput) (models.DescriptionEntity, error) {
	var descriptionEntity models.DescriptionEntity
	filters, err := getDescriptionEntityFilters(input.ResourceType, input.Project, input.Domain, input.Name, input.Version)
	if err != nil {
		return models.DescriptionEntity{}, err
	}
	tx := r.db.Table(descriptionEntityTableName)
	// Apply filters
	tx, err = applyFilters(tx, filters, nil)
	if err != nil {
		return models.DescriptionEntity{}, err
	}
	timer := r.metrics.GetDuration.Start()
	tx = tx.Take(&descriptionEntity)
	timer.Stop()
	if tx.Error != nil {
		return models.DescriptionEntity{}, r.errorTransformer.ToFlyteAdminError(tx.Error)
	}
	return descriptionEntity, nil
}
func (r *DescriptionEntityRepo) List(
	ctx context.Context, input interfaces.ListResourceInput) (interfaces.DescriptionEntityCollectionOutput, error) {
	// First validate input.
	if err := ValidateListInput(input); err != nil {
		return interfaces.DescriptionEntityCollectionOutput{}, err
	}
	var descriptionEntities []models.DescriptionEntity
	tx := r.db.Limit(input.Limit).Offset(input.Offset)
	// Apply filters
	tx, err := applyFilters(tx, input.InlineFilters, input.MapFilters)
	if err != nil {
		return interfaces.DescriptionEntityCollectionOutput{}, err
	}
	// Apply sort ordering.
	if input.SortParameter != nil {
		tx = tx.Order(input.SortParameter.GetGormOrderExpr())
	}
	timer := r.metrics.ListDuration.Start()
	tx.Find(&descriptionEntities)
	timer.Stop()
	if tx.Error != nil {
		return interfaces.DescriptionEntityCollectionOutput{}, r.errorTransformer.ToFlyteAdminError(tx.Error)
	}
	return interfaces.DescriptionEntityCollectionOutput{
		Entities: descriptionEntities,
	}, nil
}
func getDescriptionEntityFilters(resourceType core.ResourceType, project string, domain string, name string, version string) ([]common.InlineFilter, error) {
	entity := common.ResourceTypeToEntity[resourceType]
	filters := make([]common.InlineFilter, 0)
	projectFilter, err := common.NewSingleValueFilter(entity, common.Equal, Project, project)
	if err != nil {
		return nil, err
	}
	filters = append(filters, projectFilter)
	domainFilter, err := common.NewSingleValueFilter(entity, common.Equal, Domain, domain)
	if err != nil {
		return nil, err
	}
	filters = append(filters, domainFilter)
	nameFilter, err := common.NewSingleValueFilter(entity, common.Equal, Name, name)
	if err != nil {
		return nil, err
	}
	filters = append(filters, nameFilter)
	versionFilter, err := common.NewSingleValueFilter(entity, common.Equal, Version, version)
	if err != nil {
		return nil, err
	}
	filters = append(filters, versionFilter)
	return filters, nil
}
// NewDescriptionEntityRepo Returns an instance of DescriptionRepoInterface
func NewDescriptionEntityRepo(
	db *gorm.DB, errorTransformer flyteAdminDbErrors.ErrorTransformer, scope promutils.Scope) interfaces.DescriptionEntityRepoInterface {
	metrics := newMetrics(scope)
	return &DescriptionEntityRepo{
		db:               db,
		errorTransformer: errorTransformer,
		metrics:          metrics,
	}
}
",CWE-89,116.0,0
"package gormimpl
import (
	""context""
	""errors""
	""fmt""
	""github.com/flyteorg/flyteidl/gen/pb-go/flyteidl/core""
	""github.com/flyteorg/flytestdlib/promutils""
	""github.com/flyteorg/flyteadmin/pkg/common""
	adminErrors ""github.com/flyteorg/flyteadmin/pkg/repositories/errors""
	""github.com/flyteorg/flyteadmin/pkg/repositories/interfaces""
	""github.com/flyteorg/flyteadmin/pkg/repositories/models""
	""gorm.io/gorm""
)
// Implementation of ExecutionInterface.
type ExecutionRepo struct {
	db               *gorm.DB
	errorTransformer adminErrors.ErrorTransformer
	metrics          gormMetrics
}
func (r *ExecutionRepo) Create(ctx context.Context, input models.Execution) error {
	timer := r.metrics.CreateDuration.Start()
	tx := r.db.Omit(""id"").Create(&input)
	timer.Stop()
	if tx.Error != nil {
		return r.errorTransformer.ToFlyteAdminError(tx.Error)
	}
	return nil
}
func (r *ExecutionRepo) Get(_ context.Context, input interfaces.Identifier) (models.Execution, error) {
	var execution models.Execution
	timer := r.metrics.GetDuration.Start()
	tx := r.db.Where(&models.Execution{
		ExecutionKey: models.ExecutionKey{
			Project: input.Project,
			Domain:  input.Domain,
			Name:    input.Name,
		},
	}).Take(&execution)
	timer.Stop()
	if tx.Error != nil && errors.Is(tx.Error, gorm.ErrRecordNotFound) {
		return models.Execution{}, adminErrors.GetMissingEntityError(""execution"", &core.Identifier{
			Project: input.Project,
			Domain:  input.Domain,
			Name:    input.Name,
		})
	} else if tx.Error != nil {
		return models.Execution{}, r.errorTransformer.ToFlyteAdminError(tx.Error)
	}
	return execution, nil
}
func (r *ExecutionRepo) Update(ctx context.Context, execution models.Execution) error {
	timer := r.metrics.UpdateDuration.Start()
	tx := r.db.Model(&execution).Updates(execution)
	timer.Stop()
	if err := tx.Error; err != nil {
		return r.errorTransformer.ToFlyteAdminError(err)
	}
	return nil
}
func (r *ExecutionRepo) List(_ context.Context, input interfaces.ListResourceInput) (
	interfaces.ExecutionCollectionOutput, error) {
	var err error
	// First validate input.
	if err = ValidateListInput(input); err != nil {
		return interfaces.ExecutionCollectionOutput{}, err
	}
	var executions []models.Execution
	tx := r.db.Limit(input.Limit).Offset(input.Offset)
	// And add join condition as required by user-specified filters (which can potentially include join table attrs).
	if ok := input.JoinTableEntities[common.LaunchPlan]; ok {
		tx = tx.Joins(fmt.Sprintf(""INNER JOIN %s ON %s.launch_plan_id = %s.id"",
			launchPlanTableName, executionTableName, launchPlanTableName))
	}
	if ok := input.JoinTableEntities[common.Workflow]; ok {
		tx = tx.Joins(fmt.Sprintf(""INNER JOIN %s ON %s.workflow_id = %s.id"",
			workflowTableName, executionTableName, workflowTableName))
	}
	if ok := input.JoinTableEntities[common.Task]; ok {
		tx = tx.Joins(fmt.Sprintf(""INNER JOIN %s ON %s.task_id = %s.id"",
			taskTableName, executionTableName, taskTableName))
	}
	if ok := input.JoinTableEntities[common.AdminTag]; ok {
		tx = tx.Joins(fmt.Sprintf(""INNER JOIN %s ON %s.execution_name = %s.execution_name"",
			executionAdminTagsTableName, executionTableName, executionAdminTagsTableName))
		tx = tx.Joins(fmt.Sprintf(""INNER JOIN %s ON %s.id = %s.admin_tag_id"",
			AdminTagsTableName, AdminTagsTableName, executionAdminTagsTableName))
	}
	// Apply filters
	tx, err = applyScopedFilters(tx, input.InlineFilters, input.MapFilters)
	if err != nil {
		return interfaces.ExecutionCollectionOutput{}, err
	}
	// Apply sort ordering.
	if input.SortParameter != nil {
		tx = tx.Order(input.SortParameter.GetGormOrderExpr())
	}
	timer := r.metrics.ListDuration.Start()
	tx = tx.Find(&executions)
	timer.Stop()
	if tx.Error != nil {
		return interfaces.ExecutionCollectionOutput{}, r.errorTransformer.ToFlyteAdminError(tx.Error)
	}
	return interfaces.ExecutionCollectionOutput{
		Executions: executions,
	}, nil
}
func (r *ExecutionRepo) Count(ctx context.Context, input interfaces.CountResourceInput) (int64, error) {
	var err error
	tx := r.db.Model(&models.Execution{})
	// Add join condition as required by user-specified filters (which can potentially include join table attrs).
	if ok := input.JoinTableEntities[common.LaunchPlan]; ok {
		tx = tx.Joins(fmt.Sprintf(""INNER JOIN %s ON %s.launch_plan_id = %s.id"",
			launchPlanTableName, executionTableName, launchPlanTableName))
	}
	if ok := input.JoinTableEntities[common.Workflow]; ok {
		tx = tx.Joins(fmt.Sprintf(""INNER JOIN %s ON %s.workflow_id = %s.id"",
			workflowTableName, executionTableName, workflowTableName))
	}
	if ok := input.JoinTableEntities[common.Task]; ok {
		tx = tx.Joins(fmt.Sprintf(""INNER JOIN %s ON %s.task_id = %s.id"",
			taskTableName, executionTableName, taskTableName))
	}
	// Apply filters
	tx, err = applyScopedFilters(tx, input.InlineFilters, input.MapFilters)
	if err != nil {
		return 0, err
	}
	// Run the query
	timer := r.metrics.CountDuration.Start()
	var count int64
	tx = tx.Count(&count)
	timer.Stop()
	if tx.Error != nil {
		return 0, r.errorTransformer.ToFlyteAdminError(tx.Error)
	}
	return count, nil
}
// Returns an instance of ExecutionRepoInterface
func NewExecutionRepo(
	db *gorm.DB, errorTransformer adminErrors.ErrorTransformer, scope promutils.Scope) interfaces.ExecutionRepoInterface {
	metrics := newMetrics(scope)
	return &ExecutionRepo{
		db:               db,
		errorTransformer: errorTransformer,
		metrics:          metrics,
	}
}
",CWE-89,166.0,0
"package gormimpl
import (
	""context""
	""errors""
	""time""
	""github.com/flyteorg/flyteidl/gen/pb-go/flyteidl/core""
	""github.com/flyteorg/flytestdlib/promutils""
	""github.com/flyteorg/flytestdlib/logger""
	""gorm.io/gorm""
	adminErrors ""github.com/flyteorg/flyteadmin/pkg/repositories/errors""
	""github.com/flyteorg/flyteadmin/pkg/repositories/interfaces""
	""github.com/flyteorg/flyteadmin/pkg/repositories/models""
)
const launchPlanTableName = ""launch_plans""
type launchPlanMetrics struct {
	SetActiveDuration promutils.StopWatch
}
// Implementation of LaunchPlanRepoInterface.
type LaunchPlanRepo struct {
	db                *gorm.DB
	errorTransformer  adminErrors.ErrorTransformer
	metrics           gormMetrics
	launchPlanMetrics launchPlanMetrics
}
func (r *LaunchPlanRepo) Create(ctx context.Context, input models.LaunchPlan) error {
	timer := r.metrics.CreateDuration.Start()
	tx := r.db.Omit(""id"").Create(&input)
	timer.Stop()
	if tx.Error != nil {
		return r.errorTransformer.ToFlyteAdminError(tx.Error)
	}
	return nil
}
func (r *LaunchPlanRepo) Update(ctx context.Context, input models.LaunchPlan) error {
	timer := r.metrics.UpdateDuration.Start()
	tx := r.db.Model(&input).Updates(input)
	timer.Stop()
	if err := tx.Error; err != nil {
		return r.errorTransformer.ToFlyteAdminError(err)
	}
	return nil
}
func (r *LaunchPlanRepo) Get(ctx context.Context, input interfaces.Identifier) (models.LaunchPlan, error) {
	var launchPlan models.LaunchPlan
	timer := r.metrics.GetDuration.Start()
	tx := r.db.Where(&models.LaunchPlan{
		LaunchPlanKey: models.LaunchPlanKey{
			Project: input.Project,
			Domain:  input.Domain,
			Name:    input.Name,
			Version: input.Version,
		},
	}).Take(&launchPlan)
	timer.Stop()
	if tx.Error != nil && errors.Is(tx.Error, gorm.ErrRecordNotFound) {
		return models.LaunchPlan{},
			adminErrors.GetMissingEntityError(core.ResourceType_LAUNCH_PLAN.String(), &core.Identifier{
				Project: input.Project,
				Domain:  input.Domain,
				Name:    input.Name,
				Version: input.Version,
			})
	} else if tx.Error != nil {
		return models.LaunchPlan{}, r.errorTransformer.ToFlyteAdminError(tx.Error)
	}
	return launchPlan, nil
}
// This operation is performed as a two-step transaction because only one launch plan version can be active at a time.
// Transactional semantics are used to guarantee that setting the desired launch plan to active also disables
// the existing launch plan version (if any).
func (r *LaunchPlanRepo) SetActive(
	ctx context.Context, toEnable models.LaunchPlan, toDisable *models.LaunchPlan) error {
	timer := r.launchPlanMetrics.SetActiveDuration.Start()
	defer timer.Stop()
	// Use a transaction to guarantee no partial updates.
	tx := r.db.Begin()
	// There is a launch plan to disable as part of this transaction
	if toDisable != nil {
		tx.Model(&toDisable).UpdateColumns(toDisable)
		if err := tx.Error; err != nil {
			tx.Rollback()
			return r.errorTransformer.ToFlyteAdminError(err)
		}
	}
	// And update the desired version.
	tx.Model(&toEnable).UpdateColumns(toEnable)
	if err := tx.Error; err != nil {
		tx.Rollback()
		return r.errorTransformer.ToFlyteAdminError(err)
	}
	if err := tx.Commit().Error; err != nil {
		return r.errorTransformer.ToFlyteAdminError(err)
	}
	return nil
}
func (r *LaunchPlanRepo) List(ctx context.Context, input interfaces.ListResourceInput) (
	interfaces.LaunchPlanCollectionOutput, error) {
	// First validate input.
	if err := ValidateListInput(input); err != nil {
		return interfaces.LaunchPlanCollectionOutput{}, err
	}
	var launchPlans []models.LaunchPlan
	tx := r.db.Limit(input.Limit).Offset(input.Offset)
	// Add join conditions
	tx = tx.Joins(""inner join workflows on launch_plans.workflow_id = workflows.id"")
	// Apply filters
	tx, err := applyScopedFilters(tx, input.InlineFilters, input.MapFilters)
	if err != nil {
		return interfaces.LaunchPlanCollectionOutput{}, err
	}
	// Apply sort ordering.
	if input.SortParameter != nil {
		tx = tx.Order(input.SortParameter.GetGormOrderExpr())
	}
	timer := r.metrics.ListDuration.Start()
	tx.Find(&launchPlans)
	timer.Stop()
	if tx.Error != nil {
		logger.Warningf(ctx,
			""Failed to list launch plans by workflow with input [%+v] with err: %+v"", input, tx.Error)
		return interfaces.LaunchPlanCollectionOutput{}, r.errorTransformer.ToFlyteAdminError(tx.Error)
	}
	return interfaces.LaunchPlanCollectionOutput{
		LaunchPlans: launchPlans,
	}, nil
}
func (r *LaunchPlanRepo) ListLaunchPlanIdentifiers(ctx context.Context, input interfaces.ListResourceInput) (
	interfaces.LaunchPlanCollectionOutput, error) {
	// Validate input, input must have a limit
	if err := ValidateListInput(input); err != nil {
		return interfaces.LaunchPlanCollectionOutput{}, err
	}
	tx := r.db.Model(models.LaunchPlan{}).Limit(input.Limit).Offset(input.Offset)
	// Apply filters
	tx, err := applyFilters(tx, input.InlineFilters, input.MapFilters)
	if err != nil {
		return interfaces.LaunchPlanCollectionOutput{}, err
	}
	// Apply sort ordering.
	if input.SortParameter != nil {
		tx = tx.Order(input.SortParameter.GetGormOrderExpr())
	}
	// Scan the results into a list of launch plans
	var launchPlans []models.LaunchPlan
	timer := r.metrics.ListIdentifiersDuration.Start()
	tx.Select([]string{Project, Domain, Name}).Group(identifierGroupBy).Scan(&launchPlans)
	timer.Stop()
	if tx.Error != nil {
		return interfaces.LaunchPlanCollectionOutput{}, r.errorTransformer.ToFlyteAdminError(tx.Error)
	}
	return interfaces.LaunchPlanCollectionOutput{
		LaunchPlans: launchPlans,
	}, nil
}
// Returns an instance of LaunchPlanRepoInterface
func NewLaunchPlanRepo(
	db *gorm.DB, errorTransformer adminErrors.ErrorTransformer, scope promutils.Scope) interfaces.LaunchPlanRepoInterface {
	metrics := newMetrics(scope)
	launchPlanMetrics := launchPlanMetrics{
		SetActiveDuration: scope.MustNewStopWatch(
			""set_active"",
			""time taken to set a launch plan to active (and disable the currently active version)"", time.Millisecond),
	}
	return &LaunchPlanRepo{
		db:                db,
		errorTransformer:  errorTransformer,
		metrics:           metrics,
		launchPlanMetrics: launchPlanMetrics,
	}
}
",CWE-89,199.0,0
"package gormimpl
import (
	""context""
	""testing""
	""github.com/flyteorg/flyteadmin/pkg/common""
	""github.com/flyteorg/flyteidl/gen/pb-go/flyteidl/admin""
	mocket ""github.com/Selvatico/go-mocket""
	mockScope ""github.com/flyteorg/flytestdlib/promutils""
	""github.com/stretchr/testify/assert""
	""github.com/flyteorg/flyteadmin/pkg/repositories/errors""
	""github.com/flyteorg/flyteadmin/pkg/repositories/interfaces""
	""github.com/flyteorg/flyteadmin/pkg/repositories/models""
)
func getMockNamedEntityResponseFromDb(expected models.NamedEntity) map[string]interface{} {
	metadata := make(map[string]interface{})
	metadata[""resource_type""] = expected.ResourceType
	metadata[""project""] = expected.Project
	metadata[""domain""] = expected.Domain
	metadata[""name""] = expected.Name
	metadata[""description""] = expected.Description
	metadata[""state""] = expected.State
	return metadata
}
func TestGetNamedEntity(t *testing.T) {
	metadataRepo := NewNamedEntityRepo(GetDbForTest(t), errors.NewTestErrorTransformer(), mockScope.NewTestScope())
	results := make([]map[string]interface{}, 0)
	metadata := getMockNamedEntityResponseFromDb(models.NamedEntity{
		NamedEntityKey: models.NamedEntityKey{
			ResourceType: resourceType,
			Project:      project,
			Domain:       domain,
			Name:         name,
		},
		NamedEntityMetadataFields: models.NamedEntityMetadataFields{
			Description: description,
		},
	})
	results = append(results, metadata)
	GlobalMock := mocket.Catcher.Reset()
	GlobalMock.Logging = true
	GlobalMock.NewMock().WithQuery(
		`SELECT workflows.project,workflows.domain,workflows.name,'2' AS resource_type,named_entity_metadata.description,named_entity_metadata.state FROM ""workflows"" LEFT JOIN named_entity_metadata ON named_entity_metadata.resource_type = 2 AND named_entity_metadata.project = workflows.project AND named_entity_metadata.domain = workflows.domain AND named_entity_metadata.name = workflows.name WHERE workflows.project = $1 AND workflows.domain = $2 AND workflows.name = $3 LIMIT 1`).WithReply(results)
	output, err := metadataRepo.Get(context.Background(), interfaces.GetNamedEntityInput{
		ResourceType: resourceType,
		Project:      project,
		Domain:       domain,
		Name:         name,
	})
	assert.NoError(t, err)
	assert.Equal(t, project, output.Project)
	assert.Equal(t, domain, output.Domain)
	assert.Equal(t, name, output.Name)
	assert.Equal(t, resourceType, output.ResourceType)
	assert.Equal(t, description, output.Description)
}
func TestUpdateNamedEntity_WithExisting(t *testing.T) {
	metadataRepo := NewNamedEntityRepo(GetDbForTest(t), errors.NewTestErrorTransformer(), mockScope.NewTestScope())
	const updatedDescription = ""updated description""
	results := make([]map[string]interface{}, 0)
	activeState := int32(admin.NamedEntityState_NAMED_ENTITY_ACTIVE)
	metadata := getMockNamedEntityResponseFromDb(models.NamedEntity{
		NamedEntityKey: models.NamedEntityKey{
			ResourceType: resourceType,
			Project:      project,
			Domain:       domain,
			Name:         name,
		},
		NamedEntityMetadataFields: models.NamedEntityMetadataFields{
			Description: description,
			State:       &activeState,
		},
	})
	results = append(results, metadata)
	GlobalMock := mocket.Catcher.Reset()
	GlobalMock.Logging = true
	GlobalMock.NewMock().WithQuery(
		`SELECT ""named_entity_metadata"".""created_at"",""named_entity_metadata"".""updated_at"",""named_entity_metadata"".""deleted_at"",""named_entity_metadata"".""resource_type"",""named_entity_metadata"".""project"",""named_entity_metadata"".""domain"",""named_entity_metadata"".""name"",""named_entity_metadata"".""description"",""named_entity_metadata"".""state"" FROM ""named_entity_metadata"" WHERE ""named_entity_metadata"".""resource_type"" = $1 AND ""named_entity_metadata"".""project"" = $2 AND ""named_entity_metadata"".""domain"" = $3 AND ""named_entity_metadata"".""name"" = $4 ORDER BY ""named_entity_metadata"".""id"" LIMIT 1`).WithReply(results)
	mockQuery := GlobalMock.NewMock()
	mockQuery.WithQuery(
		`UPDATE ""named_entity_metadata"" SET ""description""=$1,""state""=$2,""updated_at""=$3 WHERE ""named_entity_metadata"".""resource_type"" = $4 AND ""named_entity_metadata"".""project"" = $5 AND ""named_entity_metadata"".""domain"" = $6 AND ""named_entity_metadata"".""name"" = $7 AND ""resource_type"" = $8 AND ""project"" = $9 AND ""domain"" = $10 AND ""name"" = $11`)
	err := metadataRepo.Update(context.Background(), models.NamedEntity{
		NamedEntityKey: models.NamedEntityKey{
			ResourceType: resourceType,
			Project:      project,
			Domain:       domain,
			Name:         name,
		},
		NamedEntityMetadataFields: models.NamedEntityMetadataFields{
			Description: updatedDescription,
			State:       &activeState,
		},
	})
	assert.NoError(t, err)
	assert.True(t, mockQuery.Triggered)
}
func TestUpdateNamedEntity_CreateNew(t *testing.T) {
	metadataRepo := NewNamedEntityRepo(GetDbForTest(t), errors.NewTestErrorTransformer(), mockScope.NewTestScope())
	const updatedDescription = ""updated description""
	GlobalMock := mocket.Catcher.Reset()
	GlobalMock.Logging = true
	mockQuery := GlobalMock.NewMock()
	mockQuery.WithQuery(
		`INSERT INTO ""named_entity_metadata"" (""created_at"",""updated_at"",""deleted_at"",""resource_type"",""project"",""domain"",""name"",""description"",""state"") VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9)`)
	err := metadataRepo.Update(context.Background(), models.NamedEntity{
		NamedEntityKey: models.NamedEntityKey{
			ResourceType: resourceType,
			Project:      project,
			Domain:       domain,
			Name:         name,
		},
		NamedEntityMetadataFields: models.NamedEntityMetadataFields{
			Description: updatedDescription,
		},
	})
	assert.NoError(t, err)
	assert.True(t, mockQuery.Triggered)
}
func TestListNamedEntity(t *testing.T) {
	metadataRepo := NewNamedEntityRepo(GetDbForTest(t), errors.NewTestErrorTransformer(), mockScope.NewTestScope())
	results := make([]map[string]interface{}, 0)
	metadata := getMockNamedEntityResponseFromDb(models.NamedEntity{
		NamedEntityKey: models.NamedEntityKey{
			ResourceType: resourceType,
			Project:      project,
			Domain:       domain,
			Name:         name,
		},
		NamedEntityMetadataFields: models.NamedEntityMetadataFields{
			Description: description,
		},
	})
	results = append(results, metadata)
	GlobalMock := mocket.Catcher.Reset()
	GlobalMock.Logging = true
	mockQuery := GlobalMock.NewMock()
	mockQuery.WithQuery(
		`SELECT entities.project,entities.domain,entities.name,'2' AS resource_type,named_entity_metadata.description,named_entity_metadata.state FROM ""named_entity_metadata"" RIGHT JOIN (SELECT project,domain,name FROM ""workflows"" WHERE ""domain"" = $1 AND ""project"" = $2 GROUP BY project, domain, name ORDER BY name desc LIMIT 20) AS entities ON named_entity_metadata.resource_type = 2 AND named_entity_metadata.project = entities.project AND named_entity_metadata.domain = entities.domain AND named_entity_metadata.name = entities.name GROUP BY entities.project, entities.domain, entities.name, named_entity_metadata.description, named_entity_metadata.state ORDER BY name desc`).WithReply(results)
	sortParameter, _ := common.NewSortParameter(&admin.Sort{
		Direction: admin.Sort_DESCENDING,
		Key:       ""name"",
	}, models.NamedEntityColumns)
	output, err := metadataRepo.List(context.Background(), interfaces.ListNamedEntityInput{
		ResourceType: resourceType,
		Project:      ""admintests"",
		Domain:       ""development"",
		ListResourceInput: interfaces.ListResourceInput{
			Limit:         20,
			SortParameter: sortParameter,
		},
	})
	assert.NoError(t, err)
	assert.Len(t, output.Entities, 1)
}
",CWE-89,177.0,0
"package gormimpl
import (
	""context""
	""github.com/flyteorg/flytestdlib/promutils""
	""gorm.io/gorm""
	""github.com/flyteorg/flyteadmin/pkg/repositories/errors""
	""github.com/flyteorg/flyteadmin/pkg/repositories/interfaces""
	""github.com/flyteorg/flyteadmin/pkg/repositories/models""
)
type NodeExecutionEventRepo struct {
	db               *gorm.DB
	errorTransformer errors.ErrorTransformer
	metrics          gormMetrics
}
func (r *NodeExecutionEventRepo) Create(ctx context.Context, input models.NodeExecutionEvent) error {
	timer := r.metrics.CreateDuration.Start()
	tx := r.db.Omit(""id"").Create(&input)
	timer.Stop()
	if tx.Error != nil {
		return r.errorTransformer.ToFlyteAdminError(tx.Error)
	}
	return nil
}
// Returns an instance of NodeExecutionRepoInterface
func NewNodeExecutionEventRepo(
	db *gorm.DB, errorTransformer errors.ErrorTransformer, scope promutils.Scope) interfaces.NodeExecutionEventRepoInterface {
	metrics := newMetrics(scope)
	return &NodeExecutionEventRepo{
		db:               db,
		errorTransformer: errorTransformer,
		metrics:          metrics,
	}
}
",CWE-89,40.0,0
"package gormimpl
import (
	""context""
	""errors""
	""github.com/flyteorg/flyteidl/gen/pb-go/flyteidl/admin""
	""github.com/flyteorg/flytestdlib/promutils""
	""google.golang.org/grpc/codes""
	""gorm.io/gorm""
	flyteAdminErrors ""github.com/flyteorg/flyteadmin/pkg/errors""
	flyteAdminDbErrors ""github.com/flyteorg/flyteadmin/pkg/repositories/errors""
	""github.com/flyteorg/flyteadmin/pkg/repositories/interfaces""
	""github.com/flyteorg/flyteadmin/pkg/repositories/models""
)
type ProjectRepo struct {
	db               *gorm.DB
	errorTransformer flyteAdminDbErrors.ErrorTransformer
	metrics          gormMetrics
}
func (r *ProjectRepo) Create(ctx context.Context, project models.Project) error {
	timer := r.metrics.CreateDuration.Start()
	tx := r.db.Omit(""id"").Create(&project)
	timer.Stop()
	if tx.Error != nil {
		return r.errorTransformer.ToFlyteAdminError(tx.Error)
	}
	return nil
}
func (r *ProjectRepo) Get(ctx context.Context, projectID string) (models.Project, error) {
	var project models.Project
	timer := r.metrics.GetDuration.Start()
	tx := r.db.Where(&models.Project{
		Identifier: projectID,
	}).Take(&project)
	timer.Stop()
	if errors.Is(tx.Error, gorm.ErrRecordNotFound) {
		return models.Project{}, flyteAdminErrors.NewFlyteAdminErrorf(codes.NotFound, ""project [%s] not found"", projectID)
	}
	if tx.Error != nil {
		return models.Project{}, r.errorTransformer.ToFlyteAdminError(tx.Error)
	}
	return project, nil
}
func (r *ProjectRepo) List(ctx context.Context, input interfaces.ListResourceInput) ([]models.Project, error) {
	var projects []models.Project
	tx := r.db.Offset(input.Offset)
	if input.Limit != 0 {
		tx = tx.Limit(input.Limit)
	}
	// Apply filters
	// If no filter provided, default to filtering out archived projects
	if len(input.InlineFilters) == 0 && len(input.MapFilters) == 0 {
		tx = tx.Where(""state != ?"", int32(admin.Project_ARCHIVED))
	} else {
		var err error
		tx, err = applyFilters(tx, input.InlineFilters, input.MapFilters)
		if err != nil {
			return nil, err
		}
	}
	// Apply sort ordering
	if input.SortParameter != nil {
		tx = tx.Order(input.SortParameter.GetGormOrderExpr())
	}
	timer := r.metrics.ListDuration.Start()
	tx.Find(&projects)
	timer.Stop()
	if tx.Error != nil {
		return nil, r.errorTransformer.ToFlyteAdminError(tx.Error)
	}
	return projects, nil
}
func NewProjectRepo(db *gorm.DB, errorTransformer flyteAdminDbErrors.ErrorTransformer,
	scope promutils.Scope) interfaces.ProjectRepoInterface {
	metrics := newMetrics(scope)
	return &ProjectRepo{
		db:               db,
		errorTransformer: errorTransformer,
		metrics:          metrics,
	}
}
func (r *ProjectRepo) UpdateProject(ctx context.Context, projectUpdate models.Project) error {
	// Use gorm client to update the two fields that are changed.
	writeTx := r.db.Model(&projectUpdate).Updates(projectUpdate)
	// Return error if applies.
	if writeTx.Error != nil {
		return r.errorTransformer.ToFlyteAdminError(writeTx.Error)
	}
	return nil
}
",CWE-89,108.0,0
"package gormimpl
import (
	""context""
	""testing""
	mocket ""github.com/Selvatico/go-mocket""
	""github.com/flyteorg/flyteidl/gen/pb-go/flyteidl/admin""
	mockScope ""github.com/flyteorg/flytestdlib/promutils""
	""github.com/stretchr/testify/assert""
	""github.com/flyteorg/flyteadmin/pkg/common""
	""github.com/flyteorg/flyteadmin/pkg/repositories/errors""
	""github.com/flyteorg/flyteadmin/pkg/repositories/interfaces""
	""github.com/flyteorg/flyteadmin/pkg/repositories/models""
)
var alphabeticalSortParam, _ = common.NewSortParameter(&admin.Sort{
	Direction: admin.Sort_ASCENDING,
	Key:       ""identifier"",
}, models.ProjectColumns)
func TestCreateProject(t *testing.T) {
	projectRepo := NewProjectRepo(GetDbForTest(t), errors.NewTestErrorTransformer(), mockScope.NewTestScope())
	GlobalMock := mocket.Catcher.Reset()
	query := GlobalMock.NewMock()
	GlobalMock.Logging = true
	query.WithQuery(
		`INSERT INTO ""projects"" (""created_at"",""updated_at"",""deleted_at"",""name"",""description"",""labels"",""state"",""identifier"") VALUES ($1,$2,$3,$4,$5,$6,$7,$8)`)
	activeState := int32(admin.Project_ACTIVE)
	err := projectRepo.Create(context.Background(), models.Project{
		Identifier:  ""proj"",
		Name:        ""proj"",
		Description: ""projDescription"",
		State:       &activeState,
	})
	assert.NoError(t, err)
	assert.True(t, query.Triggered)
}
func TestGetProject(t *testing.T) {
	projectRepo := NewProjectRepo(GetDbForTest(t), errors.NewTestErrorTransformer(), mockScope.NewTestScope())
	GlobalMock := mocket.Catcher.Reset()
	response := make(map[string]interface{})
	response[""identifier""] = ""project_id""
	response[""name""] = ""project_name""
	response[""description""] = ""project_description""
	response[""state""] = admin.Project_ACTIVE
	output, err := projectRepo.Get(context.Background(), ""project_id"")
	assert.Empty(t, output)
	assert.EqualError(t, err, ""project [project_id] not found"")
	query := GlobalMock.NewMock()
	GlobalMock.Logging = true
	query.WithQuery(`SELECT * FROM ""projects"" WHERE ""projects"".""identifier"" = $1 LIMIT 1`).WithReply(
		[]map[string]interface{}{
			response,
		})
	output, err = projectRepo.Get(context.Background(), ""project_id"")
	assert.Nil(t, err)
	assert.Equal(t, ""project_id"", output.Identifier)
	assert.Equal(t, ""project_name"", output.Name)
	assert.Equal(t, ""project_description"", output.Description)
	assert.Equal(t, int32(admin.Project_ACTIVE), *output.State)
}
func testListProjects(input interfaces.ListResourceInput, sql string, t *testing.T) {
	projectRepo := NewProjectRepo(GetDbForTest(t), errors.NewTestErrorTransformer(), mockScope.NewTestScope())
	projects := make([]map[string]interface{}, 1)
	fooProject := make(map[string]interface{})
	fooProject[""identifier""] = ""foo""
	fooProject[""name""] = ""foo =)""
	fooProject[""description""] = ""foo description""
	fooProject[""state""] = admin.Project_ACTIVE
	projects[0] = fooProject
	GlobalMock := mocket.Catcher.Reset()
	GlobalMock.Logging = true
	GlobalMock.NewMock().WithQuery(sql).
		WithReply(projects)
	output, err := projectRepo.List(context.Background(), input)
	assert.Nil(t, err)
	assert.Len(t, output, 1)
	assert.Equal(t, ""foo"", output[0].Identifier)
	assert.Equal(t, ""foo =)"", output[0].Name)
	assert.Equal(t, ""foo description"", output[0].Description)
	assert.Equal(t, int32(admin.Project_ACTIVE), *output[0].State)
}
func TestListProjects(t *testing.T) {
	filter, err := common.NewSingleValueFilter(common.Project, common.Equal, ""name"", ""foo"")
	assert.NoError(t, err)
	testListProjects(interfaces.ListResourceInput{
		Offset:        0,
		Limit:         1,
		InlineFilters: []common.InlineFilter{filter},
		SortParameter: alphabeticalSortParam,
	}, `SELECT * FROM ""projects"" WHERE name = $1 ORDER BY identifier asc LIMIT 1`, t)
}
func TestListProjects_NoFilters(t *testing.T) {
	testListProjects(interfaces.ListResourceInput{
		Offset:        0,
		Limit:         1,
		SortParameter: alphabeticalSortParam,
	}, `SELECT * FROM ""projects"" WHERE state != $1 ORDER BY identifier asc`, t)
}
func TestListProjects_NoLimit(t *testing.T) {
	testListProjects(interfaces.ListResourceInput{
		Offset:        0,
		SortParameter: alphabeticalSortParam,
	}, `SELECT * FROM ""projects"" WHERE state != $1 ORDER BY identifier asc`, t)
}
func TestUpdateProject(t *testing.T) {
	projectRepo := NewProjectRepo(GetDbForTest(t), errors.NewTestErrorTransformer(), mockScope.NewTestScope())
	GlobalMock := mocket.Catcher.Reset()
	query := GlobalMock.NewMock()
	GlobalMock.Logging = true
	query.WithQuery(`UPDATE ""projects"" SET ""updated_at""=$1,""identifier""=$2,""name""=$3,""description""=$4,""state""=$5 WHERE ""identifier"" = $6`)
	activeState := int32(admin.Project_ACTIVE)
	err := projectRepo.UpdateProject(context.Background(), models.Project{
		Identifier:  ""project_id"",
		Name:        ""project_name"",
		Description: ""project_description"",
		State:       &activeState,
	})
	assert.Nil(t, err)
	assert.True(t, query.Triggered)
}
",CWE-89,141.0,0
"package gormimpl
import (
	""context""
	""errors""
	""github.com/flyteorg/flytestdlib/promutils""
	""google.golang.org/grpc/codes""
	""gorm.io/gorm""
	adminerrors ""github.com/flyteorg/flyteadmin/pkg/errors""
	flyteAdminDbErrors ""github.com/flyteorg/flyteadmin/pkg/repositories/errors""
	""github.com/flyteorg/flyteadmin/pkg/repositories/interfaces""
	""github.com/flyteorg/flyteadmin/pkg/repositories/models""
)
// SignalRepo is an implementation of SignalRepoInterface.
type SignalRepo struct {
	db               *gorm.DB
	errorTransformer flyteAdminDbErrors.ErrorTransformer
	metrics          gormMetrics
}
// Get retrieves a signal model from the database store.
func (s *SignalRepo) Get(ctx context.Context, input models.SignalKey) (models.Signal, error) {
	var signal models.Signal
	timer := s.metrics.GetDuration.Start()
	tx := s.db.Where(&models.Signal{
		SignalKey: input,
	}).Take(&signal)
	timer.Stop()
	if errors.Is(tx.Error, gorm.ErrRecordNotFound) {
		return models.Signal{}, adminerrors.NewFlyteAdminError(codes.NotFound, ""signal does not exist"")
	}
	if tx.Error != nil {
		return models.Signal{}, s.errorTransformer.ToFlyteAdminError(tx.Error)
	}
	return signal, nil
}
// GetOrCreate returns a signal if it already exists, if not it creates a new one given the input
func (s *SignalRepo) GetOrCreate(ctx context.Context, input *models.Signal) error {
	timer := s.metrics.CreateDuration.Start()
	tx := s.db.FirstOrCreate(&input, input)
	timer.Stop()
	if tx.Error != nil {
		return s.errorTransformer.ToFlyteAdminError(tx.Error)
	}
	return nil
}
// List fetches all signals that match the provided input
func (s *SignalRepo) List(ctx context.Context, input interfaces.ListResourceInput) ([]models.Signal, error) {
	// First validate input.
	if err := ValidateListInput(input); err != nil {
		return nil, err
	}
	var signals []models.Signal
	tx := s.db.Limit(input.Limit).Offset(input.Offset)
	// Apply filters
	tx, err := applyFilters(tx, input.InlineFilters, input.MapFilters)
	if err != nil {
		return nil, err
	}
	// Apply sort ordering.
	if input.SortParameter != nil {
		tx = tx.Order(input.SortParameter.GetGormOrderExpr())
	}
	timer := s.metrics.ListDuration.Start()
	tx.Find(&signals)
	timer.Stop()
	if tx.Error != nil {
		return nil, s.errorTransformer.ToFlyteAdminError(tx.Error)
	}
	return signals, nil
}
// Update sets the value field on the specified signal model
func (s *SignalRepo) Update(ctx context.Context, input models.SignalKey, value []byte) error {
	signal := models.Signal{
		SignalKey: input,
		Value:     value,
	}
	timer := s.metrics.GetDuration.Start()
	tx := s.db.Model(&signal).Select(""value"").Updates(signal)
	timer.Stop()
	if tx.Error != nil {
		return s.errorTransformer.ToFlyteAdminError(tx.Error)
	}
	if tx.RowsAffected == 0 {
		return adminerrors.NewFlyteAdminError(codes.NotFound, ""signal does not exist"")
	}
	return nil
}
// Returns an instance of SignalRepoInterface
func NewSignalRepo(
	db *gorm.DB, errorTransformer flyteAdminDbErrors.ErrorTransformer, scope promutils.Scope) interfaces.SignalRepoInterface {
	metrics := newMetrics(scope)
	return &SignalRepo{
		db:               db,
		errorTransformer: errorTransformer,
		metrics:          metrics,
	}
}
",CWE-89,109.0,0
"package gormimpl
import (
	""context""
	""errors""
	""github.com/flyteorg/flyteidl/gen/pb-go/flyteidl/core""
	""github.com/flyteorg/flytestdlib/promutils""
	""gorm.io/gorm""
	flyteAdminDbErrors ""github.com/flyteorg/flyteadmin/pkg/repositories/errors""
	""github.com/flyteorg/flyteadmin/pkg/repositories/interfaces""
	""github.com/flyteorg/flyteadmin/pkg/repositories/models""
)
// Implementation of TaskExecutionInterface.
type TaskExecutionRepo struct {
	db               *gorm.DB
	errorTransformer flyteAdminDbErrors.ErrorTransformer
	metrics          gormMetrics
}
func (r *TaskExecutionRepo) Create(ctx context.Context, input models.TaskExecution) error {
	timer := r.metrics.CreateDuration.Start()
	tx := r.db.Omit(""id"").Create(&input)
	timer.Stop()
	if tx.Error != nil {
		return r.errorTransformer.ToFlyteAdminError(tx.Error)
	}
	return nil
}
func (r *TaskExecutionRepo) Get(ctx context.Context, input interfaces.GetTaskExecutionInput) (models.TaskExecution, error) {
	var taskExecution models.TaskExecution
	timer := r.metrics.GetDuration.Start()
	tx := r.db.Where(&models.TaskExecution{
		TaskExecutionKey: models.TaskExecutionKey{
			TaskKey: models.TaskKey{
				Project: input.TaskExecutionID.TaskId.Project,
				Domain:  input.TaskExecutionID.TaskId.Domain,
				Name:    input.TaskExecutionID.TaskId.Name,
				Version: input.TaskExecutionID.TaskId.Version,
			},
			NodeExecutionKey: models.NodeExecutionKey{
				NodeID: input.TaskExecutionID.NodeExecutionId.NodeId,
				ExecutionKey: models.ExecutionKey{
					Project: input.TaskExecutionID.NodeExecutionId.ExecutionId.Project,
					Domain:  input.TaskExecutionID.NodeExecutionId.ExecutionId.Domain,
					Name:    input.TaskExecutionID.NodeExecutionId.ExecutionId.Name,
				},
			},
			RetryAttempt: &input.TaskExecutionID.RetryAttempt,
		},
	}).Preload(""ChildNodeExecution"").Take(&taskExecution)
	timer.Stop()
	if tx.Error != nil && errors.Is(tx.Error, gorm.ErrRecordNotFound) {
		return models.TaskExecution{},
			flyteAdminDbErrors.GetMissingEntityError(""task execution"", &core.TaskExecutionIdentifier{
				TaskId: &core.Identifier{
					Project: input.TaskExecutionID.TaskId.Project,
					Domain:  input.TaskExecutionID.TaskId.Domain,
					Name:    input.TaskExecutionID.TaskId.Name,
					Version: input.TaskExecutionID.TaskId.Version,
				},
				NodeExecutionId: &core.NodeExecutionIdentifier{
					NodeId: input.TaskExecutionID.NodeExecutionId.NodeId,
					ExecutionId: &core.WorkflowExecutionIdentifier{
						Project: input.TaskExecutionID.NodeExecutionId.ExecutionId.Project,
						Domain:  input.TaskExecutionID.NodeExecutionId.ExecutionId.Domain,
						Name:    input.TaskExecutionID.NodeExecutionId.ExecutionId.Name,
					},
				},
			})
	} else if tx.Error != nil {
		return models.TaskExecution{}, r.errorTransformer.ToFlyteAdminError(tx.Error)
	}
	return taskExecution, nil
}
func (r *TaskExecutionRepo) Update(ctx context.Context, execution models.TaskExecution) error {
	timer := r.metrics.UpdateDuration.Start()
	tx := r.db.Save(&execution)
	timer.Stop()
	if err := tx.Error; err != nil {
		return r.errorTransformer.ToFlyteAdminError(err)
	}
	return nil
}
func (r *TaskExecutionRepo) List(ctx context.Context, input interfaces.ListResourceInput) (interfaces.TaskExecutionCollectionOutput, error) {
	if err := ValidateListInput(input); err != nil {
		return interfaces.TaskExecutionCollectionOutput{}, err
	}
	var taskExecutions []models.TaskExecution
	tx := r.db.Limit(input.Limit).Offset(input.Offset).Preload(""ChildNodeExecution"")
	// And add three join conditions (joining multiple tables is fine even we only filter on a subset of table attributes).
	// We are joining on task -> taskExec -> NodeExec -> Exec.
	// NOTE: the order in which the joins are called below are important because postgres will only know about certain
	// tables as they are joined. So we should do it in the order specified above.
	tx = tx.Joins(leftJoinTaskToTaskExec)
	tx = tx.Joins(innerJoinNodeExecToTaskExec)
	tx = tx.Joins(innerJoinExecToNodeExec)
	// Apply filters
	tx, err := applyScopedFilters(tx, input.InlineFilters, input.MapFilters)
	if err != nil {
		return interfaces.TaskExecutionCollectionOutput{}, err
	}
	// Apply sort ordering.
	if input.SortParameter != nil {
		tx = tx.Order(input.SortParameter.GetGormOrderExpr())
	}
	timer := r.metrics.ListDuration.Start()
	tx = tx.Find(&taskExecutions)
	timer.Stop()
	if tx.Error != nil {
		return interfaces.TaskExecutionCollectionOutput{}, r.errorTransformer.ToFlyteAdminError(tx.Error)
	}
	return interfaces.TaskExecutionCollectionOutput{
		TaskExecutions: taskExecutions,
	}, nil
}
func (r *TaskExecutionRepo) Count(ctx context.Context, input interfaces.CountResourceInput) (int64, error) {
	var err error
	tx := r.db.Model(&models.TaskExecution{})
	// Add three join conditions (joining multiple tables is fine even we only filter on a subset of table attributes).
	// We are joining on task -> taskExec -> NodeExec -> Exec.
	// NOTE: the order in which the joins are called below are important because postgres will only know about certain
	// tables as they are joined. So we should do it in the order specified above.
	tx = tx.Joins(leftJoinTaskToTaskExec)
	tx = tx.Joins(innerJoinNodeExecToTaskExec)
	tx = tx.Joins(innerJoinExecToNodeExec)
	// Apply filters
	tx, err = applyScopedFilters(tx, input.InlineFilters, input.MapFilters)
	if err != nil {
		return 0, err
	}
	// Run the query
	timer := r.metrics.CountDuration.Start()
	var count int64
	tx = tx.Count(&count)
	timer.Stop()
	if tx.Error != nil {
		return 0, r.errorTransformer.ToFlyteAdminError(tx.Error)
	}
	return count, nil
}
// Returns an instance of TaskExecutionRepoInterface
func NewTaskExecutionRepo(
	db *gorm.DB, errorTransformer flyteAdminDbErrors.ErrorTransformer, scope promutils.Scope) interfaces.TaskExecutionRepoInterface {
	metrics := newMetrics(scope)
	return &TaskExecutionRepo{
		db:               db,
		errorTransformer: errorTransformer,
		metrics:          metrics,
	}
}
",CWE-89,170.0,0
"package gormimpl
import (
	""context""
	""errors""
	""github.com/flyteorg/flyteidl/gen/pb-go/flyteidl/core""
	""github.com/flyteorg/flytestdlib/promutils""
	""gorm.io/gorm""
	flyteAdminDbErrors ""github.com/flyteorg/flyteadmin/pkg/repositories/errors""
	""github.com/flyteorg/flyteadmin/pkg/repositories/interfaces""
	""github.com/flyteorg/flyteadmin/pkg/repositories/models""
)
// Implementation of TaskRepoInterface.
type TaskRepo struct {
	db               *gorm.DB
	errorTransformer flyteAdminDbErrors.ErrorTransformer
	metrics          gormMetrics
}
func (r *TaskRepo) Create(_ context.Context, input models.Task, descriptionEntity *models.DescriptionEntity) error {
	timer := r.metrics.CreateDuration.Start()
	err := r.db.Transaction(func(_ *gorm.DB) error {
		if descriptionEntity == nil {
			tx := r.db.Omit(""id"").Create(&input)
			if tx.Error != nil {
				return r.errorTransformer.ToFlyteAdminError(tx.Error)
			}
			return nil
		}
		tx := r.db.Omit(""id"").Create(descriptionEntity)
		if tx.Error != nil {
			return r.errorTransformer.ToFlyteAdminError(tx.Error)
		}
		tx = r.db.Omit(""id"").Create(&input)
		if tx.Error != nil {
			return r.errorTransformer.ToFlyteAdminError(tx.Error)
		}
		return nil
	})
	timer.Stop()
	return err
}
func (r *TaskRepo) Get(ctx context.Context, input interfaces.Identifier) (models.Task, error) {
	var task models.Task
	timer := r.metrics.GetDuration.Start()
	tx := r.db.Where(&models.Task{
		TaskKey: models.TaskKey{
			Project: input.Project,
			Domain:  input.Domain,
			Name:    input.Name,
			Version: input.Version,
		},
	}).Take(&task)
	timer.Stop()
	if errors.Is(tx.Error, gorm.ErrRecordNotFound) {
		return models.Task{}, flyteAdminDbErrors.GetMissingEntityError(core.ResourceType_TASK.String(), &core.Identifier{
			Project: input.Project,
			Domain:  input.Domain,
			Name:    input.Name,
			Version: input.Version,
		})
	}
	if tx.Error != nil {
		return models.Task{}, r.errorTransformer.ToFlyteAdminError(tx.Error)
	}
	return task, nil
}
func (r *TaskRepo) List(
	ctx context.Context, input interfaces.ListResourceInput) (interfaces.TaskCollectionOutput, error) {
	// First validate input.
	if err := ValidateListInput(input); err != nil {
		return interfaces.TaskCollectionOutput{}, err
	}
	var tasks []models.Task
	tx := r.db.Limit(input.Limit).Offset(input.Offset)
	// Apply filters
	tx, err := applyFilters(tx, input.InlineFilters, input.MapFilters)
	if err != nil {
		return interfaces.TaskCollectionOutput{}, err
	}
	// Apply sort ordering.
	if input.SortParameter != nil {
		tx = tx.Order(input.SortParameter.GetGormOrderExpr())
	}
	timer := r.metrics.ListDuration.Start()
	tx.Find(&tasks)
	timer.Stop()
	if tx.Error != nil {
		return interfaces.TaskCollectionOutput{}, r.errorTransformer.ToFlyteAdminError(tx.Error)
	}
	return interfaces.TaskCollectionOutput{
		Tasks: tasks,
	}, nil
}
func (r *TaskRepo) ListTaskIdentifiers(ctx context.Context, input interfaces.ListResourceInput) (
	interfaces.TaskCollectionOutput, error) {
	// Validate input.
	if err := ValidateListInput(input); err != nil {
		return interfaces.TaskCollectionOutput{}, err
	}
	tx := r.db.Model(models.Task{}).Limit(input.Limit).Offset(input.Offset)
	// Apply filters
	tx, err := applyFilters(tx, input.InlineFilters, input.MapFilters)
	if err != nil {
		return interfaces.TaskCollectionOutput{}, err
	}
	for _, mapFilter := range input.MapFilters {
		tx = tx.Where(mapFilter.GetFilter())
	}
	// Apply sort ordering.
	if input.SortParameter != nil {
		tx = tx.Order(input.SortParameter.GetGormOrderExpr())
	}
	// Scan the results into a list of tasks
	var tasks []models.Task
	timer := r.metrics.ListIdentifiersDuration.Start()
	tx.Select([]string{Project, Domain, Name}).Group(identifierGroupBy).Scan(&tasks)
	timer.Stop()
	if tx.Error != nil {
		return interfaces.TaskCollectionOutput{}, r.errorTransformer.ToFlyteAdminError(tx.Error)
	}
	return interfaces.TaskCollectionOutput{
		Tasks: tasks,
	}, nil
}
// Returns an instance of TaskRepoInterface
func NewTaskRepo(
	db *gorm.DB, errorTransformer flyteAdminDbErrors.ErrorTransformer, scope promutils.Scope) interfaces.TaskRepoInterface {
	metrics := newMetrics(scope)
	return &TaskRepo{
		db:               db,
		errorTransformer: errorTransformer,
		metrics:          metrics,
	}
}
",CWE-89,152.0,0
"package gormimpl
import (
	""context""
	""errors""
	""github.com/flyteorg/flyteidl/gen/pb-go/flyteidl/core""
	""github.com/flyteorg/flytestdlib/promutils""
	""gorm.io/gorm""
	flyteAdminDbErrors ""github.com/flyteorg/flyteadmin/pkg/repositories/errors""
	""github.com/flyteorg/flyteadmin/pkg/repositories/interfaces""
	""github.com/flyteorg/flyteadmin/pkg/repositories/models""
)
// Implementation of WorkflowRepoInterface.
type WorkflowRepo struct {
	db               *gorm.DB
	errorTransformer flyteAdminDbErrors.ErrorTransformer
	metrics          gormMetrics
}
func (r *WorkflowRepo) Create(_ context.Context, input models.Workflow, descriptionEntity *models.DescriptionEntity) error {
	timer := r.metrics.CreateDuration.Start()
	err := r.db.Transaction(func(_ *gorm.DB) error {
		if descriptionEntity != nil {
			tx := r.db.Omit(""id"").Create(descriptionEntity)
			if tx.Error != nil {
				return r.errorTransformer.ToFlyteAdminError(tx.Error)
			}
		}
		tx := r.db.Omit(""id"").Create(&input)
		if tx.Error != nil {
			return r.errorTransformer.ToFlyteAdminError(tx.Error)
		}
		return nil
	})
	timer.Stop()
	return err
}
func (r *WorkflowRepo) Get(ctx context.Context, input interfaces.Identifier) (models.Workflow, error) {
	var workflow models.Workflow
	timer := r.metrics.GetDuration.Start()
	tx := r.db.Where(&models.Workflow{
		WorkflowKey: models.WorkflowKey{
			Project: input.Project,
			Domain:  input.Domain,
			Name:    input.Name,
			Version: input.Version,
		},
	}).Take(&workflow)
	timer.Stop()
	if tx.Error != nil && errors.Is(tx.Error, gorm.ErrRecordNotFound) {
		return models.Workflow{}, flyteAdminDbErrors.GetMissingEntityError(core.ResourceType_WORKFLOW.String(), &core.Identifier{
			Project: input.Project,
			Domain:  input.Domain,
			Name:    input.Name,
			Version: input.Version,
		})
	} else if tx.Error != nil {
		return models.Workflow{}, r.errorTransformer.ToFlyteAdminError(tx.Error)
	}
	return workflow, nil
}
func (r *WorkflowRepo) List(
	ctx context.Context, input interfaces.ListResourceInput) (interfaces.WorkflowCollectionOutput, error) {
	// First validate input.
	if err := ValidateListInput(input); err != nil {
		return interfaces.WorkflowCollectionOutput{}, err
	}
	var workflows []models.Workflow
	tx := r.db.Limit(input.Limit).Offset(input.Offset)
	// Apply filters
	tx, err := applyFilters(tx, input.InlineFilters, input.MapFilters)
	if err != nil {
		return interfaces.WorkflowCollectionOutput{}, err
	}
	// Apply sort ordering.
	if input.SortParameter != nil {
		tx = tx.Order(input.SortParameter.GetGormOrderExpr())
	}
	timer := r.metrics.ListDuration.Start()
	tx.Find(&workflows)
	timer.Stop()
	if tx.Error != nil {
		return interfaces.WorkflowCollectionOutput{}, r.errorTransformer.ToFlyteAdminError(tx.Error)
	}
	return interfaces.WorkflowCollectionOutput{
		Workflows: workflows,
	}, nil
}
func (r *WorkflowRepo) ListIdentifiers(ctx context.Context, input interfaces.ListResourceInput) (
	interfaces.WorkflowCollectionOutput, error) {
	// Validate input.
	if err := ValidateListInput(input); err != nil {
		return interfaces.WorkflowCollectionOutput{}, err
	}
	tx := r.db.Model(models.Workflow{}).Limit(input.Limit).Offset(input.Offset)
	// Apply filters
	tx, err := applyFilters(tx, input.InlineFilters, input.MapFilters)
	if err != nil {
		return interfaces.WorkflowCollectionOutput{}, err
	}
	// Apply sort ordering.
	if input.SortParameter != nil {
		tx = tx.Order(input.SortParameter.GetGormOrderExpr())
	}
	// Scan the results into a list of workflows
	var workflows []models.Workflow
	timer := r.metrics.ListIdentifiersDuration.Start()
	tx.Select([]string{Project, Domain, Name}).Group(identifierGroupBy).Scan(&workflows)
	timer.Stop()
	if tx.Error != nil {
		return interfaces.WorkflowCollectionOutput{}, r.errorTransformer.ToFlyteAdminError(tx.Error)
	}
	return interfaces.WorkflowCollectionOutput{
		Workflows: workflows,
	}, nil
}
// Returns an instance of WorkflowRepoInterface
func NewWorkflowRepo(
	db *gorm.DB, errorTransformer flyteAdminDbErrors.ErrorTransformer, scope promutils.Scope) interfaces.WorkflowRepoInterface {
	metrics := newMetrics(scope)
	return &WorkflowRepo{
		db:               db,
		errorTransformer: errorTransformer,
		metrics:          metrics,
	}
}
",CWE-89,143.0,0
"package models
import (
	""sync""
	""time""
	""gorm.io/gorm/schema""
	""k8s.io/apimachinery/pkg/util/sets""
)
// This is the base model definition every flyteadmin model embeds.
// This is nearly identical to http://doc.gorm.io/models.html
// own primary keys rather than use the ID as the primary key
type BaseModel struct {
	ID        uint `gorm:""index;autoIncrement""`
	CreatedAt time.Time
	UpdatedAt time.Time
	DeletedAt *time.Time `gorm:""index""`
}
func modelColumns(v any) sets.String {
	s, err := schema.Parse(v, &sync.Map{}, schema.NamingStrategy{})
	if err != nil {
		panic(err)
	}
	return sets.NewString(s.DBNames...)
}
",CWE-89,28.0,0
"package models
import ""github.com/flyteorg/flyteidl/gen/pb-go/flyteidl/core""
// DescriptionEntityKey DescriptionEntity primary key
type DescriptionEntityKey struct {
	ResourceType core.ResourceType `gorm:""primary_key;index:description_entity_project_domain_name_version_idx"" valid:""length(0|255)""`
	Project      string            `gorm:""primary_key;index:description_entity_project_domain_name_version_idx"" valid:""length(0|255)""`
	Domain       string            `gorm:""primary_key;index:description_entity_project_domain_name_version_idx"" valid:""length(0|255)""`
	Name         string            `gorm:""primary_key;index:description_entity_project_domain_name_version_idx"" valid:""length(0|255)""`
	Version      string            `gorm:""primary_key;index:description_entity_project_domain_name_version_idx"" valid:""length(0|255)""`
}
// SourceCode Database model to encapsulate a SourceCode.
type SourceCode struct {
	Link string `valid:""length(0|255)""`
}
// DescriptionEntity Database model to encapsulate a DescriptionEntity.
type DescriptionEntity struct {
	DescriptionEntityKey
	BaseModel
	ShortDescription string
	LongDescription []byte
	SourceCode
}
var DescriptionEntityColumns = modelColumns(DescriptionEntity{})
",CWE-89,33.0,0
"package models
import (
	""time""
	""gorm.io/gorm/clause""
	""gorm.io/gorm""
	""github.com/flyteorg/flytestdlib/storage""
)
// IMPORTANT: If you update the model below, be sure to double check model definitions in
// pkg/repositories/config/migration_models.go
// Execution primary key
type ExecutionKey struct {
	Project string `gorm:""primary_key;column:execution_project"" valid:""length(0|255)""`
	Domain  string `gorm:""primary_key;column:execution_domain"" valid:""length(0|255)""`
	Name    string `gorm:""primary_key;column:execution_name"" valid:""length(0|255)""`
}
// Database model to encapsulate a (workflow) execution.
type Execution struct {
	BaseModel
	ExecutionKey
	LaunchPlanID uint   `gorm:""index""`
	WorkflowID   uint   `gorm:""index""`
	TaskID       uint   `gorm:""index""`
	Phase        string `valid:""length(0|255)""`
	Closure      []byte
	Spec         []byte `gorm:""not null""`
	StartedAt    *time.Time
	// Corresponds to the CreatedAt field in the Execution closure.
	// Prefixed with Execution to avoid clashes with gorm.Model CreatedAt
	ExecutionCreatedAt *time.Time `gorm:""index:idx_executions_created_at""`
	// Corresponds to the UpdatedAt field in the Execution closure
	// Prefixed with Execution to avoid clashes with gorm.Model UpdatedAt
	ExecutionUpdatedAt *time.Time
	Duration           time.Duration
	// In the case of an aborted execution this string may be non-empty.
	// It should be ignored for any other value of phase other than aborted.
	AbortCause string `valid:""length(0|255)""`
	// Corresponds to the execution mode used to trigger this execution
	Mode int32
	// The ""parent"" execution (if there is one) that is related to this execution.
	SourceExecutionID uint
	// The parent node execution if this was launched by a node
	ParentNodeExecutionID uint
	// Cluster where execution was triggered
	Cluster string `valid:""length(0|255)""`
	// Offloaded location of inputs LiteralMap. These are the inputs evaluated and contain applied defaults.
	InputsURI storage.DataReference
	// User specified inputs. This map might be incomplete and not include defaults applied
	UserInputsURI storage.DataReference
	// Execution Error Kind. nullable
	ErrorKind *string `gorm:""index""`
	// Execution Error Code nullable
	ErrorCode *string `valid:""length(0|255)""`
	// The user responsible for launching this execution.
	// This is also stored in the spec but promoted as a column for filtering.
	User string `gorm:""index"" valid:""length(0|255)""`
	// GORM doesn't save the zero value for ints, so we use a pointer for the State field
	State *int32 `gorm:""index;default:0""`
	// The resource type of the entity used to launch the execution, one of 'launch_plan' or 'task'
	LaunchEntity string
	// Tags associated with the execution
	Tags []AdminTag `gorm:""many2many:execution_admin_tags;""`
}
type AdminTag struct {
	gorm.Model
	Name string `gorm:""index:,unique;size:255""`
}
func (b *AdminTag) BeforeCreate(tx *gorm.DB) (err error) {
	tx.Statement.AddClause(clause.OnConflict{
		Columns:   []clause.Column{{Name: ""name""}},            // key column
		DoUpdates: clause.AssignmentColumns([]string{""name""}), // column needed to be updated
	})
	return nil
}
var (
	ExecutionColumns = modelColumns(Execution{})
	AdminTagColumns  = modelColumns(AdminTag{})
)
",CWE-89,88.0,0
"package models
// Launch plan primary key
type LaunchPlanKey struct {
	Project string `gorm:""primary_key;index:lp_project_domain_name_idx,lp_project_domain_idx"" valid:""length(0|255)""`
	Domain  string `gorm:""primary_key;index:lp_project_domain_name_idx,lp_project_domain_idx"" valid:""length(0|255)""`
	Name    string `gorm:""primary_key;index:lp_project_domain_name_idx"" valid:""length(0|255)""`
	Version string `gorm:""primary_key"" valid:""length(0|255)""`
}
type LaunchPlanScheduleType string
const (
	// LaunchPlanScheduleTypeNONE is the const representing the launch plan does not have a schedule
	LaunchPlanScheduleTypeNONE LaunchPlanScheduleType = ""NONE""
	// LaunchPlanScheduleTypeCRON is the const representing the launch plan has a CRON type of schedule
	LaunchPlanScheduleTypeCRON LaunchPlanScheduleType = ""CRON""
	// LaunchPlanScheduleTypeRATE is the launch plan has a RATE type of schedule
	LaunchPlanScheduleTypeRATE LaunchPlanScheduleType = ""RATE""
)
// Database model to encapsulate a launch plan.
type LaunchPlan struct {
	BaseModel
	LaunchPlanKey
	Spec       []byte `gorm:""not null""`
	WorkflowID uint   `gorm:""index""`
	Closure    []byte `gorm:""not null""`
	// GORM doesn't save the zero value for ints, so we use a pointer for the State field
	State *int32 `gorm:""default:0""`
	// Hash of the launch plan
	Digest       []byte
	ScheduleType LaunchPlanScheduleType
}
var LaunchPlanColumns = modelColumns(LaunchPlan{})
",CWE-89,37.0,0
"package models
import (
	""github.com/flyteorg/flyteidl/gen/pb-go/flyteidl/core""
)
// NamedEntityMetadata primary key
type NamedEntityMetadataKey struct {
	ResourceType core.ResourceType `gorm:""primary_key;index:named_entity_metadata_type_project_domain_name_idx"" valid:""length(0|255)""`
	Project      string            `gorm:""primary_key;index:named_entity_metadata_type_project_domain_name_idx"" valid:""length(0|255)""`
	Domain       string            `gorm:""primary_key;index:named_entity_metadata_type_project_domain_name_idx"" valid:""length(0|255)""`
	Name         string            `gorm:""primary_key;index:named_entity_metadata_type_project_domain_name_idx"" valid:""length(0|255)""`
}
// Fields to be composed into any named entity
type NamedEntityMetadataFields struct {
	Description string `gorm:""type:varchar(300)""`
	// GORM doesn't save the zero value for ints, so we use a pointer for the State field
	State *int32 `gorm:""default:0""`
}
// Database model to encapsulate metadata associated with a NamedEntity
type NamedEntityMetadata struct {
	BaseModel
	NamedEntityMetadataKey
	NamedEntityMetadataFields
}
// NamedEntity key. This is used as a lookup for NamedEntityMetadata, so the
// fields here should match the ones in NamedEntityMetadataKey.
type NamedEntityKey struct {
	ResourceType core.ResourceType
	Project      string `valid:""length(0|255)""`
	Domain       string `valid:""length(0|255)""`
	Name         string `valid:""length(0|255)""`
}
// Composes an identifier (NamedEntity) and its associated metadata fields
type NamedEntity struct {
	NamedEntityKey
	NamedEntityMetadataFields
}
var (
	NamedEntityColumns         = modelColumns(NamedEntity{})
	NamedEntityMetadataColumns = modelColumns(NamedEntityMetadata{})
)
",CWE-89,48.0,0
"package models
import (
	""time""
)
// IMPORTANT: If you update the model below, be sure to double check model definitions in
// pkg/repositories/config/migration_models.go
type NodeExecutionKey struct {
	ExecutionKey
	NodeID string `gorm:""primary_key;index"" valid:""length(0|255)""`
}
// By convention, gorm foreign key references are of the form {ModelName}ID
type NodeExecution struct {
	BaseModel
	NodeExecutionKey
	// Also stored in the closure, but defined as a separate column because it's useful for filtering and sorting.
	Phase     string
	InputURI  string
	Closure   []byte
	StartedAt *time.Time
	// Corresponds to the CreatedAt field in the NodeExecution closure
	// Prefixed with NodeExecution to avoid clashes with gorm.Model CreatedAt
	NodeExecutionCreatedAt *time.Time
	// Corresponds to the UpdatedAt field in the NodeExecution closure
	// Prefixed with NodeExecution to avoid clashes with gorm.Model UpdatedAt
	NodeExecutionUpdatedAt *time.Time
	Duration               time.Duration
	// Metadata about the node execution.
	NodeExecutionMetadata []byte
	// Parent that spawned this node execution - value is empty for executions at level 0
	ParentID *uint `sql:""default:null"" gorm:""index""`
	// List of child node executions - for cases like Dynamic task, sub workflow, etc
	ChildNodeExecutions []NodeExecution `gorm:""foreignKey:ParentID;references:ID""`
	// The task execution (if any) which launched this node execution.
	// TO BE DEPRECATED - as we have now introduced ParentID
	ParentTaskExecutionID *uint `sql:""default:null"" gorm:""index""`
	// The workflow execution (if any) which this node execution launched
	// NOTE: LaunchedExecution[foreignkey:ParentNodeExecutionID] refers to Workflow execution launched and is different from ParentID
	LaunchedExecution Execution `gorm:""foreignKey:ParentNodeExecutionID;references:ID""`
	// Execution Error Kind. nullable, can be one of core.ExecutionError_ErrorKind
	ErrorKind *string `gorm:""index""`
	// Execution Error Code nullable. string value, but finite set determined by the execution engine and plugins
	ErrorCode *string
	// If the node is of Type Task, this should always exist for a successful execution, indicating the cache status for the execution
	CacheStatus *string
	// In the case of dynamic workflow nodes, the remote closure is uploaded to the path specified here.
	DynamicWorkflowRemoteClosureReference string
	// Metadata that is only relevant to the flyteadmin service that is used to parse the model and track additional attributes.
	InternalData []byte
}
var NodeExecutionColumns = modelColumns(NodeExecution{})
",CWE-89,56.0,0
"package models
import (
	""time""
)
type NodeExecutionEvent struct {
	BaseModel
	NodeExecutionKey
	RequestID  string
	OccurredAt time.Time
	Phase      string `gorm:""primary_key""`
}
var NodeExecutionEventColumns = modelColumns(NodeExecutionEvent{})
",CWE-89,16.0,0
"package models
type Project struct {
	BaseModel
	Identifier  string `gorm:""primary_key""`
	Name        string `valid:""length(0|255)""` // Human-readable name, not a unique identifier.
	Description string `gorm:""type:varchar(300)""`
	Labels      []byte
	// GORM doesn't save the zero value for ints, so we use a pointer for the State field
	State *int32 `gorm:""default:0;index""`
}
var ProjectColumns = modelColumns(Project{})
",CWE-89,14.0,0
"package models
// Signal primary key
type SignalKey struct {
	ExecutionKey
	SignalID string `gorm:""primary_key;index"" valid:""length(0|255)""`
}
// Database model to encapsulate a signal.
type Signal struct {
	BaseModel
	SignalKey
	Type  []byte `gorm:""not null""`
	Value []byte
}
var SignalColumns = modelColumns(Signal{})
",CWE-89,18.0,0
"package models
// IMPORTANT: If you update the model below, be sure to double check model definitions in
// pkg/repositories/config/migration_models.go
// Task primary key
type TaskKey struct {
	Project string `gorm:""primary_key;index:task_project_domain_name_idx;index:task_project_domain_idx"" valid:""length(0|255)""`
	Domain  string `gorm:""primary_key;index:task_project_domain_name_idx;index:task_project_domain_idx"" valid:""length(0|255)""`
	Name    string `gorm:""primary_key;index:task_project_domain_name_idx"" valid:""length(0|255)""`
	Version string `gorm:""primary_key"" valid:""length(0|255)""`
}
// Database model to encapsulate a task.
type Task struct {
	BaseModel
	TaskKey
	Closure []byte `gorm:""not null""`
	// Hash of the compiled task closure
	Digest []byte
	// Task type (also stored in the closure put promoted as a column for filtering).
	Type string `valid:""length(0|255)""`
	// ShortDescription for the task.
	ShortDescription string
}
var TaskColumns = modelColumns(Task{})
",CWE-89,28.0,0
"package models
import (
	""time""
)
// IMPORTANT: If you update the model below, be sure to double check model definitions in
// pkg/repositories/config/migration_models.go
// Task execution primary key
type TaskExecutionKey struct {
	TaskKey
	NodeExecutionKey
	// *IMPORTANT* This is a pointer to an int in order to allow setting an empty (""0"") value according to gorm convention.
	// Because RetryAttempt is part of the TaskExecution primary key is should *never* be null.
	RetryAttempt *uint32 `gorm:""primary_key""`
}
// By convention, gorm foreign key references are of the form {ModelName}ID
type TaskExecution struct {
	BaseModel
	TaskExecutionKey
	Phase        string `valid:""length(0|255)""`
	PhaseVersion uint32
	InputURI     string `valid:""length(0|255)""`
	Closure      []byte
	StartedAt    *time.Time
	// Corresponds to the CreatedAt field in the TaskExecution closure
	// This field is prefixed with TaskExecution because it signifies when
	// the execution was createdAt, not to be confused with gorm.Model.CreatedAt
	TaskExecutionCreatedAt *time.Time
	// Corresponds to the UpdatedAt field in the TaskExecution closure
	// This field is prefixed with TaskExecution because it signifies when
	// the execution was UpdatedAt, not to be confused with gorm.Model.UpdatedAt
	TaskExecutionUpdatedAt *time.Time
	Duration               time.Duration
	// The child node executions (if any) launched by this task execution.
	ChildNodeExecution []NodeExecution `gorm:""foreignkey:ParentTaskExecutionID;references:ID""`
}
var TaskExecutionColumns = modelColumns(TaskExecution{})
",CWE-89,42.0,0
"package models
// Workflow primary key
type WorkflowKey struct {
	Project string `gorm:""primary_key;index:workflow_project_domain_name_idx;index:workflow_project_domain_idx""  valid:""length(0|255)""`
	Domain  string `gorm:""primary_key;index:workflow_project_domain_name_idx;index:workflow_project_domain_idx""  valid:""length(0|255)""`
	Name    string `gorm:""primary_key;index:workflow_project_domain_name_idx""  valid:""length(0|255)""`
	Version string `gorm:""primary_key""`
}
// Database model to encapsulate a workflow.
type Workflow struct {
	BaseModel
	WorkflowKey
	TypedInterface          []byte
	RemoteClosureIdentifier string `gorm:""not null"" valid:""length(0|255)""`
	// Hash of the compiled workflow closure
	Digest []byte
	// ShortDescription for the workflow.
	ShortDescription string
}
var WorkflowColumns = modelColumns(Workflow{})
",CWE-89,24.0,0
"{
	""name"": ""typo3/html-sanitizer"",
	""description"": ""HTML sanitizer aiming to provide XSS-safe markup based on explicitly allowed tags, attributes and values."",
	""type"": ""library"",
	""license"": ""MIT"",
	""authors"": [
		{
			""name"": ""Oliver Hader"",
			""email"": ""oliver@typo3.org""
		}
	],
	""extra"": {
		""branch-alias"": {
			""dev-main"": ""2.x-dev""
		}
	},
	""require"": {
		""ext-dom"": ""*"",
		""masterminds/html5"": ""^2.7.6"",
		""php"": ""^7.2 || ^8.0"",
		""psr/log"": ""^1.0 || ^2.0 || ^3.0""
	},
	""require-dev"": {
		""phpunit/phpunit"": ""^8.5""
	},
	""scripts"": {
		""test"": ""phpunit""
	},
	""autoload"": {
		""psr-4"": {
			""TYPO3\\HtmlSanitizer\\"": ""src/""
		}
	},
	""autoload-dev"": {
		""psr-4"": {
			""TYPO3\\HtmlSanitizer\\Tests\\"": ""tests/""
		}
	}
}
",CWE-79,40.0,0
"// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.
package reg
import (
	""context""
	stdx509 ""crypto/x509""
	""crypto/x509/pkix""
	""encoding/pem""
	""log""
	""github.com/cosi-project/runtime/pkg/resource""
	""github.com/cosi-project/runtime/pkg/safe""
	""github.com/cosi-project/runtime/pkg/state""
	""github.com/siderolabs/crypto/x509""
	""google.golang.org/grpc""
	""google.golang.org/grpc/codes""
	""google.golang.org/grpc/peer""
	""google.golang.org/grpc/status""
	securityapi ""github.com/talos-systems/talos/pkg/machinery/api/security""
	""github.com/talos-systems/talos/pkg/machinery/resources/secrets""
)
// Registrator is the concrete type that implements the factory.Registrator and
// securityapi.SecurityServiceServer interfaces.
type Registrator struct {
	securityapi.UnimplementedSecurityServiceServer
	Resources state.State
}
// Register implements the factory.Registrator interface.
//
//nolint:interfacer
func (r *Registrator) Register(s *grpc.Server) {
	securityapi.RegisterSecurityServiceServer(s, r)
}
// Certificate implements the securityapi.SecurityServer interface.
//
// This API is called by Talos worker nodes to request a server certificate for apid running on the node.
// Control plane nodes generate certificates (client and server) directly from machine config PKI.
func (r *Registrator) Certificate(ctx context.Context, in *securityapi.CertificateRequest) (resp *securityapi.CertificateResponse, err error) {
	remotePeer, ok := peer.FromContext(ctx)
	if !ok {
		return nil, status.Error(codes.PermissionDenied, ""peer not found"")
	}
	osRoot, err := safe.StateGet[*secrets.OSRoot](ctx, r.Resources, resource.NewMetadata(secrets.NamespaceName, secrets.OSRootType, secrets.OSRootID, resource.VersionUndefined))
	if err != nil {
		return nil, err
	}
	// decode and validate CSR
	csrPemBlock, _ := pem.Decode(in.Csr)
	if csrPemBlock == nil {
		return nil, status.Errorf(codes.InvalidArgument, ""failed to decode CSR"")
	}
	request, err := stdx509.ParseCertificateRequest(csrPemBlock.Bytes)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, ""failed to parse CSR: %s"", err)
	}
	log.Printf(""received CSR signing request from %s: subject %s dns names %s addresses %s"", remotePeer.Addr, request.Subject, request.DNSNames, request.IPAddresses)
	// allow only server auth certificates
	x509Opts := []x509.Option{
		x509.KeyUsage(stdx509.KeyUsageDigitalSignature),
		x509.ExtKeyUsage([]stdx509.ExtKeyUsage{stdx509.ExtKeyUsageServerAuth}),
	}
	// don't allow any certificates which can be used for client authentication
	//
	// we don't return an error here, as otherwise workers running old versions of Talos
	// will fail to provision client certificate and will never launch apid
	//
	// instead, the returned certificate will be rejected when being used
	if len(request.Subject.Organization) > 0 {
		log.Printf(""removing client auth organization from CSR: %s"", request.Subject.Organization)
		x509Opts = append(x509Opts, x509.OverrideSubject(func(subject *pkix.Name) {
			subject.Organization = nil
		}))
	}
	// TODO: Verify that the request is coming from the IP address declared in
	// the CSR.
	signed, err := x509.NewCertificateFromCSRBytes(
		osRoot.TypedSpec().CA.Crt,
		osRoot.TypedSpec().CA.Key,
		in.Csr,
		x509Opts...,
	)
	if err != nil {
		return nil, status.Errorf(codes.Internal, ""failed to sign CSR: %s"", err)
	}
	resp = &securityapi.CertificateResponse{
		Ca:  osRoot.TypedSpec().CA.Crt,
		Crt: signed.X509CertificatePEM,
	}
	return resp, nil
}
",CWE-863,109.0,0
"// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.
package reg_test
import (
	""context""
	stdx509 ""crypto/x509""
	""net""
	""net/netip""
	""testing""
	""time""
	""github.com/cosi-project/runtime/pkg/state""
	""github.com/cosi-project/runtime/pkg/state/impl/inmem""
	""github.com/cosi-project/runtime/pkg/state/impl/namespaced""
	""github.com/siderolabs/crypto/x509""
	""github.com/stretchr/testify/assert""
	""github.com/stretchr/testify/require""
	""google.golang.org/grpc/peer""
	""github.com/talos-systems/talos/internal/app/trustd/internal/reg""
	""github.com/talos-systems/talos/pkg/machinery/api/security""
	""github.com/talos-systems/talos/pkg/machinery/config/types/v1alpha1/generate""
	""github.com/talos-systems/talos/pkg/machinery/resources/secrets""
	""github.com/talos-systems/talos/pkg/machinery/role""
)
func TestCertificate(t *testing.T) {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()
	resources := state.WrapCore(namespaced.NewState(inmem.Build))
	ca, err := generate.NewTalosCA(time.Now())
	require.NoError(t, err)
	osRoot := secrets.NewOSRoot(secrets.OSRootID)
	osRoot.TypedSpec().CA = &x509.PEMEncodedCertificateAndKey{
		Crt: ca.CrtPEM,
		Key: ca.KeyPEM,
	}
	require.NoError(t, resources.Create(ctx, osRoot))
	ctx = peer.NewContext(ctx, &peer.Peer{
		Addr: &net.TCPAddr{
			IP:   netip.MustParseAddr(""127.0.0.1"").AsSlice(),
			Port: 30000,
		},
	})
	r := &reg.Registrator{
		Resources: resources,
	}
	for _, tt := range []struct {
		name       string
		csrSetters []x509.Option
	}{
		{
			name: ""server certificate"",
			csrSetters: []x509.Option{
				x509.IPAddresses([]net.IP{netip.MustParseAddr(""10.5.0.4"").AsSlice()}),
				x509.DNSNames([]string{""talos-default-worker-1""}),
				x509.CommonName(""talos-default-worker-1""),
			},
		},
		{
			name: ""attempt at client certificate"",
			csrSetters: []x509.Option{
				x509.CommonName(""talos-default-worker-1""),
				x509.Organization(string(role.Impersonator)),
			},
		},
	} {
		tt := tt
		t.Run(tt.name, func(t *testing.T) {
			serverCSR, serverCert, err := x509.NewEd25519CSRAndIdentity(tt.csrSetters...)
			require.NoError(t, err)
			resp, err := r.Certificate(ctx, &security.CertificateRequest{
				Csr: serverCSR.X509CertificateRequestPEM,
			})
			require.NoError(t, err)
			assert.Equal(t, resp.Ca, ca.CrtPEM)
			serverCert.Crt = resp.Crt
			cert, err := serverCert.GetCert()
			require.NoError(t, err)
			assert.Equal(t, stdx509.KeyUsageDigitalSignature, cert.KeyUsage)
			assert.Equal(t, []stdx509.ExtKeyUsage{stdx509.ExtKeyUsageServerAuth}, cert.ExtKeyUsage)
			assert.Equal(t, ""talos-default-worker-1"", cert.Subject.CommonName)
			assert.Equal(t, []string(nil), cert.Subject.Organization)
		})
	}
}
",CWE-863,102.0,0
"package webfinger
import (
	""encoding/json""
	""fmt""
	""net/http""
	""net/url""
	""strings""
)
// GetWebfingerLinks will return webfinger data for an account.
func GetWebfingerLinks(account string) ([]map[string]interface{}, error) {
	type webfingerResponse struct {
		Links []map[string]interface{} `json:""links""`
	}
	account = strings.TrimLeft(account, ""@"") // remove any leading @
	accountComponents := strings.Split(account, ""@"")
	fediverseServer := accountComponents[1]
	// HTTPS is required.
	requestURL, err := url.Parse(""https://"" + fediverseServer)
	if err != nil {
		return nil, fmt.Errorf(""unable to parse fediverse server host %s"", fediverseServer)
	}
	requestURL.Path = ""/.well-known/webfinger""
	query := requestURL.Query()
	query.Add(""resource"", fmt.Sprintf(""acct:%s"", account))
	requestURL.RawQuery = query.Encode()
	// Do not support redirects.
	client := &http.Client{
		CheckRedirect: func(req *http.Request, via []*http.Request) error {
			return http.ErrUseLastResponse
		},
	}
	response, err := client.Get(requestURL.String())
	if err != nil {
		return nil, err
	}
	defer response.Body.Close()
	var links webfingerResponse
	decoder := json.NewDecoder(response.Body)
	if err := decoder.Decode(&links); err != nil {
		return nil, err
	}
	return links.Links, nil
}
",CWE-918,54.0,0
"package indieauth
import (
	""encoding/json""
	""fmt""
	""io""
	""net/http""
	""net/url""
	""strconv""
	""strings""
	""sync""
	""time""
	""github.com/owncast/owncast/core/data""
	""github.com/pkg/errors""
	log ""github.com/sirupsen/logrus""
)
var (
	pendingAuthRequests = make(map[string]*Request)
	lock                = sync.Mutex{}
)
const registrationTimeout = time.Minute * 10
func init() {
	go setupExpiredRequestPruner()
}
// Clear out any pending requests that have been pending for greater than
// the specified timeout value.
func setupExpiredRequestPruner() {
	pruneExpiredRequestsTimer := time.NewTicker(registrationTimeout)
	for range pruneExpiredRequestsTimer.C {
		lock.Lock()
		log.Debugln(""Pruning expired IndieAuth requests."")
		for k, v := range pendingAuthRequests {
			if time.Since(v.Timestamp) > registrationTimeout {
				delete(pendingAuthRequests, k)
			}
		}
		lock.Unlock()
	}
}
// StartAuthFlow will begin the IndieAuth flow by generating an auth request.
func StartAuthFlow(authHost, userID, accessToken, displayName string) (*url.URL, error) {
	if len(pendingAuthRequests) >= maxPendingRequests {
		return nil, errors.New(""Please try again later. Too many pending requests."")
	}
	serverURL := data.GetServerURL()
	if serverURL == """" {
		return nil, errors.New(""Owncast server URL must be set when using auth"")
	}
	r, err := createAuthRequest(authHost, userID, displayName, accessToken, serverURL)
	if err != nil {
		return nil, errors.Wrap(err, ""unable to generate IndieAuth request"")
	}
	pendingAuthRequests[r.State] = r
	return r.Redirect, nil
}
// HandleCallbackCode will handle the callback from the IndieAuth server
// to continue the next step of the auth flow.
func HandleCallbackCode(code, state string) (*Request, *Response, error) {
	request, exists := pendingAuthRequests[state]
	if !exists {
		return nil, nil, errors.New(""no auth requests pending"")
	}
	data := url.Values{}
	data.Set(""grant_type"", ""authorization_code"")
	data.Set(""code"", code)
	data.Set(""client_id"", request.ClientID)
	data.Set(""redirect_uri"", request.Callback.String())
	data.Set(""code_verifier"", request.CodeVerifier)
	// Do not support redirects.
	client := &http.Client{
		CheckRedirect: func(req *http.Request, via []*http.Request) error {
			return http.ErrUseLastResponse
		},
	}
	r, err := http.NewRequest(""POST"", request.Endpoint.String(), strings.NewReader(data.Encode())) // URL-encoded payload
	if err != nil {
		return nil, nil, err
	}
	r.Header.Add(""Content-Type"", ""application/x-www-form-urlencoded"")
	r.Header.Add(""Content-Length"", strconv.Itoa(len(data.Encode())))
	res, err := client.Do(r)
	if err != nil {
		return nil, nil, err
	}
	defer res.Body.Close()
	body, err := io.ReadAll(res.Body)
	if err != nil {
		return nil, nil, err
	}
	var response Response
	if err := json.Unmarshal(body, &response); err != nil {
		return nil, nil, errors.Wrap(err, ""unable to parse IndieAuth response: ""+string(body))
	}
	if response.Error != """" || response.ErrorDescription != """" {
		errorText := makeIndieAuthClientErrorText(response.Error)
		log.Debugln(""IndieAuth error:"", response.Error, response.ErrorDescription)
		return nil, nil, fmt.Errorf(""IndieAuth error: %s - %s"", errorText, response.ErrorDescription)
	}
	// In case this IndieAuth server does not use OAuth error keys or has internal
	// issues resulting in unstructured errors.
	if res.StatusCode < 200 || res.StatusCode > 299 {
		log.Debugln(""IndieAuth error. status code:"", res.StatusCode, ""body:"", string(body))
		return nil, nil, errors.New(""there was an error authenticating against IndieAuth server"")
	}
	// Trim any trailing slash so we can accurately compare the two ""me"" values
	meResponseVerifier := strings.TrimRight(response.Me, ""/"")
	meRequestVerifier := strings.TrimRight(request.Me.String(), ""/"")
	// What we sent and what we got back must match
	if meRequestVerifier != meResponseVerifier {
		return nil, nil, errors.New(""indieauth response does not match the initial anticipated auth destination"")
	}
	return request, &response, nil
}
// Error value should be from this list:
// https://datatracker.ietf.org/doc/html/rfc6749
func makeIndieAuthClientErrorText(err string) string {
	switch err {
	case ""invalid_request"", ""invalid_client"":
		return ""The authentication request was invalid. Please report this to the Owncast project.""
	case ""invalid_grant"", ""unauthorized_client"":
		return ""This authorization request is unauthorized.""
	case ""unsupported_grant_type"":
		return ""The authorization grant type is not supported by the authorization server.""
	default:
		return err
	}
}
",CWE-918,151.0,0
"package gocvss20_test
import (
	""testing""
	gocvss20 ""github.com/pandatix/go-cvss/20""
)
var Gcvss20 *gocvss20.CVSS20
var Gerr error
func BenchmarkParseVector_Base(b *testing.B) {
	benchmarkParseVector(""AV:N/AC:L/Au:N/C:P/I:P/A:C"", b)
}
func BenchmarkParseVector_WithTempAndEnv(b *testing.B) {
	benchmarkParseVector(""AV:N/AC:L/Au:N/C:P/I:P/A:C/E:U/RL:OF/RC:C/CDP:MH/TD:H/CR:M/IR:M/AR:M"", b)
}
func benchmarkParseVector(vector string, b *testing.B) {
	var cvss20 *gocvss20.CVSS20
	var err error
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		cvss20, err = gocvss20.ParseVector(vector)
	}
	Gcvss20 = cvss20
	Gerr = err
}
var Gstr string
func BenchmarkCVSS20Vector(b *testing.B) {
	cvss20, _ := gocvss20.ParseVector(""AV:N/AC:L/Au:N/C:P/I:P/A:C/E:U/RL:OF/RC:C/CDP:MH/TD:H/CR:M/IR:M/AR:M"")
	var str string
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		str = cvss20.Vector()
	}
	Gstr = str
}
var Gget string
func BenchmarkCVSS20Get(b *testing.B) {
	const abv = ""Au""
	cvss20, _ := gocvss20.ParseVector(""AV:N/AC:L/Au:N/C:P/I:P/A:C/E:U/RL:OF/RC:C/CDP:MH/TD:H/CR:M/IR:M/AR:M"")
	var get string
	var err error
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		get, err = cvss20.Get(abv)
	}
	Gget = get
	Gerr = err
}
func BenchmarkCVSS20Set(b *testing.B) {
	const abv = ""Au""
	const value = ""S""
	cvss20, _ := gocvss20.ParseVector(""AV:N/AC:L/Au:N/C:P/I:P/A:C/E:U/RL:OF/RC:C/CDP:MH/TD:H/CR:M/IR:M/AR:M"")
	var err error
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		err = cvss20.Set(abv, value)
	}
	Gerr = err
}
var Gscore float64
func BenchmarkCVSS20BaseScore(b *testing.B) {
	var score float64
	cvss20, _ := gocvss20.ParseVector(""AV:N/AC:L/Au:N/C:P/I:P/A:C/E:U/RL:OF/RC:C/CDP:MH/TD:H/CR:M/IR:M/AR:M"")
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		score = cvss20.BaseScore()
	}
	Gscore = score
}
func BenchmarkCVSS20TemporalScore(b *testing.B) {
	var score float64
	cvss20, _ := gocvss20.ParseVector(""AV:N/AC:L/Au:N/C:P/I:P/A:C/E:U/RL:OF/RC:C/CDP:MH/TD:H/CR:M/IR:M/AR:M"")
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		score = cvss20.TemporalScore()
	}
	Gscore = score
}
func BenchmarkCVSS20EnvironmentalScore(b *testing.B) {
	var score float64
	cvss20, _ := gocvss20.ParseVector(""AV:N/AC:L/Au:N/C:P/I:P/A:C/E:U/RL:OF/RC:C/CDP:MH/TD:H/CR:M/IR:M/AR:M"")
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		score = cvss20.EnvironmentalScore()
	}
	Gscore = score
}
",CWE-125,101.0,0
"package gocvss20
import (
	""testing""
)
func FuzzParseVector(f *testing.F) {
	for _, tt := range testsParseVector {
		f.Add(tt.Vector)
	}
	f.Fuzz(func(t *testing.T, vector string) {
		cvss20, err := ParseVector(vector)
		if err != nil {
			if cvss20 != nil {
				t.Fatal(""not supposed to get a CVSS20 when an error is returned"")
			}
		} else {
			// This check works because CVSS v2.0 has a predetermined order.
			cvss20vector := cvss20.Vector()
			if vector != cvss20vector {
				t.Fatalf(""vector differs at export: input is %s but output is %s"", vector, cvss20vector)
			}
		}
	})
}
",CWE-125,28.0,0
"package gocvss20
import (
	""errors""
	""fmt""
)
var (
	ErrTooShortVector     = errors.New(""too short vector"")
	ErrInvalidMetricOrder = errors.New(""invalid metric order"")
	ErrInvalidMetricValue = errors.New(""invalid metric value"")
)
// ErrDefinedN is an error return by ParseVector when the
// given vector has metrics abbreviations defined multiple times.
type ErrDefinedN struct {
	Abv string
}
func (err ErrDefinedN) Error() string {
	return fmt.Sprintf(""given CVSS v3.1 vector has %s metric abbreviation defined after vector end"", err.Abv)
}
var _ error = (*ErrDefinedN)(nil)
// ErrInvalidMetric is an error returned when a given
// metric does not exist.
type ErrInvalidMetric struct {
	Abv string
}
func (err ErrInvalidMetric) Error() string {
	return fmt.Sprintf(""invalid metric abbreviation : %s"", err.Abv)
}
var _ error = (*ErrInvalidMetric)(nil)
",CWE-125,37.0,0
"package ghinstallation
import (
	""bytes""
	""context""
	""encoding/json""
	""fmt""
	""io""
	""io/ioutil""
	""net/http""
	""sync""
	""time""
	""github.com/google/go-github/v30/github""
)
const (
	// acceptHeader is the GitHub Apps Preview Accept header.
	acceptHeader = ""application/vnd.github.machine-man-preview+json""
	apiBaseURL   = ""https://api.github.com""
)
// Transport provides a http.RoundTripper by wrapping an existing
// http.RoundTripper and provides GitHub Apps authentication as an
// installation.
//
// Client can also be overwritten, and is useful to change to one which
// provides retry logic if you do experience retryable errors.
//
// See https://developer.github.com/apps/building-integrations/setting-up-and-registering-github-apps/about-authentication-options-for-github-apps/
type Transport struct {
	BaseURL                  string                           // BaseURL is the scheme and host for GitHub API, defaults to https://api.github.com
	Client                   Client                           // Client to use to refresh tokens, defaults to http.Client with provided transport
	tr                       http.RoundTripper                // tr is the underlying roundtripper being wrapped
	appID                    int64                            // appID is the GitHub App's ID
	installationID           int64                            // installationID is the GitHub App Installation ID
	InstallationTokenOptions *github.InstallationTokenOptions // parameters restrict a token's access
	appsTransport            *AppsTransport
	mu    *sync.Mutex  // mu protects token
	token *accessToken // token is the installation's access token
}
// accessToken is an installation access token response from GitHub
type accessToken struct {
	Token        string                         `json:""token""`
	ExpiresAt    time.Time                      `json:""expires_at""`
	Permissions  github.InstallationPermissions `json:""permissions,omitempty""`
	Repositories []github.Repository            `json:""repositories,omitempty""`
}
var _ http.RoundTripper = &Transport{}
// NewKeyFromFile returns a Transport using a private key from file.
func NewKeyFromFile(tr http.RoundTripper, appID, installationID int64, privateKeyFile string) (*Transport, error) {
	privateKey, err := ioutil.ReadFile(privateKeyFile)
	if err != nil {
		return nil, fmt.Errorf(""could not read private key: %s"", err)
	}
	return New(tr, appID, installationID, privateKey)
}
// Client is a HTTP client which sends a http.Request and returns a http.Response
// or an error.
type Client interface {
	Do(*http.Request) (*http.Response, error)
}
// New returns an Transport using private key. The key is parsed
// and if any errors occur the error is non-nil.
//
// The provided tr http.RoundTripper should be shared between multiple
// installations to ensure reuse of underlying TCP connections.
//
// The returned Transport's RoundTrip method is safe to be used concurrently.
func New(tr http.RoundTripper, appID, installationID int64, privateKey []byte) (*Transport, error) {
	atr, err := NewAppsTransport(tr, appID, privateKey)
	if err != nil {
		return nil, err
	}
	return NewFromAppsTransport(atr, installationID), nil
}
// NewFromAppsTransport returns a Transport using an existing *AppsTransport.
func NewFromAppsTransport(atr *AppsTransport, installationID int64) *Transport {
	return &Transport{
		BaseURL:        atr.BaseURL,
		Client:         &http.Client{Transport: atr.tr},
		tr:             atr.tr,
		appID:          atr.appID,
		installationID: installationID,
		appsTransport:  atr,
		mu:             &sync.Mutex{},
	}
}
// RoundTrip implements http.RoundTripper interface.
func (t *Transport) RoundTrip(req *http.Request) (*http.Response, error) {
	token, err := t.Token(req.Context())
	if err != nil {
		return nil, err
	}
	req.Header.Set(""Authorization"", ""token ""+token)
	req.Header.Add(""Accept"", acceptHeader) // We add to ""Accept"" header to avoid overwriting existing req headers.
	resp, err := t.tr.RoundTrip(req)
	return resp, err
}
// Token checks the active token expiration and renews if necessary. Token returns
// a valid access token. If renewal fails an error is returned.
func (t *Transport) Token(ctx context.Context) (string, error) {
	t.mu.Lock()
	defer t.mu.Unlock()
	if t.token == nil || t.token.ExpiresAt.Add(-time.Minute).Before(time.Now()) {
		// Token is not set or expired/nearly expired, so refresh
		if err := t.refreshToken(ctx); err != nil {
			return """", fmt.Errorf(""could not refresh installation id %v's token: %s"", t.installationID, err)
		}
	}
	return t.token.Token, nil
}
// Permissions returns a transport token's GitHub installation permissions.
func (t *Transport) Permissions() (github.InstallationPermissions, error) {
	if t.token == nil {
		return github.InstallationPermissions{}, fmt.Errorf(""Permissions() = nil, err: nil token"")
	}
	return t.token.Permissions, nil
}
// Repositories returns a transport token's GitHub repositories.
func (t *Transport) Repositories() ([]github.Repository, error) {
	if t.token == nil {
		return nil, fmt.Errorf(""Repositories() = nil, err: nil token"")
	}
	return t.token.Repositories, nil
}
func (t *Transport) refreshToken(ctx context.Context) error {
	// Convert InstallationTokenOptions into a ReadWriter to pass as an argument to http.NewRequest.
	body, err := GetReadWriter(t.InstallationTokenOptions)
	if err != nil {
		return fmt.Errorf(""could not convert installation token parameters into json: %s"", err)
	}
	req, err := http.NewRequest(""POST"", fmt.Sprintf(""%s/app/installations/%v/access_tokens"", t.BaseURL, t.installationID), body)
	if err != nil {
		return fmt.Errorf(""could not create request: %s"", err)
	}
	// Set Content and Accept headers.
	if body != nil {
		req.Header.Set(""Content-Type"", ""application/json"")
	}
	req.Header.Set(""Accept"", acceptHeader)
	if ctx != nil {
		req = req.WithContext(ctx)
	}
	t.appsTransport.BaseURL = t.BaseURL
	t.appsTransport.Client = t.Client
	resp, err := t.appsTransport.RoundTrip(req)
	if err != nil {
		return fmt.Errorf(""could not get access_tokens from GitHub API for installation ID %v: %v"", t.installationID, err)
	}
	defer resp.Body.Close()
	if resp.StatusCode/100 != 2 {
		return fmt.Errorf(""received non 2xx response status %q when fetching %v"", resp.Status, req.URL)
	}
	return json.NewDecoder(resp.Body).Decode(&t.token)
}
// GetReadWriter converts a body interface into an io.ReadWriter object.
func GetReadWriter(i interface{}) (io.ReadWriter, error) {
	var buf io.ReadWriter
	if i != nil {
		buf = new(bytes.Buffer)
		enc := json.NewEncoder(buf)
		err := enc.Encode(i)
		if err != nil {
			return nil, err
		}
	}
	return buf, nil
}
",CWE-209,192.0,0
"package middleware
import (
	""context""
	""github.com/openfga/openfga/pkg/logger""
	serverErrors ""github.com/openfga/openfga/server/errors""
	""go.uber.org/zap""
	""google.golang.org/grpc""
)
func NewErrorLoggingInterceptor(logger logger.Logger) grpc.UnaryServerInterceptor {
	return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {
		resp, err := handler(ctx, req)
		if err != nil {
			var e error
			if internalError, ok := err.(serverErrors.InternalError); ok {
				e = internalError.Internal()
			}
			logger.Error(""grpc_error"", zap.Error(e), zap.String(""public_error"", err.Error()))
			return nil, err
		}
		return resp, nil
	}
}
func NewStreamingErrorLoggingInterceptor(logger logger.Logger) grpc.StreamServerInterceptor {
	return func(srv interface{}, stream grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) error {
		err := handler(srv, stream)
		if err != nil {
			var e error
			if internalError, ok := err.(serverErrors.InternalError); ok {
				e = internalError.Internal()
			}
			logger.Error(""grpc_error"", zap.Error(e), zap.String(""public_error"", err.Error()))
		}
		return err
	}
}
",CWE-862,43.0,0
"package validatemodels
import (
	""context""
	""encoding/json""
	""fmt""
	""github.com/openfga/openfga/pkg/storage""
	""github.com/openfga/openfga/pkg/storage/mysql""
	""github.com/openfga/openfga/pkg/storage/postgres""
	""github.com/openfga/openfga/pkg/storage/sqlcommon""
	""github.com/openfga/openfga/pkg/typesystem""
	""github.com/spf13/cobra""
	""github.com/spf13/viper""
)
const (
	datastoreEngineFlag = ""datastore-engine""
	datastoreURIFlag    = ""datastore-uri""
)
func NewValidateCommand() *cobra.Command {
	cmd := &cobra.Command{
		Use:   ""validate-models"",
		Short: ""Validate authorization models. NOTE: this command is in beta and may be removed in future releases."",
		Long:  ""List all authorization models across all stores and run validations against them.\nNOTE: this command is in beta and may be removed in future releases."",
		RunE:  runValidate,
		Args:  cobra.NoArgs,
	}
	flags := cmd.Flags()
	flags.String(datastoreEngineFlag, """", ""the datastore engine"")
	flags.String(datastoreURIFlag, """", ""the connection uri to the datastore"")
	// NOTE: if you add a new flag here, update the function below, too
	cmd.PreRun = bindRunFlagsFunc(flags)
	return cmd
}
type validationResult struct {
	StoreID       string `json:""store_id""`
	ModelID       string `json:""model_id""`
	IsLatestModel bool   `json:""is_latest_model""`
	Error         string `json:""error""`
}
func runValidate(_ *cobra.Command, _ []string) error {
	engine := viper.GetString(datastoreEngineFlag)
	uri := viper.GetString(datastoreURIFlag)
	ctx := context.Background()
	var (
		db  storage.OpenFGADatastore
		err error
	)
	switch engine {
	case ""mysql"":
		db, err = mysql.New(uri, sqlcommon.NewConfig())
	case ""postgres"":
		db, err = postgres.New(uri, sqlcommon.NewConfig())
	case """":
		return fmt.Errorf(""missing datastore engine type"")
	case ""memory"":
		fallthrough
	default:
		return fmt.Errorf(""storage engine '%s' is unsupported"", engine)
	}
	if err != nil {
		return fmt.Errorf(""failed to open a connection to the datastore: %v"", err)
	}
	validationResults, err := ValidateAllAuthorizationModels(ctx, db)
	if err != nil {
		return err
	}
	marshalled, err := json.MarshalIndent(validationResults, "" "", ""    "")
	if err != nil {
		return fmt.Errorf(""error gathering validation results: %w"", err)
	}
	fmt.Println(string(marshalled))
	return nil
}
// ValidateAllAuthorizationModels lists all stores and then, for each store, lists all models.
// Then it runs validation on each model.
func ValidateAllAuthorizationModels(ctx context.Context, db storage.OpenFGADatastore) ([]validationResult, error) {
	validationResults := make([]validationResult, 0)
	continuationTokenStores := """"
	for {
		// fetch a page of stores
		stores, tokenStores, err := db.ListStores(ctx, storage.PaginationOptions{
			PageSize: 100,
			From:     continuationTokenStores,
		})
		if err != nil {
			return nil, fmt.Errorf(""error reading stores: %w"", err)
		}
		// validate each store
		for _, store := range stores {
			latestModelID, err := db.FindLatestAuthorizationModelID(ctx, store.Id)
			if err != nil {
				fmt.Printf(""no models in store %s \n"", store.Id)
			}
			continuationTokenModels := """"
			for {
				// fetch a page of models for that store
				models, tokenModels, err := db.ReadAuthorizationModels(ctx, store.Id, storage.PaginationOptions{
					PageSize: 100,
					From:     continuationTokenModels,
				})
				if err != nil {
					return nil, fmt.Errorf(""error reading authorization models: %w"", err)
				}
				// validate each model
				for _, model := range models {
					_, err := typesystem.NewAndValidate(context.Background(), model)
					validationResult := validationResult{
						StoreID:       store.Id,
						ModelID:       model.Id,
						IsLatestModel: model.Id == latestModelID,
					}
					if err != nil {
						validationResult.Error = err.Error()
					}
					validationResults = append(validationResults, validationResult)
				}
				continuationTokenModels = string(tokenModels)
				if continuationTokenModels == """" {
					break
				}
			}
		}
		// next page of stores
		continuationTokenStores = string(tokenStores)
		if continuationTokenStores == """" {
			break
		}
	}
	return validationResults, nil
}
",CWE-835,161.0,0
"package commands
import (
	""context""
	""github.com/oklog/ulid/v2""
	""github.com/openfga/openfga/pkg/logger""
	serverErrors ""github.com/openfga/openfga/pkg/server/errors""
	""github.com/openfga/openfga/pkg/storage""
	""github.com/openfga/openfga/pkg/typesystem""
	openfgapb ""go.buf.build/openfga/go/openfga/api/openfga/v1""
)
// WriteAuthorizationModelCommand performs updates of the store authorization model.
type WriteAuthorizationModelCommand struct {
	backend storage.TypeDefinitionWriteBackend
	logger  logger.Logger
}
func NewWriteAuthorizationModelCommand(
	backend storage.TypeDefinitionWriteBackend,
	logger logger.Logger,
) *WriteAuthorizationModelCommand {
	return &WriteAuthorizationModelCommand{
		backend: backend,
		logger:  logger,
	}
}
// Execute the command using the supplied request.
func (w *WriteAuthorizationModelCommand) Execute(ctx context.Context, req *openfgapb.WriteAuthorizationModelRequest) (*openfgapb.WriteAuthorizationModelResponse, error) {
	// Until this is solved: https://github.com/envoyproxy/protoc-gen-validate/issues/74
	if len(req.GetTypeDefinitions()) > w.backend.MaxTypesPerAuthorizationModel() {
		return nil, serverErrors.ExceededEntityLimit(""type definitions in an authorization model"", w.backend.MaxTypesPerAuthorizationModel())
	}
	// Fill in the schema version for old requests, which don't contain it, while we migrate to the new schema version.
	if req.SchemaVersion == """" {
		req.SchemaVersion = typesystem.SchemaVersion1_1
	}
	model := &openfgapb.AuthorizationModel{
		Id:              ulid.Make().String(),
		SchemaVersion:   req.GetSchemaVersion(),
		TypeDefinitions: req.GetTypeDefinitions(),
	}
	_, err := typesystem.NewAndValidate(ctx, model)
	if err != nil {
		return nil, serverErrors.InvalidAuthorizationModelInput(err)
	}
	err = w.backend.WriteAuthorizationModel(ctx, req.GetStoreId(), model)
	if err != nil {
		return nil, serverErrors.NewInternalError(""Error writing authorization model configuration"", err)
	}
	return &openfgapb.WriteAuthorizationModelResponse{
		AuthorizationModelId: model.Id,
	}, nil
}
",CWE-835,62.0,0
"package test
import (
	""testing""
	""github.com/openfga/openfga/pkg/storage""
)
const (
	DefaultResolveNodeLimit = 25
)
func RunAllTests(t *testing.T, ds storage.OpenFGADatastore) {
	RunQueryTests(t, ds)
	RunCommandTests(t, ds)
}
func RunQueryTests(t *testing.T, ds storage.OpenFGADatastore) {
	t.Run(""TestReadAuthorizationModelQueryErrors"", func(t *testing.T) { TestReadAuthorizationModelQueryErrors(t, ds) })
	t.Run(""TestSuccessfulReadAuthorizationModelQuery"", func(t *testing.T) { TestSuccessfulReadAuthorizationModelQuery(t, ds) })
	t.Run(""TestReadAuthorizationModel"", func(t *testing.T) { ReadAuthorizationModelTest(t, ds) })
	t.Run(""TestExpandQuery"", func(t *testing.T) { TestExpandQuery(t, ds) })
	t.Run(""TestExpandQueryErrors"", func(t *testing.T) { TestExpandQueryErrors(t, ds) })
	t.Run(""TestGetStoreQuery"", func(t *testing.T) { TestGetStoreQuery(t, ds) })
	t.Run(""TestGetStoreSucceeds"", func(t *testing.T) { TestGetStoreSucceeds(t, ds) })
	t.Run(""TestListStores"", func(t *testing.T) { TestListStores(t, ds) })
	t.Run(""TestReadAssertionQuery"", func(t *testing.T) { TestReadAssertionQuery(t, ds) })
	t.Run(""TestReadQuerySuccess"", func(t *testing.T) { ReadQuerySuccessTest(t, ds) })
	t.Run(""TestReadQueryError"", func(t *testing.T) { ReadQueryErrorTest(t, ds) })
	t.Run(""TestReadAllTuples"", func(t *testing.T) { ReadAllTuplesTest(t, ds) })
	t.Run(""TestReadAllTuplesInvalidContinuationToken"", func(t *testing.T) { ReadAllTuplesInvalidContinuationTokenTest(t, ds) })
	t.Run(""TestReadAuthorizationModelsWithoutPaging"",
		func(t *testing.T) { TestReadAuthorizationModelsWithoutPaging(t, ds) },
	)
	t.Run(""TestReadAuthorizationModelsWithPaging"",
		func(t *testing.T) { TestReadAuthorizationModelsWithPaging(t, ds) },
	)
	t.Run(""TestReadAuthorizationModelsInvalidContinuationToken"",
		func(t *testing.T) { TestReadAuthorizationModelsInvalidContinuationToken(t, ds) },
	)
	t.Run(""TestReadChanges"", func(t *testing.T) { TestReadChanges(t, ds) })
	t.Run(""TestReadChangesReturnsSameContTokenWhenNoChanges"",
		func(t *testing.T) { TestReadChangesReturnsSameContTokenWhenNoChanges(t, ds) },
	)
	t.Run(""TestListObjectsRespectsMaxResults"", func(t *testing.T) { TestListObjectsRespectsMaxResults(t, ds) })
}
func RunCommandTests(t *testing.T, ds storage.OpenFGADatastore) {
	t.Run(""TestWriteCommand"", func(t *testing.T) { TestWriteCommand(t, ds) })
	t.Run(""TestWriteAuthorizationModel"", func(t *testing.T) { WriteAuthorizationModelTest(t, ds) })
	t.Run(""TestWriteAssertions"", func(t *testing.T) { TestWriteAssertions(t, ds) })
	t.Run(""TestCreateStore"", func(t *testing.T) { TestCreateStore(t, ds) })
	t.Run(""TestDeleteStore"", func(t *testing.T) { TestDeleteStore(t, ds) })
	t.Run(""TestConnectedObjects"", func(t *testing.T) { ConnectedObjectsTest(t, ds) })
}
func RunAllBenchmarks(b *testing.B, ds storage.OpenFGADatastore) {
	RunListObjectsBenchmarks(b, ds)
}
func RunListObjectsBenchmarks(b *testing.B, ds storage.OpenFGADatastore) {
	b.Run(""BenchmarkListObjectsWithReverseExpand"", func(b *testing.B) { BenchmarkListObjectsWithReverseExpand(b, ds) })
	b.Run(""BenchmarkListObjectsWithConcurrentChecks"", func(b *testing.B) { BenchmarkListObjectsWithConcurrentChecks(b, ds) })
}
",CWE-835,73.0,0
"package storage
import (
	""context""
	""fmt""
	""io""
	""log""
	""strings""
	""testing""
	""time""
	""github.com/cenkalti/backoff/v4""
	""github.com/docker/docker/api/types""
	""github.com/docker/docker/api/types/container""
	""github.com/docker/docker/client""
	""github.com/docker/go-connections/nat""
	""github.com/go-sql-driver/mysql""
	""github.com/oklog/ulid/v2""
	""github.com/pressly/goose/v3""
	""github.com/stretchr/testify/require""
	""github.com/openfga/openfga/assets""
)
const (
	mySQLImage = ""mysql:8""
)
type mySQLTestContainer struct {
	addr     string
	version  int64
	username string
	password string
}
// NewMySQLTestContainer returns an implementation of the DatastoreTestContainer interface
// for MySQL.
func NewMySQLTestContainer() *mySQLTestContainer {
	return &mySQLTestContainer{}
}
func (m *mySQLTestContainer) GetDatabaseSchemaVersion() int64 {
	return m.version
}
// RunMySQLTestContainer runs a MySQL container, connects to it, and returns a
// bootstrapped implementation of the DatastoreTestContainer interface wired up for the
// MySQL datastore engine.
func (m *mySQLTestContainer) RunMySQLTestContainer(t testing.TB) (DatastoreTestContainer, func()) {
	dockerClient, err := client.NewClientWithOpts(
		client.FromEnv,
		client.WithAPIVersionNegotiation(),
	)
	require.NoError(t, err)
	allImages, err := dockerClient.ImageList(context.Background(), types.ImageListOptions{
		All: true,
	})
	require.NoError(t, err)
	foundMysqlImage := false
	for _, image := range allImages {
		for _, tag := range image.RepoTags {
			if strings.Contains(tag, mySQLImage) {
				foundMysqlImage = true
				break
			}
		}
	}
	if !foundMysqlImage {
		t.Logf(""Pulling image %s"", mySQLImage)
		reader, err := dockerClient.ImagePull(context.Background(), mySQLImage, types.ImagePullOptions{})
		require.NoError(t, err)
		_, err = io.Copy(io.Discard, reader) // consume the image pull output to make sure it's done
		require.NoError(t, err)
	}
	containerCfg := container.Config{
		Env: []string{
			""MYSQL_DATABASE=defaultdb"",
			""MYSQL_ROOT_PASSWORD=secret"",
		},
		ExposedPorts: nat.PortSet{
			nat.Port(""3306/tcp""): {},
		},
		Image: mySQLImage,
	}
	hostCfg := container.HostConfig{
		AutoRemove:      true,
		PublishAllPorts: true,
		Tmpfs:           map[string]string{""/var/lib/mysql"": """"},
	}
	name := fmt.Sprintf(""mysql-%s"", ulid.Make().String())
	cont, err := dockerClient.ContainerCreate(context.Background(), &containerCfg, &hostCfg, nil, nil, name)
	require.NoError(t, err, ""failed to create mysql docker container"")
	stopContainer := func() {
		t.Logf(""stopping container %s"", name)
		timeoutSec := 5
		err := dockerClient.ContainerStop(context.Background(), cont.ID, container.StopOptions{Timeout: &timeoutSec})
		if err != nil && !client.IsErrNotFound(err) {
			t.Logf(""failed to stop mysql container: %v"", err)
		}
		dockerClient.Close()
		t.Logf(""stopped container %s"", name)
	}
	err = dockerClient.ContainerStart(context.Background(), cont.ID, types.ContainerStartOptions{})
	if err != nil {
		stopContainer()
		t.Fatalf(""failed to start mysql container: %v"", err)
	}
	containerJSON, err := dockerClient.ContainerInspect(context.Background(), cont.ID)
	require.NoError(t, err)
	p, ok := containerJSON.NetworkSettings.Ports[""3306/tcp""]
	if !ok || len(p) == 0 {
		t.Fatalf(""failed to get host port mapping from mysql container"")
	}
	mySQLTestContainer := &mySQLTestContainer{
		addr:     fmt.Sprintf(""localhost:%s"", p[0].HostPort),
		username: ""root"",
		password: ""secret"",
	}
	uri := fmt.Sprintf(""%s:%s@tcp(%s)/defaultdb?parseTime=true"", mySQLTestContainer.username, mySQLTestContainer.password, mySQLTestContainer.addr)
	err = mysql.SetLogger(log.New(io.Discard, """", 0))
	require.NoError(t, err)
	goose.SetLogger(goose.NopLogger())
	db, err := goose.OpenDBWithDriver(""mysql"", uri)
	require.NoError(t, err)
	defer db.Close()
	backoffPolicy := backoff.NewExponentialBackOff()
	backoffPolicy.MaxElapsedTime = 2 * time.Minute
	err = backoff.Retry(
		func() error {
			return db.Ping()
		},
		backoffPolicy,
	)
	if err != nil {
		stopContainer()
		t.Fatalf(""failed to connect to mysql container: %v"", err)
	}
	goose.SetBaseFS(assets.EmbedMigrations)
	err = goose.Up(db, assets.MySQLMigrationDir)
	require.NoError(t, err)
	version, err := goose.GetDBVersion(db)
	require.NoError(t, err)
	mySQLTestContainer.version = version
	return mySQLTestContainer, stopContainer
}
// GetConnectionURI returns the mysql connection uri for the running mysql test container.
func (m *mySQLTestContainer) GetConnectionURI(includeCredentials bool) string {
	creds := """"
	if includeCredentials {
		creds = fmt.Sprintf(""%s:%s@"", m.username, m.password)
	}
	return fmt.Sprintf(
		""%stcp(%s)/%s?parseTime=true"",
		creds,
		m.addr,
		""defaultdb"",
	)
}
func (m *mySQLTestContainer) GetUsername() string {
	return m.username
}
func (m *mySQLTestContainer) GetPassword() string {
	return m.password
}
",CWE-401,192.0,0
"package storage
import (
	""context""
	""fmt""
	""io""
	""strings""
	""testing""
	""time""
	""github.com/cenkalti/backoff/v4""
	""github.com/docker/docker/api/types""
	""github.com/docker/docker/api/types/container""
	""github.com/docker/docker/client""
	""github.com/docker/go-connections/nat""
	_ ""github.com/jackc/pgx/v5/stdlib""
	""github.com/oklog/ulid/v2""
	""github.com/pressly/goose/v3""
	""github.com/stretchr/testify/require""
	""github.com/openfga/openfga/assets""
)
const (
	postgresImage = ""postgres:14""
)
type postgresTestContainer struct {
	addr     string
	version  int64
	username string
	password string
}
// NewPostgresTestContainer returns an implementation of the DatastoreTestContainer interface
// for Postgres.
func NewPostgresTestContainer() *postgresTestContainer {
	return &postgresTestContainer{}
}
func (p *postgresTestContainer) GetDatabaseSchemaVersion() int64 {
	return p.version
}
// RunPostgresTestContainer runs a Postgres container, connects to it, and returns a
// bootstrapped implementation of the DatastoreTestContainer interface wired up for the
// Postgres datastore engine.
func (p *postgresTestContainer) RunPostgresTestContainer(t testing.TB) (DatastoreTestContainer, func()) {
	dockerClient, err := client.NewClientWithOpts(
		client.FromEnv,
		client.WithAPIVersionNegotiation(),
	)
	require.NoError(t, err)
	allImages, err := dockerClient.ImageList(context.Background(), types.ImageListOptions{
		All: true,
	})
	require.NoError(t, err)
	foundPostgresImage := false
	for _, image := range allImages {
		for _, tag := range image.RepoTags {
			if strings.Contains(tag, postgresImage) {
				foundPostgresImage = true
				break
			}
		}
	}
	if !foundPostgresImage {
		t.Logf(""Pulling image %s"", postgresImage)
		reader, err := dockerClient.ImagePull(context.Background(), postgresImage, types.ImagePullOptions{})
		require.NoError(t, err)
		_, err = io.Copy(io.Discard, reader) // consume the image pull output to make sure it's done
		require.NoError(t, err)
	}
	containerCfg := container.Config{
		Env: []string{
			""POSTGRES_DB=defaultdb"",
			""POSTGRES_PASSWORD=secret"",
		},
		ExposedPorts: nat.PortSet{
			nat.Port(""5432/tcp""): {},
		},
		Image: postgresImage,
	}
	hostCfg := container.HostConfig{
		AutoRemove:      true,
		PublishAllPorts: true,
		Tmpfs:           map[string]string{""/var/lib/postgresql/data"": """"},
	}
	name := fmt.Sprintf(""postgres-%s"", ulid.Make().String())
	cont, err := dockerClient.ContainerCreate(context.Background(), &containerCfg, &hostCfg, nil, nil, name)
	require.NoError(t, err, ""failed to create postgres docker container"")
	stopContainer := func() {
		t.Logf(""stopping container %s"", name)
		timeoutSec := 5
		err := dockerClient.ContainerStop(context.Background(), cont.ID, container.StopOptions{Timeout: &timeoutSec})
		if err != nil && !client.IsErrNotFound(err) {
			t.Logf(""failed to stop postgres container: %v"", err)
		}
		dockerClient.Close()
		t.Logf(""stopped container %s"", name)
	}
	err = dockerClient.ContainerStart(context.Background(), cont.ID, types.ContainerStartOptions{})
	if err != nil {
		stopContainer()
		t.Fatalf(""failed to start postgres container: %v"", err)
	}
	containerJSON, err := dockerClient.ContainerInspect(context.Background(), cont.ID)
	require.NoError(t, err)
	m, ok := containerJSON.NetworkSettings.Ports[""5432/tcp""]
	if !ok || len(m) == 0 {
		t.Fatalf(""failed to get host port mapping from postgres container"")
	}
	pgTestContainer := &postgresTestContainer{
		addr:     fmt.Sprintf(""localhost:%s"", m[0].HostPort),
		username: ""postgres"",
		password: ""secret"",
	}
	uri := fmt.Sprintf(""postgres://%s:%s@%s/defaultdb?sslmode=disable"", pgTestContainer.username, pgTestContainer.password, pgTestContainer.addr)
	goose.SetLogger(goose.NopLogger())
	db, err := goose.OpenDBWithDriver(""pgx"", uri)
	require.NoError(t, err)
	defer db.Close()
	backoffPolicy := backoff.NewExponentialBackOff()
	backoffPolicy.MaxElapsedTime = 30 * time.Second
	err = backoff.Retry(
		func() error {
			return db.Ping()
		},
		backoffPolicy,
	)
	if err != nil {
		stopContainer()
		t.Fatalf(""failed to connect to postgres container: %v"", err)
	}
	goose.SetBaseFS(assets.EmbedMigrations)
	err = goose.Up(db, assets.PostgresMigrationDir)
	require.NoError(t, err)
	version, err := goose.GetDBVersion(db)
	require.NoError(t, err)
	pgTestContainer.version = version
	return pgTestContainer, stopContainer
}
// GetConnectionURI returns the postgres connection uri for the running postgres test container.
func (p *postgresTestContainer) GetConnectionURI(includeCredentials bool) string {
	creds := """"
	if includeCredentials {
		creds = fmt.Sprintf(""%s:%s@"", p.username, p.password)
	}
	return fmt.Sprintf(
		""postgres://%s%s/%s?sslmode=disable"",
		creds,
		p.addr,
		""defaultdb"",
	)
}
func (p *postgresTestContainer) GetUsername() string {
	return p.username
}
func (p *postgresTestContainer) GetPassword() string {
	return p.password
}
",CWE-401,189.0,0
"package listobjects
import (
	""testing""
	openfgav1 ""github.com/openfga/api/proto/openfga/v1""
	""github.com/stretchr/testify/require""
	""go.uber.org/goleak""
	""google.golang.org/grpc""
	""google.golang.org/grpc/credentials/insecure""
	""github.com/openfga/openfga/cmd/run""
	""github.com/openfga/openfga/tests""
)
func TestListObjectsMemory(t *testing.T) {
	testRunAll(t, ""memory"")
}
func TestListObjectsPostgres(t *testing.T) {
	testRunAll(t, ""postgres"")
}
func TestListObjectsMySQL(t *testing.T) {
	testRunAll(t, ""mysql"")
}
func testRunAll(t *testing.T, engine string) {
	defer goleak.VerifyNone(t)
	cfg := run.MustDefaultConfigWithRandomPorts()
	cfg.Log.Level = ""error""
	cfg.Datastore.Engine = engine
	cancel := tests.StartServer(t, cfg)
	defer cancel()
	conn, err := grpc.Dial(cfg.GRPC.Addr,
		grpc.WithBlock(),
		grpc.WithTransportCredentials(insecure.NewCredentials()),
	)
	require.NoError(t, err)
	defer conn.Close()
	RunAllTests(t, openfgav1.NewOpenFGAServiceClient(conn))
}
",CWE-401,45.0,0
"//go:build go1.17
// +build go1.17
package saml
import (
	""encoding/base64""
	""encoding/xml""
	""net/http""
	""net/url""
	""strings""
	""testing""
	""time""
	dsig ""github.com/russellhaering/goxmldsig""
	""gotest.tools/assert""
	is ""gotest.tools/assert/cmp""
	""gotest.tools/golden""
)
func TestSPRejectsMalformedResponse(t *testing.T) {
	test := NewServiceProviderTest(t)
	// An actual response from google
	TimeNow = func() time.Time {
		rv, _ := time.Parse(""Mon Jan 2 15:04:05 UTC 2006"", ""Tue Jan 5 16:55:39 UTC 2016"")
		return rv
	}
	Clock = dsig.NewFakeClockAt(TimeNow())
	SamlResponse := golden.Get(t, ""TestSPRejectsMalformedResponse_response"")
	test.IDPMetadata = golden.Get(t, ""TestSPRejectsMalformedResponse_IDPMetadata"")
	s := ServiceProvider{
		Key:         test.Key,
		Certificate: test.Certificate,
		MetadataURL: mustParseURL(""https://29ee6d2e.ngrok.io/saml/metadata""),
		AcsURL:      mustParseURL(""https://29ee6d2e.ngrok.io/saml/acs""),
		IDPMetadata: &EntityDescriptor{},
	}
	err := xml.Unmarshal(test.IDPMetadata, &s.IDPMetadata)
	assert.Check(t, err)
	// this is a valid response
	{
		req := http.Request{PostForm: url.Values{}}
		req.PostForm.Set(""SAMLResponse"", string(SamlResponse))
		assertion, err := s.ParseResponse(&req, []string{""id-fd419a5ab0472645427f8e07d87a3a5dd0b2e9a6""})
		assert.Check(t, err)
		assert.Check(t, is.Equal(""ross@octolabs.io"", assertion.Subject.NameID.Value))
	}
	// this is a valid response but with a comment injected
	{
		x, _ := base64.StdEncoding.DecodeString(string(SamlResponse))
		y := strings.Replace(string(x), ""<saml2p:Response"", ""<saml2p:Response ::foo=\""bar\"""", 1)
		SamlResponse = []byte(base64.StdEncoding.EncodeToString([]byte(y)))
		req := http.Request{PostForm: url.Values{}}
		req.PostForm.Set(""SAMLResponse"", string(SamlResponse))
		assertion, err := s.ParseResponse(&req, []string{""id-fd419a5ab0472645427f8e07d87a3a5dd0b2e9a6""})
		assert.Check(t, is.Error(err.(*InvalidResponseError).PrivateErr,
			""cannot validate signature on Response: Signature could not be verified""))
		assert.Check(t, is.Nil(assertion))
	}
}
func TestSPInvalidResponses(t *testing.T) {
	test := NewServiceProviderTest(t)
	s := ServiceProvider{
		Key:         test.Key,
		Certificate: test.Certificate,
		MetadataURL: mustParseURL(""https://15661444.ngrok.io/saml2/metadata""),
		AcsURL:      mustParseURL(""https://15661444.ngrok.io/saml2/acs""),
		IDPMetadata: &EntityDescriptor{},
	}
	err := xml.Unmarshal(test.IDPMetadata, &s.IDPMetadata)
	assert.Check(t, err)
	req := http.Request{PostForm: url.Values{}}
	req.PostForm.Set(""SAMLResponse"", ""???"")
	_, err = s.ParseResponse(&req, []string{""id-9e61753d64e928af5a7a341a97f420c9""})
	assert.Check(t, is.Error(err.(*InvalidResponseError).PrivateErr,
		""cannot parse base64: illegal base64 data at input byte 0""))
	req.PostForm.Set(""SAMLResponse"", base64.StdEncoding.EncodeToString([]byte(""<hello>World!</hello>"")))
	_, err = s.ParseResponse(&req, []string{""id-9e61753d64e928af5a7a341a97f420c9""})
	assert.Check(t, is.Error(err.(*InvalidResponseError).PrivateErr,
		""cannot unmarshal response: expected element type <Response> but have <hello>""))
	req.PostForm.Set(""SAMLResponse"", base64.StdEncoding.EncodeToString(test.SamlResponse))
	_, err = s.ParseResponse(&req, []string{""wrongRequestID""})
	assert.Check(t, is.Error(err.(*InvalidResponseError).PrivateErr,
		""`InResponseTo` does not match any of the possible request IDs (expected [wrongRequestID])""))
	TimeNow = func() time.Time {
		rv, _ := time.Parse(""Mon Jan 2 15:04:05 MST 2006"", ""Mon Nov 30 20:57:09 UTC 2016"")
		return rv
	}
	Clock = dsig.NewFakeClockAt(TimeNow())
	req.PostForm.Set(""SAMLResponse"", base64.StdEncoding.EncodeToString(test.SamlResponse))
	_, err = s.ParseResponse(&req, []string{""id-9e61753d64e928af5a7a341a97f420c9""})
	assert.Check(t, is.Error(err.(*InvalidResponseError).PrivateErr,
		""response IssueInstant expired at 2015-12-01 01:57:51.375 +0000 UTC""))
	TimeNow = func() time.Time {
		rv, _ := time.Parse(""Mon Jan 2 15:04:05 MST 2006"", ""Mon Dec 1 01:57:09 UTC 2015"")
		return rv
	}
	Clock = dsig.NewFakeClockAt(TimeNow())
	s.IDPMetadata.EntityID = ""http://snakeoil.com""
	req.PostForm.Set(""SAMLResponse"", base64.StdEncoding.EncodeToString(test.SamlResponse))
	_, err = s.ParseResponse(&req, []string{""id-9e61753d64e928af5a7a341a97f420c9""})
	assert.Check(t, is.Error(err.(*InvalidResponseError).PrivateErr,
		""response Issuer does not match the IDP metadata (expected \""http://snakeoil.com\"")""))
	s.IDPMetadata.EntityID = ""https://idp.testshib.org/idp/shibboleth""
	oldSpStatusSuccess := StatusSuccess
	StatusSuccess = ""not:the:success:value""
	req.PostForm.Set(""SAMLResponse"", base64.StdEncoding.EncodeToString(test.SamlResponse))
	_, err = s.ParseResponse(&req, []string{""id-9e61753d64e928af5a7a341a97f420c9""})
	assert.Check(t, is.Error(err.(*InvalidResponseError).PrivateErr,
		""urn:oasis:names:tc:SAML:2.0:status:Success""))
	StatusSuccess = oldSpStatusSuccess
	s.IDPMetadata.IDPSSODescriptors[0].KeyDescriptors[0].KeyInfo.X509Data.X509Certificates[0].Data = ""invalid""
	req.PostForm.Set(""SAMLResponse"", base64.StdEncoding.EncodeToString(test.SamlResponse))
	_, err = s.ParseResponse(&req, []string{""id-9e61753d64e928af5a7a341a97f420c9""})
	assert.Check(t, is.Error(err.(*InvalidResponseError).PrivateErr,
		""cannot validate signature on Assertion: cannot parse certificate: illegal base64 data at input byte 4""))
	s.IDPMetadata.IDPSSODescriptors[0].KeyDescriptors[0].KeyInfo.X509Data.X509Certificates[0].Data = ""aW52YWxpZA==""
	req.PostForm.Set(""SAMLResponse"", base64.StdEncoding.EncodeToString(test.SamlResponse))
	_, err = s.ParseResponse(&req, []string{""id-9e61753d64e928af5a7a341a97f420c9""})
	assert.Check(t, is.Error(err.(*InvalidResponseError).PrivateErr,
		""cannot validate signature on Assertion: x509: malformed certificate""))
}
",CWE-287,137.0,0
"package saml
import (
	""compress/flate""
	""fmt""
	""io""
)
const flateUncompressLimit = 10 * 1024 * 1024 // 10MB
func newSaferFlateReader(r io.Reader) io.ReadCloser {
	return &saferFlateReader{r: flate.NewReader(r)}
}
type saferFlateReader struct {
	r     io.ReadCloser
	count int
}
func (r *saferFlateReader) Read(p []byte) (n int, err error) {
	if r.count+len(p) > flateUncompressLimit {
		return 0, fmt.Errorf(""flate: uncompress limit exceeded (%d bytes)"", flateUncompressLimit)
	}
	n, err = r.r.Read(p)
	r.count += n
	return n, err
}
func (r *saferFlateReader) Close() error {
	return r.r.Close()
}
",CWE-770,32.0,0
"package saml
import (
	""encoding/xml""
	""testing""
	""time""
	""gotest.tools/assert""
	is ""gotest.tools/assert/cmp""
	""gotest.tools/golden""
)
func TestCanParseMetadata(t *testing.T) {
	buf := golden.Get(t, ""TestCanParseMetadata_metadata.xml"")
	metadata := EntityDescriptor{}
	err := xml.Unmarshal(buf, &metadata)
	assert.Check(t, err)
	var False = false
	var True = true
	expected := EntityDescriptor{
		EntityID:      ""https://dev.aa.kndr.org/users/auth/saml/metadata"",
		ID:            ""_af805d1c-c2e3-444e-9cf5-efc664eeace6"",
		ValidUntil:    time.Date(2001, time.February, 3, 4, 5, 6, 789000000, time.UTC),
		CacheDuration: time.Hour,
		SPSSODescriptors: []SPSSODescriptor{
			{
				XMLName: xml.Name{Space: ""urn:oasis:names:tc:SAML:2.0:metadata"", Local: ""SPSSODescriptor""},
				SSODescriptor: SSODescriptor{
					RoleDescriptor: RoleDescriptor{
						ProtocolSupportEnumeration: ""urn:oasis:names:tc:SAML:2.0:protocol"",
					},
				},
				AuthnRequestsSigned:  &False,
				WantAssertionsSigned: &False,
				AssertionConsumerServices: []IndexedEndpoint{
					{
						Binding:   ""urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST"",
						Location:  ""https://dev.aa.kndr.org/users/auth/saml/callback"",
						Index:     0,
						IsDefault: &True,
					},
				},
				AttributeConsumingServices: []AttributeConsumingService{
					{
						Index:        1,
						IsDefault:    &True,
						ServiceNames: []LocalizedName{{Lang: ""en"", Value: ""Required attributes""}},
						RequestedAttributes: []RequestedAttribute{
							{
								Attribute: Attribute{
									FriendlyName: ""Email address"",
									Name:         ""email"",
									NameFormat:   ""urn:oasis:names:tc:SAML:2.0:attrname-format:basic"",
								},
							},
							{
								Attribute: Attribute{
									FriendlyName: ""Full name"",
									Name:         ""name"",
									NameFormat:   ""urn:oasis:names:tc:SAML:2.0:attrname-format:basic"",
								},
							},
							{
								Attribute: Attribute{
									FriendlyName: ""Given name"",
									Name:         ""first_name"",
									NameFormat:   ""urn:oasis:names:tc:SAML:2.0:attrname-format:basic"",
								},
							},
							{
								Attribute: Attribute{
									FriendlyName: ""Family name"",
									Name:         ""last_name"",
									NameFormat:   ""urn:oasis:names:tc:SAML:2.0:attrname-format:basic"",
								},
							},
						},
					},
				},
			},
		},
	}
	assert.Check(t, is.DeepEqual(expected, metadata))
}
func TestCanProduceSPMetadata(t *testing.T) {
	validUntil, _ := time.Parse(""2006-01-02T15:04:05.000000"", ""2013-03-10T00:32:19.104000"")
	AuthnRequestsSigned := true
	WantAssertionsSigned := true
	metadata := EntityDescriptor{
		EntityID:      ""http://localhost:5000/e087a985171710fb9fb30f30f41384f9/saml2/metadata/"",
		ValidUntil:    validUntil,
		CacheDuration: time.Hour,
		SPSSODescriptors: []SPSSODescriptor{
			{
				AuthnRequestsSigned:  &AuthnRequestsSigned,
				WantAssertionsSigned: &WantAssertionsSigned,
				SSODescriptor: SSODescriptor{
					RoleDescriptor: RoleDescriptor{
						ProtocolSupportEnumeration: ""urn:oasis:names:tc:SAML:2.0:protocol"",
						KeyDescriptors: []KeyDescriptor{
							{
								Use: ""encryption"",
								KeyInfo: KeyInfo{
									X509Data: X509Data{
										X509Certificates: []X509Certificate{
											{
												Data: `MIIB7zCCAVgCCQDFzbKIp7b3MTANBgkqhkiG9w0BAQUFADA8MQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCR0ExDDAKBgNVBAoMA2ZvbzESMBAGA1UEAwwJbG9jYWxob3N0MB4XDTEzMTAwMjAwMDg1MVoX
DTE0MTAwMjAwMDg1MVowPDELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAkdBMQwwCgYDVQQKDANmb28x
EjAQBgNVBAMMCWxvY2FsaG9zdDCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA1PMHYmhZj308
kWLhZVT4vOulqx/9ibm5B86fPWwUKKQ2i12MYtz07tzukPymisTDhQaqyJ8Kqb/6JjhmeMnEOdTv
SPmHO8m1ZVveJU6NoKRn/mP/BD7FW52WhbrUXLSeHVSKfWkNk6S4hk9MV9TswTvyRIKvRsw0X/gf
nqkroJcCAwEAATANBgkqhkiG9w0BAQUFAAOBgQCMMlIO+GNcGekevKgkakpMdAqJfs24maGb90Dv
TLbRZRD7Xvn1MnVBBS9hzlXiFLYOInXACMW5gcoRFfeTQLSouMM8o57h0uKjfTmuoWHLQLi6hnF+
cvCsEFiJZ4AbF+DgmO6TarJ8O05t8zvnOwJlNCASPZRH/JmF8tX0hoHuAQ==`,
											},
										},
									},
								},
							},
							{
								Use: ""signing"",
								KeyInfo: KeyInfo{
									X509Data: X509Data{
										X509Certificates: []X509Certificate{
											{
												Data: `MIIB7zCCAVgCCQDFzbKIp7b3MTANBgkqhkiG9w0BAQUFADA8MQswCQYDVQQGEwJVUzELMAkGA1UE
CAwCR0ExDDAKBgNVBAoMA2ZvbzESMBAGA1UEAwwJbG9jYWxob3N0MB4XDTEzMTAwMjAwMDg1MVoX
DTE0MTAwMjAwMDg1MVowPDELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAkdBMQwwCgYDVQQKDANmb28x
EjAQBgNVBAMMCWxvY2FsaG9zdDCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA1PMHYmhZj308
kWLhZVT4vOulqx/9ibm5B86fPWwUKKQ2i12MYtz07tzukPymisTDhQaqyJ8Kqb/6JjhmeMnEOdTv
SPmHO8m1ZVveJU6NoKRn/mP/BD7FW52WhbrUXLSeHVSKfWkNk6S4hk9MV9TswTvyRIKvRsw0X/gf
nqkroJcCAwEAATANBgkqhkiG9w0BAQUFAAOBgQCMMlIO+GNcGekevKgkakpMdAqJfs24maGb90Dv
TLbRZRD7Xvn1MnVBBS9hzlXiFLYOInXACMW5gcoRFfeTQLSouMM8o57h0uKjfTmuoWHLQLi6hnF+
cvCsEFiJZ4AbF+DgmO6TarJ8O05t8zvnOwJlNCASPZRH/JmF8tX0hoHuAQ==`,
											},
										},
									},
								},
							},
						},
					},
					SingleLogoutServices: []Endpoint{{
						Binding:  ""urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect"",
						Location: ""http://localhost:5000/e087a985171710fb9fb30f30f41384f9/saml2/ls/"",
					}},
				},
				AssertionConsumerServices: []IndexedEndpoint{{
					Binding:  ""urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST"",
					Location: ""http://localhost:5000/e087a985171710fb9fb30f30f41384f9/saml2/ls/"",
					Index:    1,
				}},
			},
		},
	}
	buf, err := xml.MarshalIndent(metadata, """", ""  "")
	assert.Check(t, err)
	golden.Assert(t, string(buf), ""TestCanProduceSPMetadata_expected"")
}
func TestMetadataValidatesUrlSchemeForProtocolBinding(t *testing.T) {
	buf := golden.Get(t, ""TestMetadataValidatesUrlSchemeForProtocolBinding_metadata.xml"")
	metadata := EntityDescriptor{}
	err := xml.Unmarshal(buf, &metadata)
	assert.Error(t, err, ""invalid url scheme \""javascript\"" for binding \""urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST\"""")
}
",CWE-79,176.0,0
"// Copyright 2020 The Prometheus Authors
// This code is partly borrowed from Caddy:
//    Copyright 2015 Matthew Holt and The Caddy Authors
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package web
import (
	""encoding/hex""
	""fmt""
	""net/http""
	""strings""
	""sync""
	""github.com/go-kit/log""
	""golang.org/x/crypto/bcrypt""
)
// extraHTTPHeaders is a map of HTTP headers that can be added to HTTP
// responses.
// This is private on purpose to ensure consistency in the Prometheus ecosystem.
var extraHTTPHeaders = map[string][]string{
	""Strict-Transport-Security"": nil,
	""X-Content-Type-Options"":    {""nosniff""},
	""X-Frame-Options"":           {""deny"", ""sameorigin""},
	""X-XSS-Protection"":          nil,
	""Content-Security-Policy"":   nil,
}
func validateUsers(configPath string) error {
	c, err := getConfig(configPath)
	if err != nil {
		return err
	}
	for _, p := range c.Users {
		_, err = bcrypt.Cost([]byte(p))
		if err != nil {
			return err
		}
	}
	return nil
}
// validateHeaderConfig checks that the provided header configuration is correct.
// It does not check the validity of all the values, only the ones which are
// well-defined enumerations.
func validateHeaderConfig(headers map[string]string) error {
HeadersLoop:
	for k, v := range headers {
		values, ok := extraHTTPHeaders[k]
		if !ok {
			return fmt.Errorf(""HTTP header %q can not be configured"", k)
		}
		for _, allowedValue := range values {
			if v == allowedValue {
				continue HeadersLoop
			}
		}
		if len(values) > 0 {
			return fmt.Errorf(""invalid value for %s. Expected one of: %q, but got: %q"", k, values, v)
		}
	}
	return nil
}
type webHandler struct {
	tlsConfigPath string
	handler       http.Handler
	logger        log.Logger
	cache         *cache
	// bcryptMtx is there to ensure that bcrypt.CompareHashAndPassword is run
	// only once in parallel as this is CPU intensive.
	bcryptMtx sync.Mutex
}
func (u *webHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	c, err := getConfig(u.tlsConfigPath)
	if err != nil {
		u.logger.Log(""msg"", ""Unable to parse configuration"", ""err"", err)
		http.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
		return
	}
	// Configure http headers.
	for k, v := range c.HTTPConfig.Header {
		w.Header().Set(k, v)
	}
	if len(c.Users) == 0 {
		u.handler.ServeHTTP(w, r)
		return
	}
	user, pass, auth := r.BasicAuth()
	if auth {
		hashedPassword, validUser := c.Users[user]
		if !validUser {
			// The user is not found. Use a fixed password hash to
			// prevent user enumeration by timing requests.
			// This is a bcrypt-hashed version of ""fakepassword"".
			hashedPassword = ""$2y$10$QOauhQNbBCuQDKes6eFzPeMqBSjb7Mr5DUmpZ/VcEd00UAV/LDeSi""
		}
		cacheKey := strings.Join(
			[]string{
				hex.EncodeToString([]byte(user)),
				hex.EncodeToString([]byte(hashedPassword)),
				hex.EncodeToString([]byte(pass)),
			}, "":"")
		authOk, ok := u.cache.get(cacheKey)
		if !ok {
			// This user, hashedPassword, password is not cached.
			u.bcryptMtx.Lock()
			err := bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(pass))
			u.bcryptMtx.Unlock()
			authOk = validUser && err == nil
			u.cache.set(cacheKey, authOk)
		}
		if authOk && validUser {
			u.handler.ServeHTTP(w, r)
			return
		}
	}
	w.Header().Set(""WWW-Authenticate"", ""Basic"")
	http.Error(w, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)
}
",CWE-287,144.0,0
"// Copyright 2020 The Prometheus Authors
// This code is partly borrowed from Caddy:
//    Copyright 2015 Matthew Holt and The Caddy Authors
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package web
import (
	""encoding/hex""
	""fmt""
	""net/http""
	""strings""
	""sync""
	""github.com/go-kit/log""
	""golang.org/x/crypto/bcrypt""
)
// extraHTTPHeaders is a map of HTTP headers that can be added to HTTP
// responses.
// This is private on purpose to ensure consistency in the Prometheus ecosystem.
var extraHTTPHeaders = map[string][]string{
	""Strict-Transport-Security"": nil,
	""X-Content-Type-Options"":    {""nosniff""},
	""X-Frame-Options"":           {""deny"", ""sameorigin""},
	""X-XSS-Protection"":          nil,
	""Content-Security-Policy"":   nil,
}
func validateUsers(configPath string) error {
	c, err := getConfig(configPath)
	if err != nil {
		return err
	}
	for _, p := range c.Users {
		_, err = bcrypt.Cost([]byte(p))
		if err != nil {
			return err
		}
	}
	return nil
}
// validateHeaderConfig checks that the provided header configuration is correct.
// It does not check the validity of all the values, only the ones which are
// well-defined enumerations.
func validateHeaderConfig(headers map[string]string) error {
HeadersLoop:
	for k, v := range headers {
		values, ok := extraHTTPHeaders[k]
		if !ok {
			return fmt.Errorf(""HTTP header %q can not be configured"", k)
		}
		for _, allowedValue := range values {
			if v == allowedValue {
				continue HeadersLoop
			}
		}
		if len(values) > 0 {
			return fmt.Errorf(""invalid value for %s. Expected one of: %q, but got: %q"", k, values, v)
		}
	}
	return nil
}
type webHandler struct {
	tlsConfigPath string
	handler       http.Handler
	logger        log.Logger
	cache         *cache
	// bcryptMtx is there to ensure that bcrypt.CompareHashAndPassword is run
	// only once in parallel as this is CPU intensive.
	bcryptMtx sync.Mutex
}
func (u *webHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	c, err := getConfig(u.tlsConfigPath)
	if err != nil {
		u.logger.Log(""msg"", ""Unable to parse configuration"", ""err"", err)
		http.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
		return
	}
	// Configure http headers.
	for k, v := range c.HTTPConfig.Header {
		w.Header().Set(k, v)
	}
	if len(c.Users) == 0 {
		u.handler.ServeHTTP(w, r)
		return
	}
	user, pass, auth := r.BasicAuth()
	if auth {
		hashedPassword, validUser := c.Users[user]
		if !validUser {
			// The user is not found. Use a fixed password hash to
			// prevent user enumeration by timing requests.
			// This is a bcrypt-hashed version of ""fakepassword"".
			hashedPassword = ""$2y$10$QOauhQNbBCuQDKes6eFzPeMqBSjb7Mr5DUmpZ/VcEd00UAV/LDeSi""
		}
		cacheKey := strings.Join(
			[]string{
				hex.EncodeToString([]byte(user)),
				hex.EncodeToString([]byte(hashedPassword)),
				hex.EncodeToString([]byte(pass)),
			}, "":"")
		authOk, ok := u.cache.get(cacheKey)
		if !ok {
			// This user, hashedPassword, password is not cached.
			u.bcryptMtx.Lock()
			err := bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(pass))
			u.bcryptMtx.Unlock()
			authOk = validUser && err == nil
			u.cache.set(cacheKey, authOk)
		}
		if authOk && validUser {
			u.handler.ServeHTTP(w, r)
			return
		}
	}
	w.Header().Set(""WWW-Authenticate"", ""Basic"")
	http.Error(w, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)
}
",CWE-303,144.0,0
"package server
import (
	""context""
	""github.com/traefik/traefik/v2/pkg/config/runtime""
	""github.com/traefik/traefik/v2/pkg/config/static""
	""github.com/traefik/traefik/v2/pkg/log""
	""github.com/traefik/traefik/v2/pkg/metrics""
	""github.com/traefik/traefik/v2/pkg/server/middleware""
	tcpmiddleware ""github.com/traefik/traefik/v2/pkg/server/middleware/tcp""
	""github.com/traefik/traefik/v2/pkg/server/router""
	tcprouter ""github.com/traefik/traefik/v2/pkg/server/router/tcp""
	udprouter ""github.com/traefik/traefik/v2/pkg/server/router/udp""
	""github.com/traefik/traefik/v2/pkg/server/service""
	""github.com/traefik/traefik/v2/pkg/server/service/tcp""
	""github.com/traefik/traefik/v2/pkg/server/service/udp""
	""github.com/traefik/traefik/v2/pkg/tls""
	udptypes ""github.com/traefik/traefik/v2/pkg/udp""
)
// RouterFactory the factory of TCP/UDP routers.
type RouterFactory struct {
	entryPointsTCP []string
	entryPointsUDP []string
	managerFactory  *service.ManagerFactory
	metricsRegistry metrics.Registry
	pluginBuilder middleware.PluginsBuilder
	chainBuilder *middleware.ChainBuilder
	tlsManager   *tls.Manager
}
// NewRouterFactory creates a new RouterFactory.
func NewRouterFactory(staticConfiguration static.Configuration, managerFactory *service.ManagerFactory, tlsManager *tls.Manager,
	chainBuilder *middleware.ChainBuilder, pluginBuilder middleware.PluginsBuilder, metricsRegistry metrics.Registry,
) *RouterFactory {
	var entryPointsTCP, entryPointsUDP []string
	for name, cfg := range staticConfiguration.EntryPoints {
		protocol, err := cfg.GetProtocol()
		if err != nil {
			// Should never happen because Traefik should not start if protocol is invalid.
			log.WithoutContext().Errorf(""Invalid protocol: %v"", err)
		}
		if protocol == ""udp"" {
			entryPointsUDP = append(entryPointsUDP, name)
		} else {
			entryPointsTCP = append(entryPointsTCP, name)
		}
	}
	return &RouterFactory{
		entryPointsTCP:  entryPointsTCP,
		entryPointsUDP:  entryPointsUDP,
		managerFactory:  managerFactory,
		metricsRegistry: metricsRegistry,
		tlsManager:      tlsManager,
		chainBuilder:    chainBuilder,
		pluginBuilder:   pluginBuilder,
	}
}
// CreateRouters creates new TCPRouters and UDPRouters.
func (f *RouterFactory) CreateRouters(rtConf *runtime.Configuration) (map[string]*tcprouter.Router, map[string]udptypes.Handler) {
	ctx := context.Background()
	// HTTP
	serviceManager := f.managerFactory.Build(rtConf)
	middlewaresBuilder := middleware.NewBuilder(rtConf.Middlewares, serviceManager, f.pluginBuilder)
	routerManager := router.NewManager(rtConf, serviceManager, middlewaresBuilder, f.chainBuilder, f.metricsRegistry, f.tlsManager)
	handlersNonTLS := routerManager.BuildHandlers(ctx, f.entryPointsTCP, false)
	handlersTLS := routerManager.BuildHandlers(ctx, f.entryPointsTCP, true)
	serviceManager.LaunchHealthCheck()
	// TCP
	svcTCPManager := tcp.NewManager(rtConf)
	middlewaresTCPBuilder := tcpmiddleware.NewBuilder(rtConf.TCPMiddlewares)
	rtTCPManager := tcprouter.NewManager(rtConf, svcTCPManager, middlewaresTCPBuilder, handlersNonTLS, handlersTLS, f.tlsManager)
	routersTCP := rtTCPManager.BuildHandlers(ctx, f.entryPointsTCP)
	// UDP
	svcUDPManager := udp.NewManager(rtConf)
	rtUDPManager := udprouter.NewManager(rtConf, svcUDPManager)
	routersUDP := rtUDPManager.BuildHandlers(ctx, f.entryPointsUDP)
	rtConf.PopulateUsedBy()
	return routersTCP, routersUDP
}
",CWE-295,99.0,0
"// Copyright 2020-2021 Clastix Labs
// SPDX-License-Identifier: Apache-2.0
package tenant
import (
	""context""
	""fmt""
	""strings""
	""golang.org/x/sync/errgroup""
	corev1 ""k8s.io/api/core/v1""
	""k8s.io/apimachinery/pkg/fields""
	""k8s.io/apimachinery/pkg/types""
	""k8s.io/client-go/util/retry""
	""sigs.k8s.io/controller-runtime/pkg/client""
	""sigs.k8s.io/controller-runtime/pkg/controller/controllerutil""
	capsulev1beta1 ""github.com/clastix/capsule/api/v1beta1""
	""github.com/clastix/capsule/pkg/utils""
)
// Ensuring all annotations are applied to each Namespace handled by the Tenant.
func (r *Manager) syncNamespaces(ctx context.Context, tenant *capsulev1beta1.Tenant) (err error) {
	group := new(errgroup.Group)
	for _, item := range tenant.Status.Namespaces {
		namespace := item
		group.Go(func() error {
			return r.syncNamespaceMetadata(ctx, namespace, tenant)
		})
	}
	if err = group.Wait(); err != nil {
		r.Log.Error(err, ""Cannot sync Namespaces"")
		err = fmt.Errorf(""cannot sync Namespaces: %w"", err)
	}
	return
}
// nolint:gocognit
func (r *Manager) syncNamespaceMetadata(ctx context.Context, namespace string, tnt *capsulev1beta1.Tenant) (err error) {
	var res controllerutil.OperationResult
	err = retry.RetryOnConflict(retry.DefaultBackoff, func() (conflictErr error) {
		ns := &corev1.Namespace{}
		if conflictErr = r.Client.Get(ctx, types.NamespacedName{Name: namespace}, ns); err != nil {
			return
		}
		capsuleLabel, _ := capsulev1beta1.GetTypeLabel(&capsulev1beta1.Tenant{})
		res, conflictErr = controllerutil.CreateOrUpdate(ctx, r.Client, ns, func() error {
			annotations := make(map[string]string)
			labels := map[string]string{
				""name"":       namespace,
				capsuleLabel: tnt.GetName(),
			}
			if tnt.Spec.NamespaceOptions != nil && tnt.Spec.NamespaceOptions.AdditionalMetadata != nil {
				for k, v := range tnt.Spec.NamespaceOptions.AdditionalMetadata.Annotations {
					annotations[k] = v
				}
			}
			if tnt.Spec.NamespaceOptions != nil && tnt.Spec.NamespaceOptions.AdditionalMetadata != nil {
				for k, v := range tnt.Spec.NamespaceOptions.AdditionalMetadata.Labels {
					labels[k] = v
				}
			}
			if tnt.Spec.NodeSelector != nil {
				annotations = utils.BuildNodeSelector(tnt, annotations)
			}
			if tnt.Spec.IngressOptions.AllowedClasses != nil {
				if len(tnt.Spec.IngressOptions.AllowedClasses.Exact) > 0 {
					annotations[capsulev1beta1.AvailableIngressClassesAnnotation] = strings.Join(tnt.Spec.IngressOptions.AllowedClasses.Exact, "","")
				}
				if len(tnt.Spec.IngressOptions.AllowedClasses.Regex) > 0 {
					annotations[capsulev1beta1.AvailableIngressClassesRegexpAnnotation] = tnt.Spec.IngressOptions.AllowedClasses.Regex
				}
			}
			if tnt.Spec.StorageClasses != nil {
				if len(tnt.Spec.StorageClasses.Exact) > 0 {
					annotations[capsulev1beta1.AvailableStorageClassesAnnotation] = strings.Join(tnt.Spec.StorageClasses.Exact, "","")
				}
				if len(tnt.Spec.StorageClasses.Regex) > 0 {
					annotations[capsulev1beta1.AvailableStorageClassesRegexpAnnotation] = tnt.Spec.StorageClasses.Regex
				}
			}
			if tnt.Spec.ContainerRegistries != nil {
				if len(tnt.Spec.ContainerRegistries.Exact) > 0 {
					annotations[capsulev1beta1.AllowedRegistriesAnnotation] = strings.Join(tnt.Spec.ContainerRegistries.Exact, "","")
				}
				if len(tnt.Spec.ContainerRegistries.Regex) > 0 {
					annotations[capsulev1beta1.AllowedRegistriesRegexpAnnotation] = tnt.Spec.ContainerRegistries.Regex
				}
			}
			if value, ok := tnt.Annotations[capsulev1beta1.ForbiddenNamespaceLabelsAnnotation]; ok {
				annotations[capsulev1beta1.ForbiddenNamespaceLabelsAnnotation] = value
			}
			if value, ok := tnt.Annotations[capsulev1beta1.ForbiddenNamespaceLabelsRegexpAnnotation]; ok {
				annotations[capsulev1beta1.ForbiddenNamespaceLabelsRegexpAnnotation] = value
			}
			if value, ok := tnt.Annotations[capsulev1beta1.ForbiddenNamespaceAnnotationsAnnotation]; ok {
				annotations[capsulev1beta1.ForbiddenNamespaceAnnotationsAnnotation] = value
			}
			if value, ok := tnt.Annotations[capsulev1beta1.ForbiddenNamespaceAnnotationsRegexpAnnotation]; ok {
				annotations[capsulev1beta1.ForbiddenNamespaceAnnotationsRegexpAnnotation] = value
			}
			if ns.Annotations == nil {
				ns.SetAnnotations(annotations)
			} else {
				for k, v := range annotations {
					ns.Annotations[k] = v
				}
			}
			if ns.Labels == nil {
				ns.SetLabels(labels)
			} else {
				for k, v := range labels {
					ns.Labels[k] = v
				}
			}
			return nil
		})
		return
	})
	r.emitEvent(tnt, namespace, res, ""Ensuring Namespace metadata"", err)
	return err
}
func (r *Manager) ensureNamespaceCount(ctx context.Context, tenant *capsulev1beta1.Tenant) error {
	return retry.RetryOnConflict(retry.DefaultBackoff, func() error {
		tenant.Status.Size = uint(len(tenant.Status.Namespaces))
		found := &capsulev1beta1.Tenant{}
		if err := r.Client.Get(ctx, types.NamespacedName{Name: tenant.GetName()}, found); err != nil {
			return err
		}
		found.Status.Size = tenant.Status.Size
		return r.Client.Status().Update(ctx, found, &client.UpdateOptions{})
	})
}
func (r *Manager) collectNamespaces(ctx context.Context, tenant *capsulev1beta1.Tenant) error {
	return retry.RetryOnConflict(retry.DefaultBackoff, func() (err error) {
		list := &corev1.NamespaceList{}
		err = r.Client.List(ctx, list, client.MatchingFieldsSelector{
			Selector: fields.OneTermEqualSelector("".metadata.ownerReferences[*].capsule"", tenant.GetName()),
		})
		if err != nil {
			return
		}
		_, err = controllerutil.CreateOrUpdate(ctx, r.Client, tenant.DeepCopy(), func() error {
			tenant.AssignNamespaces(list.Items)
			return r.Client.Status().Update(ctx, tenant, &client.UpdateOptions{})
		})
		return
	})
}
",CWE-863,184.0,0
"// Copyright 2020-2021 Clastix Labs
// SPDX-License-Identifier: Apache-2.0
package utils
import (
	""fmt""
	""sort""
	""strings""
	capsulev1beta1 ""github.com/clastix/capsule/api/v1beta1""
)
const (
	NodeSelectorAnnotation = ""scheduler.alpha.kubernetes.io/node-selector""
)
func BuildNodeSelector(tnt *capsulev1beta1.Tenant, nsAnnotations map[string]string) map[string]string {
	if nsAnnotations == nil {
		nsAnnotations = make(map[string]string)
	}
	selector := make([]string, 0, len(tnt.Spec.NodeSelector))
	for k, v := range tnt.Spec.NodeSelector {
		selector = append(selector, fmt.Sprintf(""%s=%s"", k, v))
	}
	// Sorting the resulting slice: iterating over maps is randomized, and we could end-up
	// in multiple reconciliations upon multiple node selectors.
	sort.Strings(selector)
	nsAnnotations[NodeSelectorAnnotation] = strings.Join(selector, "","")
	return nsAnnotations
}
",CWE-863,36.0,0
"// Copyright 2020-2021 Clastix Labs
// SPDX-License-Identifier: Apache-2.0
package namespace
import (
	""context""
	corev1 ""k8s.io/api/core/v1""
	""k8s.io/apimachinery/pkg/fields""
	""k8s.io/apimachinery/pkg/types""
	""k8s.io/client-go/tools/record""
	""sigs.k8s.io/controller-runtime/pkg/client""
	""sigs.k8s.io/controller-runtime/pkg/webhook/admission""
	capsulev1beta1 ""github.com/clastix/capsule/api/v1beta1""
	""github.com/clastix/capsule/pkg/configuration""
	capsulewebhook ""github.com/clastix/capsule/pkg/webhook""
	""github.com/clastix/capsule/pkg/webhook/utils""
)
type freezedHandler struct {
	configuration configuration.Configuration
}
func FreezeHandler(configuration configuration.Configuration) capsulewebhook.Handler {
	return &freezedHandler{configuration: configuration}
}
func (r *freezedHandler) OnCreate(client client.Client, decoder *admission.Decoder, recorder record.EventRecorder) capsulewebhook.Func {
	return func(ctx context.Context, req admission.Request) *admission.Response {
		ns := &corev1.Namespace{}
		if err := decoder.Decode(req, ns); err != nil {
			return utils.ErroredResponse(err)
		}
		for _, objectRef := range ns.ObjectMeta.OwnerReferences {
			// retrieving the selected Tenant
			tnt := &capsulev1beta1.Tenant{}
			if err := client.Get(ctx, types.NamespacedName{Name: objectRef.Name}, tnt); err != nil {
				return utils.ErroredResponse(err)
			}
			if tnt.IsCordoned() {
				recorder.Eventf(tnt, corev1.EventTypeWarning, ""TenantFreezed"", ""Namespace %s cannot be attached, the current Tenant is freezed"", ns.GetName())
				response := admission.Denied(""the selected Tenant is freezed"")
				return &response
			}
		}
		// creating NS that is not bounded to any Tenant
		return nil
	}
}
func (r *freezedHandler) OnDelete(c client.Client, _ *admission.Decoder, recorder record.EventRecorder) capsulewebhook.Func {
	return func(ctx context.Context, req admission.Request) *admission.Response {
		tntList := &capsulev1beta1.TenantList{}
		if err := c.List(ctx, tntList, client.MatchingFieldsSelector{
			Selector: fields.OneTermEqualSelector("".status.namespaces"", req.Name),
		}); err != nil {
			return utils.ErroredResponse(err)
		}
		if len(tntList.Items) == 0 {
			return nil
		}
		tnt := tntList.Items[0]
		if tnt.IsCordoned() && utils.IsCapsuleUser(ctx, req, c, r.configuration.UserGroups()) {
			recorder.Eventf(&tnt, corev1.EventTypeWarning, ""TenantFreezed"", ""Namespace %s cannot be deleted, the current Tenant is freezed"", req.Name)
			response := admission.Denied(""the selected Tenant is freezed"")
			return &response
		}
		return nil
	}
}
func (r *freezedHandler) OnUpdate(c client.Client, decoder *admission.Decoder, recorder record.EventRecorder) capsulewebhook.Func {
	return func(ctx context.Context, req admission.Request) *admission.Response {
		ns := &corev1.Namespace{}
		if err := decoder.Decode(req, ns); err != nil {
			return utils.ErroredResponse(err)
		}
		tntList := &capsulev1beta1.TenantList{}
		if err := c.List(ctx, tntList, client.MatchingFieldsSelector{
			Selector: fields.OneTermEqualSelector("".status.namespaces"", ns.Name),
		}); err != nil {
			return utils.ErroredResponse(err)
		}
		if len(tntList.Items) == 0 {
			return nil
		}
		tnt := tntList.Items[0]
		if tnt.IsCordoned() && utils.IsCapsuleUser(ctx, req, c, r.configuration.UserGroups()) {
			recorder.Eventf(&tnt, corev1.EventTypeWarning, ""TenantFreezed"", ""Namespace %s cannot be updated, the current Tenant is freezed"", ns.GetName())
			response := admission.Denied(""the selected Tenant is freezed"")
			return &response
		}
		return nil
	}
}
",CWE-863,115.0,0
"// Copyright 2020-2021 Clastix Labs
// SPDX-License-Identifier: Apache-2.0
package namespace
import (
	""context""
	""fmt""
	""net/http""
	corev1 ""k8s.io/api/core/v1""
	""k8s.io/client-go/tools/record""
	""sigs.k8s.io/controller-runtime/pkg/client""
	""sigs.k8s.io/controller-runtime/pkg/webhook/admission""
	capsulewebhook ""github.com/clastix/capsule/pkg/webhook""
	""github.com/clastix/capsule/pkg/webhook/utils""
)
type ownerReferenceHandler struct{}
func OwnerReferenceHandler() capsulewebhook.Handler {
	return &ownerReferenceHandler{}
}
func (r *ownerReferenceHandler) OnCreate(client.Client, *admission.Decoder, record.EventRecorder) capsulewebhook.Func {
	return func(ctx context.Context, req admission.Request) *admission.Response {
		return nil
	}
}
func (r *ownerReferenceHandler) OnDelete(client.Client, *admission.Decoder, record.EventRecorder) capsulewebhook.Func {
	return func(ctx context.Context, req admission.Request) *admission.Response {
		return nil
	}
}
func (r *ownerReferenceHandler) OnUpdate(_ client.Client, decoder *admission.Decoder, _ record.EventRecorder) capsulewebhook.Func {
	return func(ctx context.Context, req admission.Request) *admission.Response {
		oldNs := &corev1.Namespace{}
		if err := decoder.DecodeRaw(req.OldObject, oldNs); err != nil {
			return utils.ErroredResponse(err)
		}
		newNs := &corev1.Namespace{}
		if err := decoder.Decode(req, newNs); err != nil {
			return utils.ErroredResponse(err)
		}
		if len(newNs.OwnerReferences) == 0 {
			response := admission.Errored(http.StatusBadRequest, fmt.Errorf(""the OwnerReference cannot be removed""))
			return &response
		}
		if oldNs.GetOwnerReferences()[0].UID != newNs.GetOwnerReferences()[0].UID {
			response := admission.Errored(http.StatusBadRequest, fmt.Errorf(""the OwnerReference cannot be changed""))
			return &response
		}
		return nil
	}
}
",CWE-863,65.0,0
"// Copyright 2020-2021 Clastix Labs
// SPDX-License-Identifier: Apache-2.0
package namespace
import (
	""context""
	""fmt""
	""net/http""
	corev1 ""k8s.io/api/core/v1""
	""k8s.io/apimachinery/pkg/types""
	""k8s.io/client-go/tools/record""
	""sigs.k8s.io/controller-runtime/pkg/client""
	""sigs.k8s.io/controller-runtime/pkg/webhook/admission""
	capsulev1beta1 ""github.com/clastix/capsule/api/v1beta1""
	capsulewebhook ""github.com/clastix/capsule/pkg/webhook""
	""github.com/clastix/capsule/pkg/webhook/utils""
)
type patchHandler struct{}
func PatchHandler() capsulewebhook.Handler {
	return &patchHandler{}
}
func (r *patchHandler) OnCreate(client.Client, *admission.Decoder, record.EventRecorder) capsulewebhook.Func {
	return func(ctx context.Context, req admission.Request) *admission.Response {
		return nil
	}
}
func (r *patchHandler) OnDelete(client.Client, *admission.Decoder, record.EventRecorder) capsulewebhook.Func {
	return func(ctx context.Context, req admission.Request) *admission.Response {
		return nil
	}
}
func (r *patchHandler) OnUpdate(c client.Client, decoder *admission.Decoder, recorder record.EventRecorder) capsulewebhook.Func {
	return func(ctx context.Context, req admission.Request) *admission.Response {
		// Decode Namespace
		ns := &corev1.Namespace{}
		if err := decoder.DecodeRaw(req.OldObject, ns); err != nil {
			return utils.ErroredResponse(err)
		}
		// Get Tenant Label
		ln, err := capsulev1beta1.GetTypeLabel(&capsulev1beta1.Tenant{})
		if err != nil {
			response := admission.Errored(http.StatusBadRequest, err)
			return &response
		}
		// Extract Tenant from namespace
		e := fmt.Sprintf(""namespace/%s can not be patched"", ns.Name)
		if label, ok := ns.ObjectMeta.Labels[ln]; ok {
			// retrieving the selected Tenant
			tnt := &capsulev1beta1.Tenant{}
			if err = c.Get(ctx, types.NamespacedName{Name: label}, tnt); err != nil {
				response := admission.Errored(http.StatusBadRequest, err)
				return &response
			}
			if !utils.IsTenantOwner(tnt.Spec.Owners, req.UserInfo) {
				recorder.Eventf(tnt, corev1.EventTypeWarning, ""NamespacePatch"", e)
				response := admission.Denied(e)
				return &response
			}
		} else {
			recorder.Eventf(ns, corev1.EventTypeWarning, ""NamespacePatch"", e)
			response := admission.Denied(e)
			return &response
		}
		return nil
	}
}
",CWE-863,84.0,0
"// Copyright 2020-2021 Clastix Labs
// SPDX-License-Identifier: Apache-2.0
package namespace
import (
	""context""
	""fmt""
	corev1 ""k8s.io/api/core/v1""
	""k8s.io/apimachinery/pkg/types""
	""k8s.io/client-go/tools/record""
	""sigs.k8s.io/controller-runtime/pkg/client""
	""sigs.k8s.io/controller-runtime/pkg/webhook/admission""
	capsulev1beta1 ""github.com/clastix/capsule/api/v1beta1""
	capsulewebhook ""github.com/clastix/capsule/pkg/webhook""
	""github.com/clastix/capsule/pkg/webhook/utils""
)
type userMetadataHandler struct{}
func UserMetadataHandler() capsulewebhook.Handler {
	return &userMetadataHandler{}
}
func (r *userMetadataHandler) validateUserMetadata(tnt *capsulev1beta1.Tenant, recorder record.EventRecorder, labels map[string]string, annotations map[string]string) *admission.Response {
	if tnt.ForbiddenUserNamespaceLabels() != nil {
		forbiddenLabels := tnt.ForbiddenUserNamespaceLabels()
		for label := range labels {
			var forbidden, matched bool
			forbidden = forbiddenLabels.ExactMatch(label)
			matched = forbiddenLabels.RegexMatch(label)
			if forbidden || matched {
				recorder.Eventf(tnt, corev1.EventTypeWarning, ""ForbiddenNamespaceLabel"", fmt.Sprintf(""Label %s is forbidden for a namespaces of the current Tenant "", label))
				response := admission.Denied(NewNamespaceLabelForbiddenError(label, forbiddenLabels).Error())
				return &response
			}
		}
	}
	if tnt.ForbiddenUserNamespaceAnnotations() != nil {
		forbiddenAnnotations := tnt.ForbiddenUserNamespaceLabels()
		for annotation := range annotations {
			var forbidden, matched bool
			forbidden = forbiddenAnnotations.ExactMatch(annotation)
			matched = forbiddenAnnotations.RegexMatch(annotation)
			if forbidden || matched {
				recorder.Eventf(tnt, corev1.EventTypeWarning, ""ForbiddenNamespaceAnnotation"", fmt.Sprintf(""Annotation %s is forbidden for a namespaces of the current Tenant "", annotation))
				response := admission.Denied(NewNamespaceAnnotationForbiddenError(annotation, forbiddenAnnotations).Error())
				return &response
			}
		}
	}
	return nil
}
func (r *userMetadataHandler) OnCreate(client client.Client, decoder *admission.Decoder, recorder record.EventRecorder) capsulewebhook.Func {
	return func(ctx context.Context, req admission.Request) *admission.Response {
		ns := &corev1.Namespace{}
		if err := decoder.Decode(req, ns); err != nil {
			return utils.ErroredResponse(err)
		}
		tnt := &capsulev1beta1.Tenant{}
		for _, objectRef := range ns.ObjectMeta.OwnerReferences {
			// retrieving the selected Tenant
			if err := client.Get(ctx, types.NamespacedName{Name: objectRef.Name}, tnt); err != nil {
				return utils.ErroredResponse(err)
			}
		}
		labels := ns.GetLabels()
		annotations := ns.GetAnnotations()
		return r.validateUserMetadata(tnt, recorder, labels, annotations)
	}
}
func (r *userMetadataHandler) OnDelete(client client.Client, decoder *admission.Decoder, recorder record.EventRecorder) capsulewebhook.Func {
	return func(ctx context.Context, req admission.Request) *admission.Response {
		return nil
	}
}
func (r *userMetadataHandler) OnUpdate(client client.Client, decoder *admission.Decoder, recorder record.EventRecorder) capsulewebhook.Func {
	return func(ctx context.Context, req admission.Request) *admission.Response {
		oldNs := &corev1.Namespace{}
		if err := decoder.DecodeRaw(req.OldObject, oldNs); err != nil {
			return utils.ErroredResponse(err)
		}
		newNs := &corev1.Namespace{}
		if err := decoder.Decode(req, newNs); err != nil {
			return utils.ErroredResponse(err)
		}
		tnt := &capsulev1beta1.Tenant{}
		for _, objectRef := range newNs.ObjectMeta.OwnerReferences {
			// retrieving the selected Tenant
			if err := client.Get(ctx, types.NamespacedName{Name: objectRef.Name}, tnt); err != nil {
				return utils.ErroredResponse(err)
			}
		}
		if len(tnt.Spec.NodeSelector) > 0 {
			v, ok := newNs.GetAnnotations()[""scheduler.alpha.kubernetes.io/node-selector""]
			if !ok {
				response := admission.Denied(""the node-selector annotation is enforced, cannot be removed"")
				recorder.Eventf(tnt, corev1.EventTypeWarning, ""ForbiddenNodeSelectorDeletion"", string(response.Result.Reason))
				return &response
			}
			if v != oldNs.GetAnnotations()[""scheduler.alpha.kubernetes.io/node-selector""] {
				response := admission.Denied(""the the node-selector annotation is enforced, cannot be updated"")
				recorder.Eventf(tnt, corev1.EventTypeWarning, ""ForbiddenNodeSelectorUpdate"", string(response.Result.Reason))
				return &response
			}
		}
		var labels, annotations map[string]string
		for key, value := range newNs.GetLabels() {
			if _, ok := oldNs.GetLabels()[key]; ok {
				if labels == nil {
					labels = make(map[string]string)
				}
				labels[key] = value
			}
		}
		for key, value := range newNs.GetAnnotations() {
			if _, ok := oldNs.GetAnnotations()[key]; ok {
				if annotations == nil {
					annotations = make(map[string]string)
				}
				annotations[key] = value
			}
		}
		return r.validateUserMetadata(tnt, recorder, labels, annotations)
	}
}
",CWE-863,159.0,0
"// Copyright 2020-2021 Clastix Labs
// SPDX-License-Identifier: Apache-2.0
package tenant
import (
	""context""
	""fmt""
	""strings""
	corev1 ""k8s.io/api/core/v1""
	""k8s.io/apimachinery/pkg/fields""
	""k8s.io/client-go/tools/record""
	""sigs.k8s.io/controller-runtime/pkg/client""
	""sigs.k8s.io/controller-runtime/pkg/webhook/admission""
	capsulev1beta1 ""github.com/clastix/capsule/api/v1beta1""
	""github.com/clastix/capsule/pkg/configuration""
	capsulewebhook ""github.com/clastix/capsule/pkg/webhook""
	""github.com/clastix/capsule/pkg/webhook/utils""
)
type cordoningHandler struct {
	configuration configuration.Configuration
}
func CordoningHandler(configuration configuration.Configuration) capsulewebhook.Handler {
	return &cordoningHandler{
		configuration: configuration,
	}
}
func (h *cordoningHandler) cordonHandler(ctx context.Context, clt client.Client, req admission.Request, recorder record.EventRecorder) *admission.Response {
	tntList := &capsulev1beta1.TenantList{}
	if err := clt.List(ctx, tntList, client.MatchingFieldsSelector{
		Selector: fields.OneTermEqualSelector("".status.namespaces"", req.Namespace),
	}); err != nil {
		return utils.ErroredResponse(err)
	}
	// resource is not inside a Tenant namespace
	if len(tntList.Items) == 0 {
		return nil
	}
	tnt := tntList.Items[0]
	if tnt.IsCordoned() && utils.IsCapsuleUser(ctx, req, clt, h.configuration.UserGroups()) {
		recorder.Eventf(&tnt, corev1.EventTypeWarning, ""TenantFreezed"", ""%s %s/%s cannot be %sd, current Tenant is freezed"", req.Kind.String(), req.Namespace, req.Name, strings.ToLower(string(req.Operation)))
		response := admission.Denied(fmt.Sprintf(""tenant %s is freezed: please, reach out to the system administrator"", tnt.GetName()))
		return &response
	}
	return nil
}
func (h *cordoningHandler) OnCreate(client client.Client, _ *admission.Decoder, recorder record.EventRecorder) capsulewebhook.Func {
	return func(ctx context.Context, req admission.Request) *admission.Response {
		return h.cordonHandler(ctx, client, req, recorder)
	}
}
func (h *cordoningHandler) OnDelete(client client.Client, _ *admission.Decoder, recorder record.EventRecorder) capsulewebhook.Func {
	return func(ctx context.Context, req admission.Request) *admission.Response {
		return h.cordonHandler(ctx, client, req, recorder)
	}
}
func (h *cordoningHandler) OnUpdate(client client.Client, _ *admission.Decoder, recorder record.EventRecorder) capsulewebhook.Func {
	return func(ctx context.Context, req admission.Request) *admission.Response {
		return h.cordonHandler(ctx, client, req, recorder)
	}
}
",CWE-863,75.0,0
"// Copyright 2020-2021 Clastix Labs
// SPDX-License-Identifier: Apache-2.0
package utils
import (
	""context""
	""k8s.io/client-go/tools/record""
	""sigs.k8s.io/controller-runtime/pkg/client""
	""sigs.k8s.io/controller-runtime/pkg/webhook/admission""
	""github.com/clastix/capsule/pkg/configuration""
	""github.com/clastix/capsule/pkg/webhook""
)
func InCapsuleGroups(configuration configuration.Configuration, handlers ...webhook.Handler) webhook.Handler {
	return &handler{
		configuration: configuration,
		handlers:      handlers,
	}
}
type handler struct {
	configuration configuration.Configuration
	handlers      []webhook.Handler
}
func (h *handler) OnCreate(client client.Client, decoder *admission.Decoder, recorder record.EventRecorder) webhook.Func {
	return func(ctx context.Context, req admission.Request) *admission.Response {
		if !IsCapsuleUser(ctx, req, client, h.configuration.UserGroups()) {
			return nil
		}
		for _, hndl := range h.handlers {
			if response := hndl.OnCreate(client, decoder, recorder)(ctx, req); response != nil {
				return response
			}
		}
		return nil
	}
}
func (h *handler) OnDelete(client client.Client, decoder *admission.Decoder, recorder record.EventRecorder) webhook.Func {
	return func(ctx context.Context, req admission.Request) *admission.Response {
		if !IsCapsuleUser(ctx, req, client, h.configuration.UserGroups()) {
			return nil
		}
		for _, hndl := range h.handlers {
			if response := hndl.OnDelete(client, decoder, recorder)(ctx, req); response != nil {
				return response
			}
		}
		return nil
	}
}
func (h *handler) OnUpdate(client client.Client, decoder *admission.Decoder, recorder record.EventRecorder) webhook.Func {
	return func(ctx context.Context, req admission.Request) *admission.Response {
		if !IsCapsuleUser(ctx, req, client, h.configuration.UserGroups()) {
			return nil
		}
		for _, hndl := range h.handlers {
			if response := hndl.OnUpdate(client, decoder, recorder)(ctx, req); response != nil {
				return response
			}
		}
		return nil
	}
}
",CWE-863,76.0,0
"package utils
import (
	""context""
	""strings""
	""k8s.io/apimachinery/pkg/fields""
	""k8s.io/apimachinery/pkg/util/sets""
	""sigs.k8s.io/controller-runtime/pkg/client""
	""sigs.k8s.io/controller-runtime/pkg/webhook/admission""
	capsulev1beta1 ""github.com/clastix/capsule/api/v1beta1""
	""github.com/clastix/capsule/pkg/utils""
)
func IsCapsuleUser(ctx context.Context, req admission.Request, clt client.Client, userGroups []string) bool {
	groupList := utils.NewUserGroupList(req.UserInfo.Groups)
	// if the user is a ServiceAccount belonging to the kube-system namespace, definitely, it's not a Capsule user
	// and we can skip the check in case of Capsule user group assigned to system:authenticated
	// (ref: https://github.com/clastix/capsule/issues/234)
	if groupList.Find(""system:serviceaccounts:kube-system"") {
		return false
	}
	// nolint:nestif
	if sets.NewString(req.UserInfo.Groups...).Has(""system:serviceaccounts"") {
		parts := strings.Split(req.UserInfo.Username, "":"")
		targetNamespace := parts[2]
		if len(targetNamespace) > 0 {
			tl := &capsulev1beta1.TenantList{}
			if err := clt.List(ctx, tl, client.MatchingFieldsSelector{Selector: fields.OneTermEqualSelector("".status.namespaces"", targetNamespace)}); err != nil {
				return false
			}
			if len(tl.Items) == 1 {
				return true
			}
		}
	}
	for _, group := range userGroups {
		if groupList.Find(group) {
			return true
		}
	}
	return false
}
",CWE-863,50.0,0
"//go:build e2e
// Copyright 2020-2021 Clastix Labs
// SPDX-License-Identifier: Apache-2.0
package e2e
import (
	""context""
	""fmt""
	""time""
	. ""github.com/onsi/ginkgo""
	. ""github.com/onsi/gomega""
	rbacv1 ""k8s.io/api/rbac/v1""
	metav1 ""k8s.io/apimachinery/pkg/apis/meta/v1""
	""k8s.io/apimachinery/pkg/types""
	""k8s.io/apimachinery/pkg/util/uuid""
	""k8s.io/client-go/kubernetes""
	""sigs.k8s.io/controller-runtime/pkg/client/config""
	capsulev1beta1 ""github.com/clastix/capsule/api/v1beta1""
)
var _ = Describe(""trying to escalate from a Tenant Namespace ServiceAccount"", func() {
	tnt := &capsulev1beta1.Tenant{
		ObjectMeta: metav1.ObjectMeta{
			Name: ""sa-privilege-escalation"",
		},
		Spec: capsulev1beta1.TenantSpec{
			Owners: capsulev1beta1.OwnerListSpec{
				{
					Name: ""mario"",
					Kind: ""User"",
				},
			},
			NodeSelector: map[string]string{
				""kubernetes.io/os"": ""linux"",
			},
		},
	}
	ns := NewNamespace(""attack"")
	JustBeforeEach(func() {
		EventuallyCreation(func() error {
			return k8sClient.Create(context.TODO(), tnt)
		}).Should(Succeed())
		NamespaceCreation(ns, tnt.Spec.Owners[0], defaultTimeoutInterval).Should(Succeed())
		TenantNamespaceList(tnt, defaultTimeoutInterval).Should(ContainElement(ns.GetName()))
	})
	JustAfterEach(func() {
		Expect(k8sClient.Delete(context.TODO(), tnt)).Should(Succeed())
	})
	It(""should block Namespace changes"", func() {
		role := rbacv1.Role{
			ObjectMeta: metav1.ObjectMeta{
				Name:      ""ns-update-role"",
				Namespace: ns.GetName(),
			},
			Rules: []rbacv1.PolicyRule{
				{
					Verbs:         []string{""update""},
					APIGroups:     []string{""""},
					Resources:     []string{""namespaces""},
					ResourceNames: []string{ns.GetName()},
				},
			},
		}
		EventuallyCreation(func() error {
			return k8sClient.Create(context.Background(), &role)
		}).Should(Succeed())
		rolebinding := rbacv1.RoleBinding{
			ObjectMeta: metav1.ObjectMeta{
				Name:      ""attacker-rolebinding"",
				Namespace: ns.GetName(),
			},
			Subjects: []rbacv1.Subject{
				{
					Kind:      ""ServiceAccount"",
					Name:      ""attacker"",
					Namespace: ns.GetName(),
				},
			},
			RoleRef: rbacv1.RoleRef{
				APIGroup: ""rbac.authorization.k8s.io"",
				Kind:     ""Role"",
				Name:     role.GetName(),
			},
		}
		EventuallyCreation(func() error {
			return k8sClient.Create(context.Background(), &rolebinding)
		}).Should(Succeed())
		c, err := config.GetConfig()
		Expect(err).ToNot(HaveOccurred())
		c.Impersonate.Groups = []string{""system:serviceaccounts""}
		c.Impersonate.UserName = fmt.Sprintf(""system:serviceaccount:%s:%s"", rolebinding.Subjects[0].Namespace, rolebinding.Subjects[0].Name)
		saClient, err := kubernetes.NewForConfig(c)
		Expect(err).ToNot(HaveOccurred())
		// Changing Owner Reference is forbidden
		Consistently(func() error {
			if err := k8sClient.Get(context.Background(), types.NamespacedName{Name: ns.GetName()}, ns); err != nil {
				return err
			}
			ns.OwnerReferences[0].UID = uuid.NewUUID()
			_, err = saClient.CoreV1().Namespaces().Update(context.Background(), ns, metav1.UpdateOptions{})
			return err
		}, 10*time.Second, time.Second).ShouldNot(Succeed())
		// Removing Owner Reference is forbidden
		Consistently(func() error {
			if err := k8sClient.Get(context.Background(), types.NamespacedName{Name: ns.GetName()}, ns); err != nil {
				return err
			}
			ns.SetOwnerReferences(nil)
			_, err = saClient.CoreV1().Namespaces().Update(context.Background(), ns, metav1.UpdateOptions{})
			return err
		}, 10*time.Second, time.Second).ShouldNot(Succeed())
		// Breaking nodeSelector is forbidden
		Consistently(func() error {
			if err := k8sClient.Get(context.Background(), types.NamespacedName{Name: ns.GetName()}, ns); err != nil {
				return err
			}
			ns.SetAnnotations(map[string]string{
				""scheduler.alpha.kubernetes.io/node-selector"": ""kubernetes.io/os=forbidden"",
			})
			_, err = saClient.CoreV1().Namespaces().Update(context.Background(), ns, metav1.UpdateOptions{})
			return err
		}, 10*time.Second, time.Second).ShouldNot(Succeed())
	})
})
",CWE-863,147.0,0
"//go:build ocr
// +build ocr
package docconv
import (
	""fmt""
	""io""
	""io/ioutil""
	""log""
	""os""
	""os/exec""
	""path/filepath""
	""regexp""
	""strings""
	""sync""
)
var (
	exts = []string{"".jpg"", "".tif"", "".tiff"", "".png"", "".pbm""}
)
func compareExt(ext string, exts []string) bool {
	for _, e := range exts {
		if ext == e {
			return true
		}
	}
	return false
}
func cleanupTemp(tmpDir string) {
	err := os.RemoveAll(tmpDir)
	if err != nil {
		log.Println(err)
	}
}
func ConvertPDFImages(path string) (BodyResult, error) {
	bodyResult := BodyResult{}
	tmp, err := ioutil.TempDir(os.TempDir(), ""tmp-imgs-"")
	if err != nil {
		bodyResult.err = err
		return bodyResult, err
	}
	tmpDir := fmt.Sprintf(""%s/"", tmp)
	defer cleanupTemp(tmpDir)
	_, err = exec.Command(""pdfimages"", ""-j"", path, tmpDir).Output()
	if err != nil {
		return bodyResult, err
	}
	filePaths := []string{}
	walkFunc := func(path string, info os.FileInfo, err error) error {
		path, err = filepath.Abs(path)
		if err != nil {
			return err
		}
		if compareExt(filepath.Ext(path), exts) {
			filePaths = append(filePaths, path)
		}
		return nil
	}
	filepath.Walk(tmpDir, walkFunc)
	fileLength := len(filePaths)
	if fileLength < 1 {
		return bodyResult, nil
	}
	var wg sync.WaitGroup
	data := make(chan string, fileLength)
	wg.Add(fileLength)
	for _, p := range filePaths {
		go func(pathFile string) {
			defer wg.Done()
			f, err := os.Open(pathFile)
			if err != nil {
				return
			}
			defer f.Close()
			out, _, err := ConvertImage(f)
			if err != nil {
				return
			}
			data <- out
		}(p)
	}
	wg.Wait()
	close(data)
	for str := range data {
		bodyResult.body += str + "" ""
	}
	return bodyResult, nil
}
// PdfHasImage verify if `path` (PDF) has images
func PDFHasImage(path string) bool {
	cmd := ""pdffonts -l 5 %s | tail -n +3 | cut -d' ' -f1 | sort | uniq""
	out, err := exec.Command(""bash"", ""-c"", fmt.Sprintf(cmd, shellEscape(path))).CombinedOutput()
	if err != nil {
		log.Println(err)
		return false
	}
	if string(out) == """" {
		return true
	}
	return false
}
func ConvertPDF(r io.Reader) (string, map[string]string, error) {
	f, err := NewLocalFile(r)
	if err != nil {
		return """", nil, fmt.Errorf(""error creating local file: %v"", err)
	}
	defer f.Done()
	bodyResult, metaResult, textConvertErr := ConvertPDFText(f.Name())
	if textConvertErr != nil {
		return """", nil, textConvertErr
	}
	if bodyResult.err != nil {
		return """", nil, bodyResult.err
	}
	if metaResult.err != nil {
		return """", nil, metaResult.err
	}
	if !PDFHasImage(f.Name()) {
		return bodyResult.body, metaResult.meta, nil
	}
	imageConvertResult, imageConvertErr := ConvertPDFImages(f.Name())
	if imageConvertErr != nil {
		log.Println(imageConvertErr)
		return bodyResult.body, metaResult.meta, nil
	}
	if imageConvertResult.err != nil {
		log.Println(imageConvertResult.err)
		return bodyResult.body, metaResult.meta, nil
	}
	fullBody := strings.Join([]string{bodyResult.body, imageConvertResult.body}, "" "")
	return fullBody, metaResult.meta, nil
}
var shellEscapePattern *regexp.Regexp
func init() {
	shellEscapePattern = regexp.MustCompile(`[^\w@%+=:,./-]`)
}
// shellEscape returns a shell-escaped version of the string s. The returned value
// is a string that can safely be used as one token in a shell command line.
func shellEscape(s string) string {
	if len(s) == 0 {
		return ""''""
	}
	if shellEscapePattern.MatchString(s) {
		return ""'"" + strings.Replace(s, ""'"", ""'\""'\""'"", -1) + ""'""
	}
	return s
}
",CWE-78,184.0,0
"//go:build ocr
// +build ocr
package docconv
import (
	""os""
	""testing""
)
func TestPDFHasImage_CannotExecuteCode(t *testing.T) {
	// Try to inject code by passing a bad file path.
	// If the code was successful it will create a file called foo in the working directory
	badFilePath := ""$(id >> foo).pdf""
	if got, want := PDFHasImage(badFilePath), false; got != want {
		t.Errorf(""got %v, want %v"", got, want)
	}
	if got, want := fileExists(""foo""), false; got != want {
		t.Errorf(""got bad file exists, want not file to exist"")
	}
}
func fileExists(filename string) bool {
	info, err := os.Stat(filename)
	if os.IsNotExist(err) {
		return false
	}
	return !info.IsDir()
}
",CWE-78,31.0,0
"package docconv
import (
	""archive/zip""
	""bytes""
	""encoding/xml""
	""fmt""
	""io""
	""io/ioutil""
	""os""
	""time""
)
type typeOverride struct {
	XMLName     xml.Name `xml:""Override""`
	ContentType string   `xml:""ContentType,attr""`
	PartName    string   `xml:""PartName,attr""`
}
type contentTypeDefinition struct {
	XMLName   xml.Name       `xml:""Types""`
	Overrides []typeOverride `xml:""Override""`
}
// ConvertDocx converts an MS Word docx file to text.
func ConvertDocx(r io.Reader) (string, map[string]string, error) {
	var size int64
	// Common case: if the reader is a file (or trivial wrapper), avoid
	// loading it all into memory.
	var ra io.ReaderAt
	if f, ok := r.(interface {
		io.ReaderAt
		Stat() (os.FileInfo, error)
	}); ok {
		si, err := f.Stat()
		if err != nil {
			return """", nil, err
		}
		size = si.Size()
		ra = f
	} else {
		b, err := ioutil.ReadAll(io.LimitReader(r, maxBytes))
		if err != nil {
			return """", nil, nil
		}
		size = int64(len(b))
		ra = bytes.NewReader(b)
	}
	zr, err := zip.NewReader(ra, size)
	if err != nil {
		return """", nil, fmt.Errorf(""error unzipping data: %v"", err)
	}
	zipFiles := mapZipFiles(zr.File)
	contentTypeDefinition, err := getContentTypeDefinition(zipFiles[""[Content_Types].xml""])
	if err != nil {
		return """", nil, err
	}
	meta := make(map[string]string)
	var textHeader, textBody, textFooter string
	for _, override := range contentTypeDefinition.Overrides {
		f := zipFiles[override.PartName]
		switch {
		case override.ContentType == ""application/vnd.openxmlformats-package.core-properties+xml"":
			rc, err := f.Open()
			if err != nil {
				return """", nil, fmt.Errorf(""error opening '%v' from archive: %v"", f.Name, err)
			}
			defer rc.Close()
			meta, err = XMLToMap(rc)
			if err != nil {
				return """", nil, fmt.Errorf(""error parsing '%v': %v"", f.Name, err)
			}
			if tmp, ok := meta[""modified""]; ok {
				if t, err := time.Parse(time.RFC3339, tmp); err == nil {
					meta[""ModifiedDate""] = fmt.Sprintf(""%d"", t.Unix())
				}
			}
			if tmp, ok := meta[""created""]; ok {
				if t, err := time.Parse(time.RFC3339, tmp); err == nil {
					meta[""CreatedDate""] = fmt.Sprintf(""%d"", t.Unix())
				}
			}
		case override.ContentType == ""application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml"":
			body, err := parseDocxText(f)
			if err != nil {
				return """", nil, err
			}
			textBody += body + ""\n""
		case override.ContentType == ""application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml"":
			footer, err := parseDocxText(f)
			if err != nil {
				return """", nil, err
			}
			textFooter += footer + ""\n""
		case override.ContentType == ""application/vnd.openxmlformats-officedocument.wordprocessingml.header+xml"":
			header, err := parseDocxText(f)
			if err != nil {
				return """", nil, err
			}
			textHeader += header + ""\n""
		}
	}
	return textHeader + ""\n"" + textBody + ""\n"" + textFooter, meta, nil
}
func getContentTypeDefinition(zf *zip.File) (*contentTypeDefinition, error) {
	f, err := zf.Open()
	if err != nil {
		return nil, err
	}
	defer f.Close()
	x := &contentTypeDefinition{}
	if err := xml.NewDecoder(f).Decode(x); err != nil {
		return nil, err
	}
	return x, nil
}
func mapZipFiles(files []*zip.File) map[string]*zip.File {
	filesMap := make(map[string]*zip.File, 2*len(files))
	for _, f := range files {
		filesMap[f.Name] = f
		filesMap[""/""+f.Name] = f
	}
	return filesMap
}
func parseDocxText(f *zip.File) (string, error) {
	r, err := f.Open()
	if err != nil {
		return """", fmt.Errorf(""error opening '%v' from archive: %v"", f.Name, err)
	}
	defer r.Close()
	text, err := DocxXMLToText(r)
	if err != nil {
		return """", fmt.Errorf(""error parsing '%v': %v"", f.Name, err)
	}
	return text, nil
}
// DocxXMLToText converts Docx XML into plain text.
func DocxXMLToText(r io.Reader) (string, error) {
	return XMLToText(r, []string{""br"", ""p"", ""tab""}, []string{""instrText"", ""script""}, true)
}
",CWE-789,156.0,0
"package docconv
import (
	""archive/zip""
	""bytes""
	""fmt""
	""io""
	""io/ioutil""
	""time""
)
// ConvertODT converts a ODT file to text
func ConvertODT(r io.Reader) (string, map[string]string, error) {
	meta := make(map[string]string)
	var textBody string
	b, err := ioutil.ReadAll(io.LimitReader(r, maxBytes))
	if err != nil {
		return """", nil, err
	}
	zr, err := zip.NewReader(bytes.NewReader(b), int64(len(b)))
	if err != nil {
		return """", nil, fmt.Errorf(""error unzipping data: %v"", err)
	}
	for _, f := range zr.File {
		switch f.Name {
		case ""meta.xml"":
			rc, err := f.Open()
			if err != nil {
				return """", nil, fmt.Errorf(""error extracting '%v' from archive: %v"", f.Name, err)
			}
			defer rc.Close()
			info, err := XMLToMap(rc)
			if err != nil {
				return """", nil, fmt.Errorf(""error parsing '%v': %v"", f.Name, err)
			}
			if tmp, ok := info[""creator""]; ok {
				meta[""Author""] = tmp
			}
			if tmp, ok := info[""date""]; ok {
				if t, err := time.Parse(""2006-01-02T15:04:05"", tmp); err == nil {
					meta[""ModifiedDate""] = fmt.Sprintf(""%d"", t.Unix())
				}
			}
			if tmp, ok := info[""creation-date""]; ok {
				if t, err := time.Parse(""2006-01-02T15:04:05"", tmp); err == nil {
					meta[""CreatedDate""] = fmt.Sprintf(""%d"", t.Unix())
				}
			}
		case ""content.xml"":
			rc, err := f.Open()
			if err != nil {
				return """", nil, fmt.Errorf(""error extracting '%v' from archive: %v"", f.Name, err)
			}
			defer rc.Close()
			textBody, err = XMLToText(rc, []string{""br"", ""p"", ""tab""}, []string{}, true)
			if err != nil {
				return """", nil, fmt.Errorf(""error parsing '%v': %v"", f.Name, err)
			}
		}
	}
	return textBody, meta, nil
}
",CWE-789,70.0,0
"package docconv
import (
	""archive/zip""
	""bufio""
	""bytes""
	""encoding/binary""
	""fmt""
	""io""
	""io/ioutil""
	""strings""
	""google.golang.org/protobuf/proto""
	TSP ""code.sajari.com/docconv/iWork""
	""code.sajari.com/docconv/snappy""
)
// ConvertPages converts a Pages file to text.
func ConvertPages(r io.Reader) (string, map[string]string, error) {
	meta := make(map[string]string)
	var textBody string
	b, err := ioutil.ReadAll(io.LimitReader(r, maxBytes))
	if err != nil {
		return """", nil, fmt.Errorf(""error reading data: %v"", err)
	}
	zr, err := zip.NewReader(bytes.NewReader(b), int64(len(b)))
	if err != nil {
		return """", nil, fmt.Errorf(""error unzipping data: %v"", err)
	}
	for _, f := range zr.File {
		if strings.HasSuffix(f.Name, ""Preview.pdf"") {
			// There is a preview PDF version we can use
			if rc, err := f.Open(); err == nil {
				return ConvertPDF(rc)
			}
		}
		if f.Name == ""index.xml"" {
			// There's an XML version we can use
			if rc, err := f.Open(); err == nil {
				return ConvertXML(rc)
			}
		}
		if f.Name == ""Index/Document.iwa"" {
			rc, _ := f.Open()
			defer rc.Close()
			bReader := bufio.NewReader(snappy.NewReader(io.MultiReader(strings.NewReader(""\xff\x06\x00\x00sNaPpY""), rc)))
			// Ignore error.
			// NOTE: This error was unchecked. Need to revisit this to see if it
			// should be acted on.
			archiveLength, _ := binary.ReadVarint(bReader)
			// Ignore error.
			// NOTE: This error was unchecked. Need to revisit this to see if it
			// should be acted on.
			archiveInfoData, _ := ioutil.ReadAll(io.LimitReader(bReader, archiveLength))
			archiveInfo := &TSP.ArchiveInfo{}
			err = proto.Unmarshal(archiveInfoData, archiveInfo)
			fmt.Println(""archiveInfo:"", archiveInfo, err)
		}
	}
	return textBody, meta, nil
}
",CWE-789,70.0,0
"package docconv
import (
	""bytes""
	""encoding/xml""
	""fmt""
	""io""
)
// ConvertXML converts an XML file to text.
func ConvertXML(r io.Reader) (string, map[string]string, error) {
	meta := make(map[string]string)
	cleanXML, err := Tidy(r, true)
	if err != nil {
		return """", nil, fmt.Errorf(""tidy error: %v"", err)
	}
	result, err := XMLToText(bytes.NewReader(cleanXML), []string{}, []string{}, true)
	if err != nil {
		return """", nil, fmt.Errorf(""error from XMLToText: %v"", err)
	}
	return result, meta, nil
}
// XMLToText converts XML to plain text given how to treat elements.
func XMLToText(r io.Reader, breaks []string, skip []string, strict bool) (string, error) {
	var result string
	dec := xml.NewDecoder(io.LimitReader(r, maxBytes))
	dec.Strict = strict
	for {
		t, err := dec.Token()
		if err != nil {
			if err == io.EOF {
				break
			}
			return """", err
		}
		switch v := t.(type) {
		case xml.CharData:
			result += string(v)
		case xml.StartElement:
			for _, breakElement := range breaks {
				if v.Name.Local == breakElement {
					result += ""\n""
				}
			}
			for _, skipElement := range skip {
				if v.Name.Local == skipElement {
					depth := 1
					for {
						t, err := dec.Token()
						if err != nil {
							// An io.EOF here is actually an error.
							return """", err
						}
						switch t.(type) {
						case xml.StartElement:
							depth++
						case xml.EndElement:
							depth--
						}
						if depth == 0 {
							break
						}
					}
				}
			}
		}
	}
	return result, nil
}
// XMLToMap converts XML to a nested string map.
func XMLToMap(r io.Reader) (map[string]string, error) {
	m := make(map[string]string)
	dec := xml.NewDecoder(io.LimitReader(r, maxBytes))
	var tagName string
	for {
		t, err := dec.Token()
		if err != nil {
			if err == io.EOF {
				break
			}
			return nil, err
		}
		switch v := t.(type) {
		case xml.StartElement:
			tagName = string(v.Name.Local)
		case xml.CharData:
			m[tagName] = string(v)
		}
	}
	return m, nil
}
",CWE-789,99.0,0
"SSH_KEY_1 = (
    ""ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDCUQeasspT/etEJR2WUoR+h2sMOQYbJgr0QE+J8p97gEhmz107KWZ+3""
    ""mbOwyIFzfWBcJZCEg9wy5Paj+YxbGONqbpXAhPdVQ2TLgxr41bNXvbcRAxZC+Q12UZywR4Klb2kungKz4qkcmSZzouaKK""
    ""12UxzGB3xQ0N+3osKFj3xA1+B6HqrVreU19XdVoAJh0xLZwhw17/NDM+dAcEdMZ9V89KyjwjraXtOVfFhQF0EDF0ame8d""
    ""6UkayGrAiXC2He0P2Cja+J371P27AlNLHFJij8WGxvcGGSeAxMLoVSDOOllLCYH5UieV8mNpX1kNe2LeA58ciZb0AXHai""
    ""pSmCHgh/ some-comment""
)
SSH_KEY_2 = (
    ""ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDF1DyXlqc40AVUgt/IO0GFcTniaoFt5qCUAeNVlvalMnsrRULIXkb0g""
    ""1ds9P9/UI2jWr70ZYG7XieQX1F7NpzaDeUyPGCrLV1/ev1ZtUImCrDFfMznEjkcqB33mRe1rCFGKNVOYUviPE1yBdbfZB""
    ""GUuJBX2GOXQQj9fU4Hiq3rAgOhz89717mt+qZxZllZ4mdyVEaMBWCwqAvl7Z5ecDjB+llFpBORTmsT8OZoGbZnJTIB1d9""
    ""j0tSbegP17emE+g9fTrk4/ePmSIAKcSV3xj6h98AGesNibyu9eKVrroEptxX4crl0o95Me6B1/DCL632xrTO0a5mSmlF4""
    ""cxCgjLj9 to/ key2""
)
SSH_KEY_BAD = ""ssh-rsa AAAblahblahkey some-comment""
SSH_KEY_BAD_MULTILINE = SSH_KEY_1 + ""\r"" + SSH_KEY_2
SSH2_KEY_BAD = """"""\
---- BEGIN SSH2 PUBLIC KEY ----
foobar: this is a chance to hide bad things
AAAAC3NzaC1lZDI1NTE5AAAAIJ5O/AXibtVhySDYn60ATXftAU1oCe4BQubFYoV2juEb
---- END SSH2 PUBLIC KEY ----
""""""
SSH_KEY_RSA_1024 = (
    ""ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAAAgQDhKgSsCJR9UyQa/Gsheb5F56hg23CVnCLpmpyC2JMqVEptG9CL83Oft""
    ""pOPvEb/785Act4En1VFvwMwTj25VurbG3XI984csiNdWPlM1ke4lHK2PQepSYyZVYn+hhXhzSILNDixhBYeDVv4GOfJM1""
    ""HBO2AEtupOMHOqtnQLjV1UnQ== rsa-1024""
)
SSH_KEY_DSA = (
    ""ssh-dss AAAAB3NzaC1kc3MAAACBAKdCbYh9GgDPFppJmyRcpWhFn3Xc5vcljGE20df84KYQeBVCQg3zTLkwynHyrpEwT""
    ""HmIc0bgH14muGwPOdt8CEtj9EvcPHHCEaZ/4IdT02awY+Opszq7LI/YXzfu3cbgOoB22zj+chhryCiMIisEBHQv00F54z""
    ""01yOi3mOX7BIZBAAAAFQDgX/4IaAAtnbQ3DeDbWSJVxdKtIQAAAIEAoUsqfKyrzmDLgLhLpJpVs5BPdziHxlJM1+cQuIa""
    ""VsTHe7tyu61hpColor2ybyhafKhJ3ZH9bsl8DASwkGQXyjOTL/T6IzVhlcCfeDtirwAwQNINz8xwplLIbCOLAAOdVrKE9""
    ""xHMO5RPXO8i58CFF7c5fm3vg87nLH+uh1AwFyysAAACABCca7QX1ZJIoIt37HxCwV3+ktcoVhoZhuzHNRe9l4CSKSeSdn""
    ""WrdaC8G7tvKPTrImYIPqSZz3ohLDioflMUN3yIHnO1VsDn0hwTa7x9c/RiGAkiwKagF1icGfzgEiMt7PTfJT/nMeFoahu""
    ""JEk8kasRtdm0VcM4JyOLiqej/8VRo= dsa-1024""
)
SSH_KEY_ECDSA_P256 = (
    ""ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBD7FwYV01qXgP2TManNEq""
    ""nOD/JXCp7WChDk7c3GiwHSlZVn3xvmtphQjzE6Ag4GDh/bFOaKIcGc66691GsOE6Vo= ecdsa-p256""
)
SSH_KEY_ED25519 = (
    ""ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIJXKRoCgQqJ0iyC51HOIJzPqjwZcvf3DF9IAwFQWwqop comment""
)
",CWE-74,52.0,0
"{
	""name"": ""ralouphie/getallheaders"",
	""description"": ""A polyfill for getallheaders."",
	""license"": ""MIT"",
	""authors"": [
		{
			""name"": ""Ralph Khattar"",
			""email"": ""ralph.khattar@gmail.com""
		}
	],
	""require"": {
		""php"": "">=5.6""
	},
	""require-dev"": {
		""phpunit/phpunit"": ""^5 || ^6.5"",
		""php-coveralls/php-coveralls"": ""^2.1""
	},
	""autoload"": {
		""files"": [""src/getallheaders.php""]
	},
	""autoload-dev"": {
		""psr-4"": {
			""getallheaders\\Tests\\"": ""tests/""
		}
	}
}
",CWE-829,27.0,0
"{
	""name"": ""ralouphie/getallheaders"",
	""description"": ""A polyfill for getallheaders."",
	""license"": ""MIT"",
	""authors"": [
		{
			""name"": ""Ralph Khattar"",
			""email"": ""ralph.khattar@gmail.com""
		}
	],
	""require"": {
		""php"": "">=5.6""
	},
	""require-dev"": {
		""phpunit/phpunit"": ""^5 || ^6.5"",
		""php-coveralls/php-coveralls"": ""^2.1""
	},
	""autoload"": {
		""files"": [""src/getallheaders.php""]
	},
	""autoload-dev"": {
		""psr-4"": {
			""getallheaders\\Tests\\"": ""tests/""
		}
	}
}
",CWE-352,27.0,0
"package collection
import (
	""context""
	""github.com/answerdev/answer/internal/base/constant""
	""github.com/answerdev/answer/internal/base/data""
	""github.com/answerdev/answer/internal/base/pager""
	""github.com/answerdev/answer/internal/base/reason""
	""github.com/answerdev/answer/internal/entity""
	collectioncommon ""github.com/answerdev/answer/internal/service/collection_common""
	""github.com/answerdev/answer/internal/service/unique""
	""github.com/segmentfault/pacman/errors""
	""xorm.io/xorm""
)
// collectionRepo collection repository
type collectionRepo struct {
	data         *data.Data
	uniqueIDRepo unique.UniqueIDRepo
}
// NewCollectionRepo new repository
func NewCollectionRepo(data *data.Data, uniqueIDRepo unique.UniqueIDRepo) collectioncommon.CollectionRepo {
	return &collectionRepo{
		data:         data,
		uniqueIDRepo: uniqueIDRepo,
	}
}
// AddCollection add collection
func (cr *collectionRepo) AddCollection(ctx context.Context, collection *entity.Collection) (err error) {
	_, err = cr.data.DB.Transaction(func(session *xorm.Session) (result any, err error) {
		var has bool
		dbcollection := &entity.Collection{}
		result = nil
		has, err = session.Where(""user_id = ? and object_id = ?"", collection.UserID, collection.ObjectID).Get(dbcollection)
		if err != nil {
			return
		}
		if has {
			return
		}
		id, err := cr.uniqueIDRepo.GenUniqueIDStr(ctx, collection.TableName())
		if err == nil {
			collection.ID = id
			_, err = session.Insert(collection)
			if err != nil {
				return result, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
			}
		}
		return
	})
	return err
}
// RemoveCollection delete collection
func (cr *collectionRepo) RemoveCollection(ctx context.Context, id string) (err error) {
	_, err = cr.data.DB.Where(""id =?"", id).Delete(&entity.Collection{})
	if err != nil {
		return errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return nil
}
// UpdateCollection update collection
func (cr *collectionRepo) UpdateCollection(ctx context.Context, collection *entity.Collection, cols []string) (err error) {
	_, err = cr.data.DB.ID(collection.ID).Cols(cols...).Update(collection)
	return errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
}
// GetCollection get collection one
func (cr *collectionRepo) GetCollection(ctx context.Context, id int) (collection *entity.Collection, exist bool, err error) {
	collection = &entity.Collection{}
	exist, err = cr.data.DB.ID(id).Get(collection)
	if err != nil {
		return nil, false, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return
}
// GetCollectionList get collection list all
func (cr *collectionRepo) GetCollectionList(ctx context.Context, collection *entity.Collection) (collectionList []*entity.Collection, err error) {
	collectionList = make([]*entity.Collection, 0)
	err = cr.data.DB.Find(collectionList, collection)
	err = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	return
}
// GetOneByObjectIDAndUser get one by object TagID and user
func (cr *collectionRepo) GetOneByObjectIDAndUser(ctx context.Context, userID string, objectID string) (collection *entity.Collection, exist bool, err error) {
	collection = &entity.Collection{}
	exist, err = cr.data.DB.Where(""user_id = ? and object_id = ?"", userID, objectID).Get(collection)
	if err != nil {
		return nil, false, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return
}
// SearchByObjectIDsAndUser search by object IDs and user
func (cr *collectionRepo) SearchByObjectIDsAndUser(ctx context.Context, userID string, objectIDs []string) ([]*entity.Collection, error) {
	collectionList := make([]*entity.Collection, 0)
	err := cr.data.DB.Where(""user_id = ?"", userID).In(""object_id"", objectIDs).Find(&collectionList)
	if err != nil {
		return collectionList, err
	}
	return collectionList, nil
}
// CountByObjectID count by object TagID
func (cr *collectionRepo) CountByObjectID(ctx context.Context, objectID string) (total int64, err error) {
	collection := &entity.Collection{}
	total, err = cr.data.DB.Where(""object_id = ?"", objectID).Count(collection)
	if err != nil {
		return 0, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return
}
// GetCollectionPage get collection page
func (cr *collectionRepo) GetCollectionPage(ctx context.Context, page, pageSize int, collection *entity.Collection) (collectionList []*entity.Collection, total int64, err error) {
	collectionList = make([]*entity.Collection, 0)
	session := cr.data.DB.NewSession()
	if collection.UserID != """" && collection.UserID != ""0"" {
		session = session.Where(""user_id = ?"", collection.UserID)
	}
	if collection.UserCollectionGroupID != """" && collection.UserCollectionGroupID != ""0"" {
		session = session.Where(""user_collection_group_id = ?"", collection.UserCollectionGroupID)
	}
	session = session.OrderBy(""update_time desc"")
	total, err = pager.Help(page, pageSize, collectionList, collection, session)
	err = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	return
}
// SearchObjectCollected check object is collected or not
func (cr *collectionRepo) SearchObjectCollected(ctx context.Context, userID string, objectIds []string) (map[string]bool, error) {
	collectedMap := make(map[string]bool)
	list, err := cr.SearchByObjectIDsAndUser(ctx, userID, objectIds)
	if err != nil {
		err = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
		return collectedMap, err
	}
	for _, item := range list {
		collectedMap[item.ObjectID] = true
	}
	return collectedMap, err
}
// SearchList
func (cr *collectionRepo) SearchList(ctx context.Context, search *entity.CollectionSearch) ([]*entity.Collection, int64, error) {
	var count int64
	var err error
	rows := make([]*entity.Collection, 0)
	if search.Page > 0 {
		search.Page = search.Page - 1
	} else {
		search.Page = 0
	}
	if search.PageSize == 0 {
		search.PageSize = constant.DefaultPageSize
	}
	offset := search.Page * search.PageSize
	session := cr.data.DB.Where("""")
	if len(search.UserID) > 0 {
		session = session.And(""user_id = ?"", search.UserID)
	} else {
		return rows, count, nil
	}
	session = session.Limit(search.PageSize, offset)
	count, err = session.OrderBy(""updated_at desc"").FindAndCount(&rows)
	if err != nil {
		return rows, count, err
	}
	return rows, count, nil
}
",CWE-362,180.0,0
"package middleware
import (
	""fmt""
	""net/url""
	""os""
	""path""
	""path/filepath""
	""strings""
	""github.com/answerdev/answer/internal/service/service_config""
	""github.com/answerdev/answer/internal/service/uploader""
	""github.com/answerdev/answer/pkg/converter""
	""github.com/gin-gonic/gin""
	""github.com/segmentfault/pacman/log""
)
type AvatarMiddleware struct {
	serviceConfig   *service_config.ServiceConfig
	uploaderService *uploader.UploaderService
}
// NewAvatarMiddleware new auth user middleware
func NewAvatarMiddleware(serviceConfig *service_config.ServiceConfig,
	uploaderService *uploader.UploaderService,
) *AvatarMiddleware {
	return &AvatarMiddleware{
		serviceConfig:   serviceConfig,
		uploaderService: uploaderService,
	}
}
func (am *AvatarMiddleware) AvatarThumb() gin.HandlerFunc {
	return func(ctx *gin.Context) {
		u := ctx.Request.RequestURI
		if strings.Contains(u, ""/uploads/avatar/"") {
			sizeStr := ctx.Query(""s"")
			size := converter.StringToInt(sizeStr)
			uUrl, err := url.Parse(u)
			if err != nil {
				ctx.Next()
				return
			}
			_, urlfileName := filepath.Split(uUrl.Path)
			uploadPath := am.serviceConfig.UploadPath
			filePath := fmt.Sprintf(""%s/avatar/%s"", uploadPath, urlfileName)
			var avatarfile []byte
			if size == 0 {
				avatarfile, err = os.ReadFile(filePath)
			} else {
				avatarfile, err = am.uploaderService.AvatarThumbFile(ctx, uploadPath, urlfileName, size)
			}
			if err != nil {
				ctx.Next()
				return
			}
			ext := strings.ToLower(path.Ext(filePath)[1:])
			ctx.Header(""content-type"", fmt.Sprintf(""image/%s"", ext))
			_, err = ctx.Writer.WriteString(string(avatarfile))
			if err != nil {
				log.Error(err)
			}
			ctx.Abort()
			return
		} else {
			uUrl, err := url.Parse(u)
			if err != nil {
				ctx.Next()
				return
			}
			_, urlfileName := filepath.Split(uUrl.Path)
			uploadPath := am.serviceConfig.UploadPath
			filePath := fmt.Sprintf(""%s/%s"", uploadPath, urlfileName)
			ext := strings.ToLower(path.Ext(filePath)[1:])
			ctx.Header(""content-type"", fmt.Sprintf(""image/%s"", ext))
		}
		ctx.Next()
	}
}
",CWE-79,81.0,0
"package converter
import (
	""bytes""
	""github.com/asaskevich/govalidator""
	""github.com/microcosm-cc/bluemonday""
	""github.com/segmentfault/pacman/log""
	""github.com/yuin/goldmark""
	""github.com/yuin/goldmark/ast""
	""github.com/yuin/goldmark/extension""
	""github.com/yuin/goldmark/parser""
	""github.com/yuin/goldmark/renderer""
	""github.com/yuin/goldmark/renderer/html""
	goldmarkHTML ""github.com/yuin/goldmark/renderer/html""
	""github.com/yuin/goldmark/util""
)
// Markdown2HTML convert markdown to html
func Markdown2HTML(source string) string {
	mdConverter := goldmark.New(
		goldmark.WithExtensions(&DangerousHTMLFilterExtension{}, extension.GFM),
		goldmark.WithParserOptions(
			parser.WithAutoHeadingID(),
		),
		goldmark.WithRendererOptions(
			goldmarkHTML.WithHardWraps(),
		),
	)
	var buf bytes.Buffer
	if err := mdConverter.Convert([]byte(source), &buf); err != nil {
		log.Error(err)
		return source
	}
	return buf.String()
}
// Markdown2BasicHTML convert markdown to html ,Only basic syntax can be used
func Markdown2BasicHTML(source string) string {
	content := Markdown2HTML(source)
	filter := bluemonday.NewPolicy()
	filter.AllowElements(""p"", ""b"", ""br"")
	filter.AllowAttrs(""src"").OnElements(""img"")
	filter.AddSpaceWhenStrippingTag(true)
	content = filter.Sanitize(content)
	return content
}
type DangerousHTMLFilterExtension struct {
}
func (e *DangerousHTMLFilterExtension) Extend(m goldmark.Markdown) {
	m.Renderer().AddOptions(renderer.WithNodeRenderers(
		util.Prioritized(&DangerousHTMLRenderer{
			Config: goldmarkHTML.NewConfig(),
			Filter: bluemonday.UGCPolicy(),
		}, 1),
	))
}
type DangerousHTMLRenderer struct {
	goldmarkHTML.Config
	Filter *bluemonday.Policy
}
// RegisterFuncs implements renderer.NodeRenderer.RegisterFuncs.
func (r *DangerousHTMLRenderer) RegisterFuncs(reg renderer.NodeRendererFuncRegisterer) {
	reg.Register(ast.KindHTMLBlock, r.renderHTMLBlock)
	reg.Register(ast.KindRawHTML, r.renderRawHTML)
	reg.Register(ast.KindLink, r.renderLink)
	reg.Register(ast.KindAutoLink, r.renderAutoLink)
}
func (r *DangerousHTMLRenderer) renderRawHTML(w util.BufWriter, source []byte, node ast.Node, entering bool) (ast.WalkStatus, error) {
	if !entering {
		return ast.WalkSkipChildren, nil
	}
	n := node.(*ast.RawHTML)
	l := n.Segments.Len()
	for i := 0; i < l; i++ {
		segment := n.Segments.At(i)
		_, _ = w.Write(r.Filter.SanitizeBytes(segment.Value(source)))
	}
	return ast.WalkSkipChildren, nil
}
func (r *DangerousHTMLRenderer) renderHTMLBlock(w util.BufWriter, source []byte, node ast.Node, entering bool) (ast.WalkStatus, error) {
	n := node.(*ast.HTMLBlock)
	if entering {
		l := n.Lines().Len()
		for i := 0; i < l; i++ {
			line := n.Lines().At(i)
			r.Writer.SecureWrite(w, r.Filter.SanitizeBytes(line.Value(source)))
		}
	} else {
		if n.HasClosure() {
			closure := n.ClosureLine
			r.Writer.SecureWrite(w, closure.Value(source))
		}
	}
	return ast.WalkContinue, nil
}
func (r *DangerousHTMLRenderer) renderLink(w util.BufWriter, source []byte, node ast.Node, entering bool) (ast.WalkStatus, error) {
	n := node.(*ast.Link)
	if entering && r.renderLinkIsUrl(string(n.Destination)) {
		_, _ = w.WriteString(""<a href=\"""")
		if r.Unsafe || !html.IsDangerousURL(n.Destination) {
			_, _ = w.Write(util.EscapeHTML(util.URLEscape(n.Destination, true)))
		}
		_ = w.WriteByte('""')
		if n.Title != nil {
			_, _ = w.WriteString(` title=""`)
			r.Writer.Write(w, n.Title)
			_ = w.WriteByte('""')
		}
		if n.Attributes() != nil {
			html.RenderAttributes(w, n, html.LinkAttributeFilter)
		}
		_ = w.WriteByte('>')
	} else {
		_, _ = w.WriteString(""</a>"")
	}
	return ast.WalkContinue, nil
}
func (r *DangerousHTMLRenderer) renderAutoLink(w util.BufWriter, source []byte, node ast.Node, entering bool) (ast.WalkStatus, error) {
	n := node.(*ast.AutoLink)
	if !entering || !r.renderLinkIsUrl(string(n.URL(source))) {
		return ast.WalkContinue, nil
	}
	_, _ = w.WriteString(`<a href=""`)
	url := n.URL(source)
	label := n.Label(source)
	if n.AutoLinkType == ast.AutoLinkEmail && !bytes.HasPrefix(bytes.ToLower(url), []byte(""mailto:"")) {
		_, _ = w.WriteString(""mailto:"")
	}
	_, _ = w.Write(util.EscapeHTML(util.URLEscape(url, false)))
	if n.Attributes() != nil {
		_ = w.WriteByte('""')
		html.RenderAttributes(w, n, html.LinkAttributeFilter)
		_ = w.WriteByte('>')
	} else {
		_, _ = w.WriteString(`"">`)
	}
	_, _ = w.Write(util.EscapeHTML(label))
	_, _ = w.WriteString(`</a>`)
	return ast.WalkContinue, nil
}
func (r *DangerousHTMLRenderer) renderLinkIsUrl(verifyUrl string) bool {
	return govalidator.IsURL(verifyUrl)
}
",CWE-79,157.0,0
"package install
import (
	""fmt""
	""net/url""
	""strings""
	""github.com/answerdev/answer/internal/base/reason""
	""github.com/answerdev/answer/internal/base/validator""
	""github.com/answerdev/answer/pkg/checker""
	""github.com/segmentfault/pacman/errors""
	""xorm.io/xorm/schemas""
)
// CheckConfigFileResp check config file if exist or not response
type CheckConfigFileResp struct {
	ConfigFileExist     bool `json:""config_file_exist""`
	DBConnectionSuccess bool `json:""db_connection_success""`
	DbTableExist        bool `json:""db_table_exist""`
}
// CheckDatabaseReq check database
type CheckDatabaseReq struct {
	DbType     string `validate:""required,oneof=postgres sqlite3 mysql"" json:""db_type""`
	DbUsername string `json:""db_username""`
	DbPassword string `json:""db_password""`
	DbHost     string `json:""db_host""`
	DbName     string `json:""db_name""`
	DbFile     string `json:""db_file""`
}
// GetConnection get connection string
func (r *CheckDatabaseReq) GetConnection() string {
	if r.DbType == string(schemas.SQLITE) {
		return r.DbFile
	}
	if r.DbType == string(schemas.MYSQL) {
		return fmt.Sprintf(""%s:%s@tcp(%s)/%s"",
			r.DbUsername, r.DbPassword, r.DbHost, r.DbName)
	}
	if r.DbType == string(schemas.POSTGRES) {
		host, port := parsePgSQLHostPort(r.DbHost)
		return fmt.Sprintf(""host=%s port=%s user=%s password=%s dbname=%s sslmode=disable"",
			host, port, r.DbUsername, r.DbPassword, r.DbName)
	}
	return """"
}
func parsePgSQLHostPort(dbHost string) (host string, port string) {
	if strings.Contains(dbHost, "":"") {
		idx := strings.LastIndex(dbHost, "":"")
		host, port = dbHost[:idx], dbHost[idx+1:]
	} else if len(dbHost) > 0 {
		host = dbHost
	}
	if host == """" {
		host = ""127.0.0.1""
	}
	if port == """" {
		port = ""5432""
	}
	return host, port
}
// CheckDatabaseResp check database response
type CheckDatabaseResp struct {
	ConnectionSuccess bool `json:""connection_success""`
}
// InitEnvironmentResp init environment response
type InitEnvironmentResp struct {
	Success            bool   `json:""success""`
	CreateConfigFailed bool   `json:""create_config_failed""`
	DefaultConfig      string `json:""default_config""`
	ErrType            string `json:""err_type""`
}
// InitBaseInfoReq init base info request
type InitBaseInfoReq struct {
	Language      string `validate:""required,gt=0,lte=30"" json:""lang""`
	SiteName      string `validate:""required,sanitizer,gt=0,lte=30"" json:""site_name""`
	SiteURL       string `validate:""required,gt=0,lte=512,url"" json:""site_url""`
	ContactEmail  string `validate:""required,email,gt=0,lte=500"" json:""contact_email""`
	AdminName     string `validate:""required,gt=3,lte=30"" json:""name""`
	AdminPassword string `validate:""required,gte=8,lte=32"" json:""password""`
	AdminEmail    string `validate:""required,email,gt=0,lte=500"" json:""email""`
}
func (r *InitBaseInfoReq) Check() (errFields []*validator.FormErrorField, err error) {
	if checker.IsInvalidUsername(r.AdminName) {
		errField := &validator.FormErrorField{
			ErrorField: ""name"",
			ErrorMsg:   reason.UsernameInvalid,
		}
		errFields = append(errFields, errField)
		return errFields, errors.BadRequest(reason.UsernameInvalid)
	}
	return
}
func (r *InitBaseInfoReq) FormatSiteUrl() {
	parsedUrl, err := url.Parse(r.SiteURL)
	if err != nil {
		return
	}
	r.SiteURL = fmt.Sprintf(""%s://%s"", parsedUrl.Scheme, parsedUrl.Host)
}
",CWE-79,108.0,0
"package captcha
import (
	""context""
	""fmt""
	""time""
	""github.com/answerdev/answer/internal/base/data""
	""github.com/answerdev/answer/internal/base/reason""
	""github.com/answerdev/answer/internal/service/action""
	""github.com/segmentfault/pacman/errors""
	""github.com/segmentfault/pacman/log""
)
// captchaRepo captcha repository
type captchaRepo struct {
	data *data.Data
}
// NewCaptchaRepo new repository
func NewCaptchaRepo(data *data.Data) action.CaptchaRepo {
	return &captchaRepo{
		data: data,
	}
}
func (cr *captchaRepo) SetActionType(ctx context.Context, ip, actionType string, amount int) (err error) {
	cacheKey := fmt.Sprintf(""ActionRecord:%s@"", ip)
	err = cr.data.Cache.SetInt64(ctx, cacheKey, int64(amount), 6*time.Minute)
	if err != nil {
		err = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return
}
func (cr *captchaRepo) GetActionType(ctx context.Context, ip, actionType string) (amount int, err error) {
	cacheKey := fmt.Sprintf(""ActionRecord:%s@"", ip)
	res, err := cr.data.Cache.GetInt64(ctx, cacheKey)
	if err != nil {
		err = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return int(res), nil
}
func (cr *captchaRepo) DelActionType(ctx context.Context, ip, actionType string) (err error) {
	cacheKey := fmt.Sprintf(""ActionRecord:%s@"", ip)
	err = cr.data.Cache.Del(ctx, cacheKey)
	if err != nil {
		err = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return
}
// SetCaptcha set captcha to cache
func (cr *captchaRepo) SetCaptcha(ctx context.Context, key, captcha string) (err error) {
	err = cr.data.Cache.SetString(ctx, key, captcha, 6*time.Minute)
	if err != nil {
		err = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return
}
// GetCaptcha get captcha from cache
func (cr *captchaRepo) GetCaptcha(ctx context.Context, key string) (captcha string, err error) {
	captcha, err = cr.data.Cache.GetString(ctx, key)
	if err != nil {
		log.Debug(err)
	}
	return captcha, nil
}
func (cr *captchaRepo) DelCaptcha(ctx context.Context, key string) (err error) {
	err = cr.data.Cache.Del(ctx, key)
	if err != nil {
		log.Debug(err)
	}
	return nil
}
",CWE-294,79.0,0
"package captcha
import (
	""context""
	""fmt""
	""time""
	""github.com/answerdev/answer/internal/base/data""
	""github.com/answerdev/answer/internal/base/reason""
	""github.com/answerdev/answer/internal/service/action""
	""github.com/segmentfault/pacman/errors""
	""github.com/segmentfault/pacman/log""
)
// captchaRepo captcha repository
type captchaRepo struct {
	data *data.Data
}
// NewCaptchaRepo new repository
func NewCaptchaRepo(data *data.Data) action.CaptchaRepo {
	return &captchaRepo{
		data: data,
	}
}
func (cr *captchaRepo) SetActionType(ctx context.Context, ip, actionType string, amount int) (err error) {
	cacheKey := fmt.Sprintf(""ActionRecord:%s@"", ip)
	err = cr.data.Cache.SetInt64(ctx, cacheKey, int64(amount), 6*time.Minute)
	if err != nil {
		err = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return
}
func (cr *captchaRepo) GetActionType(ctx context.Context, ip, actionType string) (amount int, err error) {
	cacheKey := fmt.Sprintf(""ActionRecord:%s@"", ip)
	res, err := cr.data.Cache.GetInt64(ctx, cacheKey)
	if err != nil {
		err = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return int(res), nil
}
func (cr *captchaRepo) DelActionType(ctx context.Context, ip, actionType string) (err error) {
	cacheKey := fmt.Sprintf(""ActionRecord:%s@"", ip)
	err = cr.data.Cache.Del(ctx, cacheKey)
	if err != nil {
		err = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return
}
// SetCaptcha set captcha to cache
func (cr *captchaRepo) SetCaptcha(ctx context.Context, key, captcha string) (err error) {
	err = cr.data.Cache.SetString(ctx, key, captcha, 6*time.Minute)
	if err != nil {
		err = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return
}
// GetCaptcha get captcha from cache
func (cr *captchaRepo) GetCaptcha(ctx context.Context, key string) (captcha string, err error) {
	captcha, err = cr.data.Cache.GetString(ctx, key)
	if err != nil {
		log.Debug(err)
	}
	return captcha, nil
}
func (cr *captchaRepo) DelCaptcha(ctx context.Context, key string) (err error) {
	err = cr.data.Cache.Del(ctx, key)
	if err != nil {
		log.Debug(err)
	}
	return nil
}
",CWE-203,79.0,0
"package captcha
import (
	""context""
	""fmt""
	""time""
	""github.com/answerdev/answer/internal/base/data""
	""github.com/answerdev/answer/internal/base/reason""
	""github.com/answerdev/answer/internal/service/action""
	""github.com/segmentfault/pacman/errors""
	""github.com/segmentfault/pacman/log""
)
// captchaRepo captcha repository
type captchaRepo struct {
	data *data.Data
}
// NewCaptchaRepo new repository
func NewCaptchaRepo(data *data.Data) action.CaptchaRepo {
	return &captchaRepo{
		data: data,
	}
}
func (cr *captchaRepo) SetActionType(ctx context.Context, ip, actionType string, amount int) (err error) {
	cacheKey := fmt.Sprintf(""ActionRecord:%s@"", ip)
	err = cr.data.Cache.SetInt64(ctx, cacheKey, int64(amount), 6*time.Minute)
	if err != nil {
		err = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return
}
func (cr *captchaRepo) GetActionType(ctx context.Context, ip, actionType string) (amount int, err error) {
	cacheKey := fmt.Sprintf(""ActionRecord:%s@"", ip)
	res, err := cr.data.Cache.GetInt64(ctx, cacheKey)
	if err != nil {
		err = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return int(res), nil
}
func (cr *captchaRepo) DelActionType(ctx context.Context, ip, actionType string) (err error) {
	cacheKey := fmt.Sprintf(""ActionRecord:%s@"", ip)
	err = cr.data.Cache.Del(ctx, cacheKey)
	if err != nil {
		err = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return
}
// SetCaptcha set captcha to cache
func (cr *captchaRepo) SetCaptcha(ctx context.Context, key, captcha string) (err error) {
	err = cr.data.Cache.SetString(ctx, key, captcha, 6*time.Minute)
	if err != nil {
		err = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return
}
// GetCaptcha get captcha from cache
func (cr *captchaRepo) GetCaptcha(ctx context.Context, key string) (captcha string, err error) {
	captcha, err = cr.data.Cache.GetString(ctx, key)
	if err != nil {
		log.Debug(err)
	}
	return captcha, nil
}
func (cr *captchaRepo) DelCaptcha(ctx context.Context, key string) (err error) {
	err = cr.data.Cache.Del(ctx, key)
	if err != nil {
		log.Debug(err)
	}
	return nil
}
",CWE-307,79.0,0
"package captcha
import (
	""context""
	""fmt""
	""time""
	""github.com/answerdev/answer/internal/base/data""
	""github.com/answerdev/answer/internal/base/reason""
	""github.com/answerdev/answer/internal/service/action""
	""github.com/segmentfault/pacman/errors""
	""github.com/segmentfault/pacman/log""
)
// captchaRepo captcha repository
type captchaRepo struct {
	data *data.Data
}
// NewCaptchaRepo new repository
func NewCaptchaRepo(data *data.Data) action.CaptchaRepo {
	return &captchaRepo{
		data: data,
	}
}
func (cr *captchaRepo) SetActionType(ctx context.Context, ip, actionType string, amount int) (err error) {
	cacheKey := fmt.Sprintf(""ActionRecord:%s@"", ip)
	err = cr.data.Cache.SetInt64(ctx, cacheKey, int64(amount), 6*time.Minute)
	if err != nil {
		err = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return
}
func (cr *captchaRepo) GetActionType(ctx context.Context, ip, actionType string) (amount int, err error) {
	cacheKey := fmt.Sprintf(""ActionRecord:%s@"", ip)
	res, err := cr.data.Cache.GetInt64(ctx, cacheKey)
	if err != nil {
		err = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return int(res), nil
}
func (cr *captchaRepo) DelActionType(ctx context.Context, ip, actionType string) (err error) {
	cacheKey := fmt.Sprintf(""ActionRecord:%s@"", ip)
	err = cr.data.Cache.Del(ctx, cacheKey)
	if err != nil {
		err = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return
}
// SetCaptcha set captcha to cache
func (cr *captchaRepo) SetCaptcha(ctx context.Context, key, captcha string) (err error) {
	err = cr.data.Cache.SetString(ctx, key, captcha, 6*time.Minute)
	if err != nil {
		err = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return
}
// GetCaptcha get captcha from cache
func (cr *captchaRepo) GetCaptcha(ctx context.Context, key string) (captcha string, err error) {
	captcha, err = cr.data.Cache.GetString(ctx, key)
	if err != nil {
		log.Debug(err)
	}
	return captcha, nil
}
func (cr *captchaRepo) DelCaptcha(ctx context.Context, key string) (err error) {
	err = cr.data.Cache.Del(ctx, key)
	if err != nil {
		log.Debug(err)
	}
	return nil
}
",CWE-263,79.0,0
"package action
import (
	""context""
	""image/color""
	""strings""
	""github.com/answerdev/answer/internal/base/reason""
	""github.com/answerdev/answer/internal/schema""
	""github.com/mojocn/base64Captcha""
	""github.com/segmentfault/pacman/errors""
	""github.com/segmentfault/pacman/log""
)
// CaptchaRepo captcha repository
type CaptchaRepo interface {
	SetCaptcha(ctx context.Context, key, captcha string) (err error)
	GetCaptcha(ctx context.Context, key string) (captcha string, err error)
	DelCaptcha(ctx context.Context, key string) (err error)
	SetActionType(ctx context.Context, ip, actionType string, amount int) (err error)
	GetActionType(ctx context.Context, ip, actionType string) (amount int, err error)
	DelActionType(ctx context.Context, ip, actionType string) (err error)
}
// CaptchaService kit service
type CaptchaService struct {
	captchaRepo CaptchaRepo
}
// NewCaptchaService captcha service
func NewCaptchaService(captchaRepo CaptchaRepo) *CaptchaService {
	return &CaptchaService{
		captchaRepo: captchaRepo,
	}
}
// ActionRecord action record
func (cs *CaptchaService) ActionRecord(ctx context.Context, req *schema.ActionRecordReq) (resp *schema.ActionRecordResp, err error) {
	resp = &schema.ActionRecordResp{}
	num, err := cs.captchaRepo.GetActionType(ctx, req.IP, req.Action)
	if err != nil {
		num = 0
	}
	// TODO config num to config file
	if num >= 3 {
		resp.CaptchaID, resp.CaptchaImg, err = cs.GenerateCaptcha(ctx)
		resp.Verify = true
	}
	return
}
func (cs *CaptchaService) UserRegisterCaptcha(ctx context.Context) (resp *schema.ActionRecordResp, err error) {
	resp = &schema.ActionRecordResp{}
	resp.CaptchaID, resp.CaptchaImg, err = cs.GenerateCaptcha(ctx)
	resp.Verify = true
	return
}
func (cs *CaptchaService) UserRegisterVerifyCaptcha(
	ctx context.Context, id string, VerifyValue string,
) bool {
	if id == """" || VerifyValue == """" {
		return false
	}
	pass, err := cs.VerifyCaptcha(ctx, id, VerifyValue)
	if err != nil {
		return false
	}
	return pass
}
// ActionRecordVerifyCaptcha
// Verify that you need to enter a CAPTCHA, and that the CAPTCHA is correct
func (cs *CaptchaService) ActionRecordVerifyCaptcha(
	ctx context.Context, actionType string, ip string, id string, VerifyValue string,
) bool {
	num, cahceErr := cs.captchaRepo.GetActionType(ctx, ip, actionType)
	if cahceErr != nil {
		return true
	}
	if num >= 3 {
		if id == """" || VerifyValue == """" {
			return false
		}
		pass, err := cs.VerifyCaptcha(ctx, id, VerifyValue)
		if err != nil {
			return false
		}
		return pass
	}
	return true
}
func (cs *CaptchaService) ActionRecordAdd(ctx context.Context, actionType string, ip string) (int, error) {
	var err error
	num, cahceErr := cs.captchaRepo.GetActionType(ctx, ip, actionType)
	if cahceErr != nil {
		log.Error(err)
	}
	num++
	err = cs.captchaRepo.SetActionType(ctx, ip, actionType, num)
	if err != nil {
		return 0, err
	}
	return num, nil
}
func (cs *CaptchaService) ActionRecordDel(ctx context.Context, actionType string, ip string) {
	err := cs.captchaRepo.DelActionType(ctx, ip, actionType)
	if err != nil {
		log.Error(err)
	}
}
// GenerateCaptcha generate captcha
func (cs *CaptchaService) GenerateCaptcha(ctx context.Context) (key, captchaBase64 string, err error) {
	driverString := base64Captcha.DriverString{
		Height:          40,
		Width:           100,
		NoiseCount:      0,
		ShowLineOptions: 2 | 4,
		Length:          4,
		Source:          ""1234567890qwertyuioplkjhgfdsazxcvbnm"",
		BgColor:         &color.RGBA{R: 3, G: 102, B: 214, A: 125},
		Fonts:           []string{""wqy-microhei.ttc""},
	}
	driver := driverString.ConvertFonts()
	id, content, answer := driver.GenerateIdQuestionAnswer()
	item, err := driver.DrawCaptcha(content)
	if err != nil {
		return """", """", errors.InternalServer(reason.UnknownError).WithError(err).WithStack()
	}
	err = cs.captchaRepo.SetCaptcha(ctx, id, answer)
	if err != nil {
		return """", """", err
	}
	captchaBase64 = item.EncodeB64string()
	return id, captchaBase64, nil
}
// VerifyCaptcha generate captcha
func (cs *CaptchaService) VerifyCaptcha(ctx context.Context, key, captcha string) (isCorrect bool, err error) {
	realCaptcha, err := cs.captchaRepo.GetCaptcha(ctx, key)
	if err != nil {
		log.Error(""VerifyCaptcha GetCaptcha Error"", err.Error())
		return false, nil
	}
	err = cs.captchaRepo.DelCaptcha(ctx, key)
	if err != nil {
		log.Error(""VerifyCaptcha DelCaptcha Error"", err.Error())
		return false, nil
	}
	return strings.TrimSpace(captcha) == realCaptcha, nil
}
",CWE-294,157.0,0
"package action
import (
	""context""
	""image/color""
	""strings""
	""github.com/answerdev/answer/internal/base/reason""
	""github.com/answerdev/answer/internal/schema""
	""github.com/mojocn/base64Captcha""
	""github.com/segmentfault/pacman/errors""
	""github.com/segmentfault/pacman/log""
)
// CaptchaRepo captcha repository
type CaptchaRepo interface {
	SetCaptcha(ctx context.Context, key, captcha string) (err error)
	GetCaptcha(ctx context.Context, key string) (captcha string, err error)
	DelCaptcha(ctx context.Context, key string) (err error)
	SetActionType(ctx context.Context, ip, actionType string, amount int) (err error)
	GetActionType(ctx context.Context, ip, actionType string) (amount int, err error)
	DelActionType(ctx context.Context, ip, actionType string) (err error)
}
// CaptchaService kit service
type CaptchaService struct {
	captchaRepo CaptchaRepo
}
// NewCaptchaService captcha service
func NewCaptchaService(captchaRepo CaptchaRepo) *CaptchaService {
	return &CaptchaService{
		captchaRepo: captchaRepo,
	}
}
// ActionRecord action record
func (cs *CaptchaService) ActionRecord(ctx context.Context, req *schema.ActionRecordReq) (resp *schema.ActionRecordResp, err error) {
	resp = &schema.ActionRecordResp{}
	num, err := cs.captchaRepo.GetActionType(ctx, req.IP, req.Action)
	if err != nil {
		num = 0
	}
	// TODO config num to config file
	if num >= 3 {
		resp.CaptchaID, resp.CaptchaImg, err = cs.GenerateCaptcha(ctx)
		resp.Verify = true
	}
	return
}
func (cs *CaptchaService) UserRegisterCaptcha(ctx context.Context) (resp *schema.ActionRecordResp, err error) {
	resp = &schema.ActionRecordResp{}
	resp.CaptchaID, resp.CaptchaImg, err = cs.GenerateCaptcha(ctx)
	resp.Verify = true
	return
}
func (cs *CaptchaService) UserRegisterVerifyCaptcha(
	ctx context.Context, id string, VerifyValue string,
) bool {
	if id == """" || VerifyValue == """" {
		return false
	}
	pass, err := cs.VerifyCaptcha(ctx, id, VerifyValue)
	if err != nil {
		return false
	}
	return pass
}
// ActionRecordVerifyCaptcha
// Verify that you need to enter a CAPTCHA, and that the CAPTCHA is correct
func (cs *CaptchaService) ActionRecordVerifyCaptcha(
	ctx context.Context, actionType string, ip string, id string, VerifyValue string,
) bool {
	num, cahceErr := cs.captchaRepo.GetActionType(ctx, ip, actionType)
	if cahceErr != nil {
		return true
	}
	if num >= 3 {
		if id == """" || VerifyValue == """" {
			return false
		}
		pass, err := cs.VerifyCaptcha(ctx, id, VerifyValue)
		if err != nil {
			return false
		}
		return pass
	}
	return true
}
func (cs *CaptchaService) ActionRecordAdd(ctx context.Context, actionType string, ip string) (int, error) {
	var err error
	num, cahceErr := cs.captchaRepo.GetActionType(ctx, ip, actionType)
	if cahceErr != nil {
		log.Error(err)
	}
	num++
	err = cs.captchaRepo.SetActionType(ctx, ip, actionType, num)
	if err != nil {
		return 0, err
	}
	return num, nil
}
func (cs *CaptchaService) ActionRecordDel(ctx context.Context, actionType string, ip string) {
	err := cs.captchaRepo.DelActionType(ctx, ip, actionType)
	if err != nil {
		log.Error(err)
	}
}
// GenerateCaptcha generate captcha
func (cs *CaptchaService) GenerateCaptcha(ctx context.Context) (key, captchaBase64 string, err error) {
	driverString := base64Captcha.DriverString{
		Height:          40,
		Width:           100,
		NoiseCount:      0,
		ShowLineOptions: 2 | 4,
		Length:          4,
		Source:          ""1234567890qwertyuioplkjhgfdsazxcvbnm"",
		BgColor:         &color.RGBA{R: 3, G: 102, B: 214, A: 125},
		Fonts:           []string{""wqy-microhei.ttc""},
	}
	driver := driverString.ConvertFonts()
	id, content, answer := driver.GenerateIdQuestionAnswer()
	item, err := driver.DrawCaptcha(content)
	if err != nil {
		return """", """", errors.InternalServer(reason.UnknownError).WithError(err).WithStack()
	}
	err = cs.captchaRepo.SetCaptcha(ctx, id, answer)
	if err != nil {
		return """", """", err
	}
	captchaBase64 = item.EncodeB64string()
	return id, captchaBase64, nil
}
// VerifyCaptcha generate captcha
func (cs *CaptchaService) VerifyCaptcha(ctx context.Context, key, captcha string) (isCorrect bool, err error) {
	realCaptcha, err := cs.captchaRepo.GetCaptcha(ctx, key)
	if err != nil {
		log.Error(""VerifyCaptcha GetCaptcha Error"", err.Error())
		return false, nil
	}
	err = cs.captchaRepo.DelCaptcha(ctx, key)
	if err != nil {
		log.Error(""VerifyCaptcha DelCaptcha Error"", err.Error())
		return false, nil
	}
	return strings.TrimSpace(captcha) == realCaptcha, nil
}
",CWE-203,157.0,0
"package action
import (
	""context""
	""image/color""
	""strings""
	""github.com/answerdev/answer/internal/base/reason""
	""github.com/answerdev/answer/internal/schema""
	""github.com/mojocn/base64Captcha""
	""github.com/segmentfault/pacman/errors""
	""github.com/segmentfault/pacman/log""
)
// CaptchaRepo captcha repository
type CaptchaRepo interface {
	SetCaptcha(ctx context.Context, key, captcha string) (err error)
	GetCaptcha(ctx context.Context, key string) (captcha string, err error)
	DelCaptcha(ctx context.Context, key string) (err error)
	SetActionType(ctx context.Context, ip, actionType string, amount int) (err error)
	GetActionType(ctx context.Context, ip, actionType string) (amount int, err error)
	DelActionType(ctx context.Context, ip, actionType string) (err error)
}
// CaptchaService kit service
type CaptchaService struct {
	captchaRepo CaptchaRepo
}
// NewCaptchaService captcha service
func NewCaptchaService(captchaRepo CaptchaRepo) *CaptchaService {
	return &CaptchaService{
		captchaRepo: captchaRepo,
	}
}
// ActionRecord action record
func (cs *CaptchaService) ActionRecord(ctx context.Context, req *schema.ActionRecordReq) (resp *schema.ActionRecordResp, err error) {
	resp = &schema.ActionRecordResp{}
	num, err := cs.captchaRepo.GetActionType(ctx, req.IP, req.Action)
	if err != nil {
		num = 0
	}
	// TODO config num to config file
	if num >= 3 {
		resp.CaptchaID, resp.CaptchaImg, err = cs.GenerateCaptcha(ctx)
		resp.Verify = true
	}
	return
}
func (cs *CaptchaService) UserRegisterCaptcha(ctx context.Context) (resp *schema.ActionRecordResp, err error) {
	resp = &schema.ActionRecordResp{}
	resp.CaptchaID, resp.CaptchaImg, err = cs.GenerateCaptcha(ctx)
	resp.Verify = true
	return
}
func (cs *CaptchaService) UserRegisterVerifyCaptcha(
	ctx context.Context, id string, VerifyValue string,
) bool {
	if id == """" || VerifyValue == """" {
		return false
	}
	pass, err := cs.VerifyCaptcha(ctx, id, VerifyValue)
	if err != nil {
		return false
	}
	return pass
}
// ActionRecordVerifyCaptcha
// Verify that you need to enter a CAPTCHA, and that the CAPTCHA is correct
func (cs *CaptchaService) ActionRecordVerifyCaptcha(
	ctx context.Context, actionType string, ip string, id string, VerifyValue string,
) bool {
	num, cahceErr := cs.captchaRepo.GetActionType(ctx, ip, actionType)
	if cahceErr != nil {
		return true
	}
	if num >= 3 {
		if id == """" || VerifyValue == """" {
			return false
		}
		pass, err := cs.VerifyCaptcha(ctx, id, VerifyValue)
		if err != nil {
			return false
		}
		return pass
	}
	return true
}
func (cs *CaptchaService) ActionRecordAdd(ctx context.Context, actionType string, ip string) (int, error) {
	var err error
	num, cahceErr := cs.captchaRepo.GetActionType(ctx, ip, actionType)
	if cahceErr != nil {
		log.Error(err)
	}
	num++
	err = cs.captchaRepo.SetActionType(ctx, ip, actionType, num)
	if err != nil {
		return 0, err
	}
	return num, nil
}
func (cs *CaptchaService) ActionRecordDel(ctx context.Context, actionType string, ip string) {
	err := cs.captchaRepo.DelActionType(ctx, ip, actionType)
	if err != nil {
		log.Error(err)
	}
}
// GenerateCaptcha generate captcha
func (cs *CaptchaService) GenerateCaptcha(ctx context.Context) (key, captchaBase64 string, err error) {
	driverString := base64Captcha.DriverString{
		Height:          40,
		Width:           100,
		NoiseCount:      0,
		ShowLineOptions: 2 | 4,
		Length:          4,
		Source:          ""1234567890qwertyuioplkjhgfdsazxcvbnm"",
		BgColor:         &color.RGBA{R: 3, G: 102, B: 214, A: 125},
		Fonts:           []string{""wqy-microhei.ttc""},
	}
	driver := driverString.ConvertFonts()
	id, content, answer := driver.GenerateIdQuestionAnswer()
	item, err := driver.DrawCaptcha(content)
	if err != nil {
		return """", """", errors.InternalServer(reason.UnknownError).WithError(err).WithStack()
	}
	err = cs.captchaRepo.SetCaptcha(ctx, id, answer)
	if err != nil {
		return """", """", err
	}
	captchaBase64 = item.EncodeB64string()
	return id, captchaBase64, nil
}
// VerifyCaptcha generate captcha
func (cs *CaptchaService) VerifyCaptcha(ctx context.Context, key, captcha string) (isCorrect bool, err error) {
	realCaptcha, err := cs.captchaRepo.GetCaptcha(ctx, key)
	if err != nil {
		log.Error(""VerifyCaptcha GetCaptcha Error"", err.Error())
		return false, nil
	}
	err = cs.captchaRepo.DelCaptcha(ctx, key)
	if err != nil {
		log.Error(""VerifyCaptcha DelCaptcha Error"", err.Error())
		return false, nil
	}
	return strings.TrimSpace(captcha) == realCaptcha, nil
}
",CWE-307,157.0,0
"package action
import (
	""context""
	""image/color""
	""strings""
	""github.com/answerdev/answer/internal/base/reason""
	""github.com/answerdev/answer/internal/schema""
	""github.com/mojocn/base64Captcha""
	""github.com/segmentfault/pacman/errors""
	""github.com/segmentfault/pacman/log""
)
// CaptchaRepo captcha repository
type CaptchaRepo interface {
	SetCaptcha(ctx context.Context, key, captcha string) (err error)
	GetCaptcha(ctx context.Context, key string) (captcha string, err error)
	DelCaptcha(ctx context.Context, key string) (err error)
	SetActionType(ctx context.Context, ip, actionType string, amount int) (err error)
	GetActionType(ctx context.Context, ip, actionType string) (amount int, err error)
	DelActionType(ctx context.Context, ip, actionType string) (err error)
}
// CaptchaService kit service
type CaptchaService struct {
	captchaRepo CaptchaRepo
}
// NewCaptchaService captcha service
func NewCaptchaService(captchaRepo CaptchaRepo) *CaptchaService {
	return &CaptchaService{
		captchaRepo: captchaRepo,
	}
}
// ActionRecord action record
func (cs *CaptchaService) ActionRecord(ctx context.Context, req *schema.ActionRecordReq) (resp *schema.ActionRecordResp, err error) {
	resp = &schema.ActionRecordResp{}
	num, err := cs.captchaRepo.GetActionType(ctx, req.IP, req.Action)
	if err != nil {
		num = 0
	}
	// TODO config num to config file
	if num >= 3 {
		resp.CaptchaID, resp.CaptchaImg, err = cs.GenerateCaptcha(ctx)
		resp.Verify = true
	}
	return
}
func (cs *CaptchaService) UserRegisterCaptcha(ctx context.Context) (resp *schema.ActionRecordResp, err error) {
	resp = &schema.ActionRecordResp{}
	resp.CaptchaID, resp.CaptchaImg, err = cs.GenerateCaptcha(ctx)
	resp.Verify = true
	return
}
func (cs *CaptchaService) UserRegisterVerifyCaptcha(
	ctx context.Context, id string, VerifyValue string,
) bool {
	if id == """" || VerifyValue == """" {
		return false
	}
	pass, err := cs.VerifyCaptcha(ctx, id, VerifyValue)
	if err != nil {
		return false
	}
	return pass
}
// ActionRecordVerifyCaptcha
// Verify that you need to enter a CAPTCHA, and that the CAPTCHA is correct
func (cs *CaptchaService) ActionRecordVerifyCaptcha(
	ctx context.Context, actionType string, ip string, id string, VerifyValue string,
) bool {
	num, cahceErr := cs.captchaRepo.GetActionType(ctx, ip, actionType)
	if cahceErr != nil {
		return true
	}
	if num >= 3 {
		if id == """" || VerifyValue == """" {
			return false
		}
		pass, err := cs.VerifyCaptcha(ctx, id, VerifyValue)
		if err != nil {
			return false
		}
		return pass
	}
	return true
}
func (cs *CaptchaService) ActionRecordAdd(ctx context.Context, actionType string, ip string) (int, error) {
	var err error
	num, cahceErr := cs.captchaRepo.GetActionType(ctx, ip, actionType)
	if cahceErr != nil {
		log.Error(err)
	}
	num++
	err = cs.captchaRepo.SetActionType(ctx, ip, actionType, num)
	if err != nil {
		return 0, err
	}
	return num, nil
}
func (cs *CaptchaService) ActionRecordDel(ctx context.Context, actionType string, ip string) {
	err := cs.captchaRepo.DelActionType(ctx, ip, actionType)
	if err != nil {
		log.Error(err)
	}
}
// GenerateCaptcha generate captcha
func (cs *CaptchaService) GenerateCaptcha(ctx context.Context) (key, captchaBase64 string, err error) {
	driverString := base64Captcha.DriverString{
		Height:          40,
		Width:           100,
		NoiseCount:      0,
		ShowLineOptions: 2 | 4,
		Length:          4,
		Source:          ""1234567890qwertyuioplkjhgfdsazxcvbnm"",
		BgColor:         &color.RGBA{R: 3, G: 102, B: 214, A: 125},
		Fonts:           []string{""wqy-microhei.ttc""},
	}
	driver := driverString.ConvertFonts()
	id, content, answer := driver.GenerateIdQuestionAnswer()
	item, err := driver.DrawCaptcha(content)
	if err != nil {
		return """", """", errors.InternalServer(reason.UnknownError).WithError(err).WithStack()
	}
	err = cs.captchaRepo.SetCaptcha(ctx, id, answer)
	if err != nil {
		return """", """", err
	}
	captchaBase64 = item.EncodeB64string()
	return id, captchaBase64, nil
}
// VerifyCaptcha generate captcha
func (cs *CaptchaService) VerifyCaptcha(ctx context.Context, key, captcha string) (isCorrect bool, err error) {
	realCaptcha, err := cs.captchaRepo.GetCaptcha(ctx, key)
	if err != nil {
		log.Error(""VerifyCaptcha GetCaptcha Error"", err.Error())
		return false, nil
	}
	err = cs.captchaRepo.DelCaptcha(ctx, key)
	if err != nil {
		log.Error(""VerifyCaptcha DelCaptcha Error"", err.Error())
		return false, nil
	}
	return strings.TrimSpace(captcha) == realCaptcha, nil
}
",CWE-263,157.0,0
"package converter
import (
	""bytes""
	""github.com/asaskevich/govalidator""
	""github.com/microcosm-cc/bluemonday""
	""github.com/segmentfault/pacman/log""
	""github.com/yuin/goldmark""
	""github.com/yuin/goldmark/ast""
	""github.com/yuin/goldmark/extension""
	""github.com/yuin/goldmark/parser""
	""github.com/yuin/goldmark/renderer""
	""github.com/yuin/goldmark/renderer/html""
	goldmarkHTML ""github.com/yuin/goldmark/renderer/html""
	""github.com/yuin/goldmark/util""
)
// Markdown2HTML convert markdown to html
func Markdown2HTML(source string) string {
	mdConverter := goldmark.New(
		goldmark.WithExtensions(&DangerousHTMLFilterExtension{}, extension.GFM),
		goldmark.WithParserOptions(
			parser.WithAutoHeadingID(),
		),
		goldmark.WithRendererOptions(
			goldmarkHTML.WithHardWraps(),
		),
	)
	var buf bytes.Buffer
	if err := mdConverter.Convert([]byte(source), &buf); err != nil {
		log.Error(err)
		return source
	}
	html := buf.String()
	filter := bluemonday.NewPolicy()
	html = filter.Sanitize(html)
	return html
}
// Markdown2BasicHTML convert markdown to html ,Only basic syntax can be used
func Markdown2BasicHTML(source string) string {
	content := Markdown2HTML(source)
	filter := bluemonday.NewPolicy()
	filter.AllowElements(""p"", ""b"", ""br"")
	filter.AllowAttrs(""src"").OnElements(""img"")
	filter.AddSpaceWhenStrippingTag(true)
	content = filter.Sanitize(content)
	return content
}
type DangerousHTMLFilterExtension struct {
}
func (e *DangerousHTMLFilterExtension) Extend(m goldmark.Markdown) {
	m.Renderer().AddOptions(renderer.WithNodeRenderers(
		util.Prioritized(&DangerousHTMLRenderer{
			Config: goldmarkHTML.NewConfig(),
			Filter: bluemonday.UGCPolicy(),
		}, 1),
	))
}
type DangerousHTMLRenderer struct {
	goldmarkHTML.Config
	Filter *bluemonday.Policy
}
// RegisterFuncs implements renderer.NodeRenderer.RegisterFuncs.
func (r *DangerousHTMLRenderer) RegisterFuncs(reg renderer.NodeRendererFuncRegisterer) {
	reg.Register(ast.KindHTMLBlock, r.renderHTMLBlock)
	reg.Register(ast.KindRawHTML, r.renderRawHTML)
	reg.Register(ast.KindLink, r.renderLink)
	reg.Register(ast.KindAutoLink, r.renderAutoLink)
}
func (r *DangerousHTMLRenderer) renderRawHTML(w util.BufWriter, source []byte, node ast.Node, entering bool) (ast.WalkStatus, error) {
	if !entering {
		return ast.WalkSkipChildren, nil
	}
	n := node.(*ast.RawHTML)
	l := n.Segments.Len()
	for i := 0; i < l; i++ {
		segment := n.Segments.At(i)
		_, _ = w.Write(r.Filter.SanitizeBytes(segment.Value(source)))
	}
	return ast.WalkSkipChildren, nil
}
func (r *DangerousHTMLRenderer) renderHTMLBlock(w util.BufWriter, source []byte, node ast.Node, entering bool) (ast.WalkStatus, error) {
	n := node.(*ast.HTMLBlock)
	if entering {
		l := n.Lines().Len()
		for i := 0; i < l; i++ {
			line := n.Lines().At(i)
			r.Writer.SecureWrite(w, r.Filter.SanitizeBytes(line.Value(source)))
		}
	} else {
		if n.HasClosure() {
			closure := n.ClosureLine
			r.Writer.SecureWrite(w, closure.Value(source))
		}
	}
	return ast.WalkContinue, nil
}
func (r *DangerousHTMLRenderer) renderLink(w util.BufWriter, source []byte, node ast.Node, entering bool) (ast.WalkStatus, error) {
	n := node.(*ast.Link)
	if entering && r.renderLinkIsUrl(string(n.Destination)) {
		_, _ = w.WriteString(""<a href=\"""")
		if r.Unsafe || !html.IsDangerousURL(n.Destination) {
			_, _ = w.Write(util.EscapeHTML(util.URLEscape(n.Destination, true)))
		}
		_ = w.WriteByte('""')
		if n.Title != nil {
			_, _ = w.WriteString(` title=""`)
			r.Writer.Write(w, n.Title)
			_ = w.WriteByte('""')
		}
		if n.Attributes() != nil {
			html.RenderAttributes(w, n, html.LinkAttributeFilter)
		}
		_ = w.WriteByte('>')
	} else {
		_, _ = w.WriteString(""</a>"")
	}
	return ast.WalkContinue, nil
}
func (r *DangerousHTMLRenderer) renderAutoLink(w util.BufWriter, source []byte, node ast.Node, entering bool) (ast.WalkStatus, error) {
	n := node.(*ast.AutoLink)
	if !entering || !r.renderLinkIsUrl(string(n.URL(source))) {
		return ast.WalkContinue, nil
	}
	_, _ = w.WriteString(`<a href=""`)
	url := n.URL(source)
	label := n.Label(source)
	if n.AutoLinkType == ast.AutoLinkEmail && !bytes.HasPrefix(bytes.ToLower(url), []byte(""mailto:"")) {
		_, _ = w.WriteString(""mailto:"")
	}
	_, _ = w.Write(util.EscapeHTML(util.URLEscape(url, false)))
	if n.Attributes() != nil {
		_ = w.WriteByte('""')
		html.RenderAttributes(w, n, html.LinkAttributeFilter)
		_ = w.WriteByte('>')
	} else {
		_, _ = w.WriteString(`"">`)
	}
	_, _ = w.Write(util.EscapeHTML(label))
	_, _ = w.WriteString(`</a>`)
	return ast.WalkContinue, nil
}
func (r *DangerousHTMLRenderer) renderLinkIsUrl(verifyUrl string) bool {
	return govalidator.IsURL(verifyUrl)
}
",CWE-79,160.0,0
"module github.com/answerdev/answer
go 1.18
require (
	github.com/Chain-Zhang/pinyin v0.1.3
	github.com/anargu/gin-brotli v0.0.0-20220116052358-12bf532d5267
	github.com/asaskevich/govalidator v0.0.0-20210307081110-f21760c49a8d
	github.com/bwmarrin/snowflake v0.3.0
	github.com/davecgh/go-spew v1.1.1
	github.com/disintegration/imaging v1.6.2
	github.com/gin-gonic/gin v1.8.1
	github.com/go-playground/locales v0.14.0
	github.com/go-playground/universal-translator v0.18.0
	github.com/go-playground/validator/v10 v10.11.1
	github.com/go-sql-driver/mysql v1.6.0
	github.com/goccy/go-json v0.9.11
	github.com/golang/mock v1.6.0
	github.com/google/uuid v1.3.0
	github.com/google/wire v0.5.0
	github.com/gosimple/slug v1.13.1
	github.com/grokify/html-strip-tags-go v0.0.1
	github.com/jinzhu/copier v0.3.5
	github.com/jinzhu/now v1.1.5
	github.com/lib/pq v1.10.7
	github.com/microcosm-cc/bluemonday v1.0.21
	github.com/mojocn/base64Captcha v1.3.5
	github.com/ory/dockertest/v3 v3.9.1
	github.com/robfig/cron/v3 v3.0.1
	github.com/scottleedavis/go-exif-remove v0.0.0-20230314195146-7e059d593405
	github.com/segmentfault/pacman v1.0.3
	github.com/segmentfault/pacman/contrib/cache/memory v0.0.0-20221219081300-f734f4a16aa0
	github.com/segmentfault/pacman/contrib/conf/viper v0.0.0-20221018072427-a15dd1434e05
	github.com/segmentfault/pacman/contrib/i18n v0.0.0-20221219081300-f734f4a16aa0
	github.com/segmentfault/pacman/contrib/log/zap v0.0.0-20221018072427-a15dd1434e05
	github.com/segmentfault/pacman/contrib/server/http v0.0.0-20221018072427-a15dd1434e05
	github.com/spf13/cobra v1.6.1
	github.com/stretchr/testify v1.8.1
	github.com/swaggo/files v1.0.0
	github.com/swaggo/gin-swagger v1.5.3
	github.com/swaggo/swag v1.8.10
	github.com/tidwall/gjson v1.14.4
	github.com/yuin/goldmark v1.4.13
	golang.org/x/crypto v0.1.0
	golang.org/x/net v0.7.0
	gopkg.in/gomail.v2 v2.0.0-20160411212932-81ebce5c23df
	gopkg.in/yaml.v3 v3.0.1
	modernc.org/sqlite v1.14.2
	xorm.io/builder v0.3.12
	xorm.io/core v0.7.3
	xorm.io/xorm v1.3.2
)
require (
	github.com/Azure/go-ansiterm v0.0.0-20170929234023-d6e3b3328b78 // indirect
	github.com/KyleBanks/depth v1.2.1 // indirect
	github.com/LinkinStars/go-i18n/v2 v2.2.2 // indirect
	github.com/Microsoft/go-winio v0.5.2 // indirect
	github.com/Nvveen/Gotty v0.0.0-20120604004816-cd527374f1e5 // indirect
	github.com/andybalholm/brotli v1.0.4 // indirect
	github.com/aymerick/douceur v0.2.0 // indirect
	github.com/cenkalti/backoff/v4 v4.1.3 // indirect
	github.com/containerd/continuity v0.3.0 // indirect
	github.com/docker/cli v20.10.14+incompatible // indirect
	github.com/docker/docker v20.10.7+incompatible // indirect
	github.com/docker/go-connections v0.4.0 // indirect
	github.com/docker/go-units v0.4.0 // indirect
	github.com/dsoprea/go-exif v0.0.0-20190901173045-3ce78807c90f // indirect
	github.com/dsoprea/go-jpeg-image-structure v0.0.0-20190422055009-d6f9ba25cf48 // indirect
	github.com/dsoprea/go-logging v0.0.0-20190624164917-c4f10aab7696 // indirect
	github.com/dsoprea/go-png-image-structure v0.0.0-20190624104353-c9b28dcdc5c8 // indirect
	github.com/fsnotify/fsnotify v1.6.0 // indirect
	github.com/gin-contrib/sse v0.1.0 // indirect
	github.com/go-errors/errors v1.0.1 // indirect
	github.com/go-openapi/jsonpointer v0.19.5 // indirect
	github.com/go-openapi/jsonreference v0.20.0 // indirect
	github.com/go-openapi/spec v0.20.7 // indirect
	github.com/go-openapi/swag v0.22.3 // indirect
	github.com/gogo/protobuf v1.3.2 // indirect
	github.com/golang/freetype v0.0.0-20170609003504-e2365dfdc4a0 // indirect
	github.com/golang/geo v0.0.0-20190812012225-f41920e961ce // indirect
	github.com/golang/snappy v0.0.4 // indirect
	github.com/google/shlex v0.0.0-20191202100458-e7afc7fbc510 // indirect
	github.com/gorilla/css v1.0.0 // indirect
	github.com/gosimple/unidecode v1.0.1 // indirect
	github.com/hashicorp/hcl v1.0.0 // indirect
	github.com/imdario/mergo v0.3.12 // indirect
	github.com/inconshreveable/mousetrap v1.0.1 // indirect
	github.com/josharian/intern v1.0.0 // indirect
	github.com/json-iterator/go v1.1.12 // indirect
	github.com/kballard/go-shellquote v0.0.0-20180428030007-95032a82bc51 // indirect
	github.com/leodido/go-urn v1.2.1 // indirect
	github.com/lestrrat-go/file-rotatelogs v2.4.0+incompatible // indirect
	github.com/lestrrat-go/strftime v1.0.6 // indirect
	github.com/magiconair/properties v1.8.6 // indirect
	github.com/mailru/easyjson v0.7.7 // indirect
	github.com/mattn/go-isatty v0.0.16 // indirect
	github.com/mattn/go-sqlite3 v1.14.16 // indirect
	github.com/mitchellh/mapstructure v1.5.0 // indirect
	github.com/moby/term v0.0.0-20201216013528-df9cb8a40635 // indirect
	github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect
	github.com/modern-go/reflect2 v1.0.2 // indirect
	github.com/opencontainers/go-digest v1.0.0 // indirect
	github.com/opencontainers/image-spec v1.0.2 // indirect
	github.com/opencontainers/runc v1.1.2 // indirect
	github.com/patrickmn/go-cache v2.1.0+incompatible // indirect
	github.com/pelletier/go-toml v1.9.5 // indirect
	github.com/pelletier/go-toml/v2 v2.0.5 // indirect
	github.com/pkg/errors v0.9.1 // indirect
	github.com/pmezard/go-difflib v1.0.0 // indirect
	github.com/remyoudompheng/bigfft v0.0.0-20200410134404-eec4a21b6bb0 // indirect
	github.com/sirupsen/logrus v1.8.1 // indirect
	github.com/spf13/afero v1.9.2 // indirect
	github.com/spf13/cast v1.5.0 // indirect
	github.com/spf13/jwalterweatherman v1.1.0 // indirect
	github.com/spf13/pflag v1.0.5 // indirect
	github.com/spf13/viper v1.13.0 // indirect
	github.com/subosito/gotenv v1.4.1 // indirect
	github.com/syndtr/goleveldb v1.0.0 // indirect
	github.com/tidwall/match v1.1.1 // indirect
	github.com/tidwall/pretty v1.2.0 // indirect
	github.com/ugorji/go/codec v1.2.7 // indirect
	github.com/xeipuuv/gojsonpointer v0.0.0-20180127040702-4e3ac2762d5f // indirect
	github.com/xeipuuv/gojsonreference v0.0.0-20180127040603-bd5ef7bd5415 // indirect
	github.com/xeipuuv/gojsonschema v1.2.0 // indirect
	go.uber.org/atomic v1.10.0 // indirect
	go.uber.org/multierr v1.8.0 // indirect
	go.uber.org/zap v1.23.0 // indirect
	golang.org/x/image v0.1.0 // indirect
	golang.org/x/mod v0.6.0 // indirect
	golang.org/x/sys v0.5.0 // indirect
	golang.org/x/text v0.7.0 // indirect
	golang.org/x/tools v0.2.0 // indirect
	google.golang.org/protobuf v1.28.1 // indirect
	gopkg.in/alexcesaro/quotedprintable.v3 v3.0.0-20150716171945-2caba252f4dc // indirect
	gopkg.in/ini.v1 v1.67.0 // indirect
	gopkg.in/yaml.v2 v2.4.0 // indirect
	lukechampine.com/uint128 v1.1.1 // indirect
	modernc.org/cc/v3 v3.35.18 // indirect
	modernc.org/ccgo/v3 v3.12.82 // indirect
	modernc.org/libc v1.11.87 // indirect
	modernc.org/mathutil v1.4.1 // indirect
	modernc.org/memory v1.0.5 // indirect
	modernc.org/opt v0.1.1 // indirect
	modernc.org/strutil v1.1.1 // indirect
	modernc.org/token v1.0.0 // indirect
	sigs.k8s.io/yaml v1.3.0 // indirect
)
",CWE-1230,149.0,0
"module github.com/answerdev/answer
go 1.18
require (
	github.com/Chain-Zhang/pinyin v0.1.3
	github.com/anargu/gin-brotli v0.0.0-20220116052358-12bf532d5267
	github.com/asaskevich/govalidator v0.0.0-20210307081110-f21760c49a8d
	github.com/bwmarrin/snowflake v0.3.0
	github.com/davecgh/go-spew v1.1.1
	github.com/disintegration/imaging v1.6.2
	github.com/gin-gonic/gin v1.8.1
	github.com/go-playground/locales v0.14.0
	github.com/go-playground/universal-translator v0.18.0
	github.com/go-playground/validator/v10 v10.11.1
	github.com/go-sql-driver/mysql v1.6.0
	github.com/goccy/go-json v0.9.11
	github.com/golang/mock v1.6.0
	github.com/google/uuid v1.3.0
	github.com/google/wire v0.5.0
	github.com/gosimple/slug v1.13.1
	github.com/grokify/html-strip-tags-go v0.0.1
	github.com/jinzhu/copier v0.3.5
	github.com/jinzhu/now v1.1.5
	github.com/lib/pq v1.10.7
	github.com/microcosm-cc/bluemonday v1.0.21
	github.com/mojocn/base64Captcha v1.3.5
	github.com/ory/dockertest/v3 v3.9.1
	github.com/robfig/cron/v3 v3.0.1
	github.com/scottleedavis/go-exif-remove v0.0.0-20230314195146-7e059d593405
	github.com/segmentfault/pacman v1.0.3
	github.com/segmentfault/pacman/contrib/cache/memory v0.0.0-20221219081300-f734f4a16aa0
	github.com/segmentfault/pacman/contrib/conf/viper v0.0.0-20221018072427-a15dd1434e05
	github.com/segmentfault/pacman/contrib/i18n v0.0.0-20221219081300-f734f4a16aa0
	github.com/segmentfault/pacman/contrib/log/zap v0.0.0-20221018072427-a15dd1434e05
	github.com/segmentfault/pacman/contrib/server/http v0.0.0-20221018072427-a15dd1434e05
	github.com/spf13/cobra v1.6.1
	github.com/stretchr/testify v1.8.1
	github.com/swaggo/files v1.0.0
	github.com/swaggo/gin-swagger v1.5.3
	github.com/swaggo/swag v1.8.10
	github.com/tidwall/gjson v1.14.4
	github.com/yuin/goldmark v1.4.13
	golang.org/x/crypto v0.1.0
	golang.org/x/net v0.7.0
	gopkg.in/gomail.v2 v2.0.0-20160411212932-81ebce5c23df
	gopkg.in/yaml.v3 v3.0.1
	modernc.org/sqlite v1.14.2
	xorm.io/builder v0.3.12
	xorm.io/core v0.7.3
	xorm.io/xorm v1.3.2
)
require (
	github.com/Azure/go-ansiterm v0.0.0-20170929234023-d6e3b3328b78 // indirect
	github.com/KyleBanks/depth v1.2.1 // indirect
	github.com/LinkinStars/go-i18n/v2 v2.2.2 // indirect
	github.com/Microsoft/go-winio v0.5.2 // indirect
	github.com/Nvveen/Gotty v0.0.0-20120604004816-cd527374f1e5 // indirect
	github.com/andybalholm/brotli v1.0.4 // indirect
	github.com/aymerick/douceur v0.2.0 // indirect
	github.com/cenkalti/backoff/v4 v4.1.3 // indirect
	github.com/containerd/continuity v0.3.0 // indirect
	github.com/docker/cli v20.10.14+incompatible // indirect
	github.com/docker/docker v20.10.7+incompatible // indirect
	github.com/docker/go-connections v0.4.0 // indirect
	github.com/docker/go-units v0.4.0 // indirect
	github.com/dsoprea/go-exif v0.0.0-20190901173045-3ce78807c90f // indirect
	github.com/dsoprea/go-jpeg-image-structure v0.0.0-20190422055009-d6f9ba25cf48 // indirect
	github.com/dsoprea/go-logging v0.0.0-20190624164917-c4f10aab7696 // indirect
	github.com/dsoprea/go-png-image-structure v0.0.0-20190624104353-c9b28dcdc5c8 // indirect
	github.com/fsnotify/fsnotify v1.6.0 // indirect
	github.com/gin-contrib/sse v0.1.0 // indirect
	github.com/go-errors/errors v1.0.1 // indirect
	github.com/go-openapi/jsonpointer v0.19.5 // indirect
	github.com/go-openapi/jsonreference v0.20.0 // indirect
	github.com/go-openapi/spec v0.20.7 // indirect
	github.com/go-openapi/swag v0.22.3 // indirect
	github.com/gogo/protobuf v1.3.2 // indirect
	github.com/golang/freetype v0.0.0-20170609003504-e2365dfdc4a0 // indirect
	github.com/golang/geo v0.0.0-20190812012225-f41920e961ce // indirect
	github.com/golang/snappy v0.0.4 // indirect
	github.com/google/shlex v0.0.0-20191202100458-e7afc7fbc510 // indirect
	github.com/gorilla/css v1.0.0 // indirect
	github.com/gosimple/unidecode v1.0.1 // indirect
	github.com/hashicorp/hcl v1.0.0 // indirect
	github.com/imdario/mergo v0.3.12 // indirect
	github.com/inconshreveable/mousetrap v1.0.1 // indirect
	github.com/josharian/intern v1.0.0 // indirect
	github.com/json-iterator/go v1.1.12 // indirect
	github.com/kballard/go-shellquote v0.0.0-20180428030007-95032a82bc51 // indirect
	github.com/leodido/go-urn v1.2.1 // indirect
	github.com/lestrrat-go/file-rotatelogs v2.4.0+incompatible // indirect
	github.com/lestrrat-go/strftime v1.0.6 // indirect
	github.com/magiconair/properties v1.8.6 // indirect
	github.com/mailru/easyjson v0.7.7 // indirect
	github.com/mattn/go-isatty v0.0.16 // indirect
	github.com/mattn/go-sqlite3 v1.14.16 // indirect
	github.com/mitchellh/mapstructure v1.5.0 // indirect
	github.com/moby/term v0.0.0-20201216013528-df9cb8a40635 // indirect
	github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect
	github.com/modern-go/reflect2 v1.0.2 // indirect
	github.com/opencontainers/go-digest v1.0.0 // indirect
	github.com/opencontainers/image-spec v1.0.2 // indirect
	github.com/opencontainers/runc v1.1.2 // indirect
	github.com/patrickmn/go-cache v2.1.0+incompatible // indirect
	github.com/pelletier/go-toml v1.9.5 // indirect
	github.com/pelletier/go-toml/v2 v2.0.5 // indirect
	github.com/pkg/errors v0.9.1 // indirect
	github.com/pmezard/go-difflib v1.0.0 // indirect
	github.com/remyoudompheng/bigfft v0.0.0-20200410134404-eec4a21b6bb0 // indirect
	github.com/sirupsen/logrus v1.8.1 // indirect
	github.com/spf13/afero v1.9.2 // indirect
	github.com/spf13/cast v1.5.0 // indirect
	github.com/spf13/jwalterweatherman v1.1.0 // indirect
	github.com/spf13/pflag v1.0.5 // indirect
	github.com/spf13/viper v1.13.0 // indirect
	github.com/subosito/gotenv v1.4.1 // indirect
	github.com/syndtr/goleveldb v1.0.0 // indirect
	github.com/tidwall/match v1.1.1 // indirect
	github.com/tidwall/pretty v1.2.0 // indirect
	github.com/ugorji/go/codec v1.2.7 // indirect
	github.com/xeipuuv/gojsonpointer v0.0.0-20180127040702-4e3ac2762d5f // indirect
	github.com/xeipuuv/gojsonreference v0.0.0-20180127040603-bd5ef7bd5415 // indirect
	github.com/xeipuuv/gojsonschema v1.2.0 // indirect
	go.uber.org/atomic v1.10.0 // indirect
	go.uber.org/multierr v1.8.0 // indirect
	go.uber.org/zap v1.23.0 // indirect
	golang.org/x/image v0.1.0 // indirect
	golang.org/x/mod v0.6.0 // indirect
	golang.org/x/sys v0.5.0 // indirect
	golang.org/x/text v0.7.0 // indirect
	golang.org/x/tools v0.2.0 // indirect
	google.golang.org/protobuf v1.28.1 // indirect
	gopkg.in/alexcesaro/quotedprintable.v3 v3.0.0-20150716171945-2caba252f4dc // indirect
	gopkg.in/ini.v1 v1.67.0 // indirect
	gopkg.in/yaml.v2 v2.4.0 // indirect
	lukechampine.com/uint128 v1.1.1 // indirect
	modernc.org/cc/v3 v3.35.18 // indirect
	modernc.org/ccgo/v3 v3.12.82 // indirect
	modernc.org/libc v1.11.87 // indirect
	modernc.org/mathutil v1.4.1 // indirect
	modernc.org/memory v1.0.5 // indirect
	modernc.org/opt v0.1.1 // indirect
	modernc.org/strutil v1.1.1 // indirect
	modernc.org/token v1.0.0 // indirect
	sigs.k8s.io/yaml v1.3.0 // indirect
)
",CWE-201,149.0,0
"package migrations
import (
	""context""
	""fmt""
	""github.com/answerdev/answer/internal/base/data""
	""github.com/answerdev/answer/internal/entity""
	""xorm.io/xorm""
)
const minDBVersion = 0 // answer 1.0.0
// Migration describes on migration from lower version to high version
type Migration interface {
	Description() string
	Migrate(*xorm.Engine) error
	ShouldCleanCache() bool
}
type migration struct {
	description      string
	migrate          func(*xorm.Engine) error
	shouldCleanCache bool
}
// Description returns the migration's description
func (m *migration) Description() string {
	return m.description
}
// Migrate executes the migration
func (m *migration) Migrate(x *xorm.Engine) error {
	return m.migrate(x)
}
// ShouldCleanCache should clean the cache
func (m *migration) ShouldCleanCache() bool {
	return m.shouldCleanCache
}
// NewMigration creates a new migration
func NewMigration(desc string, fn func(*xorm.Engine) error, shouldCleanCache bool) Migration {
	return &migration{description: desc, migrate: fn, shouldCleanCache: shouldCleanCache}
}
// Use noopMigration when there is a migration that has been no-oped
var noopMigration = func(_ *xorm.Engine) error { return nil }
var migrations = []Migration{
	// 0->1
	NewMigration(""this is first version, no operation"", noopMigration, false),
	NewMigration(""add user language"", addUserLanguage, false),
	NewMigration(""add recommend and reserved tag fields"", addTagRecommendedAndReserved, false),
	NewMigration(""add activity timeline"", addActivityTimeline, false),
	NewMigration(""add user role"", addRoleFeatures, false),
	NewMigration(""add theme and private mode"", addThemeAndPrivateMode, true),
	NewMigration(""add new answer notification"", addNewAnswerNotification, true),
	NewMigration(""add user pin hide features"", addRolePinAndHideFeatures, true),
	NewMigration(""update accept answer rank"", updateAcceptAnswerRank, true),
}
// GetCurrentDBVersion returns the current db version
func GetCurrentDBVersion(engine *xorm.Engine) (int64, error) {
	if err := engine.Sync(new(entity.Version)); err != nil {
		return -1, fmt.Errorf(""sync version failed: %v"", err)
	}
	currentVersion := &entity.Version{ID: 1}
	has, err := engine.Get(currentVersion)
	if err != nil {
		return -1, fmt.Errorf(""get first version failed: %v"", err)
	}
	if !has {
		_, err := engine.InsertOne(&entity.Version{ID: 1, VersionNumber: 0})
		if err != nil {
			return -1, fmt.Errorf(""insert first version failed: %v"", err)
		}
		return 0, nil
	}
	return currentVersion.VersionNumber, nil
}
// ExpectedVersion returns the expected db version
func ExpectedVersion() int64 {
	return int64(minDBVersion + len(migrations))
}
// Migrate database to current version
func Migrate(dbConf *data.Database, cacheConf *data.CacheConf) error {
	cache, cacheCleanup, err := data.NewCache(cacheConf)
	if err != nil {
		fmt.Println(""new check failed:"", err.Error())
	}
	engine, err := data.NewDB(false, dbConf)
	if err != nil {
		fmt.Println(""new database failed: "", err.Error())
		return err
	}
	currentDBVersion, err := GetCurrentDBVersion(engine)
	if err != nil {
		return err
	}
	expectedVersion := ExpectedVersion()
	for currentDBVersion < expectedVersion {
		fmt.Printf(""[migrate] current db version is %d, try to migrate version %d, latest version is %d\n"",
			currentDBVersion, currentDBVersion+1, expectedVersion)
		migrationFunc := migrations[currentDBVersion]
		fmt.Printf(""[migrate] try to migrate db version %d, description: %s\n"", currentDBVersion+1, migrationFunc.Description())
		if err := migrationFunc.Migrate(engine); err != nil {
			fmt.Printf(""[migrate] migrate to db version %d failed: %s\n"", currentDBVersion+1, err.Error())
			return err
		}
		if migrationFunc.ShouldCleanCache() {
			if err := cache.Flush(context.Background()); err != nil {
				fmt.Printf(""[migrate] flush cache failed: %s\n"", err.Error())
			}
		}
		fmt.Printf(""[migrate] migrate to db version %d success\n"", currentDBVersion+1)
		if _, err := engine.Update(&entity.Version{ID: 1, VersionNumber: currentDBVersion + 1}); err != nil {
			fmt.Printf(""[migrate] migrate to db version %d, update failed: %s"", currentDBVersion+1, err.Error())
			return err
		}
		currentDBVersion++
	}
	if cache != nil {
		cacheCleanup()
	}
	return nil
}
",CWE-862,133.0,0
"package migrations
import (
	""fmt""
	""github.com/answerdev/answer/internal/entity""
	""github.com/segmentfault/pacman/log""
	""xorm.io/xorm""
)
func updateAcceptAnswerRank(x *xorm.Engine) error {
	c := &entity.Config{ID: 44, Key: ""rank.answer.accept"", Value: `-1`}
	if _, err := x.Update(c, &entity.Config{ID: 44, Key: ""rank.answer.accept""}); err != nil {
		log.Errorf(""update %+v config failed: %s"", c, err)
		return fmt.Errorf(""update config failed: %w"", err)
	}
	return nil
}
",CWE-862,19.0,0
"package auth
import (
	""context""
	""encoding/json""
	""github.com/answerdev/answer/internal/base/constant""
	""github.com/answerdev/answer/internal/base/data""
	""github.com/answerdev/answer/internal/base/reason""
	""github.com/answerdev/answer/internal/entity""
	""github.com/answerdev/answer/internal/service/auth""
	""github.com/segmentfault/pacman/errors""
	""github.com/segmentfault/pacman/log""
)
// authRepo auth repository
type authRepo struct {
	data *data.Data
}
// GetUserCacheInfo get user cache info
func (ar *authRepo) GetUserCacheInfo(ctx context.Context, accessToken string) (userInfo *entity.UserCacheInfo, err error) {
	userInfoCache, err := ar.data.Cache.GetString(ctx, constant.UserTokenCacheKey+accessToken)
	if err != nil {
		return nil, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	userInfo = &entity.UserCacheInfo{}
	err = json.Unmarshal([]byte(userInfoCache), userInfo)
	if err != nil {
		return nil, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return userInfo, nil
}
// SetUserCacheInfo set user cache info
func (ar *authRepo) SetUserCacheInfo(ctx context.Context, accessToken string, userInfo *entity.UserCacheInfo) (err error) {
	userInfoCache, err := json.Marshal(userInfo)
	if err != nil {
		return err
	}
	err = ar.data.Cache.SetString(ctx, constant.UserTokenCacheKey+accessToken,
		string(userInfoCache), constant.UserTokenCacheTime)
	if err != nil {
		return errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	if err := ar.AddUserTokenMapping(ctx, userInfo.UserID, accessToken); err != nil {
		log.Error(err)
	}
	return nil
}
// RemoveUserCacheInfo remove user cache info
func (ar *authRepo) RemoveUserCacheInfo(ctx context.Context, accessToken string) (err error) {
	err = ar.data.Cache.Del(ctx, constant.UserTokenCacheKey+accessToken)
	if err != nil {
		return errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return nil
}
// SetUserStatus set user status
func (ar *authRepo) SetUserStatus(ctx context.Context, userID string, userInfo *entity.UserCacheInfo) (err error) {
	userInfoCache, err := json.Marshal(userInfo)
	if err != nil {
		return err
	}
	err = ar.data.Cache.SetString(ctx, constant.UserStatusChangedCacheKey+userID,
		string(userInfoCache), constant.UserStatusChangedCacheTime)
	if err != nil {
		return errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return nil
}
// GetUserStatus get user status
func (ar *authRepo) GetUserStatus(ctx context.Context, userID string) (userInfo *entity.UserCacheInfo, err error) {
	userInfoCache, err := ar.data.Cache.GetString(ctx, constant.UserStatusChangedCacheKey+userID)
	if err != nil {
		return nil, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	userInfo = &entity.UserCacheInfo{}
	err = json.Unmarshal([]byte(userInfoCache), userInfo)
	if err != nil {
		return nil, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return userInfo, nil
}
// RemoveUserStatus remove user status
func (ar *authRepo) RemoveUserStatus(ctx context.Context, userID string) (err error) {
	err = ar.data.Cache.Del(ctx, constant.UserStatusChangedCacheKey+userID)
	if err != nil {
		return errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return nil
}
// GetAdminUserCacheInfo get admin user cache info
func (ar *authRepo) GetAdminUserCacheInfo(ctx context.Context, accessToken string) (userInfo *entity.UserCacheInfo, err error) {
	userInfoCache, err := ar.data.Cache.GetString(ctx, constant.AdminTokenCacheKey+accessToken)
	if err != nil {
		err = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
		return
	}
	userInfo = &entity.UserCacheInfo{}
	err = json.Unmarshal([]byte(userInfoCache), userInfo)
	if err != nil {
		return nil, err
	}
	return userInfo, nil
}
// SetAdminUserCacheInfo set admin user cache info
func (ar *authRepo) SetAdminUserCacheInfo(ctx context.Context, accessToken string, userInfo *entity.UserCacheInfo) (err error) {
	userInfoCache, err := json.Marshal(userInfo)
	if err != nil {
		return err
	}
	err = ar.data.Cache.SetString(ctx, constant.AdminTokenCacheKey+accessToken, string(userInfoCache),
		constant.AdminTokenCacheTime)
	if err != nil {
		return errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return nil
}
// RemoveAdminUserCacheInfo remove admin user cache info
func (ar *authRepo) RemoveAdminUserCacheInfo(ctx context.Context, accessToken string) (err error) {
	err = ar.data.Cache.Del(ctx, constant.AdminTokenCacheKey+accessToken)
	if err != nil {
		return errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return nil
}
// AddUserTokenMapping add user token mapping
func (ar *authRepo) AddUserTokenMapping(ctx context.Context, userID, accessToken string) (err error) {
	key := constant.UserTokenMappingCacheKey + userID
	resp, _ := ar.data.Cache.GetString(ctx, key)
	mapping := make(map[string]bool, 0)
	if len(resp) > 0 {
		_ = json.Unmarshal([]byte(resp), &mapping)
	}
	mapping[accessToken] = true
	content, _ := json.Marshal(mapping)
	return ar.data.Cache.SetString(ctx, key, string(content), constant.UserTokenCacheTime)
}
// RemoveUserTokens Log out all users under this user id
func (ar *authRepo) RemoveUserTokens(ctx context.Context, userID string, remainToken string) {
	key := constant.UserTokenMappingCacheKey + userID
	resp, _ := ar.data.Cache.GetString(ctx, key)
	mapping := make(map[string]bool, 0)
	if len(resp) > 0 {
		_ = json.Unmarshal([]byte(resp), &mapping)
		log.Debugf(""find %d user tokens by user id %s"", len(mapping), userID)
	}
	for token := range mapping {
		if token == remainToken {
			continue
		}
		if err := ar.RemoveUserCacheInfo(ctx, token); err != nil {
			log.Error(err)
		} else {
			log.Debugf(""del user %s token success"")
		}
	}
	if err := ar.RemoveUserStatus(ctx, userID); err != nil {
		log.Error(err)
	}
	if err := ar.data.Cache.Del(ctx, key); err != nil {
		log.Error(err)
	}
}
// NewAuthRepo new repository
func NewAuthRepo(data *data.Data) auth.AuthRepo {
	return &authRepo{
		data: data,
	}
}
",CWE-613,184.0,0
"package auth
import (
	""context""
	""github.com/answerdev/answer/internal/entity""
	""github.com/answerdev/answer/pkg/token""
	""github.com/segmentfault/pacman/log""
)
// AuthRepo auth repository
type AuthRepo interface {
	GetUserCacheInfo(ctx context.Context, accessToken string) (userInfo *entity.UserCacheInfo, err error)
	SetUserCacheInfo(ctx context.Context, accessToken string, userInfo *entity.UserCacheInfo) error
	RemoveUserCacheInfo(ctx context.Context, accessToken string) (err error)
	SetUserStatus(ctx context.Context, userID string, userInfo *entity.UserCacheInfo) (err error)
	GetUserStatus(ctx context.Context, userID string) (userInfo *entity.UserCacheInfo, err error)
	RemoveUserStatus(ctx context.Context, userID string) (err error)
	GetAdminUserCacheInfo(ctx context.Context, accessToken string) (userInfo *entity.UserCacheInfo, err error)
	SetAdminUserCacheInfo(ctx context.Context, accessToken string, userInfo *entity.UserCacheInfo) error
	RemoveAdminUserCacheInfo(ctx context.Context, accessToken string) (err error)
	AddUserTokenMapping(ctx context.Context, userID, accessToken string) (err error)
	RemoveUserTokens(ctx context.Context, userID string, remainToken string)
}
// AuthService kit service
type AuthService struct {
	authRepo AuthRepo
}
// NewAuthService email service
func NewAuthService(authRepo AuthRepo) *AuthService {
	return &AuthService{
		authRepo: authRepo,
	}
}
func (as *AuthService) GetUserCacheInfo(ctx context.Context, accessToken string) (userInfo *entity.UserCacheInfo, err error) {
	userCacheInfo, err := as.authRepo.GetUserCacheInfo(ctx, accessToken)
	if err != nil {
		return nil, err
	}
	cacheInfo, _ := as.authRepo.GetUserStatus(ctx, userCacheInfo.UserID)
	if cacheInfo != nil {
		log.Debugf(""user status updated: %+v"", cacheInfo)
		userCacheInfo.UserStatus = cacheInfo.UserStatus
		userCacheInfo.EmailStatus = cacheInfo.EmailStatus
		userCacheInfo.RoleID = cacheInfo.RoleID
		// update current user cache info
		err := as.authRepo.SetUserCacheInfo(ctx, accessToken, userCacheInfo)
		if err != nil {
			return nil, err
		}
	}
	return userCacheInfo, nil
}
func (as *AuthService) SetUserCacheInfo(ctx context.Context, userInfo *entity.UserCacheInfo) (accessToken string, err error) {
	accessToken = token.GenerateToken()
	err = as.authRepo.SetUserCacheInfo(ctx, accessToken, userInfo)
	return accessToken, err
}
func (as *AuthService) SetUserStatus(ctx context.Context, userInfo *entity.UserCacheInfo) (err error) {
	return as.authRepo.SetUserStatus(ctx, userInfo.UserID, userInfo)
}
func (as *AuthService) UpdateUserCacheInfo(ctx context.Context, token string, userInfo *entity.UserCacheInfo) (err error) {
	err = as.authRepo.SetUserCacheInfo(ctx, token, userInfo)
	if err != nil {
		return err
	}
	if err := as.authRepo.RemoveUserStatus(ctx, userInfo.UserID); err != nil {
		log.Error(err)
	}
	return
}
func (as *AuthService) RemoveUserCacheInfo(ctx context.Context, accessToken string) (err error) {
	return as.authRepo.RemoveUserCacheInfo(ctx, accessToken)
}
// AddUserTokenMapping add user token mapping
func (as *AuthService) AddUserTokenMapping(ctx context.Context, userID, accessToken string) (err error) {
	return as.authRepo.AddUserTokenMapping(ctx, userID, accessToken)
}
// RemoveUserAllTokens Log out all users under this user id
func (as *AuthService) RemoveUserAllTokens(ctx context.Context, userID string) {
	as.authRepo.RemoveUserTokens(ctx, userID, """")
}
// RemoveTokensExceptCurrentUser remove all tokens except the current user
func (as *AuthService) RemoveTokensExceptCurrentUser(ctx context.Context, userID string, accessToken string) {
	as.authRepo.RemoveUserTokens(ctx, userID, accessToken)
}
//Admin
func (as *AuthService) GetAdminUserCacheInfo(ctx context.Context, accessToken string) (userInfo *entity.UserCacheInfo, err error) {
	return as.authRepo.GetAdminUserCacheInfo(ctx, accessToken)
}
func (as *AuthService) SetAdminUserCacheInfo(ctx context.Context, accessToken string, userInfo *entity.UserCacheInfo) (err error) {
	err = as.authRepo.SetAdminUserCacheInfo(ctx, accessToken, userInfo)
	return err
}
func (as *AuthService) RemoveAdminUserCacheInfo(ctx context.Context, accessToken string) (err error) {
	return as.authRepo.RemoveAdminUserCacheInfo(ctx, accessToken)
}
",CWE-613,112.0,0
"package migrations
import (
	""encoding/json""
	""fmt""
	""github.com/answerdev/answer/internal/base/constant""
	""github.com/answerdev/answer/internal/entity""
	""github.com/answerdev/answer/internal/schema""
	""github.com/tidwall/gjson""
	""xorm.io/xorm""
)
func addLoginLimitations(x *xorm.Engine) error {
	loginSiteInfo := &entity.SiteInfo{
		Type: constant.SiteTypeLogin,
	}
	exist, err := x.Get(loginSiteInfo)
	if err != nil {
		return fmt.Errorf(""get config failed: %w"", err)
	}
	if exist {
		content := &schema.SiteLoginReq{}
		_ = json.Unmarshal([]byte(loginSiteInfo.Content), content)
		content.AllowEmailRegistrations = true
		content.AllowEmailDomains = make([]string, 0)
		data, _ := json.Marshal(content)
		loginSiteInfo.Content = string(data)
		_, err = x.ID(loginSiteInfo.ID).Cols(""content"").Update(loginSiteInfo)
		if err != nil {
			return fmt.Errorf(""update site info failed: %w"", err)
		}
	}
	interfaceSiteInfo := &entity.SiteInfo{
		Type: constant.SiteTypeInterface,
	}
	exist, err = x.Get(interfaceSiteInfo)
	if err != nil {
		return fmt.Errorf(""get config failed: %w"", err)
	}
	siteUsers := &schema.SiteUsersReq{
		AllowUpdateDisplayName: true,
		AllowUpdateUsername:    true,
		AllowUpdateAvatar:      true,
		AllowUpdateBio:         true,
		AllowUpdateWebsite:     true,
		AllowUpdateLocation:    true,
	}
	if exist {
		siteUsers.DefaultAvatar = gjson.Get(interfaceSiteInfo.Content, ""default_avatar"").String()
	}
	data, _ := json.Marshal(siteUsers)
	exist, err = x.Get(&entity.SiteInfo{Type: constant.SiteTypeUsers})
	if err != nil {
		return fmt.Errorf(""get config failed: %w"", err)
	}
	if !exist {
		usersSiteInfo := &entity.SiteInfo{
			Type:    constant.SiteTypeUsers,
			Content: string(data),
			Status:  1,
		}
		_, err = x.InsertOne(usersSiteInfo)
		if err != nil {
			return fmt.Errorf(""insert site info failed: %w"", err)
		}
	}
	return nil
}
",CWE-521,72.0,0
"package checker
import (
	""fmt""
	""regexp""
	""strings""
)
const (
	levelD = iota
	LevelC
	LevelB
	LevelA
	LevelS
)
const (
	PasswordCannotContainSpaces = ""error.password.space_invalid""
)
// CheckPassword checks the password strength
func CheckPassword(password string) error {
	if strings.Contains(password, "" "") {
		return fmt.Errorf(PasswordCannotContainSpaces)
	}
	// TODO Currently there is no requirement for password strength
	minLevel := 0
	// The password strength level is initialized to D.
	// The regular is used to verify the password strength.
	// If the matching is successful, the password strength increases by 1
	level := levelD
	patternList := []string{`[0-9]+`, `[a-z]+`, `[A-Z]+`, `[~!@
	for _, pattern := range patternList {
		match, _ := regexp.MatchString(pattern, password)
		if match {
			level++
		}
	}
	// If the final password strength falls below the required minimum strength, return with an error
	if level < minLevel {
		return fmt.Errorf(""the password does not satisfy the current policy requirements"")
	}
	return nil
}
",CWE-521,48.0,0
"package controller
import (
	""github.com/answerdev/answer/internal/base/handler""
	""github.com/answerdev/answer/internal/base/middleware""
	""github.com/answerdev/answer/internal/base/reason""
	""github.com/answerdev/answer/internal/base/translator""
	""github.com/answerdev/answer/internal/schema""
	""github.com/answerdev/answer/internal/service""
	""github.com/answerdev/answer/internal/service/rank""
	""github.com/answerdev/answer/pkg/uid""
	""github.com/gin-gonic/gin""
	""github.com/segmentfault/pacman/errors""
)
// VoteController activity controller
type VoteController struct {
	VoteService *service.VoteService
	rankService *rank.RankService
}
// NewVoteController new controller
func NewVoteController(voteService *service.VoteService, rankService *rank.RankService) *VoteController {
	return &VoteController{VoteService: voteService, rankService: rankService}
}
// VoteUp godoc
// @Summary vote up
// @Description add vote
// @Tags Activity
// @Accept json
// @Produce json
// @Security ApiKeyAuth
// @Param data body schema.VoteReq true ""vote""
// @Success 200 {object} handler.RespBody{data=schema.VoteResp}
// @Router /answer/api/v1/vote/up [post]
func (vc *VoteController) VoteUp(ctx *gin.Context) {
	req := &schema.VoteReq{}
	if handler.BindAndCheck(ctx, req) {
		return
	}
	req.ObjectID = uid.DeShortID(req.ObjectID)
	req.UserID = middleware.GetLoginUserIDFromContext(ctx)
	can, needRank, err := vc.rankService.CheckVotePermission(ctx, req.UserID, req.ObjectID, true)
	if err != nil {
		handler.HandleResponse(ctx, err, nil)
		return
	}
	if !can {
		lang := handler.GetLang(ctx)
		msg := translator.TrWithData(lang, reason.NoEnoughRankToOperate, &schema.PermissionTrTplData{Rank: needRank})
		handler.HandleResponse(ctx, errors.Forbidden(reason.NoEnoughRankToOperate).WithMsg(msg), nil)
		return
	}
	resp, err := vc.VoteService.VoteUp(ctx, req)
	if err != nil {
		handler.HandleResponse(ctx, err, schema.ErrTypeToast)
	} else {
		handler.HandleResponse(ctx, err, resp)
	}
}
// VoteDown godoc
// @Summary vote down
// @Description add vote
// @Tags Activity
// @Accept json
// @Produce json
// @Security ApiKeyAuth
// @Param data body schema.VoteReq true ""vote""
// @Success 200 {object} handler.RespBody{data=schema.VoteResp}
// @Router /answer/api/v1/vote/down [post]
func (vc *VoteController) VoteDown(ctx *gin.Context) {
	req := &schema.VoteReq{}
	if handler.BindAndCheck(ctx, req) {
		return
	}
	req.ObjectID = uid.DeShortID(req.ObjectID)
	req.UserID = middleware.GetLoginUserIDFromContext(ctx)
	can, needRank, err := vc.rankService.CheckVotePermission(ctx, req.UserID, req.ObjectID, false)
	if err != nil {
		handler.HandleResponse(ctx, err, nil)
		return
	}
	if !can {
		lang := handler.GetLang(ctx)
		msg := translator.TrWithData(lang, reason.NoEnoughRankToOperate, &schema.PermissionTrTplData{Rank: needRank})
		handler.HandleResponse(ctx, errors.Forbidden(reason.NoEnoughRankToOperate).WithMsg(msg), nil)
		return
	}
	resp, err := vc.VoteService.VoteDown(ctx, req)
	if err != nil {
		handler.HandleResponse(ctx, err, schema.ErrTypeToast)
	} else {
		handler.HandleResponse(ctx, err, resp)
	}
}
// UserVotes user votes
// @Summary get user personal votes
// @Description get user personal votes
// @Tags Activity
// @Accept json
// @Produce json
// @Security ApiKeyAuth
// @Param page query int false ""page size""
// @Param page_size query int false ""page size""
// @Success 200 {object} handler.RespBody{data=pager.PageModel{list=[]schema.GetVoteWithPageResp}}
// @Router /answer/api/v1/personal/vote/page [get]
func (vc *VoteController) UserVotes(ctx *gin.Context) {
	req := schema.GetVoteWithPageReq{}
	if handler.BindAndCheck(ctx, &req) {
		return
	}
	req.UserID = middleware.GetLoginUserIDFromContext(ctx)
	resp, err := vc.VoteService.ListUserVotes(ctx, req)
	handler.HandleResponse(ctx, err, resp)
}
",CWE-366,123.0,0
"package activity
import (
	""context""
	""time""
	""github.com/answerdev/answer/internal/service/activity_common""
	""github.com/answerdev/answer/internal/service/follow""
	""github.com/answerdev/answer/pkg/obj""
	""github.com/segmentfault/pacman/log""
	""xorm.io/builder""
	""github.com/answerdev/answer/internal/base/data""
	""github.com/answerdev/answer/internal/base/reason""
	""github.com/answerdev/answer/internal/entity""
	""github.com/answerdev/answer/internal/service/unique""
	""github.com/segmentfault/pacman/errors""
	""xorm.io/xorm""
)
// FollowRepo activity repository
type FollowRepo struct {
	data         *data.Data
	uniqueIDRepo unique.UniqueIDRepo
	activityRepo activity_common.ActivityRepo
}
// NewFollowRepo new repository
func NewFollowRepo(
	data *data.Data,
	uniqueIDRepo unique.UniqueIDRepo,
	activityRepo activity_common.ActivityRepo,
) follow.FollowRepo {
	return &FollowRepo{
		data:         data,
		uniqueIDRepo: uniqueIDRepo,
		activityRepo: activityRepo,
	}
}
func (ar *FollowRepo) Follow(ctx context.Context, objectID, userID string) error {
	objectTypeStr, err := obj.GetObjectTypeStrByObjectID(objectID)
	if err != nil {
		return errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	activityType, err := ar.activityRepo.GetActivityTypeByObjectType(ctx, objectTypeStr, ""follow"")
	if err != nil {
		return err
	}
	_, err = ar.data.DB.Transaction(func(session *xorm.Session) (result any, err error) {
		session = session.Context(ctx)
		var (
			existsActivity entity.Activity
			has            bool
		)
		result = nil
		has, err = session.Where(builder.Eq{""activity_type"": activityType}).
			And(builder.Eq{""user_id"": userID}).
			And(builder.Eq{""object_id"": objectID}).
			Get(&existsActivity)
		if err != nil {
			return
		}
		if has && existsActivity.Cancelled == entity.ActivityAvailable {
			return
		}
		if has {
			_, err = session.Where(builder.Eq{""id"": existsActivity.ID}).
				Cols(`cancelled`).
				Update(&entity.Activity{
					Cancelled: entity.ActivityAvailable,
				})
		} else {
			// update existing activity with new user id and u object id
			_, err = session.Insert(&entity.Activity{
				UserID:           userID,
				ObjectID:         objectID,
				OriginalObjectID: objectID,
				ActivityType:     activityType,
				Cancelled:        entity.ActivityAvailable,
				Rank:             0,
				HasRank:          0,
			})
		}
		if err != nil {
			log.Error(err)
			return
		}
		// start update followers when everything is fine
		err = ar.updateFollows(ctx, session, objectID, 1)
		if err != nil {
			log.Error(err)
		}
		return
	})
	return err
}
func (ar *FollowRepo) FollowCancel(ctx context.Context, objectID, userID string) error {
	objectTypeStr, err := obj.GetObjectTypeStrByObjectID(objectID)
	if err != nil {
		return errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	activityType, err := ar.activityRepo.GetActivityTypeByObjectType(ctx, objectTypeStr, ""follow"")
	if err != nil {
		return err
	}
	_, err = ar.data.DB.Transaction(func(session *xorm.Session) (result any, err error) {
		session = session.Context(ctx)
		var (
			existsActivity entity.Activity
			has            bool
		)
		result = nil
		has, err = session.Where(builder.Eq{""activity_type"": activityType}).
			And(builder.Eq{""user_id"": userID}).
			And(builder.Eq{""object_id"": objectID}).
			Get(&existsActivity)
		if err != nil || !has {
			return
		}
		if has && existsActivity.Cancelled == entity.ActivityCancelled {
			return
		}
		if _, err = session.Where(""id = ?"", existsActivity.ID).
			Cols(""cancelled"").
			Update(&entity.Activity{
				Cancelled:   entity.ActivityCancelled,
				CancelledAt: time.Now(),
			}); err != nil {
			return
		}
		err = ar.updateFollows(ctx, session, objectID, -1)
		return
	})
	return err
}
func (ar *FollowRepo) updateFollows(ctx context.Context, session *xorm.Session, objectID string, follows int) error {
	objectType, err := obj.GetObjectTypeStrByObjectID(objectID)
	if err != nil {
		return err
	}
	switch objectType {
	case ""question"":
		_, err = session.Where(""id = ?"", objectID).Incr(""follow_count"", follows).Update(&entity.Question{})
	case ""user"":
		_, err = session.Where(""id = ?"", objectID).Incr(""follow_count"", follows).Update(&entity.User{})
	case ""tag"":
		_, err = session.Where(""id = ?"", objectID).Incr(""follow_count"", follows).Update(&entity.Tag{})
	default:
		err = errors.InternalServer(reason.DisallowFollow).WithMsg(""this object can't be followed"")
	}
	return err
}
",CWE-366,169.0,0
"package activity
import (
	""context""
	""fmt""
	""xorm.io/builder""
	""github.com/answerdev/answer/internal/base/data""
	""github.com/answerdev/answer/internal/base/reason""
	""github.com/answerdev/answer/internal/entity""
	""github.com/answerdev/answer/internal/service/activity""
	""github.com/answerdev/answer/internal/service/activity_common""
	""github.com/answerdev/answer/internal/service/config""
	""github.com/answerdev/answer/internal/service/rank""
	""github.com/segmentfault/pacman/errors""
	""xorm.io/xorm""
)
// UserActiveActivityRepo answer accepted
type UserActiveActivityRepo struct {
	data          *data.Data
	activityRepo  activity_common.ActivityRepo
	userRankRepo  rank.UserRankRepo
	configService *config.ConfigService
}
const (
	UserActivated = ""user.activated""
)
// NewUserActiveActivityRepo new repository
func NewUserActiveActivityRepo(
	data *data.Data,
	activityRepo activity_common.ActivityRepo,
	userRankRepo rank.UserRankRepo,
	configService *config.ConfigService,
) activity.UserActiveActivityRepo {
	return &UserActiveActivityRepo{
		data:          data,
		activityRepo:  activityRepo,
		userRankRepo:  userRankRepo,
		configService: configService,
	}
}
// UserActive user active
func (ar *UserActiveActivityRepo) UserActive(ctx context.Context, userID string) (err error) {
	cfg, err := ar.configService.GetConfigByKey(ctx, UserActivated)
	if err != nil {
		return err
	}
	addActivity := &entity.Activity{
		UserID:           userID,
		ObjectID:         ""0"",
		OriginalObjectID: ""0"",
		ActivityType:     cfg.ID,
		Rank:             cfg.GetIntValue(),
		HasRank:          1,
	}
	_, err = ar.data.DB.Transaction(func(session *xorm.Session) (result any, err error) {
		session = session.Context(ctx)
		user := &entity.User{}
		exist, err := session.ID(userID).ForUpdate().Get(user)
		if err != nil {
			return nil, err
		}
		if !exist {
			return nil, fmt.Errorf(""user not exist"")
		}
		existsActivity := &entity.Activity{}
		exist, err = session.
			And(builder.Eq{""user_id"": addActivity.UserID}).
			And(builder.Eq{""activity_type"": addActivity.ActivityType}).
			Get(existsActivity)
		if err != nil {
			return nil, err
		}
		if exist {
			return nil, nil
		}
		err = ar.userRankRepo.ChangeUserRank(ctx, session, addActivity.UserID, user.Rank, addActivity.Rank)
		if err != nil {
			return nil, err
		}
		_, err = session.Insert(addActivity)
		if err != nil {
			return nil, err
		}
		return nil, nil
	})
	if err != nil {
		return errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return nil
}
",CWE-366,101.0,0
"package activity_common
import (
	""context""
	""fmt""
	""time""
	""github.com/answerdev/answer/internal/entity""
	""github.com/answerdev/answer/internal/service/activity_common""
	""github.com/answerdev/answer/internal/service/activity_type""
	""github.com/answerdev/answer/pkg/obj""
	""xorm.io/builder""
	""xorm.io/xorm""
	""github.com/answerdev/answer/internal/base/data""
	""github.com/answerdev/answer/internal/base/reason""
	""github.com/answerdev/answer/internal/service/config""
	""github.com/answerdev/answer/internal/service/unique""
	""github.com/segmentfault/pacman/errors""
)
// ActivityRepo activity repository
type ActivityRepo struct {
	data          *data.Data
	uniqueIDRepo  unique.UniqueIDRepo
	configService *config.ConfigService
}
// NewActivityRepo new repository
func NewActivityRepo(
	data *data.Data,
	uniqueIDRepo unique.UniqueIDRepo,
	configService *config.ConfigService,
) activity_common.ActivityRepo {
	return &ActivityRepo{
		data:          data,
		uniqueIDRepo:  uniqueIDRepo,
		configService: configService,
	}
}
func (ar *ActivityRepo) GetActivityTypeByObjID(ctx context.Context, objectID string, action string) (
	activityType, rank, hasRank int, err error) {
	objectType, err := obj.GetObjectTypeStrByObjectID(objectID)
	if err != nil {
		return
	}
	confKey := fmt.Sprintf(""%s.%s"", objectType, action)
	cfg, err := ar.configService.GetConfigByKey(ctx, confKey)
	if err != nil {
		return
	}
	activityType, rank = cfg.ID, cfg.GetIntValue()
	hasRank = 0
	if rank != 0 {
		hasRank = 1
	}
	return
}
func (ar *ActivityRepo) GetActivityTypeByObjectType(ctx context.Context, objectType, action string) (activityType int, err error) {
	configKey := fmt.Sprintf(""%s.%s"", objectType, action)
	cfg, err := ar.configService.GetConfigByKey(ctx, configKey)
	if err != nil {
		return 0, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return cfg.ID, nil
}
func (ar *ActivityRepo) GetActivityTypeByConfigKey(ctx context.Context, configKey string) (activityType int, err error) {
	cfg, err := ar.configService.GetConfigByKey(ctx, configKey)
	if err != nil {
		return 0, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return cfg.ID, nil
}
func (ar *ActivityRepo) GetActivity(ctx context.Context, session *xorm.Session,
	objectID, userID string, activityType int,
) (existsActivity *entity.Activity, exist bool, err error) {
	existsActivity = &entity.Activity{}
	exist, err = session.
		Where(builder.Eq{""object_id"": objectID}).
		And(builder.Eq{""user_id"": userID}).
		And(builder.Eq{""activity_type"": activityType}).
		Get(existsActivity)
	return
}
func (ar *ActivityRepo) GetUserIDObjectIDActivitySum(ctx context.Context, userID, objectID string) (int, error) {
	sum := &entity.ActivityRankSum{}
	_, err := ar.data.DB.Context(ctx).Table(entity.Activity{}.TableName()).
		Select(""sum(`rank`) as `rank`"").
		Where(""user_id =?"", userID).
		And(""object_id = ?"", objectID).
		And(""cancelled =0"").
		Get(sum)
	if err != nil {
		err = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
		return 0, err
	}
	return sum.Rank, nil
}
// AddActivity add activity
func (ar *ActivityRepo) AddActivity(ctx context.Context, activity *entity.Activity) (err error) {
	_, err = ar.data.DB.Context(ctx).Insert(activity)
	if err != nil {
		err = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return
}
// GetUsersWhoHasGainedTheMostReputation get users who has gained the most reputation over a period of time
func (ar *ActivityRepo) GetUsersWhoHasGainedTheMostReputation(
	ctx context.Context, startTime, endTime time.Time, limit int) (rankStat []*entity.ActivityUserRankStat, err error) {
	rankStat = make([]*entity.ActivityUserRankStat, 0)
	session := ar.data.DB.Context(ctx).Select(""user_id, SUM(`rank`) AS rank_amount"").Table(""activity"")
	session.Where(""has_rank = 1 AND cancelled = 0"")
	session.Where(""created_at >= ?"", startTime)
	session.Where(""created_at <= ?"", endTime)
	session.GroupBy(""user_id"")
	session.Desc(""rank_amount"")
	session.Limit(limit)
	err = session.Find(&rankStat)
	if err != nil {
		err = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return
}
// GetUsersWhoHasVoteMost get users who has vote most
func (ar *ActivityRepo) GetUsersWhoHasVoteMost(
	ctx context.Context, startTime, endTime time.Time, limit int) (voteStat []*entity.ActivityUserVoteStat, err error) {
	voteStat = make([]*entity.ActivityUserVoteStat, 0)
	actIDs := make([]int, 0)
	for _, act := range activity_type.ActivityTypeList {
		cfg, err := ar.configService.GetConfigByKey(ctx, act)
		if err == nil {
			actIDs = append(actIDs, cfg.ID)
		}
	}
	session := ar.data.DB.Context(ctx).Select(""user_id, COUNT(*) AS vote_count"").Table(""activity"")
	session.Where(""cancelled = 0"")
	session.In(""activity_type"", actIDs)
	session.Where(""created_at >= ?"", startTime)
	session.Where(""created_at <= ?"", endTime)
	session.GroupBy(""user_id"")
	session.Desc(""vote_count"")
	session.Limit(limit)
	err = session.Find(&voteStat)
	if err != nil {
		err = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return
}
",CWE-366,160.0,0
"package activity_common
import (
	""context""
	""github.com/answerdev/answer/internal/base/data""
	""github.com/answerdev/answer/internal/base/reason""
	""github.com/answerdev/answer/internal/entity""
	""github.com/answerdev/answer/internal/service/activity_common""
	""github.com/answerdev/answer/internal/service/unique""
	""github.com/answerdev/answer/pkg/obj""
	""github.com/segmentfault/pacman/errors""
	""github.com/segmentfault/pacman/log""
)
// FollowRepo follow repository
type FollowRepo struct {
	data         *data.Data
	uniqueIDRepo unique.UniqueIDRepo
	activityRepo activity_common.ActivityRepo
}
// NewFollowRepo new repository
func NewFollowRepo(
	data *data.Data,
	uniqueIDRepo unique.UniqueIDRepo,
	activityRepo activity_common.ActivityRepo,
) activity_common.FollowRepo {
	return &FollowRepo{
		data:         data,
		uniqueIDRepo: uniqueIDRepo,
		activityRepo: activityRepo,
	}
}
// GetFollowAmount get object id's follows
func (ar *FollowRepo) GetFollowAmount(ctx context.Context, objectID string) (follows int, err error) {
	objectType, err := obj.GetObjectTypeStrByObjectID(objectID)
	if err != nil {
		return 0, err
	}
	switch objectType {
	case ""question"":
		model := &entity.Question{}
		_, err = ar.data.DB.Context(ctx).Where(""id = ?"", objectID).Cols(""`follow_count`"").Get(model)
		if err == nil {
			follows = int(model.FollowCount)
		}
	case ""user"":
		model := &entity.User{}
		_, err = ar.data.DB.Context(ctx).Where(""id = ?"", objectID).Cols(""`follow_count`"").Get(model)
		if err == nil {
			follows = int(model.FollowCount)
		}
	case ""tag"":
		model := &entity.Tag{}
		_, err = ar.data.DB.Context(ctx).Where(""id = ?"", objectID).Cols(""`follow_count`"").Get(model)
		if err == nil {
			follows = int(model.FollowCount)
		}
	default:
		err = errors.InternalServer(reason.DisallowFollow).WithMsg(""this object can't be followed"")
	}
	if err != nil {
		return 0, err
	}
	return follows, nil
}
// GetFollowUserIDs get follow userID by objectID
func (ar *FollowRepo) GetFollowUserIDs(ctx context.Context, objectID string) (userIDs []string, err error) {
	objectTypeStr, err := obj.GetObjectTypeStrByObjectID(objectID)
	if err != nil {
		return nil, err
	}
	activityType, err := ar.activityRepo.GetActivityTypeByObjectType(ctx, objectTypeStr, ""follow"")
	if err != nil {
		log.Errorf(""can't get activity type by object key: %s"", objectTypeStr)
		return nil, err
	}
	userIDs = make([]string, 0)
	session := ar.data.DB.Context(ctx).Select(""user_id"")
	session.Table(entity.Activity{}.TableName())
	session.Where(""object_id = ?"", objectID)
	session.Where(""activity_type = ?"", activityType)
	session.Where(""cancelled = 0"")
	err = session.Find(&userIDs)
	if err != nil {
		return nil, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return userIDs, nil
}
// GetFollowIDs get all follow id list
func (ar *FollowRepo) GetFollowIDs(ctx context.Context, userID, objectKey string) (followIDs []string, err error) {
	followIDs = make([]string, 0)
	activityType, err := ar.activityRepo.GetActivityTypeByObjectType(ctx, objectKey, ""follow"")
	if err != nil {
		return nil, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	session := ar.data.DB.Context(ctx).Select(""object_id"")
	session.Table(entity.Activity{}.TableName())
	session.Where(""user_id = ? AND activity_type = ?"", userID, activityType)
	session.Where(""cancelled = 0"")
	err = session.Find(&followIDs)
	if err != nil {
		return nil, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return followIDs, nil
}
// IsFollowed check user if follow object or not
func (ar *FollowRepo) IsFollowed(ctx context.Context, userID, objectID string) (followed bool, err error) {
	objectKey, err := obj.GetObjectTypeStrByObjectID(objectID)
	if err != nil {
		return false, err
	}
	activityType, err := ar.activityRepo.GetActivityTypeByObjectType(ctx, objectKey, ""follow"")
	if err != nil {
		return false, err
	}
	at := &entity.Activity{}
	has, err := ar.data.DB.Context(ctx).Where(""user_id = ? AND object_id = ? AND activity_type = ?"", userID, objectID, activityType).Get(at)
	if err != nil {
		return false, err
	}
	if !has {
		return false, nil
	}
	if at.Cancelled == entity.ActivityCancelled {
		return false, nil
	} else {
		return true, nil
	}
}
",CWE-366,140.0,0
"package repo
import (
	""github.com/answerdev/answer/internal/base/data""
	""github.com/answerdev/answer/internal/repo/activity""
	""github.com/answerdev/answer/internal/repo/activity_common""
	""github.com/answerdev/answer/internal/repo/answer""
	""github.com/answerdev/answer/internal/repo/auth""
	""github.com/answerdev/answer/internal/repo/captcha""
	""github.com/answerdev/answer/internal/repo/collection""
	""github.com/answerdev/answer/internal/repo/comment""
	""github.com/answerdev/answer/internal/repo/config""
	""github.com/answerdev/answer/internal/repo/export""
	""github.com/answerdev/answer/internal/repo/meta""
	""github.com/answerdev/answer/internal/repo/notification""
	""github.com/answerdev/answer/internal/repo/plugin_config""
	""github.com/answerdev/answer/internal/repo/question""
	""github.com/answerdev/answer/internal/repo/rank""
	""github.com/answerdev/answer/internal/repo/reason""
	""github.com/answerdev/answer/internal/repo/report""
	""github.com/answerdev/answer/internal/repo/revision""
	""github.com/answerdev/answer/internal/repo/role""
	""github.com/answerdev/answer/internal/repo/search_common""
	""github.com/answerdev/answer/internal/repo/site_info""
	""github.com/answerdev/answer/internal/repo/tag""
	""github.com/answerdev/answer/internal/repo/tag_common""
	""github.com/answerdev/answer/internal/repo/unique""
	""github.com/answerdev/answer/internal/repo/user""
	""github.com/answerdev/answer/internal/repo/user_external_login""
	""github.com/google/wire""
)
// ProviderSetRepo is data providers.
var ProviderSetRepo = wire.NewSet(
	data.NewData,
	data.NewDB,
	data.NewCache,
	comment.NewCommentRepo,
	comment.NewCommentCommonRepo,
	captcha.NewCaptchaRepo,
	unique.NewUniqueIDRepo,
	report.NewReportRepo,
	activity_common.NewFollowRepo,
	activity_common.NewVoteRepo,
	config.NewConfigRepo,
	user.NewUserRepo,
	user.NewUserAdminRepo,
	rank.NewUserRankRepo,
	question.NewQuestionRepo,
	answer.NewAnswerRepo,
	activity_common.NewActivityRepo,
	activity.NewVoteRepo,
	activity.NewFollowRepo,
	activity.NewAnswerActivityRepo,
	activity.NewUserActiveActivityRepo,
	activity.NewActivityRepo,
	tag.NewTagRepo,
	tag_common.NewTagCommonRepo,
	tag.NewTagRelRepo,
	collection.NewCollectionRepo,
	collection.NewCollectionGroupRepo,
	auth.NewAuthRepo,
	revision.NewRevisionRepo,
	search_common.NewSearchRepo,
	meta.NewMetaRepo,
	export.NewEmailRepo,
	reason.NewReasonRepo,
	site_info.NewSiteInfo,
	notification.NewNotificationRepo,
	role.NewRoleRepo,
	role.NewUserRoleRelRepo,
	role.NewRolePowerRelRepo,
	role.NewPowerRepo,
	user_external_login.NewUserExternalLoginRepo,
	plugin_config.NewPluginConfigRepo,
)
",CWE-366,77.0,0
"package rank
import (
	""context""
	""github.com/answerdev/answer/internal/base/data""
	""github.com/answerdev/answer/internal/base/pager""
	""github.com/answerdev/answer/internal/base/reason""
	""github.com/answerdev/answer/internal/entity""
	""github.com/answerdev/answer/internal/service/config""
	""github.com/answerdev/answer/internal/service/rank""
	""github.com/answerdev/answer/plugin""
	""github.com/jinzhu/now""
	""github.com/segmentfault/pacman/errors""
	""github.com/segmentfault/pacman/log""
	""xorm.io/builder""
	""xorm.io/xorm""
)
// UserRankRepo user rank repository
type UserRankRepo struct {
	data          *data.Data
	configService *config.ConfigService
}
// NewUserRankRepo new repository
func NewUserRankRepo(data *data.Data, configService *config.ConfigService) rank.UserRankRepo {
	return &UserRankRepo{
		data:          data,
		configService: configService,
	}
}
func (ur *UserRankRepo) GetMaxDailyRank(ctx context.Context) (maxDailyRank int, err error) {
	maxDailyRank, err = ur.configService.GetIntValue(ctx, ""daily_rank_limit"")
	if err != nil {
		return 0, err
	}
	return maxDailyRank, nil
}
func (ur *UserRankRepo) CheckReachLimit(ctx context.Context, session *xorm.Session,
	userID string, maxDailyRank int) (
	reach bool, err error) {
	session.Where(builder.Eq{""user_id"": userID})
	session.Where(builder.Eq{""cancelled"": 0})
	session.Where(builder.Between{
		Col:     ""updated_at"",
		LessVal: now.BeginningOfDay(),
		MoreVal: now.EndOfDay(),
	})
	earned, err := session.Sum(&entity.Activity{}, ""`rank`"")
	if err != nil {
		return false, err
	}
	if int(earned) <= maxDailyRank {
		return false, nil
	}
	log.Infof(""user %s today has rank %d is reach stand %d"", userID, earned, maxDailyRank)
	return true, nil
}
// ChangeUserRank change user rank
func (ur *UserRankRepo) ChangeUserRank(
	ctx context.Context, session *xorm.Session, userID string, userCurrentScore, deltaRank int) (err error) {
	// IMPORTANT: If user center enabled the rank agent, then we should not change user rank.
	if plugin.RankAgentEnabled() || deltaRank == 0 {
		return nil
	}
	// If user rank is lower than 1 after this action, then user rank will be set to 1 only.
	if deltaRank < 0 && userCurrentScore+deltaRank < 1 {
		deltaRank = 1 - userCurrentScore
	}
	_, err = session.ID(userID).Incr(""`rank`"", deltaRank).Update(&entity.User{})
	if err != nil {
		return err
	}
	return nil
}
// TriggerUserRank trigger user rank change
// session is need provider, it means this action must be success or failure
// if outer action is failed then this action is need rollback
func (ur *UserRankRepo) TriggerUserRank(ctx context.Context,
	session *xorm.Session, userID string, deltaRank int, activityType int,
) (isReachStandard bool, err error) {
	// IMPORTANT: If user center enabled the rank agent, then we should not change user rank.
	if plugin.RankAgentEnabled() || deltaRank == 0 {
		return false, nil
	}
	if deltaRank < 0 {
		// if user rank is lower than 1 after this action, then user rank will be set to 1 only.
		var isReachMin bool
		isReachMin, err = ur.checkUserMinRank(ctx, session, userID, deltaRank)
		if err != nil {
			return false, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
		}
		if isReachMin {
			_, err = session.Where(builder.Eq{""id"": userID}).Update(&entity.User{Rank: 1})
			if err != nil {
				return false, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
			}
			return true, nil
		}
	} else {
		isReachStandard, err = ur.checkUserTodayRank(ctx, session, userID, activityType)
		if err != nil {
			return false, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
		}
		if isReachStandard {
			return isReachStandard, nil
		}
	}
	_, err = session.Where(builder.Eq{""id"": userID}).Incr(""`rank`"", deltaRank).Update(&entity.User{})
	if err != nil {
		return false, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return false, nil
}
func (ur *UserRankRepo) checkUserMinRank(ctx context.Context, session *xorm.Session, userID string, deltaRank int) (
	isReachStandard bool, err error,
) {
	bean := &entity.User{ID: userID}
	_, err = session.Select(""`rank`"").Get(bean)
	if err != nil {
		return false, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	if bean.Rank+deltaRank < 1 {
		log.Infof(""user %s is rank %d out of range before rank operation"", userID, deltaRank)
		return true, nil
	}
	return
}
func (ur *UserRankRepo) checkUserTodayRank(ctx context.Context,
	session *xorm.Session, userID string, activityType int,
) (isReachStandard bool, err error) {
	// exclude daily rank
	exclude, _ := ur.configService.GetArrayStringValue(ctx, ""daily_rank_limit.exclude"")
	for _, item := range exclude {
		cfg, err := ur.configService.GetConfigByKey(ctx, item)
		if err != nil {
			return false, err
		}
		if activityType == cfg.ID {
			return false, nil
		}
	}
	// get user
	start, end := now.BeginningOfDay(), now.EndOfDay()
	session.Where(builder.Eq{""user_id"": userID})
	session.Where(builder.Eq{""cancelled"": 0})
	session.Where(builder.Between{
		Col:     ""updated_at"",
		LessVal: start,
		MoreVal: end,
	})
	earned, err := session.Sum(&entity.Activity{}, ""`rank`"")
	if err != nil {
		return false, err
	}
	// max rank
	maxDailyRank, err := ur.configService.GetIntValue(ctx, ""daily_rank_limit"")
	if err != nil {
		return false, err
	}
	if int(earned) < maxDailyRank {
		return false, nil
	}
	log.Infof(""user %s today has rank %d is reach stand %d"", userID, earned, maxDailyRank)
	return true, nil
}
func (ur *UserRankRepo) UserRankPage(ctx context.Context, userID string, page, pageSize int) (
	rankPage []*entity.Activity, total int64, err error,
) {
	rankPage = make([]*entity.Activity, 0)
	session := ur.data.DB.Context(ctx).Where(builder.Eq{""has_rank"": 1}.And(builder.Eq{""cancelled"": 0})).And(builder.Gt{""`rank`"": 0})
	session.Desc(""created_at"")
	cond := &entity.Activity{UserID: userID}
	total, err = pager.Help(page, pageSize, &rankPage, cond, session)
	if err != nil {
		err = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()
	}
	return
}
",CWE-366,197.0,0
"package schema
type VoteReq struct {
	ObjectID string `validate:""required"" form:""object_id"" json:""object_id""`  //	 id
	IsCancel bool   `validate:""omitempty"" form:""is_cancel"" json:""is_cancel""` // is cancel
	UserID   string `json:""-""`
}
type VoteResp struct {
	UpVotes    int64  `json:""up_votes""`
	DownVotes  int64  `json:""down_votes""`
	Votes      int64  `json:""votes""`
	VoteStatus string `json:""vote_status""`
}
// VoteOperationInfo vote operation info
type VoteOperationInfo struct {
	// operation object id
	ObjectID string
	// question answer comment
	ObjectType string
	// object owner user id
	ObjectCreatorUserID string
	// operation user id
	OperatingUserID string
	// vote up
	VoteUp bool
	// vote down
	VoteDown bool
	// vote activity info
	Activities []*VoteActivity
}
// VoteActivity vote activity
type VoteActivity struct {
	ActivityType   int
	ActivityUserID string
	TriggerUserID  string
	Rank           int
}
func (v *VoteActivity) HasRank() int {
	if v.Rank != 0 {
		return 1
	}
	return 0
}
type GetVoteWithPageReq struct {
	// page
	Page int `validate:""omitempty,min=1"" form:""page""`
	// page size
	PageSize int `validate:""omitempty,min=1"" form:""page_size""`
	// user id
	UserID string `json:""-""`
}
type GetVoteWithPageResp struct {
	// create time
	CreatedAt int64 `json:""created_at""`
	// object id
	ObjectID string `json:""object_id""`
	// question id
	QuestionID string `json:""question_id""`
	// answer id
	AnswerID string `json:""answer_id""`
	// object type
	ObjectType string `json:""object_type"" enums:""question,answer,tag,comment""`
	// title
	Title string `json:""title""`
	// url title
	UrlTitle string `json:""url_title""`
	// content
	Content string `json:""content""`
	// vote type
	VoteType string `json:""vote_type""`
}
",CWE-366,78.0,0
"package activity
import (
	""context""
)
// AnswerActivityRepo answer activity
type AnswerActivityRepo interface {
	AcceptAnswer(ctx context.Context,
		answerObjID, questionObjID, questionUserID, answerUserID string, isSelf bool) (err error)
	CancelAcceptAnswer(ctx context.Context,
		answerObjID, questionObjID, questionUserID, answerUserID string) (err error)
}
// AnswerActivityService user service
type AnswerActivityService struct {
	answerActivityRepo AnswerActivityRepo
}
// NewAnswerActivityService new comment service
func NewAnswerActivityService(
	answerActivityRepo AnswerActivityRepo) *AnswerActivityService {
	return &AnswerActivityService{
		answerActivityRepo: answerActivityRepo,
	}
}
// AcceptAnswer accept answer change activity
func (as *AnswerActivityService) AcceptAnswer(ctx context.Context,
	answerObjID, questionObjID, questionUserID, answerUserID string, isSelf bool) (err error) {
	return as.answerActivityRepo.AcceptAnswer(ctx, answerObjID, questionObjID, questionUserID, answerUserID, isSelf)
}
// CancelAcceptAnswer cancel accept answer change activity
func (as *AnswerActivityService) CancelAcceptAnswer(ctx context.Context,
	answerObjID, questionObjID, questionUserID, answerUserID string) (err error) {
	return as.answerActivityRepo.CancelAcceptAnswer(ctx, answerObjID, questionObjID, questionUserID, answerUserID)
}
",CWE-366,39.0,0
"package activity_common
import (
	""context""
	""time""
	""github.com/answerdev/answer/internal/entity""
	""github.com/answerdev/answer/internal/schema""
	""github.com/answerdev/answer/internal/service/activity_queue""
	""github.com/answerdev/answer/pkg/converter""
	""github.com/answerdev/answer/pkg/uid""
	""github.com/segmentfault/pacman/log""
	""xorm.io/xorm""
)
type ActivityRepo interface {
	GetActivityTypeByObjID(ctx context.Context, objectId string, action string) (activityType, rank int, hasRank int, err error)
	GetActivityTypeByObjectType(ctx context.Context, objectKey, action string) (activityType int, err error)
	GetActivity(ctx context.Context, session *xorm.Session, objectID, userID string, activityType int) (
		existsActivity *entity.Activity, exist bool, err error)
	GetUserIDObjectIDActivitySum(ctx context.Context, userID, objectID string) (int, error)
	GetActivityTypeByConfigKey(ctx context.Context, configKey string) (activityType int, err error)
	AddActivity(ctx context.Context, activity *entity.Activity) (err error)
	GetUsersWhoHasGainedTheMostReputation(
		ctx context.Context, startTime, endTime time.Time, limit int) (rankStat []*entity.ActivityUserRankStat, err error)
	GetUsersWhoHasVoteMost(
		ctx context.Context, startTime, endTime time.Time, limit int) (voteStat []*entity.ActivityUserVoteStat, err error)
}
type ActivityCommon struct {
	activityRepo         ActivityRepo
	activityQueueService activity_queue.ActivityQueueService
}
// NewActivityCommon new activity common
func NewActivityCommon(
	activityRepo ActivityRepo,
	activityQueueService activity_queue.ActivityQueueService,
) *ActivityCommon {
	activity := &ActivityCommon{
		activityRepo:         activityRepo,
		activityQueueService: activityQueueService,
	}
	activity.activityQueueService.RegisterHandler(activity.HandleActivity)
	return activity
}
// HandleActivity handle activity message
func (ac *ActivityCommon) HandleActivity(ctx context.Context, msg *schema.ActivityMsg) error {
	activityType, err := ac.activityRepo.GetActivityTypeByConfigKey(ctx, string(msg.ActivityTypeKey))
	if err != nil {
		log.Errorf(""error getting activity type %s, activity type is %d"", err, activityType)
		return err
	}
	act := &entity.Activity{
		UserID:           msg.UserID,
		TriggerUserID:    msg.TriggerUserID,
		ObjectID:         uid.DeShortID(msg.ObjectID),
		OriginalObjectID: uid.DeShortID(msg.OriginalObjectID),
		ActivityType:     activityType,
		Cancelled:        entity.ActivityAvailable,
	}
	if len(msg.RevisionID) > 0 {
		act.RevisionID = converter.StringToInt64(msg.RevisionID)
	}
	if err := ac.activityRepo.AddActivity(ctx, act); err != nil {
		return err
	}
	return nil
}
",CWE-366,72.0,0
"package config
import (
	""crypto/rand""
	""encoding/json""
	""fmt""
	""github.com/KubeOperator/kubepi/internal/model/v1/config""
	""github.com/KubeOperator/kubepi/pkg/file""
	""github.com/coreos/etcd/pkg/fileutil""
	""github.com/spf13/viper""
	""math/big""
	""strconv""
)
const configNotFoundSkipErr = ""config file not found in %s, skip""
const configReadErr = ""can not read config file %s ,%s""
const configMergeErr = ""can not merge config file, %s""
var configFilePaths = []string{
	""/etc/kubepi"",
}
func ReadConfig(c *config.Config, path ...string) error {
	v := viper.New()
	v.SetConfigName(""app"")
	v.SetConfigType(""yaml"")
	for i := range path {
		configFilePaths = append(configFilePaths, path[i])
	}
	for i := range configFilePaths {
		realDir := file.ReplaceHomeDir(configFilePaths[i])
		if exists := fileutil.Exist(realDir); !exists {
			fmt.Println(fmt.Sprintf(configNotFoundSkipErr, realDir))
			continue
		}
		v.AddConfigPath(realDir)
		if err := v.ReadInConfig(); err != nil {
			fmt.Println(fmt.Sprintf(configReadErr, realDir, err.Error()))
			continue
		}
		if err := v.MergeInConfig(); err != nil {
			fmt.Println(fmt.Sprintf(configMergeErr, configFilePaths))
		}
	}
	var configMap map[string]interface{}
	if err := v.Unmarshal(&configMap); err != nil {
		return err
	}
	str, err := json.Marshal(&configMap)
	if err != nil {
		return err
	}
	if err := json.Unmarshal(str, &c); err != nil {
		return nil
	}
	if c.Spec.Jwt.Key == """" {
		v.Set(""spec.jwt.key"", generate(32))
		if err := v.WriteConfig(); err != nil {
			return err
		}
	}
	return nil
}
func generate(length int) string {
	const base = 36
	size := big.NewInt(base)
	n := make([]byte, length)
	for i := range n {
		c, _ := rand.Int(rand.Reader, size)
		n[i] = strconv.FormatInt(c.Int64(), base)[0]
	}
	return string(n)
}
",CWE-798,80.0,0
"package config
import v1 ""github.com/KubeOperator/kubepi/internal/model/v1""
type Config struct {
	v1.BaseModel
	v1.Metadata
	Spec Spec `json:""spec""`
}
type Spec struct {
	Server  ServerConfig  `json:""server""`
	DB      DBConfig      `json:""db""`
	Session SessionConfig `json:""session""`
	Logger  LoggerConfig  `json:""logger""`
	Jwt     JwtConfig     `json:""jwt""`
	AppId   string        `json:""appId""`
}
type ServerConfig struct {
	Bind BindConfig `json:""bind""`
	SSL  SSLConfig  `json:""ssl""`
}
type BindConfig struct {
	Host string `json:""host""`
	Port int    `json:""port""`
}
type SSLConfig struct {
	Enable         bool   `json:""enable""`
	Certificate    string `json:""certificate""`
	CertificateKey string `json:""certificateKey""`
}
type LoggerConfig struct {
	Level string
}
type DBConfig struct {
	Path string `json:""path""`
}
type SessionConfig struct {
	Expires int `json:""expires""`
}
type JwtConfig struct {
	Key string `json:""key""`
}
",CWE-798,50.0,0
"package v1
import (
	""encoding/json""
	""net/http""
	""github.com/KubeOperator/KubeOperator/pkg/controller""
	""github.com/KubeOperator/KubeOperator/pkg/errorf""
	""github.com/KubeOperator/KubeOperator/pkg/middleware""
	""github.com/jinzhu/gorm""
	""github.com/kataras/iris/v12""
	""github.com/kataras/iris/v12/context""
	""github.com/kataras/iris/v12/mvc""
	""github.com/pkg/errors""
)
var AuthScope iris.Party
var WhiteScope iris.Party
func V1(parent iris.Party) {
	v1 := parent.Party(""/v1"")
	authParty := v1.Party(""/auth"")
	mvc.New(authParty.Party(""/session"")).HandleError(ErrorHandler).Handle(controller.NewSessionController())
	mvc.New(v1.Party(""/user"")).HandleError(ErrorHandler).Handle(controller.NewForgotPasswordController())
	AuthScope = v1.Party(""/"")
	AuthScope.Use(middleware.JWTMiddleware().Serve)
	AuthScope.Use(middleware.UserMiddleware)
	AuthScope.Use(middleware.RBACMiddleware())
	AuthScope.Use(middleware.PagerMiddleware)
	AuthScope.Use(middleware.ForceMiddleware)
	mvc.New(AuthScope.Party(""/clusters"")).HandleError(ErrorHandler).Handle(controller.NewClusterController())
	mvc.New(AuthScope.Party(""/credentials"")).HandleError(ErrorHandler).Handle(controller.NewCredentialController())
	mvc.New(AuthScope.Party(""/hosts"")).HandleError(ErrorHandler).Handle(controller.NewHostController())
	mvc.New(AuthScope.Party(""/users"")).HandleError(ErrorHandler).Handle(controller.NewUserController())
	mvc.New(AuthScope.Party(""/dashboard"")).HandleError(ErrorHandler).Handle(controller.NewKubePiController())
	mvc.New(AuthScope.Party(""/regions"")).HandleError(ErrorHandler).Handle(controller.NewRegionController())
	mvc.New(AuthScope.Party(""/zones"")).HandleError(ErrorHandler).Handle(controller.NewZoneController())
	mvc.New(AuthScope.Party(""/plans"")).HandleError(ErrorHandler).Handle(controller.NewPlanController())
	mvc.New(AuthScope.Party(""/settings"")).HandleError(ErrorHandler).Handle(controller.NewSystemSettingController())
	mvc.New(AuthScope.Party(""/ntp"")).HandleError(ErrorHandler).Handle(controller.NewNtpServerController())
	mvc.New(AuthScope.Party(""/logs"")).HandleError(ErrorHandler).Handle(controller.NewSystemLogController())
	mvc.New(AuthScope.Party(""/projects"")).HandleError(ErrorHandler).Handle(controller.NewProjectController())
	mvc.New(AuthScope.Party(""/clusters/provisioner"")).HandleError(ErrorHandler).Handle(controller.NewProvisionerController())
	mvc.New(AuthScope.Party(""/kubernetes"")).HandleError(ErrorHandler).Handle(controller.NewKubernetesController())
	mvc.New(AuthScope.Party(""/clusters/tool"")).HandleError(ErrorHandler).Handle(controller.NewClusterToolController())
	mvc.New(AuthScope.Party(""/backupaccounts"")).HandleError(ErrorHandler).Handle(controller.NewBackupAccountController())
	mvc.New(AuthScope.Party(""/clusters/backup"")).HandleError(ErrorHandler).Handle(controller.NewClusterBackupStrategyController())
	mvc.New(AuthScope.Party(""/clusters/monitor"")).HandleError(ErrorHandler).Handle(controller.NewMonitorController())
	mvc.New(AuthScope.Party(""/tasks"")).Handle(ErrorHandler).Handle(controller.NewTaskLogController())
	mvc.New(AuthScope.Party(""/components"")).Handle(ErrorHandler).Handle(controller.NewComponentController())
	mvc.New(AuthScope.Party(""/license"")).Handle(ErrorHandler).Handle(controller.NewLicenseController())
	mvc.New(AuthScope.Party(""/clusters/backup/files"")).HandleError(ErrorHandler).Handle(controller.NewClusterBackupFileController())
	mvc.New(AuthScope.Party(""/clusters/velero/{cluster}/{operate}"")).HandleError(ErrorHandler).Handle(controller.NewClusterVeleroBackupController())
	mvc.New(AuthScope.Party(""/manifests"")).HandleError(ErrorHandler).Handle(controller.NewManifestController())
	mvc.New(AuthScope.Party(""/vmconfigs"")).HandleError(ErrorHandler).Handle(controller.NewVmConfigController())
	mvc.New(AuthScope.Party(""/ippools"")).HandleError(ErrorHandler).Handle(controller.NewIpPoolController())
	mvc.New(AuthScope.Party(""/ippools/{name}/ips"")).HandleError(ErrorHandler).Handle(controller.NewIpController())
	mvc.New(AuthScope.Party(""/projects/{project}/resources"")).HandleError(ErrorHandler).Handle(controller.NewProjectResourceController())
	mvc.New(AuthScope.Party(""/projects/{project}/members"")).HandleError(ErrorHandler).Handle(controller.NewProjectMemberController())
	mvc.New(AuthScope.Party(""/projects/{project}/clusters/{cluster}/members"")).HandleError(ErrorHandler).Handle(controller.NewClusterMemberController())
	mvc.New(AuthScope.Party(""/projects/{project}/clusters/{cluster}/resources"")).HandleError(ErrorHandler).Handle(controller.NewClusterResourceController())
	mvc.New(AuthScope.Party(""/templates"")).HandleError(ErrorHandler).Handle(controller.NewTemplateConfigController())
	mvc.New(AuthScope.Party(""/clusters/grade"")).HandleError(ErrorHandler).Handle(controller.NewGradeController())
	mvc.New(AuthScope.Party(""/ldap"")).HandleError(ErrorHandler).Handle(controller.NewLdapController())
	mvc.New(AuthScope.Party(""/msg/accounts"")).HandleError(ErrorHandler).Handle(controller.NewMessageAccountController())
	mvc.New(AuthScope.Party(""/msg/subscribes"")).HandleError(ErrorHandler).Handle(controller.NewMessageSubscribeController())
	mvc.New(AuthScope.Party(""/user/messages"")).HandleError(ErrorHandler).Handle(controller.NewUserMsgController())
	mvc.New(AuthScope.Party(""/user/settings"")).HandleError(ErrorHandler).Handle(controller.NewUserSettingController())
	AuthScope.Get(""/clusters/kubeconfig/{name}"", downloadKubeconfig)
	WhiteScope = v1.Party(""/"")
	WhiteScope.Get(""/captcha"", generateCaptcha)
	mvc.New(WhiteScope.Party(""/theme"")).HandleError(ErrorHandler).Handle(controller.NewThemeController())
}
func ErrorHandler(ctx context.Context, err error) {
	if err != nil {
		warp := struct {
			Msg string `json:""msg""`
		}{err.Error()}
		var result string
		switch errType := err.(type) {
		case gorm.Errors:
			errorSet := make(map[string]string)
			for _, er := range errType {
				tr := ctx.Tr(er.Error())
				if tr != """" {
					errorMsg := tr
					errorSet[er.Error()] = errorMsg
				}
			}
			for _, set := range errorSet {
				result = result + set + "" ""
			}
		case error:
			switch errRoot := errors.Cause(err).(type) {
			case errorf.CErrFs:
				errs := errRoot.Get()
				for _, er := range errs {
					args := er.Args.([]interface{})
					tr := ctx.Tr(er.Msg, args...)
					if tr != """" {
						result = result + tr + ""\n ""
					}
				}
			default:
				tr := ctx.Tr(errors.Cause(err).Error())
				if tr != """" {
					result = tr
				} else {
					result = err.Error()
				}
			}
		}
		warp.Msg = result
		bf, _ := json.Marshal(&warp)
		ctx.StatusCode(http.StatusBadRequest)
		_, _ = ctx.WriteString(string(bf))
		ctx.StopExecution()
		return
	}
}
",CWE-863,123.0,0
"package command
import (
	""time""
	""github.com/zitadel/zitadel/internal/eventstore""
	""github.com/zitadel/zitadel/internal/crypto""
	""github.com/zitadel/zitadel/internal/domain""
	""github.com/zitadel/zitadel/internal/repository/user""
)
type HumanPasswordWriteModel struct {
	eventstore.WriteModel
	EncodedHash          string
	SecretChangeRequired bool
	Code                     *crypto.CryptoValue
	CodeCreationDate         time.Time
	CodeExpiry               time.Duration
	PasswordCheckFailedCount uint64
	UserState domain.UserState
}
func NewHumanPasswordWriteModel(userID, resourceOwner string) *HumanPasswordWriteModel {
	return &HumanPasswordWriteModel{
		WriteModel: eventstore.WriteModel{
			AggregateID:   userID,
			ResourceOwner: resourceOwner,
		},
	}
}
func (wm *HumanPasswordWriteModel) Reduce() error {
	for _, event := range wm.Events {
		switch e := event.(type) {
		case *user.HumanAddedEvent:
			wm.EncodedHash = user.SecretOrEncodedHash(e.Secret, e.EncodedHash)
			wm.SecretChangeRequired = e.ChangeRequired
			wm.UserState = domain.UserStateActive
		case *user.HumanRegisteredEvent:
			wm.EncodedHash = user.SecretOrEncodedHash(e.Secret, e.EncodedHash)
			wm.SecretChangeRequired = e.ChangeRequired
			wm.UserState = domain.UserStateActive
		case *user.HumanInitialCodeAddedEvent:
			wm.UserState = domain.UserStateInitial
		case *user.HumanInitializedCheckSucceededEvent:
			wm.UserState = domain.UserStateActive
		case *user.HumanPasswordChangedEvent:
			wm.EncodedHash = user.SecretOrEncodedHash(e.Secret, e.EncodedHash)
			wm.SecretChangeRequired = e.ChangeRequired
			wm.Code = nil
			wm.PasswordCheckFailedCount = 0
		case *user.HumanPasswordCodeAddedEvent:
			wm.Code = e.Code
			wm.CodeCreationDate = e.CreationDate()
			wm.CodeExpiry = e.Expiry
		case *user.HumanEmailVerifiedEvent:
			if wm.UserState == domain.UserStateInitial {
				wm.UserState = domain.UserStateActive
			}
		case *user.HumanPasswordCheckFailedEvent:
			wm.PasswordCheckFailedCount += 1
		case *user.HumanPasswordCheckSucceededEvent:
			wm.PasswordCheckFailedCount = 0
		case *user.UserLockedEvent:
			wm.UserState = domain.UserStateLocked
		case *user.UserUnlockedEvent:
			wm.PasswordCheckFailedCount = 0
			if wm.UserState != domain.UserStateDeleted {
				wm.UserState = domain.UserStateActive
			}
		case *user.UserRemovedEvent:
			wm.UserState = domain.UserStateDeleted
		case *user.HumanPasswordHashUpdatedEvent:
			wm.EncodedHash = e.EncodedHash
		}
	}
	return wm.WriteModel.Reduce()
}
func (wm *HumanPasswordWriteModel) Query() *eventstore.SearchQueryBuilder {
	query := eventstore.NewSearchQueryBuilder(eventstore.ColumnsEvent).
		AddQuery().
		AggregateTypes(user.AggregateType).
		AggregateIDs(wm.AggregateID).
		EventTypes(user.HumanAddedType,
			user.HumanRegisteredType,
			user.HumanInitialCodeAddedType,
			user.HumanInitializedCheckSucceededType,
			user.HumanPasswordChangedType,
			user.HumanPasswordCodeAddedType,
			user.HumanEmailVerifiedType,
			user.HumanPasswordCheckFailedType,
			user.HumanPasswordCheckSucceededType,
			user.HumanPasswordHashUpdatedType,
			user.UserRemovedType,
			user.UserLockedType,
			user.UserUnlockedType,
			user.UserV1AddedType,
			user.UserV1RegisteredType,
			user.UserV1InitialCodeAddedType,
			user.UserV1InitializedCheckSucceededType,
			user.UserV1PasswordChangedType,
			user.UserV1PasswordCodeAddedType,
			user.UserV1EmailVerifiedType,
			user.UserV1PasswordCheckFailedType,
			user.UserV1PasswordCheckSucceededType,
		).
		Builder()
	if wm.ResourceOwner != """" {
		query.ResourceOwner(wm.ResourceOwner)
	}
	if wm.WriteModel.ProcessedSequence != 0 {
		query.SequenceGreater(wm.WriteModel.ProcessedSequence)
	}
	return query
}
",CWE-362,122.0,0
"package query
import (
	""context""
	""time""
	""github.com/zitadel/zitadel/internal/crypto""
	""github.com/zitadel/zitadel/internal/domain""
	""github.com/zitadel/zitadel/internal/errors""
	""github.com/zitadel/zitadel/internal/eventstore""
	""github.com/zitadel/zitadel/internal/repository/user""
	""github.com/zitadel/zitadel/internal/telemetry/tracing""
)
type HumanPasswordReadModel struct {
	*eventstore.ReadModel
	EncodedHash          string
	SecretChangeRequired bool
	Code                     *crypto.CryptoValue
	CodeCreationDate         time.Time
	CodeExpiry               time.Duration
	PasswordCheckFailedCount uint64
	UserState domain.UserState
}
func (q *Queries) GetHumanPassword(ctx context.Context, orgID, userID string) (encodedHash string, err error) {
	ctx, span := tracing.NewSpan(ctx)
	defer func() { span.EndWithError(err) }()
	if userID == """" {
		return """", errors.ThrowInvalidArgument(nil, ""QUERY-4Mfsf"", ""Errors.User.UserIDMissing"")
	}
	existingPassword, err := q.passwordReadModel(ctx, userID, orgID)
	if err != nil {
		return """", errors.ThrowInternal(nil, ""QUERY-p1k1n2i"", ""Errors.User.NotFound"")
	}
	if existingPassword.UserState == domain.UserStateUnspecified || existingPassword.UserState == domain.UserStateDeleted {
		return """", errors.ThrowPreconditionFailed(nil, ""QUERY-3n77z"", ""Errors.User.NotFound"")
	}
	return existingPassword.EncodedHash, nil
}
func (q *Queries) passwordReadModel(ctx context.Context, userID, resourceOwner string) (readModel *HumanPasswordReadModel, err error) {
	ctx, span := tracing.NewSpan(ctx)
	defer func() { span.EndWithError(err) }()
	readModel = NewHumanPasswordReadModel(userID, resourceOwner)
	err = q.eventstore.FilterToQueryReducer(ctx, readModel)
	if err != nil {
		return nil, err
	}
	return readModel, nil
}
func NewHumanPasswordReadModel(userID, resourceOwner string) *HumanPasswordReadModel {
	return &HumanPasswordReadModel{
		ReadModel: &eventstore.ReadModel{
			AggregateID:   userID,
			ResourceOwner: resourceOwner,
		},
	}
}
func (rm *HumanPasswordReadModel) AppendEvents(events ...eventstore.Event) {
	rm.ReadModel.AppendEvents(events...)
}
func (wm *HumanPasswordReadModel) Reduce() error {
	for _, event := range wm.Events {
		switch e := event.(type) {
		case *user.HumanAddedEvent:
			wm.EncodedHash = user.SecretOrEncodedHash(e.Secret, e.EncodedHash)
			wm.SecretChangeRequired = e.ChangeRequired
			wm.UserState = domain.UserStateActive
		case *user.HumanRegisteredEvent:
			wm.EncodedHash = user.SecretOrEncodedHash(e.Secret, e.EncodedHash)
			wm.SecretChangeRequired = e.ChangeRequired
			wm.UserState = domain.UserStateActive
		case *user.HumanInitialCodeAddedEvent:
			wm.UserState = domain.UserStateInitial
		case *user.HumanInitializedCheckSucceededEvent:
			wm.UserState = domain.UserStateActive
		case *user.HumanPasswordChangedEvent:
			wm.EncodedHash = user.SecretOrEncodedHash(e.Secret, e.EncodedHash)
			wm.SecretChangeRequired = e.ChangeRequired
			wm.Code = nil
			wm.PasswordCheckFailedCount = 0
		case *user.HumanPasswordCodeAddedEvent:
			wm.Code = e.Code
			wm.CodeCreationDate = e.CreationDate()
			wm.CodeExpiry = e.Expiry
		case *user.HumanEmailVerifiedEvent:
			if wm.UserState == domain.UserStateInitial {
				wm.UserState = domain.UserStateActive
			}
		case *user.HumanPasswordCheckFailedEvent:
			wm.PasswordCheckFailedCount += 1
		case *user.HumanPasswordCheckSucceededEvent:
			wm.PasswordCheckFailedCount = 0
		case *user.UserLockedEvent:
			wm.UserState = domain.UserStateLocked
		case *user.UserUnlockedEvent:
			wm.PasswordCheckFailedCount = 0
			if wm.UserState != domain.UserStateDeleted {
				wm.UserState = domain.UserStateActive
			}
		case *user.UserRemovedEvent:
			wm.UserState = domain.UserStateDeleted
		case *user.HumanPasswordHashUpdatedEvent:
			wm.EncodedHash = e.EncodedHash
		}
	}
	return wm.ReadModel.Reduce()
}
func (wm *HumanPasswordReadModel) Query() *eventstore.SearchQueryBuilder {
	query := eventstore.NewSearchQueryBuilder(eventstore.ColumnsEvent).
		AwaitOpenTransactions().
		AllowTimeTravel().
		AddQuery().
		AggregateTypes(user.AggregateType).
		AggregateIDs(wm.AggregateID).
		EventTypes(user.HumanAddedType,
			user.HumanRegisteredType,
			user.HumanInitialCodeAddedType,
			user.HumanInitializedCheckSucceededType,
			user.HumanPasswordChangedType,
			user.HumanPasswordCodeAddedType,
			user.HumanEmailVerifiedType,
			user.HumanPasswordCheckFailedType,
			user.HumanPasswordCheckSucceededType,
			user.HumanPasswordHashUpdatedType,
			user.UserRemovedType,
			user.UserLockedType,
			user.UserUnlockedType,
			user.UserV1AddedType,
			user.UserV1RegisteredType,
			user.UserV1InitialCodeAddedType,
			user.UserV1InitializedCheckSucceededType,
			user.UserV1PasswordChangedType,
			user.UserV1PasswordCodeAddedType,
			user.UserV1EmailVerifiedType,
			user.UserV1PasswordCheckFailedType,
			user.UserV1PasswordCheckSucceededType,
		).
		Builder()
	if wm.ResourceOwner != """" {
		query.ResourceOwner(wm.ResourceOwner)
	}
	return query
}
",CWE-362,156.0,0
"package bitfield
// NOTE: Don't bother replacing the divisions/modulo with shifts/ands, go is smart.
import (
	""fmt""
	""math/bits""
)
// NewBitfield creates a new fixed-sized Bitfield (allocated up-front).
func NewBitfield(size int) (Bitfield, error) {
	if size < 0 {
		return nil, fmt.Errorf(""bitfield size must be positive; got %d"", size)
	}
	if size%8 != 0 {
		return nil, fmt.Errorf(""bitfield size must be a multiple of 8; got %d"", size)
	}
	return make([]byte, size/8), nil
}
// FromBytes constructs a new bitfield from a serialized bitfield.
func FromBytes(size int, bits []byte) (Bitfield, error) {
	bf, err := NewBitfield(size)
	if err != nil {
		return nil, err
	}
	start := len(bf) - len(bits)
	if start < 0 {
		return nil, fmt.Errorf(""bitfield too small: got %d; need %d"", size, len(bits)*8)
	}
	copy(bf[start:], bits)
	return bf, nil
}
func (bf Bitfield) offset(i int) (uint, uint8) {
	return uint(len(bf)) - (uint(i) / 8) - 1, uint8(i) % 8
}
// Bitfield is, well, a bitfield.
type Bitfield []byte
// Bytes returns the Bitfield as a byte string.
//
// This function *does not* copy.
func (bf Bitfield) Bytes() []byte {
	for i, b := range bf {
		if b != 0 {
			return bf[i:]
		}
	}
	return nil
}
// Bit returns the ith bit.
//
// Panics if the bit is out of bounds.
func (bf Bitfield) Bit(i int) bool {
	idx, off := bf.offset(i)
	return (bf[idx]>>off)&0x1 != 0
}
// SetBit sets the ith bit.
//
// Panics if the bit is out of bounds.
func (bf Bitfield) SetBit(i int) {
	idx, off := bf.offset(i)
	bf[idx] |= 1 << off
}
// UnsetBit unsets the ith bit.
//
// Panics if the bit is out of bounds.
func (bf Bitfield) UnsetBit(i int) {
	idx, off := bf.offset(i)
	bf[idx] &= 0xFF ^ (1 << off)
}
// SetBytes sets the bits to the given byte array.
//
// Panics if 'b' is larger than the bitfield.
func (bf Bitfield) SetBytes(b []byte) {
	start := len(bf) - len(b)
	if start < 0 {
		panic(""bitfield too small"")
	}
	for i := range bf[:start] {
		bf[i] = 0
	}
	copy(bf[start:], b)
}
// Ones returns the number of bits set.
func (bf Bitfield) Ones() int {
	cnt := 0
	for _, b := range bf {
		cnt += bits.OnesCount8(b)
	}
	return cnt
}
// OnesBefore returns the number of bits set *before* this bit.
func (bf Bitfield) OnesBefore(i int) int {
	idx, off := bf.offset(i)
	cnt := bits.OnesCount8(bf[idx] << (8 - off))
	for _, b := range bf[idx+1:] {
		cnt += bits.OnesCount8(b)
	}
	return cnt
}
// OnesAfter returns the number of bits set *after* this bit.
func (bf Bitfield) OnesAfter(i int) int {
	idx, off := bf.offset(i)
	cnt := bits.OnesCount8(bf[idx] >> off)
	for _, b := range bf[:idx] {
		cnt += bits.OnesCount8(b)
	}
	return cnt
}
",CWE-1284,120.0,0
"package hamt
// adapted from https://github.com/ipfs/go-unixfs/blob/master/hamt/util.go
import (
	""fmt""
	""math/bits""
	bitfield ""github.com/ipfs/go-bitfield""
	""github.com/ipfs/go-unixfsnode/data""
	dagpb ""github.com/ipld/go-codec-dagpb""
	""github.com/spaolacci/murmur3""
)
// hashBits is a helper that allows the reading of the 'next n bits' as an integer.
type hashBits struct {
	b        []byte
	consumed int
}
func mkmask(n int) byte {
	return (1 << uint(n)) - 1
}
// Next returns the next 'i' bits of the hashBits value as an integer, or an
// error if there aren't enough bits.
func (hb *hashBits) Next(i int) (int, error) {
	if hb.consumed+i > len(hb.b)*8 {
		return 0, ErrHAMTTooDeep
	}
	return hb.next(i), nil
}
func (hb *hashBits) next(i int) int {
	curbi := hb.consumed / 8
	leftb := 8 - (hb.consumed % 8)
	curb := hb.b[curbi]
	if i == leftb {
		out := int(mkmask(i) & curb)
		hb.consumed += i
		return out
	}
	if i < leftb {
		a := curb & mkmask(leftb) // mask out the high bits we don't want
		b := a & ^mkmask(leftb-i) // mask out the low bits we don't want
		c := b >> uint(leftb-i)   // shift whats left down
		hb.consumed += i
		return int(c)
	}
	out := int(mkmask(leftb) & curb)
	out <<= uint(i - leftb)
	hb.consumed += leftb
	out += hb.next(i - leftb)
	return out
}
func validateHAMTData(nd data.UnixFSData) error {
	if nd.FieldDataType().Int() != data.Data_HAMTShard {
		return data.ErrWrongNodeType{Expected: data.Data_HAMTShard, Actual: nd.FieldDataType().Int()}
	}
	if !nd.FieldHashType().Exists() || uint64(nd.FieldHashType().Must().Int()) != HashMurmur3 {
		return ErrInvalidHashType
	}
	if !nd.FieldData().Exists() {
		return ErrNoDataField
	}
	if !nd.FieldFanout().Exists() {
		return ErrNoFanoutField
	}
	if err := checkLogTwo(int(nd.FieldFanout().Must().Int())); err != nil {
		return err
	}
	return nil
}
func log2Size(nd data.UnixFSData) int {
	return bits.TrailingZeros(uint(nd.FieldFanout().Must().Int()))
}
func maxPadLength(nd data.UnixFSData) int {
	return len(fmt.Sprintf(""%X"", nd.FieldFanout().Must().Int()-1))
}
const maximumHamtWidth = 1 << 10
func bitField(nd data.UnixFSData) (bitfield.Bitfield, error) {
	fanout := int(nd.FieldFanout().Must().Int())
	if fanout > maximumHamtWidth {
		return nil, fmt.Errorf(""hamt witdh (%d) exceed maximum allowed (%d)"", fanout, maximumHamtWidth)
	}
	bf := bitfield.NewBitfield(fanout)
	bf.SetBytes(nd.FieldData().Must().Bytes())
	return bf, nil
}
func checkLogTwo(v int) error {
	if v <= 0 {
		return ErrHAMTSizeInvalid
	}
	lg2 := bits.TrailingZeros(uint(v))
	if 1<<uint(lg2) != v {
		return ErrHAMTSizeInvalid
	}
	return nil
}
func hash(val []byte) []byte {
	h := murmur3.New64()
	h.Write(val)
	return h.Sum(nil)
}
func isValueLink(pbLink dagpb.PBLink, maxPadLen int) (bool, error) {
	if !pbLink.FieldName().Exists() {
		return false, ErrMissingLinkName
	}
	name := pbLink.FieldName().Must().String()
	if len(name) < maxPadLen {
		return false, ErrInvalidLinkName{name}
	}
	if len(name) == maxPadLen {
		return false, nil
	}
	return true, nil
}
func MatchKey(pbLink dagpb.PBLink, key string, maxPadLen int) bool {
	return pbLink.FieldName().Must().String()[maxPadLen:] == key
}
",CWE-400,137.0,0
"module github.com/ipfs/go-unixfsnode
go 1.18
require (
	github.com/ipfs/go-bitfield v1.1.0
	github.com/ipfs/go-cid v0.3.2
	github.com/ipfs/go-ipfs-chunker v0.0.1
	github.com/ipfs/go-ipfs-util v0.0.2
	github.com/ipfs/go-ipld-format v0.2.0
	github.com/ipfs/go-merkledag v0.5.1
	github.com/ipfs/go-unixfs v0.4.3
	github.com/ipld/go-car/v2 v2.1.1
	github.com/ipld/go-codec-dagpb v1.4.1
	github.com/ipld/go-ipld-prime v0.16.0
	github.com/multiformats/go-multicodec v0.7.0
	github.com/multiformats/go-multihash v0.2.1
	github.com/spaolacci/murmur3 v1.1.0
	github.com/stretchr/testify v1.8.1
	google.golang.org/protobuf v1.28.1
)
require (
	github.com/benbjohnson/clock v1.3.0 // indirect
	github.com/davecgh/go-spew v1.1.1 // indirect
	github.com/gogo/protobuf v1.3.2 // indirect
	github.com/google/uuid v1.3.0 // indirect
	github.com/hashicorp/golang-lru v0.5.4 // indirect
	github.com/ipfs/bbloom v0.0.4 // indirect
	github.com/ipfs/go-block-format v0.0.3 // indirect
	github.com/ipfs/go-blockservice v0.2.1 // indirect
	github.com/ipfs/go-datastore v0.6.0 // indirect
	github.com/ipfs/go-ipfs-blockstore v1.1.2 // indirect
	github.com/ipfs/go-ipfs-ds-help v1.1.0 // indirect
	github.com/ipfs/go-ipfs-exchange-interface v0.1.0 // indirect
	github.com/ipfs/go-ipfs-exchange-offline v0.1.1 // indirect
	github.com/ipfs/go-ipld-cbor v0.0.5 // indirect
	github.com/ipfs/go-ipld-legacy v0.1.0 // indirect
	github.com/ipfs/go-log v1.0.5 // indirect
	github.com/ipfs/go-log/v2 v2.5.1 // indirect
	github.com/ipfs/go-metrics-interface v0.0.1 // indirect
	github.com/ipfs/go-verifcid v0.0.1 // indirect
	github.com/jbenet/goprocess v0.1.4 // indirect
	github.com/klauspost/cpuid/v2 v2.2.1 // indirect
	github.com/libp2p/go-buffer-pool v0.1.0 // indirect
	github.com/libp2p/go-libp2p v0.25.0 // indirect
	github.com/mattn/go-isatty v0.0.16 // indirect
	github.com/minio/sha256-simd v1.0.0 // indirect
	github.com/mr-tron/base58 v1.2.0 // indirect
	github.com/multiformats/go-base32 v0.1.0 // indirect
	github.com/multiformats/go-base36 v0.2.0 // indirect
	github.com/multiformats/go-multiaddr v0.8.0 // indirect
	github.com/multiformats/go-multibase v0.1.1 // indirect
	github.com/multiformats/go-varint v0.0.7 // indirect
	github.com/opentracing/opentracing-go v1.2.0 // indirect
	github.com/petar/GoLLRB v0.0.0-20210522233825-ae3b015fd3e9 // indirect
	github.com/pmezard/go-difflib v1.0.0 // indirect
	github.com/polydawn/refmt v0.0.0-20201211092308-30ac6d18308e // indirect
	github.com/whyrusleeping/cbor v0.0.0-20171005072247-63513f603b11 // indirect
	github.com/whyrusleeping/cbor-gen v0.0.0-20200123233031-1cdf64d27158 // indirect
	github.com/whyrusleeping/chunker v0.0.0-20181014151217-fe64bd25879f // indirect
	go.uber.org/atomic v1.10.0 // indirect
	go.uber.org/multierr v1.8.0 // indirect
	go.uber.org/zap v1.24.0 // indirect
	golang.org/x/crypto v0.4.0 // indirect
	golang.org/x/exp v0.0.0-20221205204356-47842c84f3db // indirect
	golang.org/x/sync v0.1.0 // indirect
	golang.org/x/sys v0.3.0 // indirect
	golang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
	lukechampine.com/blake3 v1.1.7 // indirect
)
",CWE-400,73.0,0
"package hamt
// adapted from https://github.com/ipfs/go-unixfs/blob/master/hamt/util.go
import (
	""fmt""
	""math/bits""
	bitfield ""github.com/ipfs/go-bitfield""
	""github.com/ipfs/go-unixfsnode/data""
	dagpb ""github.com/ipld/go-codec-dagpb""
	""github.com/spaolacci/murmur3""
)
// hashBits is a helper that allows the reading of the 'next n bits' as an integer.
type hashBits struct {
	b        []byte
	consumed int
}
func mkmask(n int) byte {
	return (1 << uint(n)) - 1
}
// Next returns the next 'i' bits of the hashBits value as an integer, or an
// error if there aren't enough bits.
func (hb *hashBits) Next(i int) (int, error) {
	if hb.consumed+i > len(hb.b)*8 {
		return 0, ErrHAMTTooDeep
	}
	return hb.next(i), nil
}
func (hb *hashBits) next(i int) int {
	curbi := hb.consumed / 8
	leftb := 8 - (hb.consumed % 8)
	curb := hb.b[curbi]
	if i == leftb {
		out := int(mkmask(i) & curb)
		hb.consumed += i
		return out
	}
	if i < leftb {
		a := curb & mkmask(leftb) // mask out the high bits we don't want
		b := a & ^mkmask(leftb-i) // mask out the low bits we don't want
		c := b >> uint(leftb-i)   // shift whats left down
		hb.consumed += i
		return int(c)
	}
	out := int(mkmask(leftb) & curb)
	out <<= uint(i - leftb)
	hb.consumed += leftb
	out += hb.next(i - leftb)
	return out
}
func validateHAMTData(nd data.UnixFSData) error {
	if nd.FieldDataType().Int() != data.Data_HAMTShard {
		return data.ErrWrongNodeType{Expected: data.Data_HAMTShard, Actual: nd.FieldDataType().Int()}
	}
	if !nd.FieldHashType().Exists() || uint64(nd.FieldHashType().Must().Int()) != HashMurmur3 {
		return ErrInvalidHashType
	}
	if !nd.FieldData().Exists() {
		return ErrNoDataField
	}
	if !nd.FieldFanout().Exists() {
		return ErrNoFanoutField
	}
	if err := checkLogTwo(int(nd.FieldFanout().Must().Int())); err != nil {
		return err
	}
	return nil
}
func log2Size(nd data.UnixFSData) int {
	return bits.TrailingZeros(uint(nd.FieldFanout().Must().Int()))
}
func maxPadLength(nd data.UnixFSData) int {
	return len(fmt.Sprintf(""%X"", nd.FieldFanout().Must().Int()-1))
}
const maximumHamtWidth = 1 << 10
func bitField(nd data.UnixFSData) (bitfield.Bitfield, error) {
	fanout := int(nd.FieldFanout().Must().Int())
	if fanout > maximumHamtWidth {
		return nil, fmt.Errorf(""hamt witdh (%d) exceed maximum allowed (%d)"", fanout, maximumHamtWidth)
	}
	bf, err := bitfield.NewBitfield(fanout)
	if err != nil {
		return nil, err
	}
	bf.SetBytes(nd.FieldData().Must().Bytes())
	return bf, nil
}
func checkLogTwo(v int) error {
	if v <= 0 {
		return ErrHAMTSizeInvalid
	}
	lg2 := bits.TrailingZeros(uint(v))
	if 1<<uint(lg2) != v {
		return ErrHAMTSizeInvalid
	}
	return nil
}
func hash(val []byte) []byte {
	h := murmur3.New64()
	h.Write(val)
	return h.Sum(nil)
}
func isValueLink(pbLink dagpb.PBLink, maxPadLen int) (bool, error) {
	if !pbLink.FieldName().Exists() {
		return false, ErrMissingLinkName
	}
	name := pbLink.FieldName().Must().String()
	if len(name) < maxPadLen {
		return false, ErrInvalidLinkName{name}
	}
	if len(name) == maxPadLen {
		return false, nil
	}
	return true, nil
}
func MatchKey(pbLink dagpb.PBLink, key string, maxPadLen int) bool {
	return pbLink.FieldName().Must().String()[maxPadLen:] == key
}
",CWE-400,140.0,0
"// Copyright 2022 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//go:build !purego && (amd64 || arm64)
package nistec
import ""errors""
// Montgomery multiplication modulo org(G). Sets res = in1 * in2 * R⁻¹.
//
//go:noescape
func p256OrdMul(res, in1, in2 *p256OrdElement)
// Montgomery square modulo org(G), repeated n times (n >= 1).
//
//go:noescape
func p256OrdSqr(res, in *p256OrdElement, n int)
func p256OrdInverse(k []byte) ([]byte, error) {
	if len(k) != 32 {
		return nil, errors.New(""invalid scalar length"")
	}
	x := new(p256OrdElement)
	p256OrdBigToLittle(x, (*[32]byte)(k))
	p256OrdReduce(x)
	// Inversion is implemented as exponentiation by n - 2, per Fermat's little theorem.
	//
	// The sequence of 38 multiplications and 254 squarings is derived from
	// https://briansmith.org/ecc-inversion-addition-chains-01
	_1 := new(p256OrdElement)
	_11 := new(p256OrdElement)
	_101 := new(p256OrdElement)
	_111 := new(p256OrdElement)
	_1111 := new(p256OrdElement)
	_10101 := new(p256OrdElement)
	_101111 := new(p256OrdElement)
	t := new(p256OrdElement)
	// This code operates in the Montgomery domain where R = 2²⁵⁶ mod n and n is
	// the order of the scalar field. Elements in the Montgomery domain take the
	// form a×R and p256OrdMul calculates (a × b × R⁻¹) mod n. RR is R in the
	// domain, or R×R mod n, thus p256OrdMul(x, RR) gives x×R, i.e. converts x
	// into the Montgomery domain.
	RR := &p256OrdElement{0x83244c95be79eea2, 0x4699799c49bd6fa6,
		0x2845b2392b6bec59, 0x66e12d94f3d95620}
	p256OrdMul(_1, x, RR)      // _1
	p256OrdSqr(x, _1, 1)       // _10
	p256OrdMul(_11, x, _1)     // _11
	p256OrdMul(_101, x, _11)   // _101
	p256OrdMul(_111, x, _101)  // _111
	p256OrdSqr(x, _101, 1)     // _1010
	p256OrdMul(_1111, _101, x) // _1111
	p256OrdSqr(t, x, 1)          // _10100
	p256OrdMul(_10101, t, _1)    // _10101
	p256OrdSqr(x, _10101, 1)     // _101010
	p256OrdMul(_101111, _101, x) // _101111
	p256OrdMul(x, _10101, x)     // _111111 = x6
	p256OrdSqr(t, x, 2)          // _11111100
	p256OrdMul(t, t, _11)        // _11111111 = x8
	p256OrdSqr(x, t, 8)          // _ff00
	p256OrdMul(x, x, t)          // _ffff = x16
	p256OrdSqr(t, x, 16)         // _ffff0000
	p256OrdMul(t, t, x)          // _ffffffff = x32
	p256OrdSqr(x, t, 64)
	p256OrdMul(x, x, t)
	p256OrdSqr(x, x, 32)
	p256OrdMul(x, x, t)
	sqrs := []int{
		6, 5, 4, 5, 5,
		4, 3, 3, 5, 9,
		6, 2, 5, 6, 5,
		4, 5, 5, 3, 10,
		2, 5, 5, 3, 7, 6}
	muls := []*p256OrdElement{
		_101111, _111, _11, _1111, _10101,
		_101, _101, _101, _111, _101111,
		_1111, _1, _1, _1111, _111,
		_111, _111, _101, _11, _101111,
		_11, _11, _11, _1, _10101, _1111}
	for i, s := range sqrs {
		p256OrdSqr(x, x, s)
		p256OrdMul(x, x, muls[i])
	}
	// Montgomery multiplication by R⁻¹, or 1 outside the domain as R⁻¹×R = 1,
	// converts a Montgomery value out of the domain.
	one := &p256OrdElement{1}
	p256OrdMul(x, x, one)
	var xOut [32]byte
	p256OrdLittleToBig(&xOut, x)
	return xOut[:], nil
}
",CWE-682,103.0,0
"package paranoidhttp
import (
	""context""
	""errors""
	""fmt""
	""net""
	""net/http""
	""regexp""
	""time""
)
// Config stores the rules for allowing IP/hosts
type config struct {
	ForbiddenIPNets []*net.IPNet
	PermittedIPNets []*net.IPNet
	ForbiddenHosts  []*regexp.Regexp
}
// DefaultClient is the default Client whose setting is the same as http.DefaultClient.
var (
	defaultConfig config
	DefaultClient *http.Client
)
func mustParseCIDR(addr string) *net.IPNet {
	_, ipnet, err := net.ParseCIDR(addr)
	if err != nil {
		panic(`net: ParseCIDR(""` + addr + `""): ` + err.Error())
	}
	return ipnet
}
func init() {
	defaultConfig = config{
		ForbiddenIPNets: []*net.IPNet{
			mustParseCIDR(""10.0.0.0/8""),     // private class A
			mustParseCIDR(""172.16.0.0/12""),  // private class B
			mustParseCIDR(""192.168.0.0/16""), // private class C
			mustParseCIDR(""192.0.2.0/24""),   // test net 1
			mustParseCIDR(""192.88.99.0/24""), // 6to4 relay
		},
		ForbiddenHosts: []*regexp.Regexp{
			regexp.MustCompile(`(?i)^localhost$`),
			regexp.MustCompile(`(?i)\s+`),
		},
	}
	DefaultClient, _, _ = NewClient()
}
// isHostForbidden checks whether a hostname is forbidden by the Config
func (c *config) isHostForbidden(host string) bool {
	for _, forbiddenHost := range c.ForbiddenHosts {
		if forbiddenHost.MatchString(host) {
			return true
		}
	}
	return false
}
// isIPForbidden checks whether an IP address is forbidden by the Config
func (c *config) isIPForbidden(ip net.IP) bool {
	for _, permittedIPNet := range c.PermittedIPNets {
		if permittedIPNet.Contains(ip) {
			return false
		}
	}
	if ip.Equal(net.IPv4bcast) || !ip.IsGlobalUnicast() {
		return true
	}
	for _, forbiddenIPNet := range c.ForbiddenIPNets {
		if forbiddenIPNet.Contains(ip) {
			return true
		}
	}
	return false
}
// BasicConfig contains the most common hosts and IPs to be blocked
func basicConfig() *config {
	c := defaultConfig // copy to return clone
	return &c
}
// Option type of paranoidhttp
type Option func(*config)
// ForbiddenIPNets sets forbidden IPNets
func ForbiddenIPNets(ips ...*net.IPNet) Option {
	return func(c *config) {
		c.ForbiddenIPNets = ips
	}
}
// PermittedIPNets sets permitted IPNets
// It takes priority over other forbidden rules.
func PermittedIPNets(ips ...*net.IPNet) Option {
	return func(c *config) {
		c.PermittedIPNets = ips
	}
}
// ForbiddenHosts set forbidden host rules by regexp
func ForbiddenHosts(hostRegs ...*regexp.Regexp) Option {
	return func(c *config) {
		c.ForbiddenHosts = hostRegs
	}
}
func safeAddr(ctx context.Context, resolver *net.Resolver, hostport string, opts ...Option) (string, error) {
	c := basicConfig()
	for _, opt := range opts {
		opt(c)
	}
	host, port, err := net.SplitHostPort(hostport)
	if err != nil {
		return """", err
	}
	ip := net.ParseIP(host)
	if ip != nil {
		if ip.IsUnspecified() || (ip.To4() != nil && c.isIPForbidden(ip)) {
			return """", fmt.Errorf(""bad ip is detected: %v"", ip)
		}
		return net.JoinHostPort(ip.String(), port), nil
	}
	if c.isHostForbidden(host) {
		return """", fmt.Errorf(""bad host is detected: %v"", host)
	}
	r := resolver
	if r == nil {
		r = net.DefaultResolver
	}
	addrs, err := r.LookupIPAddr(ctx, host)
	if err != nil || len(addrs) <= 0 {
		return """", err
	}
	safeAddrs := make([]net.IPAddr, 0, len(addrs))
	for _, addr := range addrs {
		// only support IPv4 address
		if addr.IP.To4() == nil {
			continue
		}
		if c.isIPForbidden(addr.IP) {
			return """", fmt.Errorf(""bad ip is detected: %v"", addr.IP)
		}
		safeAddrs = append(safeAddrs, addr)
	}
	if len(safeAddrs) == 0 {
		return """", fmt.Errorf(""fail to lookup ip addr: %v"", host)
	}
	return net.JoinHostPort(safeAddrs[0].IP.String(), port), nil
}
// NewDialer returns a dialer function which only accepts IPv4 connections.
//
// This is used to create a new paranoid http.Client,
// because I'm not sure about a paranoid behavior for IPv6 connections :(
func NewDialer(dialer *net.Dialer, opts ...Option) func(ctx context.Context, network, addr string) (net.Conn, error) {
	return func(ctx context.Context, network, hostport string) (net.Conn, error) {
		switch network {
		case ""tcp"", ""tcp4"":
			addr, err := safeAddr(ctx, dialer.Resolver, hostport, opts...)
			if err != nil {
				return nil, err
			}
			return dialer.DialContext(ctx, ""tcp4"", addr)
		default:
			return nil, errors.New(""does not support any networks except tcp4"")
		}
	}
}
// NewClient returns a new http.Client configured to be paranoid for attackers.
//
// This also returns http.Tranport and net.Dialer so that you can customize those behavior.
func NewClient(opts ...Option) (*http.Client, *http.Transport, *net.Dialer) {
	dialer := &net.Dialer{
		Timeout:   30 * time.Second,
		KeepAlive: 30 * time.Second,
	}
	transport := &http.Transport{
		Proxy:               http.ProxyFromEnvironment,
		DialContext:         NewDialer(dialer, opts...),
		TLSHandshakeTimeout: 10 * time.Second,
	}
	return &http.Client{
		Timeout:   30 * time.Second,
		Transport: transport,
	}, transport, dialer
}
",CWE-918,196.0,0
"package paranoidhttp
import (
	""net""
	""testing""
)
func TestRequest(t *testing.T) {
	resp, err := DefaultClient.Get(""http://www.example.org"")
	if err != nil && resp.StatusCode == 200 {
		t.Error(""The request with an ordinal url should be successful"")
	}
	resp, err = DefaultClient.Get(""http://localhost"")
	if err == nil {
		t.Errorf(""The request for localhost should be fail"")
	}
	if _, err := DefaultClient.Get(""http://192.168.0.1""); err == nil {
		t.Errorf(""The request for localhost should be fail"")
	}
	if _, err := DefaultClient.Get(""http://[::]""); err == nil {
		t.Errorf(""The request for IPv6 unspecified address should be fail"")
	}
}
func TestIsHostForbidden(t *testing.T) {
	badHosts := []string{
		""localhost"",
		""host has space"",
	}
	for _, h := range badHosts {
		if !basicConfig().isHostForbidden(h) {
			t.Errorf(""%s should be forbidden"", h)
		}
	}
	notBadHosts := []string{
		""www.hatena.ne.jp"",
		""www.google.com"",
		""xn--t8jx73hngb.jp"",
	}
	for _, h := range notBadHosts {
		if basicConfig().isHostForbidden(h) {
			t.Errorf(""%s should not be forbidden"", h)
		}
	}
}
func TestIsIpForbidden(t *testing.T) {
	badIPs := []string{
		""0.0.0.0"",                      // Unspecified
		""127.0.0.0"", ""127.255.255.255"", // Loopback
		""10.0.0.0"", ""10.255.255.255"", // Private A
		""172.16.0.0"", ""172.31.255.255"", // Private B
		""192.168.0.0"", ""192.168.255.255"", // Private C
		""192.0.2.0"", ""192.0.2.255"", // Test-Net
		""192.88.99.0"", ""192.88.99.255"", // 6to4 relay
		""224.0.0.0"", ""239.255.255.255"", // Multicast
		""169.254.0.0"", ""169.254.255.255"", // Link local
	}
	for _, ip := range badIPs {
		if !basicConfig().isIPForbidden(net.ParseIP(ip)) {
			t.Errorf(""%s should be forbidden"", ip)
		}
	}
	notBadIPs := []string{
		""0.0.0.1"", ""8.8.8.8"",
		""126.255.255.255"", ""128.0.0.0"",
		""9.255.255.255"", ""11.0.0.0"",
		""172.15.255.255"", ""172.32.0.0"",
		""192.167.255.255"", ""192.169.0.0"",
		""192.88.98.255"", ""192.88.100.0"",
		""223.255.255.255"", ""240.0.0.0"",
		""169.253.255.255"", ""169.255.0.0"",
	}
	for _, ip := range notBadIPs {
		if basicConfig().isIPForbidden(net.ParseIP(ip)) {
			t.Errorf(""%s should not be forbidden"", ip)
		}
	}
	c := basicConfig()
	ip := ""172.18.0.1""
	if !c.isIPForbidden(net.ParseIP(ip)) {
		t.Errorf(""%s should be forbidden"", ip)
	}
	c.PermittedIPNets = append(c.PermittedIPNets, mustParseCIDR(""172.18.0.1/32""))
	if c.isIPForbidden(net.ParseIP(ip)) {
		t.Errorf(""%s should not be forbidden"", ip)
	}
}
",CWE-918,100.0,0
"package config
import ""github.com/spf13/viper""
type attest struct {
	// IMPORTANT: do not show the attestation key/password in any YAML/JSON output (sensitive information)
	Key      string `yaml:""-"" json:""-"" mapstructure:""key""`
	Password string `yaml:""-"" json:""-"" mapstructure:""password""`
}
func (cfg attest) loadDefaultValues(v *viper.Viper) {
	v.SetDefault(""attest.key"", """")
	v.SetDefault(""attest.password"", """")
}
",CWE-532,15.0,0
"package defaults
import (
	""time""
)
const (
	// these requests take at _least_ two minutes at the moment.
	ProvideTimeout  = time.Minute * 3
	ProvSearchDelay = time.Second
	// Number of concurrent workers in decision engine that process requests to the blockstore
	BitswapEngineBlockstoreWorkerCount = 128
	// the total number of simultaneous threads sending outgoing messages
	BitswapTaskWorkerCount = 8
	// how many worker threads to start for decision engine task worker
	BitswapEngineTaskWorkerCount = 8
	// the total amount of bytes that a peer should have outstanding, it is utilized by the decision engine
	BitswapMaxOutstandingBytesPerPeer = 1 << 20
	// the number of bytes we attempt to make each outgoing bitswap message
	BitswapEngineTargetMessageSize = 16 * 1024
	// HasBlockBufferSize is the buffer size of the channel for new blocks
	// that need to be provided. They should get pulled over by the
	// provideCollector even before they are actually provided.
	// TODO: Does this need to be this large givent that?
	HasBlockBufferSize = 256
	// Maximum size of the wantlist we are willing to keep in memory.
	MaxQueuedWantlistEntiresPerPeer = 1024
)
",CWE-770,31.0,0
"package bitswap
import (
	""time""
	delay ""github.com/ipfs/go-ipfs-delay""
	""github.com/ipfs/go-libipfs/bitswap/client""
	""github.com/ipfs/go-libipfs/bitswap/server""
	""github.com/ipfs/go-libipfs/bitswap/tracer""
)
type option func(*Bitswap)
// Option is interface{} of server.Option or client.Option or func(*Bitswap)
// wrapped in a struct to gain strong type checking.
type Option struct {
	v interface{}
}
func EngineBlockstoreWorkerCount(count int) Option {
	return Option{server.EngineBlockstoreWorkerCount(count)}
}
func EngineTaskWorkerCount(count int) Option {
	return Option{server.EngineTaskWorkerCount(count)}
}
func MaxOutstandingBytesPerPeer(count int) Option {
	return Option{server.MaxOutstandingBytesPerPeer(count)}
}
func MaxQueuedWantlistEntriesPerPeer(count uint) Option {
	return Option{server.MaxQueuedWantlistEntriesPerPeer(count)}
}
func TaskWorkerCount(count int) Option {
	return Option{server.TaskWorkerCount(count)}
}
func ProvideEnabled(enabled bool) Option {
	return Option{server.ProvideEnabled(enabled)}
}
func SetSendDontHaves(send bool) Option {
	return Option{server.SetSendDontHaves(send)}
}
func WithPeerBlockRequestFilter(pbrf server.PeerBlockRequestFilter) Option {
	return Option{server.WithPeerBlockRequestFilter(pbrf)}
}
func WithScoreLedger(scoreLedger server.ScoreLedger) Option {
	return Option{server.WithScoreLedger(scoreLedger)}
}
func WithTargetMessageSize(tms int) Option {
	return Option{server.WithTargetMessageSize(tms)}
}
func WithTaskComparator(comparator server.TaskComparator) Option {
	return Option{server.WithTaskComparator(comparator)}
}
func ProviderSearchDelay(newProvSearchDelay time.Duration) Option {
	return Option{client.ProviderSearchDelay(newProvSearchDelay)}
}
func RebroadcastDelay(newRebroadcastDelay delay.D) Option {
	return Option{client.RebroadcastDelay(newRebroadcastDelay)}
}
func SetSimulateDontHavesOnTimeout(send bool) Option {
	return Option{client.SetSimulateDontHavesOnTimeout(send)}
}
func WithTracer(tap tracer.Tracer) Option {
	// Only trace the server, both receive the same messages anyway
	return Option{
		option(func(bs *Bitswap) {
			bs.tracer = tap
		}),
	}
}
",CWE-770,84.0,0
"package decision
import (
	wl ""github.com/ipfs/go-libipfs/bitswap/client/wantlist""
	pb ""github.com/ipfs/go-libipfs/bitswap/message/pb""
	""github.com/ipfs/go-cid""
	""github.com/libp2p/go-libp2p/core/peer""
)
type peerLedger struct {
	// thoses two maps are inversions of each other
	peers map[peer.ID]map[cid.Cid]entry
	cids  map[cid.Cid]map[peer.ID]entry
}
func newPeerLedger() *peerLedger {
	return &peerLedger{
		peers: make(map[peer.ID]map[cid.Cid]entry),
		cids:  make(map[cid.Cid]map[peer.ID]entry),
	}
}
func (l *peerLedger) Wants(p peer.ID, e wl.Entry) {
	cids, ok := l.peers[p]
	if !ok {
		cids = make(map[cid.Cid]entry)
		l.peers[p] = cids
	}
	cids[e.Cid] = entry{e.Priority, e.WantType}
	m, ok := l.cids[e.Cid]
	if !ok {
		m = make(map[peer.ID]entry)
		l.cids[e.Cid] = m
	}
	m[p] = entry{e.Priority, e.WantType}
}
// CancelWant returns true if the cid was present in the wantlist.
func (l *peerLedger) CancelWant(p peer.ID, k cid.Cid) bool {
	wants, ok := l.peers[p]
	if !ok {
		return false
	}
	delete(wants, k)
	if len(wants) == 0 {
		delete(l.peers, p)
	}
	l.removePeerFromCid(p, k)
	return true
}
// CancelWantWithType will not cancel WantBlock if we sent a HAVE message.
func (l *peerLedger) CancelWantWithType(p peer.ID, k cid.Cid, typ pb.Message_Wantlist_WantType) {
	wants, ok := l.peers[p]
	if !ok {
		return
	}
	e, ok := wants[k]
	if !ok {
		return
	}
	if typ == pb.Message_Wantlist_Have && e.WantType == pb.Message_Wantlist_Block {
		return
	}
	delete(wants, k)
	if len(wants) == 0 {
		delete(l.peers, p)
	}
	l.removePeerFromCid(p, k)
}
func (l *peerLedger) removePeerFromCid(p peer.ID, k cid.Cid) {
	m, ok := l.cids[k]
	if !ok {
		return
	}
	delete(m, p)
	if len(m) == 0 {
		delete(l.cids, k)
	}
}
type entryForPeer struct {
	Peer peer.ID
	entry
}
type entry struct {
	Priority int32
	WantType pb.Message_Wantlist_WantType
}
func (l *peerLedger) Peers(k cid.Cid) []entryForPeer {
	m, ok := l.cids[k]
	if !ok {
		return nil
	}
	peers := make([]entryForPeer, 0, len(m))
	for p, e := range m {
		peers = append(peers, entryForPeer{p, e})
	}
	return peers
}
func (l *peerLedger) CollectPeerIDs() []peer.ID {
	peers := make([]peer.ID, 0, len(l.peers))
	for p := range l.peers {
		peers = append(peers, p)
	}
	return peers
}
func (l *peerLedger) WantlistSizeForPeer(p peer.ID) int {
	return len(l.peers[p])
}
func (l *peerLedger) WantlistForPeer(p peer.ID) []wl.Entry {
	cids, ok := l.peers[p]
	if !ok {
		return nil
	}
	entries := make([]wl.Entry, 0, len(l.cids))
	for c, e := range cids {
		entries = append(entries, wl.Entry{
			Cid:      c,
			Priority: e.Priority,
			WantType: e.WantType,
		})
	}
	return entries
}
// ClearPeerWantlist does not take an effort to fully erase it from memory.
// This is intended when the peer is still connected and the map capacity could
// be reused. If the memory should be freed use PeerDisconnected instead.
func (l *peerLedger) ClearPeerWantlist(p peer.ID) {
	cids, ok := l.peers[p]
	if !ok {
		return
	}
	for c := range cids {
		l.removePeerFromCid(p, c)
	}
}
func (l *peerLedger) PeerDisconnected(p peer.ID) {
	l.ClearPeerWantlist(p)
	delete(l.peers, p)
}
",CWE-770,157.0,0
"module github.com/ipfs/go-libipfs
go 1.19
require (
	github.com/benbjohnson/clock v1.3.0
	github.com/cespare/xxhash v1.1.0
	github.com/crackcomm/go-gitignore v0.0.0-20170627025303-887ab5e44cc3
	github.com/cskr/pubsub v1.0.2
	github.com/dustin/go-humanize v1.0.0
	github.com/gabriel-vasile/mimetype v1.4.1
	github.com/gogo/protobuf v1.3.2
	github.com/google/uuid v1.3.0
	github.com/gorilla/mux v1.8.0
	github.com/ipfs/go-blockservice v0.5.0
	github.com/ipfs/go-cid v0.3.2
	github.com/ipfs/go-datastore v0.6.0
	github.com/ipfs/go-detect-race v0.0.1
	github.com/ipfs/go-fetcher v1.6.1
	github.com/ipfs/go-ipfs-blockstore v1.2.0
	github.com/ipfs/go-ipfs-blocksutil v0.0.1
	github.com/ipfs/go-ipfs-delay v0.0.1
	github.com/ipfs/go-ipfs-exchange-interface v0.2.0
	github.com/ipfs/go-ipfs-exchange-offline v0.3.0
	github.com/ipfs/go-ipfs-redirects-file v0.1.1
	github.com/ipfs/go-ipfs-routing v0.3.0
	github.com/ipfs/go-ipfs-util v0.0.2
	github.com/ipfs/go-ipld-format v0.4.0
	github.com/ipfs/go-ipns v0.3.0
	github.com/ipfs/go-log v1.0.5
	github.com/ipfs/go-log/v2 v2.5.1
	github.com/ipfs/go-merkledag v0.9.0
	github.com/ipfs/go-metrics-interface v0.0.1
	github.com/ipfs/go-namesys v0.7.0
	github.com/ipfs/go-path v0.3.0
	github.com/ipfs/go-peertaskqueue v0.8.1
	github.com/ipfs/go-unixfs v0.3.1
	github.com/ipfs/go-unixfsnode v1.5.1
	github.com/ipfs/interface-go-ipfs-core v0.10.0
	github.com/ipld/go-car v0.5.0
	github.com/ipld/go-car/v2 v2.5.1
	github.com/ipld/go-codec-dagpb v1.5.0
	github.com/ipld/go-ipld-prime v0.19.0
	github.com/jbenet/goprocess v0.1.4
	github.com/libp2p/go-buffer-pool v0.1.0
	github.com/libp2p/go-libp2p v0.25.1
	github.com/libp2p/go-libp2p-record v0.2.0
	github.com/libp2p/go-libp2p-testing v0.12.0
	github.com/libp2p/go-msgio v0.3.0
	github.com/miekg/dns v1.1.50
	github.com/multiformats/go-multiaddr v0.8.0
	github.com/multiformats/go-multibase v0.1.1
	github.com/multiformats/go-multicodec v0.7.0
	github.com/multiformats/go-multihash v0.2.1
	github.com/multiformats/go-multistream v0.4.1
	github.com/prometheus/client_golang v1.14.0
	github.com/samber/lo v1.36.0
	github.com/stretchr/testify v1.8.1
	go.opencensus.io v0.24.0
	go.opentelemetry.io/otel v1.7.0
	go.opentelemetry.io/otel/trace v1.7.0
	go.uber.org/multierr v1.9.0
	go.uber.org/zap v1.24.0
	golang.org/x/sys v0.4.0
)
require (
	github.com/alecthomas/units v0.0.0-20210927113745-59d0afb8317a // indirect
	github.com/beorn7/perks v1.0.1 // indirect
	github.com/cespare/xxhash/v2 v2.2.0 // indirect
	github.com/davecgh/go-spew v1.1.1 // indirect
	github.com/decred/dcrd/dcrec/secp256k1/v4 v4.1.0 // indirect
	github.com/go-logr/logr v1.2.3 // indirect
	github.com/go-logr/stdr v1.2.2 // indirect
	github.com/golang/protobuf v1.5.2 // indirect
	github.com/google/gopacket v1.1.19 // indirect
	github.com/hashicorp/errwrap v1.1.0 // indirect
	github.com/hashicorp/go-multierror v1.1.1 // indirect
	github.com/hashicorp/golang-lru v0.5.4 // indirect
	github.com/huin/goupnp v1.0.3 // indirect
	github.com/ipfs/bbloom v0.0.4 // indirect
	github.com/ipfs/go-bitfield v1.0.0 // indirect
	github.com/ipfs/go-block-format v0.1.1 // indirect
	github.com/ipfs/go-ipfs-ds-help v1.1.0 // indirect
	github.com/ipfs/go-ipfs-files v0.3.0 // indirect
	github.com/ipfs/go-ipfs-pq v0.0.3 // indirect
	github.com/ipfs/go-ipld-cbor v0.0.6 // indirect
	github.com/ipfs/go-ipld-legacy v0.1.1 // indirect
	github.com/ipfs/go-verifcid v0.0.2 // indirect
	github.com/jackpal/go-nat-pmp v1.0.2 // indirect
	github.com/klauspost/cpuid/v2 v2.2.3 // indirect
	github.com/koron/go-ssdp v0.0.3 // indirect
	github.com/libp2p/go-cidranger v1.1.0 // indirect
	github.com/libp2p/go-libp2p-asn-util v0.2.0 // indirect
	github.com/libp2p/go-libp2p-kad-dht v0.21.0 // indirect
	github.com/libp2p/go-libp2p-kbucket v0.5.0 // indirect
	github.com/libp2p/go-nat v0.1.0 // indirect
	github.com/libp2p/go-netroute v0.2.1 // indirect
	github.com/mattn/go-isatty v0.0.17 // indirect
	github.com/matttproud/golang_protobuf_extensions v1.0.4 // indirect
	github.com/minio/sha256-simd v1.0.0 // indirect
	github.com/mr-tron/base58 v1.2.0 // indirect
	github.com/multiformats/go-base32 v0.1.0 // indirect
	github.com/multiformats/go-base36 v0.2.0 // indirect
	github.com/multiformats/go-multiaddr-dns v0.3.1 // indirect
	github.com/multiformats/go-multiaddr-fmt v0.1.0 // indirect
	github.com/multiformats/go-varint v0.0.7 // indirect
	github.com/opentracing/opentracing-go v1.2.0 // indirect
	github.com/petar/GoLLRB v0.0.0-20210522233825-ae3b015fd3e9 // indirect
	github.com/pkg/errors v0.9.1 // indirect
	github.com/pmezard/go-difflib v1.0.0 // indirect
	github.com/polydawn/refmt v0.89.0 // indirect
	github.com/prometheus/client_model v0.3.0 // indirect
	github.com/prometheus/common v0.37.0 // indirect
	github.com/prometheus/procfs v0.8.0 // indirect
	github.com/spaolacci/murmur3 v1.1.0 // indirect
	github.com/stretchr/objx v0.5.0 // indirect
	github.com/ucarion/urlpath v0.0.0-20200424170820-7ccc79b76bbb // indirect
	github.com/whyrusleeping/base32 v0.0.0-20170828182744-c30ac30633cc // indirect
	github.com/whyrusleeping/cbor v0.0.0-20171005072247-63513f603b11 // indirect
	github.com/whyrusleeping/cbor-gen v0.0.0-20230126041949-52956bd4c9aa // indirect
	github.com/whyrusleeping/go-keyspace v0.0.0-20160322163242-5b898ac5add1 // indirect
	go.uber.org/atomic v1.10.0 // indirect
	golang.org/x/crypto v0.5.0 // indirect
	golang.org/x/exp v0.0.0-20230129154200-a960b3787bd2 // indirect
	golang.org/x/mod v0.7.0 // indirect
	golang.org/x/net v0.5.0 // indirect
	golang.org/x/sync v0.1.0 // indirect
	golang.org/x/tools v0.3.0 // indirect
	golang.org/x/xerrors v0.0.0-20220907171357-04be3eba64a2 // indirect
	google.golang.org/protobuf v1.28.1 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
	lukechampine.com/blake3 v1.1.7 // indirect
)
",CWE-770,135.0,0
"package defaults
import (
	""encoding/binary""
	""time""
)
const (
	// these requests take at _least_ two minutes at the moment.
	ProvideTimeout  = time.Minute * 3
	ProvSearchDelay = time.Second
	// Number of concurrent workers in decision engine that process requests to the blockstore
	BitswapEngineBlockstoreWorkerCount = 128
	// the total number of simultaneous threads sending outgoing messages
	BitswapTaskWorkerCount = 8
	// how many worker threads to start for decision engine task worker
	BitswapEngineTaskWorkerCount = 8
	// the total amount of bytes that a peer should have outstanding, it is utilized by the decision engine
	BitswapMaxOutstandingBytesPerPeer = 1 << 20
	// the number of bytes we attempt to make each outgoing bitswap message
	BitswapEngineTargetMessageSize = 16 * 1024
	// HasBlockBufferSize is the buffer size of the channel for new blocks
	// that need to be provided. They should get pulled over by the
	// provideCollector even before they are actually provided.
	// TODO: Does this need to be this large givent that?
	HasBlockBufferSize = 256
	// Maximum size of the wantlist we are willing to keep in memory.
	MaxQueuedWantlistEntiresPerPeer = 1024
	// Copied from github.com/ipfs/go-verifcid
	// FIXME: expose this in go-verifcid.
	MaximumHashLength = 128
	MaximumAllowedCid = binary.MaxVarintLen64*4 + MaximumHashLength
)
",CWE-770,37.0,0
"package bitswap
import (
	""time""
	delay ""github.com/ipfs/go-ipfs-delay""
	""github.com/ipfs/go-libipfs/bitswap/client""
	""github.com/ipfs/go-libipfs/bitswap/server""
	""github.com/ipfs/go-libipfs/bitswap/tracer""
)
type option func(*Bitswap)
// Option is interface{} of server.Option or client.Option or func(*Bitswap)
// wrapped in a struct to gain strong type checking.
type Option struct {
	v interface{}
}
func EngineBlockstoreWorkerCount(count int) Option {
	return Option{server.EngineBlockstoreWorkerCount(count)}
}
func EngineTaskWorkerCount(count int) Option {
	return Option{server.EngineTaskWorkerCount(count)}
}
func MaxOutstandingBytesPerPeer(count int) Option {
	return Option{server.MaxOutstandingBytesPerPeer(count)}
}
func MaxQueuedWantlistEntriesPerPeer(count uint) Option {
	return Option{server.MaxQueuedWantlistEntriesPerPeer(count)}
}
// MaxCidSize only affects the server.
// If it is 0 no limit is applied.
func MaxCidSize(n uint) Option {
	return Option{server.MaxCidSize(n)}
}
func TaskWorkerCount(count int) Option {
	return Option{server.TaskWorkerCount(count)}
}
func ProvideEnabled(enabled bool) Option {
	return Option{server.ProvideEnabled(enabled)}
}
func SetSendDontHaves(send bool) Option {
	return Option{server.SetSendDontHaves(send)}
}
func WithPeerBlockRequestFilter(pbrf server.PeerBlockRequestFilter) Option {
	return Option{server.WithPeerBlockRequestFilter(pbrf)}
}
func WithScoreLedger(scoreLedger server.ScoreLedger) Option {
	return Option{server.WithScoreLedger(scoreLedger)}
}
func WithTargetMessageSize(tms int) Option {
	return Option{server.WithTargetMessageSize(tms)}
}
func WithTaskComparator(comparator server.TaskComparator) Option {
	return Option{server.WithTaskComparator(comparator)}
}
func ProviderSearchDelay(newProvSearchDelay time.Duration) Option {
	return Option{client.ProviderSearchDelay(newProvSearchDelay)}
}
func RebroadcastDelay(newRebroadcastDelay delay.D) Option {
	return Option{client.RebroadcastDelay(newRebroadcastDelay)}
}
func SetSimulateDontHavesOnTimeout(send bool) Option {
	return Option{client.SetSimulateDontHavesOnTimeout(send)}
}
func WithTracer(tap tracer.Tracer) Option {
	// Only trace the server, both receive the same messages anyway
	return Option{
		option(func(bs *Bitswap) {
			bs.tracer = tap
		}),
	}
}
",CWE-770,90.0,0
"package teler
import (
	""fmt""
	""html""
	""strings""
	""net/http""
	""github.com/kitabisa/teler-waf/request""
	""github.com/kitabisa/teler-waf/threat""
	""gitlab.com/golang-commonmark/mdurl""
)
// inThreatIndex checks if the given substring is in specific threat datasets
func (t *Teler) inThreatIndex(kind threat.Threat, substr string) bool {
	if i := strings.Index(t.threat.data[kind], substr); i >= 0 {
		return true
	}
	return false
}
// inWhitelist checks if the given substring is in whitelist patterns
func (t *Teler) inWhitelist(r *http.Request) bool {
	uri := toURLDecode(r.URL.RequestURI())
	headers := headersToRawString(r.Header)
	clientIP := getClientIP(r)
	// Check the request URI, headers, and client IP address against the whitelist
	for _, pattern := range t.whitelistRegexes {
		if pattern.MatchString(uri) || pattern.MatchString(headers) || pattern.MatchString(clientIP) {
			return true
		}
	}
	return false
}
// headersToRawString converts a map of http.Header to
// multiline string, example:
// from,
//
//	Header = map[string][]string{
//		""Accept-Encoding"": {""gzip, deflate""},
//		""Accept-Language"": {""en-us""},
//		""Foo"": {""Bar"", ""two""},
//	}
//
// to
//
//	Host: example.com
//	accept-encoding: gzip, deflate
//	Accept-Language: en-us
//	fOO: Bar
//	foo: two
func headersToRawString(headers http.Header) string {
	var h strings.Builder
	// Iterate over the request headers and append each key-value pair to the builder
	for key, values := range headers {
		for _, value := range values {
			h.WriteString(
				fmt.Sprintf(""%s: %s\n"", toURLDecode(key), toURLDecode(value)),
			)
		}
	}
	// Returns the accumulated string of builder
	return h.String()
}
// unescapeHTML to unescapes any HTML entities, i.e. &aacute;""
// unescapes to ""á"", as does ""&
func unescapeHTML(s string) string {
	return html.UnescapeString(s)
}
// toURLDecode decode URL-decoded characters string using mdurl
func toURLDecode(s string) string {
	return mdurl.Decode(s)
}
// stringDeUnescape to decode URL-decoded characters, and
// unescapes any HTML entities
func stringDeUnescape(s string) string {
	s = toURLDecode(s)
	return unescapeHTML(s)
}
// isValidMethod check if the given request.Method is valid
func isValidMethod(method request.Method) bool {
	switch method {
	case request.GET, request.HEAD, request.POST, request.PUT, request.PATCH:
	case request.DELETE, request.CONNECT, request.OPTIONS, request.TRACE, request.ALL:
	case """":
		return true
	}
	return false
}
// normalizeRawStringReader trim double-quotes of HTTP raw string,
// replace double-escape of CR and LF, and double it in the end, and
// returning as pointer of strings.Reader
func normalizeRawStringReader(raw string) *strings.Reader {
	var builder strings.Builder
	raw = strings.Trim(raw, `""`)
	raw = strings.ReplaceAll(raw, ""\\n"", ""\n"")
	raw = strings.ReplaceAll(raw, ""\\r"", ""\r"")
	builder.WriteString(raw)
	builder.WriteString(""\r\n\r\n"")
	return strings.NewReader(builder.String())
}
// getClientIP to get client IP address from request
func getClientIP(r *http.Request) string {
	// Get the client's IP address from the X-Real-Ip header field
	clientIP := r.Header.Get(""X-Real-Ip"")
	// If the X-Real-Ip header field is not present, try the X-Forwarded-For header field
	if clientIP == """" {
		clientIP = r.Header.Get(""X-Forwarded-For"")
	}
	// If the X-Forwarded-For header field is not present, use the RemoteAddr field
	if clientIP == """" {
		clientIP = r.RemoteAddr
	}
	// Returning client IP address
	return clientIP
}
",CWE-79,136.0,0
"package middleware
import (
	""errors""
	jwt ""github.com/appleboy/gin-jwt/v2""
	""github.com/gin-gonic/gin""
	""github.com/px-org/PanIndex/module""
	log ""github.com/sirupsen/logrus""
	""net/http""
	""net/url""
	""strings""
	""time""
)
const (
	LoginTimeOut = 24 * 365
	identityKey  = ""id""
)
func JWTMiddlewar() (*jwt.GinJWTMiddleware, error) {
	authMiddleware, err := jwt.New(&jwt.GinJWTMiddleware{
		Realm:       ""PanIndex Zone"",
		Key:         []byte(module.GloablConfig.JwtSignKey),
		Timeout:     (time.Duration(LoginTimeOut)) * time.Hour,
		MaxRefresh:  (time.Duration(LoginTimeOut)) * time.Hour,
		IdentityKey: identityKey,
		PayloadFunc: func(data interface{}) jwt.MapClaims {
			if v, ok := data.(*User); ok {
				return jwt.MapClaims{
					identityKey: v.UserName,
				}
			}
			return jwt.MapClaims{}
		},
		IdentityHandler: func(c *gin.Context) interface{} {
			claims := jwt.ExtractClaims(c)
			return &User{
				UserName: claims[identityKey].(string),
			}
		},
		Authenticator: func(c *gin.Context) (interface{}, error) {
			var loginVals Login
			if err := c.ShouldBind(&loginVals); err != nil {
				return """", jwt.ErrMissingLoginValues
			}
			password := loginVals.Password
			user := loginVals.User
			if user == module.GloablConfig.AdminUser &&
				password == module.GloablConfig.AdminPassword {
				return &User{
					UserName: module.GloablConfig.AdminUser,
				}, nil
			}
			return nil, errors.New(""密码错误！请重试"")
		},
		Authorizator: func(data interface{}, c *gin.Context) bool {
			if v, ok := data.(*User); ok && v.UserName == module.GloablConfig.AdminUser {
				return true
			}
			return false
		},
		LoginResponse: func(c *gin.Context, code int, token string, expire time.Time) {
			//c.Redirect(http.StatusFound, module.GloablConfig.AdminPath+""/common"")
			referer := c.Request.Header.Get(""Referer"")
			u, _ := url.Parse(referer)
			if strings.HasPrefix(u.Path, module.GloablConfig.AdminPath) {
				c.Redirect(http.StatusFound, module.GloablConfig.AdminPath+""/common"")
			} else {
				c.Redirect(http.StatusFound, c.Request.Header.Get(""Referer""))
			}
		},
		LogoutResponse: func(c *gin.Context, code int) {
			ThemeCheck(c)
			theme := c.GetString(""theme"")
			c.HTML(http.StatusOK, ""templates/pan/admin/login.html"", gin.H{
				""error"":        true,
				""msg"":          ""退出成功"",
				""redirect_url"": ""login"",
				""config"":       module.GloablConfig,
				""theme"":        theme,
			})
		},
		Unauthorized: func(c *gin.Context, code int, message string) {
			path := c.Request.RequestURI
			if strings.HasPrefix(path, ""/api"") {
				//api return json
				c.JSON(code, gin.H{
					""status"": code,
					""msg"":    message,
				})
			} else {
				//return to login
				data := gin.H{
					""error"":        true,
					""msg"":          message,
					""redirect_url"": ""login"",
					""config"":       module.GloablConfig,
					""theme"":        module.GloablConfig.Theme,
				}
				if message == ""cookie token is empty"" {
					data[""error""] = false
					data[""msg""] = """"
				}
				c.HTML(http.StatusOK, ""templates/pan/admin/login.html"", data)
			}
		},
		SendCookie:     true,
		SecureCookie:   false,   //non HTTPS dev environments
		CookieHTTPOnly: true,    // JS can't modify
		CookieName:     ""token"", // default jwt
		TokenLookup:    ""header: Authorization, cookie: token"",
		CookieSameSite: http.SameSiteDefaultMode, //SameSiteDefaultMode, SameSiteLaxMode, SameSiteStrictMode, SameSiteNoneMode
		TokenHeadName:  ""Bearer"",
		// TimeFunc provides the current time. You can override it to use another time value. This is useful for testing or if your server uses a different time zone than your tokens.
		TimeFunc: time.Now,
	})
	errInit := authMiddleware.MiddlewareInit()
	if errInit != nil {
		log.Fatal(""authMiddleware.MiddlewareInit() Error:"" + errInit.Error())
	}
	if err != nil {
		log.Fatal(""JWT Error:"" + err.Error())
	}
	return authMiddleware, err
}
type Login struct {
	User     string `form:""user"" json:""user"" binding:""required""`
	Password string `form:""password"" json:""password"" binding:""required""`
}
type User struct {
	UserName string
}
",CWE-798,136.0,0
"package zip
import (
	""archive/zip""
	""io""
	""os""
	""path""
	""path/filepath""
	""strings""
)
// Unzip decompresses a zip file to specified directory.
// Note that the destination directory don't need to specify the trailing path separator.
func Unzip(zipPath, dstDir string) error {
	// Open zip file.
	reader, err := zip.OpenReader(zipPath)
	if err != nil {
		return err
	}
	defer reader.Close()
	for _, file := range reader.File {
		if err := unzipFile(file, dstDir); err != nil {
			return err
		}
	}
	return nil
}
func unzipFile(file *zip.File, dstDir string) error {
	// Prevent path traversal vulnerability.
	// Such as if the file name is ""../../../path/to/file.txt"" which will be cleaned to ""path/to/file.txt"".
	name := strings.TrimPrefix(filepath.Join(string(filepath.Separator), file.Name), string(filepath.Separator))
	filePath := path.Join(dstDir, name)
	// Create the directory of file.
	if file.FileInfo().IsDir() {
		if err := os.MkdirAll(filePath, os.ModePerm); err != nil {
			return err
		}
		return nil
	}
	if err := os.MkdirAll(filepath.Dir(filePath), os.ModePerm); err != nil {
		return err
	}
	// Open the file.
	r, err := file.Open()
	if err != nil {
		return err
	}
	defer r.Close()
	// Create the file.
	w, err := os.Create(filePath)
	if err != nil {
		return err
	}
	defer w.Close()
	// Save the decompressed file content.
	_, err = io.Copy(w, r)
	return err
}
",CWE-22,64.0,0
"package api
import (
	log ""github.com/Sirupsen/logrus""
	""github.com/ansible-semaphore/semaphore/api/helpers""
	""github.com/ansible-semaphore/semaphore/db""
	""github.com/ansible-semaphore/semaphore/util""
	""github.com/gorilla/context""
	""net/http""
	""strings""
	""time""
)
func authenticationHandler(w http.ResponseWriter, r *http.Request) bool {
	var userID int
	authHeader := strings.ToLower(r.Header.Get(""authorization""))
	if len(authHeader) > 0 && strings.Contains(authHeader, ""bearer"") {
		token, err := helpers.Store(r).GetAPIToken(strings.Replace(authHeader, ""bearer "", """", 1))
		if err != nil {
			if err != db.ErrNotFound {
				log.Error(err)
			}
			w.WriteHeader(http.StatusUnauthorized)
			return false
		}
		userID = token.UserID
	} else {
		// fetch session from cookie
		cookie, err := r.Cookie(""semaphore"")
		if err != nil {
			w.WriteHeader(http.StatusUnauthorized)
			return false
		}
		value := make(map[string]interface{})
		if err = util.Cookie.Decode(""semaphore"", cookie.Value, &value); err != nil {
			w.WriteHeader(http.StatusUnauthorized)
			return false
		}
		user, ok := value[""user""]
		sessionVal, okSession := value[""session""]
		if !ok || !okSession {
			w.WriteHeader(http.StatusUnauthorized)
			return false
		}
		userID = user.(int)
		sessionID := sessionVal.(int)
		// fetch session
		session, err := helpers.Store(r).GetSession(userID, sessionID)
		if err != nil {
			w.WriteHeader(http.StatusUnauthorized)
			return false
		}
		if time.Since(session.LastActive).Hours() > 7*24 {
			// more than week old unused session
			// destroy.
			if err := helpers.Store(r).ExpireSession(userID, sessionID); err != nil {
				// it is internal error, it doesn't concern the user
				log.Error(err)
			}
			w.WriteHeader(http.StatusUnauthorized)
			return false
		}
		if err := helpers.Store(r).TouchSession(userID, sessionID); err != nil {
			log.Error(err)
			w.WriteHeader(http.StatusUnauthorized)
			return false
		}
	}
	user, err := helpers.Store(r).GetUser(userID)
	if err != nil {
		if err != db.ErrNotFound {
			// internal error
			log.Error(err)
		}
		w.WriteHeader(http.StatusUnauthorized)
		return false
	}
	if util.Config.DemoMode {
		if !user.Admin && r.Method != ""GET"" &&
			!strings.HasSuffix(r.URL.Path, ""/tasks"") &&
			!strings.HasSuffix(r.URL.Path, ""/stop"") {
			w.WriteHeader(http.StatusUnauthorized)
			return false
		}
	}
	context.Set(r, ""user"", &user)
	return true
}
// nolint: gocyclo
func authentication(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ok := authenticationHandler(w, r)
		if ok {
			next.ServeHTTP(w, r)
		}
	})
}
// nolint: gocyclo
func authenticationWithStore(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		store := helpers.Store(r)
		var ok bool
		
		db.StoreSession(store, r.URL.String(), func() {
			ok = authenticationHandler(w, r)
		})
		if ok {
			next.ServeHTTP(w, r)
		}
	})
}
",CWE-287,132.0,0
"//
// Copyright 2021 The Sigstore Authors.
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package app
import (
	""fmt""
	""net/http""
	""net/http/pprof""
	""os""
	""time""
	homedir ""github.com/mitchellh/go-homedir""
	""github.com/sigstore/rekor/pkg/log""
	""github.com/spf13/cobra""
	""github.com/spf13/viper""
)
var (
	cfgFile     string
	logType     string
	enablePprof bool
	// these map to the operationId as defined in openapi.yaml file
	operationIds = []string{
		""searchIndex"",
		""getLogInfo"",
		""getPublicKey"",
		""getLogProof"",
		""createLogEntry"",
		""getLogEntryByIndex"",
		""getLogEntryByUUID"",
		""searchLogQuery"",
	}
)
// rootCmd represents the base command when called without any subcommands
var rootCmd = &cobra.Command{
	Use:   ""rekor-server"",
	Short: ""Rekor signature transparency log server"",
	Long: `Rekor fulfills the signature transparency role of sigstore's software
	signing infrastructure. It can also be run on its own and is designed to be
	extensible to work with different manifest schemas and PKI tooling`,
	// Uncomment the following line if your bare application
	// has an action associated with it:
	//	Run: func(cmd *cobra.Command, args []string) { },
}
// Execute adds all child commands to the root command and sets flags appropriately.
// This is called by main.main(). It only needs to happen once to the rootCmd.
func Execute() {
	if err := rootCmd.Execute(); err != nil {
		log.Logger.Error(err)
		os.Exit(1)
	}
}
func init() {
	cobra.OnInitialize(initConfig)
	rootCmd.PersistentFlags().StringVar(&cfgFile, ""config"", """", ""config file (default is $HOME/.rekor-server.yaml)"")
	rootCmd.PersistentFlags().StringVar(&logType, ""log_type"", ""dev"", ""logger type to use (dev/prod)"")
	rootCmd.PersistentFlags().BoolVar(&enablePprof, ""enable_pprof"", false, ""enable pprof for profiling on port 6060"")
	rootCmd.PersistentFlags().Bool(""enable_killswitch"", false, ""enable killswitch for TESTING ONLY on port 2345"")
	_ = rootCmd.PersistentFlags().MarkHidden(""enable_killswitch"")
	rootCmd.PersistentFlags().String(""trillian_log_server.address"", ""127.0.0.1"", ""Trillian log server address"")
	rootCmd.PersistentFlags().Uint16(""trillian_log_server.port"", 8090, ""Trillian log server port"")
	rootCmd.PersistentFlags().Uint(""trillian_log_server.tlog_id"", 0, ""Trillian tree id"")
	rootCmd.PersistentFlags().String(""trillian_log_server.sharding_config"", """", ""path to config file for inactive shards, in JSON or YAML"")
	hostname, err := os.Hostname()
	if err != nil {
		hostname = ""localhost""
	}
	rootCmd.PersistentFlags().String(""rekor_server.hostname"", hostname, ""public hostname of instance"")
	rootCmd.PersistentFlags().String(""rekor_server.address"", ""127.0.0.1"", ""Address to bind to"")
	rootCmd.PersistentFlags().String(""rekor_server.signer"", ""memory"",
		`Rekor signer to use. Valid options are: [gcpkms, memory, filename containing PEM encoded private key].
Memory and file-based signers should only be used for testing.`)
	rootCmd.PersistentFlags().String(""rekor_server.signer-passwd"", """", ""Password to decrypt signer private key"")
	rootCmd.PersistentFlags().Uint16(""port"", 3000, ""Port to bind to"")
	rootCmd.PersistentFlags().Bool(""enable_retrieve_api"", true, ""enables Redis-based index API endpoint"")
	_ = rootCmd.PersistentFlags().MarkDeprecated(""enable_retrieve_api"", ""this flag is deprecated in favor of enabled_api_endpoints (searchIndex)"")
	rootCmd.PersistentFlags().String(""redis_server.address"", ""127.0.0.1"", ""Redis server address"")
	rootCmd.PersistentFlags().Uint16(""redis_server.port"", 6379, ""Redis server port"")
	rootCmd.PersistentFlags().Bool(""enable_attestation_storage"", false, ""enables rich attestation storage"")
	rootCmd.PersistentFlags().String(""attestation_storage_bucket"", """", ""url for attestation storage bucket"")
	rootCmd.PersistentFlags().Int(""max_attestation_size"", 100*1024, ""max size for attestation storage, in bytes"")
	rootCmd.PersistentFlags().StringSlice(""enabled_api_endpoints"", operationIds, ""list of API endpoints to enable using operationId from openapi.yaml"")
	rootCmd.PersistentFlags().Uint64(""max_request_body_size"", 0, ""maximum size for HTTP request body, in bytes; set to 0 for unlimited"")
	rootCmd.PersistentFlags().Uint64(""max_jar_metadata_size"", 1048576, ""maximum permitted size for jar META-INF/ files, in bytes; set to 0 for unlimited"")
	rootCmd.PersistentFlags().Uint64(""max_apk_metadata_size"", 1048576, ""maximum permitted size for apk .SIGN and .PKGINFO files, in bytes; set to 0 for unlimited"")
	if err := viper.BindPFlags(rootCmd.PersistentFlags()); err != nil {
		log.Logger.Fatal(err)
	}
	rootCmd.Flags().BoolP(""toggle"", ""t"", false, ""Help message for toggle"")
	log.Logger.Debugf(""pprof enabled %v"", enablePprof)
	// Enable pprof
	if enablePprof {
		go func() {
			mux := http.NewServeMux()
			mux.HandleFunc(""/debug/pprof/"", pprof.Index)
			mux.HandleFunc(""/debug/pprof/{action}"", pprof.Index)
			mux.HandleFunc(""/debug/pprof/symbol"", pprof.Symbol)
			srv := &http.Server{
				Addr:         "":6060"",
				ReadTimeout:  10 * time.Second,
				WriteTimeout: 10 * time.Second,
				Handler:      mux,
			}
			if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
				log.Logger.Fatalf(""Error when starting or running http server: %v"", err)
			}
		}()
	}
}
// initConfig reads in config file and ENV variables if set.
func initConfig() {
	if cfgFile != """" {
		// Use config file from the flag.
		viper.SetConfigFile(cfgFile)
	} else {
		// Find home directory.
		home, err := homedir.Dir()
		if err != nil {
			fmt.Println(err)
			os.Exit(1)
		}
		viper.AddConfigPath(home)
		viper.AddConfigPath(""."")
		viper.SetConfigName(""rekor-server"")
		viper.SetConfigType(""yaml"")
	}
	viper.AutomaticEnv() // read in environment variables that match
	// If a config file is found, read it in.
	if err := viper.ReadInConfig(); err == nil {
		log.Logger.Infof(""Using config file: %s"", viper.ConfigFileUsed())
	}
}
",CWE-770,168.0,0
"//
// Copyright 2021 The Sigstore Authors.
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package alpine
import (
	""os""
	""strings""
	""testing""
	""github.com/sigstore/rekor/pkg/pki/x509""
	""github.com/spf13/viper""
)
func TestAlpinePackage(t *testing.T) {
	inputArchive, err := os.Open(""tests/test_alpine.apk"")
	if err != nil {
		t.Fatalf(""could not open archive %v"", err)
	}
	p := Package{}
	err = p.Unmarshal(inputArchive)
	if err != nil {
		t.Fatalf(""unmarshal error: %v"", err)
	}
	pubKey, err := os.Open(""tests/test_alpine.pub"")
	if err != nil {
		t.Fatalf(""could not open archive %v"", err)
	}
	pub, err := x509.NewPublicKey(pubKey)
	if err != nil {
		t.Fatalf(""failed to parse public key: %v"", err)
	}
	if err = p.VerifySignature(pub.CryptoPubKey()); err != nil {
		t.Fatalf(""signature verification failed: %v"", err)
	}
}
func TestAlpineMetadataSize(t *testing.T) {
	os.Setenv(""MAX_APK_METADATA_SIZE"", ""10"")
	viper.AutomaticEnv()
	inputArchive, err := os.Open(""tests/test_alpine.apk"")
	if err != nil {
		t.Fatalf(""could not open archive %v"", err)
	}
	p := Package{}
	err = p.Unmarshal(inputArchive)
	if err == nil {
		t.Fatal(""expecting metadata too large err"")
	}
	if !strings.Contains(err.Error(), ""exceeds max allowed size 10"") {
		t.Fatalf(""unexpected error %v"", err)
	}
}
",CWE-770,73.0,0
"//
// Copyright 2021 The Sigstore Authors.
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package jar
import (
	""bytes""
	""context""
	""os""
	""reflect""
	""strings""
	""testing""
	""github.com/go-openapi/runtime""
	""github.com/go-openapi/strfmt""
	""github.com/go-openapi/swag""
	""github.com/sigstore/rekor/pkg/generated/models""
	""github.com/sigstore/rekor/pkg/types""
	""github.com/spf13/viper""
	""go.uber.org/goleak""
)
func TestMain(m *testing.M) {
	goleak.VerifyTestMain(m)
}
func TestNewEntryReturnType(t *testing.T) {
	entry := NewEntry()
	if reflect.TypeOf(entry) != reflect.ValueOf(&V001Entry{}).Type() {
		t.Errorf(""invalid type returned from NewEntry: %T"", entry)
	}
}
func TestCrossFieldValidation(t *testing.T) {
	type TestCase struct {
		caseDesc                  string
		entry                     V001Entry
		expectUnmarshalSuccess    bool
		expectCanonicalizeSuccess bool
		expectedVerifierSuccess   bool
	}
	jarBytes, _ := os.ReadFile(""tests/test.jar"")
	// extracted from jar
	certificate := `-----BEGIN CERTIFICATE-----
MIIB+DCCAX6gAwIBAgITNVkDZoCiofPDsy7dfm6geLbuhzAKBggqhkjOPQQDAzAq
MRUwEwYDVQQKEwxzaWdzdG9yZS5kZXYxETAPBgNVBAMTCHNpZ3N0b3JlMB4XDTIx
MDMwNzAzMjAyOVoXDTMxMDIyMzAzMjAyOVowKjEVMBMGA1UEChMMc2lnc3RvcmUu
ZGV2MREwDwYDVQQDEwhzaWdzdG9yZTB2MBAGByqGSM49AgEGBSuBBAAiA2IABLSy
A7Ii5k+pNO8ZEWY0ylemWDowOkNa3kL+GZE5Z5GWehL9/A9bRNA3RbrsZ5i0Jcas
taRL7Sp5fp/jD5dxqc/UdTVnlvS16an+2Yfswe/QuLolRUCrcOE2+2iA5+tzd6Nm
MGQwDgYDVR0PAQH/BAQDAgEGMBIGA1UdEwEB/wQIMAYBAf8CAQEwHQYDVR0OBBYE
FMjFHQBBmiQpMlEk6w2uSu1KBtPsMB8GA1UdIwQYMBaAFMjFHQBBmiQpMlEk6w2u
Su1KBtPsMAoGCCqGSM49BAMDA2gAMGUCMH8liWJfMui6vXXBhjDgY4MwslmN/TJx
Ve/83WrFomwmNf056y1X48F9c4m3a3ozXAIxAKjRay5/aj/jsKKGIkmQatjI8uup
Hr/+CxFvaJWmpYqNkLDGRU+9orzh5hI2RrcuaQ==
-----END CERTIFICATE-----
`
	testCases := []TestCase{
		{
			caseDesc:                ""empty obj"",
			entry:                   V001Entry{},
			expectUnmarshalSuccess:  false,
			expectedVerifierSuccess: false,
		},
		{
			caseDesc: ""empty archive"",
			entry: V001Entry{
				JARModel: models.JarV001Schema{
					Archive: &models.JarV001SchemaArchive{},
				},
			},
			expectUnmarshalSuccess:  false,
			expectedVerifierSuccess: false,
		},
		{
			caseDesc: ""archive with inline content"",
			entry: V001Entry{
				JARModel: models.JarV001Schema{
					Archive: &models.JarV001SchemaArchive{
						Content: strfmt.Base64(jarBytes),
					},
				},
			},
			expectUnmarshalSuccess:    true,
			expectCanonicalizeSuccess: true,
			expectedVerifierSuccess:   true,
		},
	}
	for _, tc := range testCases {
		v := &V001Entry{}
		r := models.Jar{
			APIVersion: swag.String(tc.entry.APIVersion()),
			Spec:       tc.entry.JARModel,
		}
		if err := v.Unmarshal(&r); (err == nil) != tc.expectUnmarshalSuccess {
			t.Errorf(""unexpected result in '%v': %v"", tc.caseDesc, err)
		}
		// No need to continue here if unmarshal failed
		if !tc.expectUnmarshalSuccess {
			continue
		}
		b, err := v.Canonicalize(context.TODO())
		if (err == nil) != tc.expectCanonicalizeSuccess {
			t.Errorf(""unexpected result from Canonicalize for '%v': %v"", tc.caseDesc, err)
		} else if err != nil {
			if _, ok := err.(types.ValidationError); !ok {
				t.Errorf(""canonicalize returned an unexpected error that isn't of type types.ValidationError: %v"", err)
			}
		}
		if b != nil {
			pe, err := models.UnmarshalProposedEntry(bytes.NewReader(b), runtime.JSONConsumer())
			if err != nil {
				t.Errorf(""unexpected err from Unmarshalling canonicalized entry for '%v': %v"", tc.caseDesc, err)
			}
			if _, err := types.UnmarshalEntry(pe); err != nil {
				t.Errorf(""unexpected err from type-specific unmarshalling for '%v': %v"", tc.caseDesc, err)
			}
		}
		verifier, err := v.Verifier()
		if tc.expectedVerifierSuccess {
			if err != nil {
				t.Errorf(""%v: unexpected error, got %v"", tc.caseDesc, err)
			} else {
				pub, _ := verifier.CanonicalValue()
				if !reflect.DeepEqual(pub, []byte(certificate)) {
					t.Errorf(""verifier and public keys do not match: %v, %v"", string(pub), certificate)
				}
			}
		} else {
			if err == nil {
				s, _ := verifier.CanonicalValue()
				t.Errorf(""%v: expected error for %v, got %v"", tc.caseDesc, string(s), err)
			}
		}
	}
}
func TestJarMetadataSize(t *testing.T) {
	type TestCase struct {
		caseDesc                  string
		entry                     V001Entry
		expectUnmarshalSuccess    bool
		expectCanonicalizeSuccess bool
		expectedVerifierSuccess   bool
	}
	jarBytes, _ := os.ReadFile(""tests/test.jar"")
	os.Setenv(""MAX_JAR_METADATA_SIZE"", ""10"")
	viper.AutomaticEnv()
	v := V001Entry{
		JARModel: models.JarV001Schema{
			Archive: &models.JarV001SchemaArchive{
				Content: strfmt.Base64(jarBytes),
			},
		},
	}
	r := models.Jar{
		APIVersion: swag.String(v.APIVersion()),
		Spec:       v.JARModel,
	}
	if err := v.Unmarshal(&r); err != nil {
		t.Errorf(""unexpected unmarshal failure: %v"", err)
	}
	_, err := v.Canonicalize(context.TODO())
	if err == nil {
		t.Fatal(""expecting metadata too large err"")
	}
	if !strings.Contains(err.Error(), ""exceeds max allowed size 10"") {
		t.Fatalf(""unexpected error %v"", err)
	}
}
",CWE-770,195.0,0
"package router
import (
	""context""
	""database/sql""
	""encoding/json""
	""fmt""
	""strings""
	""time""
	""github.com/rudderlabs/rudder-server/utils/misc""
)
var failedEventsManager FailedEventsManagerI
type FailedEventRowT struct {
	DestinationID string          `json:""destination_id""`
	RecordID      json.RawMessage `json:""record_id""`
}
var (
	failedKeysTablePrefix  = ""failed_keys""
	failedKeysExpire       time.Duration
	failedKeysCleanUpSleep time.Duration
	failedKeysEnabled      bool
)
type FailedEventsManagerI interface {
	SaveFailedRecordIDs(map[string][]*FailedEventRowT, *sql.Tx)
	DropFailedRecordIDs(jobRunID string)
	FetchFailedRecordIDs(jobRunID string) []*FailedEventRowT
	GetDBHandle() *sql.DB
}
type FailedEventsManagerT struct {
	dbHandle *sql.DB
}
func GetFailedEventsManager() FailedEventsManagerI {
	if failedEventsManager == nil {
		fem := new(FailedEventsManagerT)
		dbHandle, err := sql.Open(""postgres"", misc.GetConnectionString())
		if err != nil {
			panic(err)
		}
		fem.dbHandle = dbHandle
		failedEventsManager = fem
	}
	return failedEventsManager
}
func (*FailedEventsManagerT) SaveFailedRecordIDs(taskRunIDFailedEventsMap map[string][]*FailedEventRowT, txn *sql.Tx) {
	if !failedKeysEnabled {
		return
	}
	for taskRunID, failedEvents := range taskRunIDFailedEventsMap {
		table := `""` + strings.ReplaceAll(fmt.Sprintf(`%s_%s`, failedKeysTablePrefix, taskRunID), `""`, `""""`) + `""`
		sqlStatement := fmt.Sprintf(`CREATE TABLE IF NOT EXISTS %s (
		destination_id TEXT NOT NULL,
		record_id JSONB NOT NULL,
		created_at TIMESTAMP NOT NULL);`, table)
		_, err := txn.Exec(sqlStatement)
		if err != nil {
			_ = txn.Rollback()
			panic(err)
		}
		insertQuery := fmt.Sprintf(`INSERT INTO %s VALUES($1, $2, $3);`, table)
		stmt, err := txn.Prepare(insertQuery)
		if err != nil {
			_ = txn.Rollback()
			panic(err)
		}
		createdAt := time.Now()
		for _, failedEvent := range failedEvents {
			if len(failedEvent.RecordID) == 0 || !json.Valid(failedEvent.RecordID) {
				pkgLogger.Infof(""skipped adding invalid recordId: %s, to failed keys table: %s"", failedEvent.RecordID, table)
				continue
			}
			_, err = stmt.Exec(failedEvent.DestinationID, failedEvent.RecordID, createdAt)
			if err != nil {
				panic(err)
			}
		}
		stmt.Close()
	}
}
func (fem *FailedEventsManagerT) DropFailedRecordIDs(taskRunID string) {
	if !failedKeysEnabled {
		return
	}
	// Drop table
	table := fmt.Sprintf(`%s_%s`, failedKeysTablePrefix, taskRunID)
	sqlStatement := fmt.Sprintf(`DROP TABLE IF EXISTS %s`, table)
	_, err := fem.dbHandle.Exec(sqlStatement)
	if err != nil {
		pkgLogger.Errorf(""Failed to drop table %s with error: %v"", taskRunID, err)
	}
}
func (fem *FailedEventsManagerT) FetchFailedRecordIDs(taskRunID string) []*FailedEventRowT {
	if !failedKeysEnabled {
		return []*FailedEventRowT{}
	}
	failedEvents := make([]*FailedEventRowT, 0)
	var rows *sql.Rows
	var err error
	table := `""` + strings.ReplaceAll(fmt.Sprintf(`%s_%s`, failedKeysTablePrefix, taskRunID), `""`, `""""`) + `""`
	sqlStatement := fmt.Sprintf(`SELECT %[1]s.destination_id, %[1]s.record_id
                                             FROM %[1]s `, table)
	rows, err = fem.dbHandle.Query(sqlStatement)
	if err != nil {
		pkgLogger.Errorf(""Failed to fetch from table %s with error: %v"", taskRunID, err)
		return failedEvents
	}
	defer rows.Close()
	for rows.Next() {
		var failedEvent FailedEventRowT
		err := rows.Scan(&failedEvent.DestinationID, &failedEvent.RecordID)
		if err != nil {
			panic(err)
		}
		failedEvents = append(failedEvents, &failedEvent)
	}
	return failedEvents
}
func CleanFailedRecordsTableProcess(ctx context.Context) {
	if !failedKeysEnabled {
		return
	}
	for {
		select {
		case <-ctx.Done():
			return
		case <-time.After(failedKeysCleanUpSleep):
			dbHandle, err := sql.Open(""postgres"", misc.GetConnectionString())
			if err != nil {
				panic(err)
			}
			failedKeysLike := failedKeysTablePrefix + ""%""
			failedKeysTableQuery := fmt.Sprintf(`SELECT table_name
													FROM information_schema.tables
													WHERE table_schema='public' AND table_type='BASE TABLE' AND table_name ilike '%s'`, failedKeysLike)
			rows, err := dbHandle.Query(failedKeysTableQuery)
			if err != nil {
				panic(err)
			}
			for rows.Next() {
				var table string
				err = rows.Scan(&table)
				if err != nil {
					pkgLogger.Errorf(""Failed to scan failed keys table %s with error: %v"", table, err)
					return
				}
				latestCreatedAtQuery := fmt.Sprintf(`SELECT created_at from %s order by created_at desc limit 1`, table)
				row := dbHandle.QueryRow(latestCreatedAtQuery)
				var latestCreatedAt time.Time
				err = row.Scan(&latestCreatedAt)
				if err != nil && err != sql.ErrNoRows {
					pkgLogger.Errorf(""Failed to fetch records from failed keys table %s with error: %v"", table, err)
					continue
				}
				currentTime := time.Now()
				diff := currentTime.Sub(latestCreatedAt)
				if diff > failedKeysExpire {
					dropQuery := fmt.Sprintf(`DROP TABLE IF EXISTS %s`, table)
					rows, err = dbHandle.Query(dropQuery)
					if err != nil {
						pkgLogger.Errorf(""Failed to drop table %s with error: %v"", table, err)
					}
				}
			}
			dbHandle.Close()
		}
	}
}
func (fem *FailedEventsManagerT) GetDBHandle() *sql.DB {
	return fem.dbHandle
}
",CWE-89,191.0,0
"package router
import (
	""context""
	""database/sql""
	""encoding/json""
	""fmt""
	""strings""
	""time""
	""github.com/rudderlabs/rudder-server/utils/misc""
)
var failedEventsManager FailedEventsManagerI
type FailedEventRowT struct {
	DestinationID string          `json:""destination_id""`
	RecordID      json.RawMessage `json:""record_id""`
}
var (
	failedKeysTablePrefix  = ""failed_keys""
	failedKeysExpire       time.Duration
	failedKeysCleanUpSleep time.Duration
	failedKeysEnabled      bool
)
type FailedEventsManagerI interface {
	SaveFailedRecordIDs(map[string][]*FailedEventRowT, *sql.Tx)
	DropFailedRecordIDs(jobRunID string)
	FetchFailedRecordIDs(jobRunID string) []*FailedEventRowT
	GetDBHandle() *sql.DB
}
type FailedEventsManagerT struct {
	dbHandle *sql.DB
}
func GetFailedEventsManager() FailedEventsManagerI {
	if failedEventsManager == nil {
		fem := new(FailedEventsManagerT)
		dbHandle, err := sql.Open(""postgres"", misc.GetConnectionString())
		if err != nil {
			panic(err)
		}
		fem.dbHandle = dbHandle
		failedEventsManager = fem
	}
	return failedEventsManager
}
func (*FailedEventsManagerT) SaveFailedRecordIDs(taskRunIDFailedEventsMap map[string][]*FailedEventRowT, txn *sql.Tx) {
	if !failedKeysEnabled {
		return
	}
	for taskRunID, failedEvents := range taskRunIDFailedEventsMap {
		table := getSqlSafeTablename(taskRunID)
		sqlStatement := fmt.Sprintf(`CREATE TABLE IF NOT EXISTS %s (
		destination_id TEXT NOT NULL,
		record_id JSONB NOT NULL,
		created_at TIMESTAMP NOT NULL);`, table)
		_, err := txn.Exec(sqlStatement)
		if err != nil {
			_ = txn.Rollback()
			panic(err)
		}
		insertQuery := fmt.Sprintf(`INSERT INTO %s VALUES($1, $2, $3);`, table)
		stmt, err := txn.Prepare(insertQuery)
		if err != nil {
			_ = txn.Rollback()
			panic(err)
		}
		createdAt := time.Now()
		for _, failedEvent := range failedEvents {
			if len(failedEvent.RecordID) == 0 || !json.Valid(failedEvent.RecordID) {
				pkgLogger.Infof(""skipped adding invalid recordId: %s, to failed keys table: %s"", failedEvent.RecordID, table)
				continue
			}
			_, err = stmt.Exec(failedEvent.DestinationID, failedEvent.RecordID, createdAt)
			if err != nil {
				panic(err)
			}
		}
		stmt.Close()
	}
}
func (fem *FailedEventsManagerT) DropFailedRecordIDs(taskRunID string) {
	if !failedKeysEnabled {
		return
	}
	// Drop table
	table := getSqlSafeTablename(taskRunID)
	sqlStatement := fmt.Sprintf(`DROP TABLE IF EXISTS %s`, table)
	_, err := fem.dbHandle.Exec(sqlStatement)
	if err != nil {
		pkgLogger.Errorf(""Failed to drop table %s with error: %v"", taskRunID, err)
	}
}
func (fem *FailedEventsManagerT) FetchFailedRecordIDs(taskRunID string) []*FailedEventRowT {
	if !failedKeysEnabled {
		return []*FailedEventRowT{}
	}
	failedEvents := make([]*FailedEventRowT, 0)
	var rows *sql.Rows
	var err error
	table := getSqlSafeTablename(taskRunID)
	sqlStatement := fmt.Sprintf(`SELECT %[1]s.destination_id, %[1]s.record_id
                                             FROM %[1]s `, table)
	rows, err = fem.dbHandle.Query(sqlStatement)
	if err != nil {
		pkgLogger.Errorf(""Failed to fetch from table %s with error: %v"", taskRunID, err)
		return failedEvents
	}
	defer rows.Close()
	for rows.Next() {
		var failedEvent FailedEventRowT
		err := rows.Scan(&failedEvent.DestinationID, &failedEvent.RecordID)
		if err != nil {
			panic(err)
		}
		failedEvents = append(failedEvents, &failedEvent)
	}
	return failedEvents
}
func CleanFailedRecordsTableProcess(ctx context.Context) {
	if !failedKeysEnabled {
		return
	}
	for {
		select {
		case <-ctx.Done():
			return
		case <-time.After(failedKeysCleanUpSleep):
			dbHandle, err := sql.Open(""postgres"", misc.GetConnectionString())
			if err != nil {
				panic(err)
			}
			failedKeysLike := failedKeysTablePrefix + ""%""
			failedKeysTableQuery := fmt.Sprintf(`SELECT table_name
													FROM information_schema.tables
													WHERE table_schema='public' AND table_type='BASE TABLE' AND table_name ilike '%s'`, failedKeysLike)
			rows, err := dbHandle.Query(failedKeysTableQuery)
			if err != nil {
				panic(err)
			}
			for rows.Next() {
				var table string
				err = rows.Scan(&table)
				if err != nil {
					pkgLogger.Errorf(""Failed to scan failed keys table %s with error: %v"", table, err)
					return
				}
				latestCreatedAtQuery := fmt.Sprintf(`SELECT created_at from %s order by created_at desc limit 1`, table)
				row := dbHandle.QueryRow(latestCreatedAtQuery)
				var latestCreatedAt time.Time
				err = row.Scan(&latestCreatedAt)
				if err != nil && err != sql.ErrNoRows {
					pkgLogger.Errorf(""Failed to fetch records from failed keys table %s with error: %v"", table, err)
					continue
				}
				currentTime := time.Now()
				diff := currentTime.Sub(latestCreatedAt)
				if diff > failedKeysExpire {
					dropQuery := fmt.Sprintf(`DROP TABLE IF EXISTS %s`, table)
					rows, err = dbHandle.Query(dropQuery)
					if err != nil {
						pkgLogger.Errorf(""Failed to drop table %s with error: %v"", table, err)
					}
				}
			}
			dbHandle.Close()
		}
	}
}
func (fem *FailedEventsManagerT) GetDBHandle() *sql.DB {
	return fem.dbHandle
}
func getSqlSafeTablename(taskRunID string) string {
	return `""` + strings.ReplaceAll(fmt.Sprintf(`%s_%s`, failedKeysTablePrefix, taskRunID), `""`, `""""`) + `""`
}
",CWE-89,195.0,0
"/*
Copyright 2021 The Fluid Authors.
Licensed under the Apache License, Version 2.0 (the ""License"");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an ""AS IS"" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package app
import (
	""context""
	""errors""
	""flag""
	""fmt""
	""net/http""
	""net/http/pprof""
	""os""
	""time""
	""github.com/fluid-cloudnative/fluid""
	datav1alpha1 ""github.com/fluid-cloudnative/fluid/api/v1alpha1""
	""github.com/fluid-cloudnative/fluid/pkg/csi""
	""github.com/fluid-cloudnative/fluid/pkg/csi/config""
	utilfeature ""github.com/fluid-cloudnative/fluid/pkg/utils/feature""
	""github.com/golang/glog""
	""github.com/spf13/cobra""
	""k8s.io/apimachinery/pkg/runtime""
	clientgoscheme ""k8s.io/client-go/kubernetes/scheme""
	ctrl ""sigs.k8s.io/controller-runtime""
)
var (
	endpoint              string
	nodeID                string
	metricsAddr           string
	pprofAddr             string
	pruneFs               []string
	prunePath             string
	kubeletKubeConfigPath string
)
var scheme = runtime.NewScheme()
var startCmd = &cobra.Command{
	Use:   ""start"",
	Short: ""start fluid driver on node"",
	Run: func(cmd *cobra.Command, args []string) {
		handle()
	},
}
func init() {
	// Register k8s-native resources and Fluid CRDs
	_ = clientgoscheme.AddToScheme(scheme)
	_ = datav1alpha1.AddToScheme(scheme)
	if err := flag.Set(""logtostderr"", ""true""); err != nil {
		fmt.Printf(""Failed to flag.set due to %v"", err)
		os.Exit(1)
	}
	startCmd.Flags().StringVarP(&nodeID, ""nodeid"", """", """", ""node id"")
	if err := startCmd.MarkFlagRequired(""nodeid""); err != nil {
		ErrorAndExit(err)
	}
	startCmd.Flags().StringVarP(&endpoint, ""endpoint"", """", """", ""CSI endpoint"")
	if err := startCmd.MarkFlagRequired(""endpoint""); err != nil {
		ErrorAndExit(err)
	}
	startCmd.Flags().StringSliceVarP(&pruneFs, ""prune-fs"", """", []string{""fuse.alluxio-fuse"", ""fuse.jindofs-fuse"", ""fuse.juicefs"", ""fuse.goosefs-fuse"", ""ossfs""}, ""Prune fs to add in /etc/updatedb.conf, separated by comma"")
	startCmd.Flags().StringVarP(&prunePath, ""prune-path"", """", ""/runtime-mnt"", ""Prune path to add in /etc/updatedb.conf"")
	startCmd.Flags().StringVarP(&metricsAddr, ""metrics-addr"", """", "":8080"", ""The address the metrics endpoint binds to."")
	startCmd.Flags().StringVarP(&pprofAddr, ""pprof-addr"", """", """", ""The address for pprof to use while exporting profiling results"")
	startCmd.Flags().StringVarP(&kubeletKubeConfigPath, ""kubelet-kube-config"", """", ""/etc/kubernetes/kubelet.conf"", ""The file path to kubelet kube config"")
	utilfeature.DefaultMutableFeatureGate.AddFlag(startCmd.Flags())
	startCmd.Flags().AddGoFlagSet(flag.CommandLine)
}
func ErrorAndExit(err error) {
	fmt.Fprintf(os.Stderr, ""%s"", err.Error())
	os.Exit(1)
}
func handle() {
	// startReaper()
	fluid.LogVersion()
	if pprofAddr != """" {
		newPprofServer(pprofAddr)
	}
	mgr, err := ctrl.NewManager(ctrl.GetConfigOrDie(), ctrl.Options{
		Scheme:             scheme,
		MetricsBindAddress: metricsAddr,
		Port:               9443,
	})
	if err != nil {
		panic(fmt.Sprintf(""csi: unable to create controller manager due to error %v"", err))
	}
	config := config.Config{
		NodeId:            nodeID,
		Endpoint:          endpoint,
		PruneFs:           pruneFs,
		PrunePath:         prunePath,
		KubeletConfigPath: kubeletKubeConfigPath,
	}
	if err = csi.SetupWithManager(mgr, config); err != nil {
		panic(fmt.Sprintf(""unable to set up manager due to error %v"", err))
	}
	ctx := ctrl.SetupSignalHandler()
	if err = mgr.Start(ctx); err != nil {
		panic(fmt.Sprintf(""unable to start controller recover due to error %v"", err))
	}
}
func newPprofServer(pprofAddr string) {
	glog.Infof(""Enabling pprof with address %s"", pprofAddr)
	mux := http.NewServeMux()
	mux.HandleFunc(""/debug/pprof/"", pprof.Index)
	mux.HandleFunc(""/debug/pprof/cmdline"", pprof.Cmdline)
	mux.HandleFunc(""/debug/pprof/profile"", pprof.Profile)
	mux.HandleFunc(""/debug/pprof/symbol"", pprof.Symbol)
	mux.HandleFunc(""/debug/pprof/trace"", pprof.Trace)
	pprofServer := http.Server{
		Addr:    pprofAddr,
		Handler: mux,
	}
	glog.Infof(""Starting pprof HTTP server at %s"", pprofServer.Addr)
	go func() {
		go func() {
			ctx := context.Background()
			<-ctx.Done()
			ctx, cancelFunc := context.WithTimeout(context.Background(), 60*time.Minute)
			defer cancelFunc()
			if err := pprofServer.Shutdown(ctx); err != nil {
				glog.Error(err, ""Failed to shutdown debug HTTP server"")
			}
		}()
		if err := pprofServer.ListenAndServe(); !errors.Is(http.ErrServerClosed, err) {
			glog.Error(err, ""Failed to start debug HTTP server"")
			panic(err)
		}
	}()
}
",CWE-863,165.0,0
"/*
Copyright 2022 The Fluid Authors.
Licensed under the Apache License, Version 2.0 (the ""License"");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an ""AS IS"" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package config
type Config struct {
	NodeId            string
	Endpoint          string
	PruneFs           []string
	PrunePath         string
	KubeletConfigPath string
}
",CWE-863,26.0,0
"/*
Copyright 2023 The Fluid Authors.
Licensed under the Apache License, Version 2.0 (the ""License"");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an ""AS IS"" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package plugins
import (
	""context""
	""fmt""
	""os""
	""path/filepath""
	""strings""
	""k8s.io/client-go/kubernetes""
	""sigs.k8s.io/controller-runtime/pkg/client""
	""sigs.k8s.io/controller-runtime/pkg/manager""
	""github.com/container-storage-interface/spec/lib/go/csi""
	""github.com/fluid-cloudnative/fluid/pkg/utils""
	""github.com/golang/glog""
	csicommon ""github.com/kubernetes-csi/drivers/pkg/csi-common""
)
const (
	driverName = ""fuse.csi.fluid.io""
	version    = ""1.0.0""
)
type driver struct {
	client               client.Client
	apiReader            client.Reader
	nodeAuthorizedClient *kubernetes.Clientset
	csiDriver            *csicommon.CSIDriver
	nodeId, endpoint     string
}
var _ manager.Runnable = &driver{}
func NewDriver(nodeID, endpoint string, client client.Client, apiReader client.Reader, nodeAuthorizedClient *kubernetes.Clientset) *driver {
	glog.Infof(""Driver: %v version: %v"", driverName, version)
	proto, addr := utils.SplitSchemaAddr(endpoint)
	glog.Infof(""protocol: %v addr: %v"", proto, addr)
	if !strings.HasPrefix(addr, ""/"") {
		addr = fmt.Sprintf(""/%s"", addr)
	}
	socketDir := filepath.Dir(addr)
	err := os.MkdirAll(socketDir, 0755)
	if err != nil {
		glog.Errorf(""failed due to %v"", err)
		os.Exit(1)
	}
	csiDriver := csicommon.NewCSIDriver(driverName, version, nodeID)
	csiDriver.AddControllerServiceCapabilities([]csi.ControllerServiceCapability_RPC_Type{csi.ControllerServiceCapability_RPC_CREATE_DELETE_VOLUME})
	csiDriver.AddVolumeCapabilityAccessModes([]csi.VolumeCapability_AccessMode_Mode{csi.VolumeCapability_AccessMode_MULTI_NODE_MULTI_WRITER})
	return &driver{
		nodeId:               nodeID,
		endpoint:             endpoint,
		csiDriver:            csiDriver,
		client:               client,
		nodeAuthorizedClient: nodeAuthorizedClient,
		apiReader:            apiReader,
	}
}
func (d *driver) newControllerServer() *controllerServer {
	return &controllerServer{
		DefaultControllerServer: csicommon.NewDefaultControllerServer(d.csiDriver),
	}
}
func (d *driver) newNodeServer() *nodeServer {
	return &nodeServer{
		nodeId:               d.nodeId,
		DefaultNodeServer:    csicommon.NewDefaultNodeServer(d.csiDriver),
		client:               d.client,
		apiReader:            d.apiReader,
		nodeAuthorizedClient: d.nodeAuthorizedClient,
	}
}
func (d *driver) run() {
	s := csicommon.NewNonBlockingGRPCServer()
	s.Start(
		d.endpoint,
		csicommon.NewDefaultIdentityServer(d.csiDriver),
		d.newControllerServer(),
		d.newNodeServer(),
	)
	s.Wait()
}
func (d *driver) Start(ctx context.Context) error {
	d.run()
	return nil
}
",CWE-863,113.0,0
"/*
Copyright 2022 The Fluid Authors.
Licensed under the Apache License, Version 2.0 (the ""License"");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an ""AS IS"" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package plugins
import (
	""github.com/fluid-cloudnative/fluid/pkg/csi/config""
	""github.com/fluid-cloudnative/fluid/pkg/utils/kubelet""
	""sigs.k8s.io/controller-runtime/pkg/manager""
)
// Register initializes the csi driver and registers it to the controller manager.
func Register(mgr manager.Manager, cfg config.Config) error {
	client, err := kubelet.InitNodeAuthorizedClient(cfg.KubeletConfigPath)
	if err != nil {
		return err
	}
	csiDriver := NewDriver(cfg.NodeId, cfg.Endpoint, mgr.GetClient(), mgr.GetAPIReader(), client)
	if err := mgr.Add(csiDriver); err != nil {
		return err
	}
	return nil
}
// Enabled checks if the csi driver should be enabled.
func Enabled() bool {
	return true
}
",CWE-863,45.0,0
"package kubelet
import (
	""github.com/pkg/errors""
	""k8s.io/client-go/kubernetes""
	""k8s.io/client-go/tools/clientcmd""
)
// InitNodeAuthorizedClient initializes node authorized client with kubelet's kube config.
// This is now an available workaround to implement a node-scoped daemonset.
// See discussion https://github.com/kubernetes/enhancements/pull/944
func InitNodeAuthorizedClient(kubeletKubeConfigPath string) (*kubernetes.Clientset, error) {
	config, err := clientcmd.BuildConfigFromFlags("""", kubeletKubeConfigPath)
	if err != nil {
		return nil, errors.Wrapf(err, ""fail to build kubelet config"")
	}
	client, err := kubernetes.NewForConfig(config)
	if err != nil {
		return nil, errors.Wrap(err, ""fail to build client-go client from kubelet kubeconfig"")
	}
	return client, nil
}
",CWE-863,25.0,0
"// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
syntax = ""proto3"";
package espv2.api.envoy.v11.http.header_sanitizer;
// header_sanitizer filter doesn't need any config.
// But a config protobuf type is required by FilterFactory.
// Hence defines an empty FilterConfig here.
message FilterConfig {}
",CWE-287,23.0,0
"// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package configgenerator
import (
	""github.com/GoogleCloudPlatform/esp-v2/src/go/configgenerator/filtergen""
	ci ""github.com/GoogleCloudPlatform/esp-v2/src/go/configinfo""
	""github.com/GoogleCloudPlatform/esp-v2/src/go/util/httppattern""
	hcmpb ""github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3""
	anypb ""github.com/golang/protobuf/ptypes/any""
)
// FilterGenerator is an interface for objects that generate Envoy filters.
type FilterGenerator interface {
	// FilterName returns the name of the filter.
	FilterName() string
	// IsEnabled returns true if the filter config should be generated.
	// If false, none of the generation methods will be called.
	IsEnabled() bool
	// GenFilterConfig generates the filter config.
	//
	// Return (nil, nil) if the filter has no listener-level config, but may
	// have per-route configurations.
	GenFilterConfig(*ci.ServiceInfo) (*hcmpb.HttpFilter, error)
	// GenPerRouteConfig generates the per-route config for the given HTTP route (HTTP pattern).
	// The MethodInfo that contains the route is also provided.
	//
	// This method is called on all routes. Return (nil, nil) to indicate the
	// filter does NOT require a per-route config for the given route.
	GenPerRouteConfig(*ci.MethodInfo, *httppattern.Pattern) (*anypb.Any, error)
}
// MakeFilterGenerators provide of a slice of FilterGenerator in sequence.
func MakeFilterGenerators(serviceInfo *ci.ServiceInfo) ([]FilterGenerator, error) {
	return []FilterGenerator{
		&filtergen.HeaderSanitizerGenerator{},
		filtergen.NewCORSGenerator(serviceInfo),
		// Health check filter is behind Path Matcher filter, since Service Control
		// filter needs to get the corresponding rule for health check in order to skip Report
		filtergen.NewHealthCheckGenerator(serviceInfo),
		filtergen.NewCompressorGenerator(serviceInfo, filtergen.GzipCompressor),
		filtergen.NewCompressorGenerator(serviceInfo, filtergen.BrotliCompressor),
		filtergen.NewJwtAuthnGenerator(serviceInfo),
		filtergen.NewServiceControlGenerator(serviceInfo),
		// grpc-web filter should be before grpc transcoder filter.
		// It converts content-type application/grpc-web to application/grpc and
		// grpc transcoder will bypass requests with application/grpc content type.
		// Otherwise grpc transcoder will try to transcode a grpc-web request which
		// will fail.
		filtergen.NewGRPCWebGenerator(serviceInfo),
		filtergen.NewGRPCTranscoderGenerator(serviceInfo),
		filtergen.NewBackendAuthGenerator(serviceInfo),
		filtergen.NewPathRewriteGenerator(serviceInfo),
		filtergen.NewGRPCMetadataScrubberGenerator(serviceInfo),
		// Add Envoy Router filter so requests are routed upstream.
		// Router filter should be the last.
		&filtergen.RouterGenerator{},
	}, nil
}
",CWE-287,80.0,0
"// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package filtergen
import (
	ci ""github.com/GoogleCloudPlatform/esp-v2/src/go/configinfo""
	hspb ""github.com/GoogleCloudPlatform/esp-v2/src/go/proto/api/envoy/v11/http/header_sanitizer""
	""github.com/GoogleCloudPlatform/esp-v2/src/go/util""
	""github.com/GoogleCloudPlatform/esp-v2/src/go/util/httppattern""
	hcmpb ""github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3""
	""github.com/golang/protobuf/ptypes""
	anypb ""github.com/golang/protobuf/ptypes/any""
)
type HeaderSanitizerGenerator struct{}
func (g *HeaderSanitizerGenerator) FilterName() string {
	return util.HeaderSanitizerScrubber
}
func (g *HeaderSanitizerGenerator) IsEnabled() bool {
	return true
}
func (g *HeaderSanitizerGenerator) GenFilterConfig(serviceInfo *ci.ServiceInfo) (*hcmpb.HttpFilter, error) {
	a, err := ptypes.MarshalAny(&hspb.FilterConfig{})
	if err != nil {
		return nil, err
	}
	return &hcmpb.HttpFilter{
		Name:       g.FilterName(),
		ConfigType: &hcmpb.HttpFilter_TypedConfig{TypedConfig: a},
	}, nil
}
func (g *HeaderSanitizerGenerator) GenPerRouteConfig(method *ci.MethodInfo, httpRule *httppattern.Pattern) (*anypb.Any, error) {
	return nil, nil
}
",CWE-287,51.0,0
"// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package util
import (
	""fmt""
	""io""
	""github.com/golang/protobuf/jsonpb""
	""github.com/golang/protobuf/proto""
	bapb ""github.com/GoogleCloudPlatform/esp-v2/src/go/proto/api/envoy/v11/http/backend_auth""
	gmspb ""github.com/GoogleCloudPlatform/esp-v2/src/go/proto/api/envoy/v11/http/grpc_metadata_scrubber""
	hspb ""github.com/GoogleCloudPlatform/esp-v2/src/go/proto/api/envoy/v11/http/header_sanitizer""
	prpb ""github.com/GoogleCloudPlatform/esp-v2/src/go/proto/api/envoy/v11/http/path_rewrite""
	scpb ""github.com/GoogleCloudPlatform/esp-v2/src/go/proto/api/envoy/v11/http/service_control""
	listenerpb ""github.com/envoyproxy/go-control-plane/envoy/config/listener/v3""
	statspb ""github.com/envoyproxy/go-control-plane/envoy/config/metrics/v3""
	tracepb ""github.com/envoyproxy/go-control-plane/envoy/config/trace/v3""
	accessfilepb ""github.com/envoyproxy/go-control-plane/envoy/extensions/access_loggers/file/v3""
	accessgrpcpb ""github.com/envoyproxy/go-control-plane/envoy/extensions/access_loggers/grpc/v3""
	brpb ""github.com/envoyproxy/go-control-plane/envoy/extensions/compression/brotli/compressor/v3""
	gzippb ""github.com/envoyproxy/go-control-plane/envoy/extensions/compression/gzip/compressor/v3""
	comppb ""github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/compressor/v3""
	corspb ""github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/cors/v3""
	transcoderpb ""github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/grpc_json_transcoder/v3""
	gspb ""github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/grpc_stats/v3""
	grpcwebpb ""github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/grpc_web/v3""
	jwtpb ""github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/jwt_authn/v3""
	routerpb ""github.com/envoyproxy/go-control-plane/envoy/extensions/filters/http/router/v3""
	hcmpb ""github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3""
	tlspb ""github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3""
	httppb ""github.com/envoyproxy/go-control-plane/envoy/extensions/upstreams/http/v3""
	wrapperspb ""github.com/golang/protobuf/ptypes/wrappers""
	annotationspb ""google.golang.org/genproto/googleapis/api/annotations""
	confpb ""google.golang.org/genproto/googleapis/api/serviceconfig""
	servicecontrolpb ""google.golang.org/genproto/googleapis/api/servicecontrol/v1""
	smpb ""google.golang.org/genproto/googleapis/api/servicemanagement/v1""
	visibilitypb ""google.golang.org/genproto/googleapis/api/visibility""
)
// Helper to convert Json string to protobuf.Any.
type FuncResolver func(url string) (proto.Message, error)
func (fn FuncResolver) Resolve(url string) (proto.Message, error) {
	return fn(url)
}
var Resolver = FuncResolver(func(url string) (proto.Message, error) {
	switch url {
	case ""type.googleapis.com/google.api.servicemanagement.v1.ConfigFile"":
		return new(smpb.ConfigFile), nil
	case ""type.googleapis.com/google.api.HttpRule"":
		return new(annotationspb.HttpRule), nil
	case ""type.googleapis.com/google.api.VisibilityRule"":
		return new(visibilitypb.VisibilityRule), nil
	case ""type.googleapis.com/google.protobuf.BoolValue"":
		return new(wrapperspb.BoolValue), nil
	case ""type.googleapis.com/google.protobuf.StringValue"":
		return new(wrapperspb.StringValue), nil
	case ""type.googleapis.com/google.protobuf.BytesValue"":
		return new(wrapperspb.BytesValue), nil
	case ""type.googleapis.com/google.protobuf.DoubleValue"":
		return new(wrapperspb.DoubleValue), nil
	case ""type.googleapis.com/google.protobuf.FloatValue"":
		return new(wrapperspb.FloatValue), nil
	case ""type.googleapis.com/google.protobuf.Int64Value"":
		return new(wrapperspb.Int64Value), nil
	case ""type.googleapis.com/google.protobuf.UInt64Value"":
		return new(wrapperspb.UInt64Value), nil
	case ""type.googleapis.com/google.protobuf.Int32Value"":
		return new(wrapperspb.Int32Value), nil
	case ""type.googleapis.com/google.protobuf.UInt32Value"":
		return new(wrapperspb.UInt32Value), nil
	case ""type.googleapis.com/google.api.Service"":
		return new(confpb.Service), nil
	case ""type.googleapis.com/envoy.extensions.filters.http.compressor.v3.Compressor"":
		return new(comppb.Compressor), nil
	case ""type.googleapis.com/envoy.extensions.filters.http.cors.v3.Cors"":
		return new(corspb.Cors), nil
	case ""type.googleapis.com/envoy.extensions.filters.http.grpc_stats.v3.FilterConfig"":
		return new(gspb.FilterConfig), nil
	case ""type.googleapis.com/envoy.extensions.filters.http.grpc_json_transcoder.v3.GrpcJsonTranscoder"":
		return new(transcoderpb.GrpcJsonTranscoder), nil
	case ""type.googleapis.com/envoy.extensions.filters.http.grpc_web.v3.GrpcWeb"":
		return new(grpcwebpb.GrpcWeb), nil
	case ""type.googleapis.com/envoy.extensions.filters.http.jwt_authn.v3.JwtAuthentication"":
		return new(jwtpb.JwtAuthentication), nil
	case ""type.googleapis.com/envoy.extensions.filters.http.jwt_authn.v3.PerRouteConfig"":
		return new(jwtpb.PerRouteConfig), nil
	case ""type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager"":
		return new(hcmpb.HttpConnectionManager), nil
	case ""type.googleapis.com/espv2.api.envoy.v11.http.path_rewrite.FilterConfig"":
		return new(prpb.FilterConfig), nil
	case ""type.googleapis.com/espv2.api.envoy.v11.http.path_rewrite.PerRouteFilterConfig"":
		return new(prpb.PerRouteFilterConfig), nil
	case ""type.googleapis.com/espv2.api.envoy.v11.http.service_control.PerRouteFilterConfig"":
		return new(scpb.PerRouteFilterConfig), nil
	case ""type.googleapis.com/espv2.api.envoy.v11.http.service_control.FilterConfig"":
		return new(scpb.FilterConfig), nil
	case ""type.googleapis.com/espv2.api.envoy.v11.http.backend_auth.PerRouteFilterConfig"":
		return new(bapb.PerRouteFilterConfig), nil
	case ""type.googleapis.com/espv2.api.envoy.v11.http.backend_auth.FilterConfig"":
		return new(bapb.FilterConfig), nil
	case ""type.googleapis.com/espv2.api.envoy.v11.http.grpc_metadata_scrubber.FilterConfig"":
		return new(gmspb.FilterConfig), nil
	case ""type.googleapis.com/espv2.api.envoy.v11.http.header_sanitizer.FilterConfig"":
		return new(hspb.FilterConfig), nil
	case ""type.googleapis.com/envoy.extensions.filters.http.router.v3.Router"":
		return new(routerpb.Router), nil
	case ""type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext"":
		return new(tlspb.UpstreamTlsContext), nil
	case ""type.googleapis.com/envoy.extensions.access_loggers.file.v3.FileAccessLog"":
		return new(accessfilepb.FileAccessLog), nil
	case ""type.googleapis.com/envoy.extensions.access_loggers.grpc.v3.HttpGrpcAccessLogConfig"":
		return new(accessgrpcpb.HttpGrpcAccessLogConfig), nil
	case ""type.googleapis.com/envoy.extensions.access_loggers.grpc.v3.TcpGrpcAccessLogConfig"":
		return new(accessgrpcpb.TcpGrpcAccessLogConfig), nil
	case ""type.googleapis.com/envoy.extensions.access_loggers.grpc.v3.CommonGrpcAccessLogConfig"":
		return new(accessgrpcpb.CommonGrpcAccessLogConfig), nil
	case ""type.googleapis.com/envoy.extensions.compression.brotli.compressor.v3.Brotli"":
		return new(brpb.Brotli), nil
	case ""type.googleapis.com/envoy.extensions.compression.gzip.compressor.v3.Gzip"":
		return new(gzippb.Gzip), nil
	case ""type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions"":
		return new(httppb.HttpProtocolOptions), nil
	case ""type.googleapis.com/envoy.config.listener.v3.Listener"":
		return new(listenerpb.Listener), nil
	case ""type.googleapis.com/envoy.config.metrics.v3.StatsConfig"":
		return new(statspb.StatsConfig), nil
	case ""type.googleapis.com/envoy.config.metrics.v3.StatsSink"":
		return new(statspb.StatsSink), nil
	case ""type.googleapis.com/envoy.config.metrics.v3.StatsdSink"":
		return new(statspb.StatsdSink), nil
	case ""type.googleapis.com/envoy.config.trace.v3.OpenCensusConfig"":
		return new(tracepb.OpenCensusConfig), nil
	default:
		return nil, fmt.Errorf(""unexpected protobuf.Any with url: %s"", url)
	}
})
// UnmarshalBytesToPbMessage converts bytes to corresponding pb message.
var UnmarshalBytesToPbMessage = func(input []byte, output proto.Message) error {
	switch t := output.(type) {
	case *confpb.Service:
		if err := proto.Unmarshal(input, output.(*confpb.Service)); err != nil {
			return fmt.Errorf(""fail to unmarshal %T: %v"", t, err)
		}
	case *smpb.ListServiceRolloutsResponse:
		if err := proto.Unmarshal(input, output.(*smpb.ListServiceRolloutsResponse)); err != nil {
			return fmt.Errorf(""fail to unmarshal %T: %v"", t, err)
		}
	case *servicecontrolpb.ReportResponse:
		if err := proto.Unmarshal(input, output.(*servicecontrolpb.ReportResponse)); err != nil {
			return fmt.Errorf(""fail to unmarshal %T: %v"", t, err)
		}
		return nil
	default:
		return fmt.Errorf(""not support unmarshalling %T"", t)
	}
	return nil
}
// UnmarshalServiceConfig converts service config in JSON to proto
func UnmarshalServiceConfig(config io.Reader) (*confpb.Service, error) {
	unmarshaler := &jsonpb.Unmarshaler{
		AllowUnknownFields: true,
		AnyResolver:        Resolver,
	}
	var serviceConfig confpb.Service
	if err := unmarshaler.Unmarshal(config, &serviceConfig); err != nil {
		return nil, fmt.Errorf(""fail to unmarshal serviceConfig: %s"", err)
	}
	return &serviceConfig, nil
}
func ProtoToJson(msg proto.Message) (string, error) {
	marshaler := &jsonpb.Marshaler{}
	return marshaler.MarshalToString(msg)
}
",CWE-287,195.0,0
"// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package util
import ""fmt""
const (
	// Upstream envoy http filter names.
	// Buffer HTTP filter
	Buffer = ""envoy.filters.http.buffer""
	// CORS HTTP filter
	CORS = ""envoy.filters.http.cors""
	// GRPCJSONTranscoder HTTP filter
	GRPCJSONTranscoder = ""envoy.filters.http.grpc_json_transcoder""
	// GRPCWeb HTTP filter
	GRPCWeb = ""envoy.filters.http.grpc_web""
	// Router HTTP filter
	Router = ""envoy.filters.http.router""
	// Health checking HTTP filter
	HealthCheck = ""envoy.filters.http.health_check""
	// Echo network filter
	Echo = ""envoy.filters.network.echo""
	// HTTPConnectionManager network filter
	HTTPConnectionManager = ""envoy.filters.network.http_connection_manager""
	// JwtAuthn filter.
	JwtAuthn = ""envoy.filters.http.jwt_authn""
	// TLSTransportSocket is Envoy TLS Transport Socket name.
	TLSTransportSocket = ""envoy.transport_sockets.tls""
	// AccessFileLogger filter name
	AccessFileLogger = ""envoy.access_loggers.file""
	// Upstream protocol options
	UpstreamProtocolOptions = ""envoy.extensions.upstreams.http.v3.HttpProtocolOptions""
	// Envoy compressor filter name
	EnvoyCompressorFilter = ""envoy.filters.http.compressor""
	EnvoyBrotliCompressor = ""envoy.compression.brotli.compressor""
	EnvoyGzipCompressor   = ""envoy.compression.gzip.compressor""
	// ESPv2 custom http filters.
	// ServiceControl filter.
	ServiceControl = ""com.google.espv2.filters.http.service_control""
	// PathRewrite filter.
	PathRewrite = ""com.google.espv2.filters.http.path_rewrite""
	// BackendAuth filter.
	BackendAuth = ""com.google.espv2.filters.http.backend_auth""
	// gRPC Metadata Scrubber filter.
	GrpcMetadataScrubber = ""com.google.espv2.filters.http.grpc_metadata_scrubber""
	// HeaderSanitizerScrubber is the filter name (matches c++ factory).
	HeaderSanitizerScrubber = ""com.google.espv2.filters.http.header_sanitizer""
	// The metadata server cluster name.
	MetadataServerClusterName = ""metadata-cluster""
	// The token agent server cluster name.
	TokenAgentClusterName = ""token-agent-cluster""
	// The iam server cluster name.
	IamServerClusterName = ""iam-cluster""
	// The service control server cluster name.
	ServiceControlClusterName = ""service-control-cluster""
	IngressListenerName  = ""ingress_listener""
	LoopbackListenerName = ""loopback_listener""
)
// Jwt provider cluster's name will be in form of ""jwt-provider-cluster-${JWT_PROVIDER_ADDRESS}"".
func JwtProviderClusterName(address string) string {
	return fmt.Sprintf(""jwt-provider-cluster-%s"", address)
}
// Backend cluster'name will be in form of ""backend-cluster-${BACKEND_ADDRESS}""
func BackendClusterName(address string) string {
	return fmt.Sprintf(""backend-cluster-%s"", address)
}
",CWE-287,89.0,0
"/*
Copyright 2022 labring.
Licensed under the Apache License, Version 2.0 (the ""License"");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an ""AS IS"" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package controllers
import (
	""context""
	""github.com/go-logr/logr""
	""github.com/labring/sealos/controllers/user/controllers/helper""
	v1 ""k8s.io/api/core/v1""
	""k8s.io/apimachinery/pkg/runtime""
	""k8s.io/client-go/tools/record""
	""k8s.io/client-go/util/retry""
	ctrl ""sigs.k8s.io/controller-runtime""
	""sigs.k8s.io/controller-runtime/pkg/builder""
	""sigs.k8s.io/controller-runtime/pkg/client""
	""sigs.k8s.io/controller-runtime/pkg/controller/controllerutil""
	""sigs.k8s.io/controller-runtime/pkg/predicate""
	""strings""
)
// NamespaceReconciler reconciles a Namespace object
type NamespaceReconciler struct {
	Logger   logr.Logger
	Recorder record.EventRecorder
	*runtime.Scheme
	client.Client
}
// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the cluster closer to the desired state.
// TODO(user): Modify the Reconcile function to compare the state specified by
// the User object against the actual cluster state, and then
// perform operations to make the cluster state reflect the state specified by
// the user.
//
// For more details, check Reconcile and its Result here:
// - https://pkg.go.dev/sigs.k8s.io/controller-runtime@v0.12.2/pkg/reconcile
func (r *NamespaceReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	r.Logger.V(1).Info(""start reconcile for ns"")
	ns := &v1.Namespace{}
	if err := r.Get(ctx, req.NamespacedName, ns); err != nil {
		return ctrl.Result{}, client.IgnoreNotFound(err)
	}
	if strings.HasPrefix(ns.Name, ""ns-"") {
		err := retry.RetryOnConflict(retry.DefaultRetry, func() error {
			change, err := controllerutil.CreateOrUpdate(ctx, r.Client, ns, func() error {
				if ns.Labels == nil {
					ns.Labels = map[string]string{}
				}
				ns.Labels = helper.SetPodSecurity(ns.Labels)
				return nil
			})
			if err != nil {
				return err
			}
			r.Logger.V(1).Info(""create or update ns"", ""change"", change, ""ns"", ns.Name)
			return nil
		})
		if err != nil {
			r.Logger.Error(err, ""create or update ns error"", ""ns"", ns.Name)
			return ctrl.Result{}, err
		}
	}
	return ctrl.Result{}, nil
}
// SetupWithManager sets up the controller with the Manager.
func (r *NamespaceReconciler) SetupWithManager(mgr ctrl.Manager) error {
	const controllerName = ""namespace_controller""
	if r.Client == nil {
		r.Client = mgr.GetClient()
	}
	r.Logger = ctrl.Log.WithName(controllerName)
	if r.Recorder == nil {
		r.Recorder = mgr.GetEventRecorderFor(controllerName)
	}
	r.Scheme = mgr.GetScheme()
	r.Logger.V(1).Info(""init reconcile controller namespace"")
	return ctrl.NewControllerManagedBy(mgr).
		For(&v1.Namespace{}, builder.WithPredicates(
			predicate.Or(predicate.AnnotationChangedPredicate{}, predicate.LabelChangedPredicate{}))).
		Complete(r)
}
",CWE-863,100.0,0
"/*
Copyright 2022 labring.
Licensed under the Apache License, Version 2.0 (the ""License"");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an ""AS IS"" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package main
import (
	""context""
	""flag""
	""os""
	""k8s.io/apimachinery/pkg/runtime""
	utilruntime ""k8s.io/apimachinery/pkg/util/runtime""
	clientgoscheme ""k8s.io/client-go/kubernetes/scheme""
	""github.com/labring/sealos/controllers/user/controllers/cache""
	// Import all Kubernetes client auth plugins (e.g. Azure, GCP, OIDC, etc.)
	// to ensure that exec-entrypoint and run can make use of them.
	_ ""k8s.io/client-go/plugin/pkg/client/auth""
	ctrl ""sigs.k8s.io/controller-runtime""
	""sigs.k8s.io/controller-runtime/pkg/healthz""
	""sigs.k8s.io/controller-runtime/pkg/log/zap""
	userv1 ""github.com/labring/sealos/controllers/user/api/v1""
	""github.com/labring/sealos/controllers/user/controllers""
	//+kubebuilder:scaffold:imports
)
var (
	scheme   = runtime.NewScheme()
	setupLog = ctrl.Log.WithName(""setup"")
)
func init() {
	utilruntime.Must(clientgoscheme.AddToScheme(scheme))
	utilruntime.Must(userv1.AddToScheme(scheme))
	//+kubebuilder:scaffold:scheme
}
func main() {
	var metricsAddr string
	var enableLeaderElection bool
	var probeAddr string
	flag.StringVar(&metricsAddr, ""metrics-bind-address"", "":8080"", ""The address the metric endpoint binds to."")
	flag.StringVar(&probeAddr, ""health-probe-bind-address"", "":8081"", ""The address the probe endpoint binds to."")
	flag.BoolVar(&enableLeaderElection, ""leader-elect"", false,
		""Enable leader election for controller manager. ""+
			""Enabling this will ensure there is only one active controller manager."")
	opts := zap.Options{
		Development: true,
	}
	opts.BindFlags(flag.CommandLine)
	flag.Parse()
	ctrl.SetLogger(zap.New(zap.UseFlagOptions(&opts)))
	mgr, err := ctrl.NewManager(ctrl.GetConfigOrDie(), ctrl.Options{
		Scheme:                 scheme,
		MetricsBindAddress:     metricsAddr,
		Port:                   9443,
		HealthProbeBindAddress: probeAddr,
		LeaderElection:         enableLeaderElection,
		LeaderElectionID:       ""785548a1.sealos.io"",
		// LeaderElectionReleaseOnCancel defines if the leader should step down voluntarily
		// when the Manager ends. This requires the binary to immediately end when the
		// Manager is stopped, otherwise, this setting is unsafe. Setting this significantly
		// speeds up voluntary leader transitions as the new leader don't have to wait
		// LeaseDuration time first.
		//
		// In the default scaffold provided, the program ends immediately after
		// the manager stops, so would be fine to enable this option. However,
		// if you are doing or is intended to do any operation such as perform cleanups
		// after the manager stops then its usage might be unsafe.
		// LeaderElectionReleaseOnCancel: true,
	})
	if err != nil {
		setupLog.Error(err, ""unable to start manager"")
		os.Exit(1)
	}
	if err = (&controllers.UserReconciler{}).SetupWithManager(mgr); err != nil {
		setupLog.Error(err, ""unable to create controller"", ""controller"", ""User"")
		os.Exit(1)
	}
	if err = (&controllers.UserGroupReconciler{}).SetupWithManager(mgr); err != nil {
		setupLog.Error(err, ""unable to create controller"", ""controller"", ""UserGroup"")
		os.Exit(1)
	}
	if err = (&controllers.UserGroupBindingReconciler{
		Client: mgr.GetClient(),
		Scheme: mgr.GetScheme(),
	}).SetupWithManager(mgr); err != nil {
		setupLog.Error(err, ""unable to create controller"", ""controller"", ""UserGroupBinding"")
		os.Exit(1)
	}
	if err = (&controllers.NamespaceReconciler{
		Client: mgr.GetClient(),
		Scheme: mgr.GetScheme(),
	}).SetupWithManager(mgr); err != nil {
		setupLog.Error(err, ""unable to create controller"", ""controller"", ""Namespace"")
		os.Exit(1)
	}
	//if err = (&controllers.UserExpirationReconciler{
	//	Client: mgr.GetClient(),
	//	Scheme: mgr.GetScheme(),
	//}).SetupWithManager(mgr); err != nil {
	//	setupLog.Error(err, ""unable to create controller"", ""controller"", ""Secret"")
	//	os.Exit(1)
	//}
	if err = cache.SetupCache(mgr); err != nil {
		setupLog.Error(err, ""unable to cache controller"")
		os.Exit(1)
	}
	if os.Getenv(""DISABLE_WEBHOOKS"") == ""true"" {
		setupLog.Info(""disable all webhooks"")
	} else {
		if err = (&userv1.User{}).SetupWebhookWithManager(mgr); err != nil {
			setupLog.Error(err, ""unable to create webhook"", ""webhook"", ""User"")
			os.Exit(1)
		}
		setupLog.Info(""add ug and ugb webhooks"")
		if err = (&userv1.UserGroup{}).SetupWebhookWithManager(mgr); err != nil {
			setupLog.Error(err, ""unable to create webhook"", ""webhook"", ""UserGroup"")
			os.Exit(1)
		}
		if err = (&userv1.UserGroupBinding{}).SetupWebhookWithManager(mgr); err != nil {
			setupLog.Error(err, ""unable to create webhook"", ""webhook"", ""UserGroupBinding"")
			os.Exit(1)
		}
	}
	//+kubebuilder:scaffold:builder
	if err := mgr.AddHealthzCheck(""healthz"", healthz.Ping); err != nil {
		setupLog.Error(err, ""unable to set up health check"")
		os.Exit(1)
	}
	if err := mgr.AddReadyzCheck(""readyz"", healthz.Ping); err != nil {
		setupLog.Error(err, ""unable to set up ready check"")
		os.Exit(1)
	}
	ctx, cancel := context.WithCancel(context.TODO())
	defer cancel()
	setupLog.Info(""starting manager"")
	if err = mgr.Start(ctx); err != nil {
		setupLog.Error(err, ""failed to running manager"")
		os.Exit(1)
	}
}
",CWE-863,167.0,0
"package main
import (
	""testing""
	""github.com/notaryproject/notation/internal/cmd""
)
func TestInspectCommand_SecretsFromArgs(t *testing.T) {
	opts := &inspectOpts{}
	command := inspectCommand(opts)
	expected := &inspectOpts{
		reference: ""ref"",
		SecureFlagOpts: SecureFlagOpts{
			Password:         ""password"",
			InsecureRegistry: true,
			Username:         ""user"",
		},
		outputFormat:  cmd.OutputPlaintext,
		maxSignatures: 100,
	}
	if err := command.ParseFlags([]string{
		""--password"", expected.Password,
		expected.reference,
		""-u"", expected.Username,
		""--insecure-registry"",
		""--output"", ""text""}); err != nil {
		t.Fatalf(""Parse Flag failed: %v"", err)
	}
	if err := command.Args(command, command.Flags().Args()); err != nil {
		t.Fatalf(""Parse Args failed: %v"", err)
	}
	if *opts != *expected {
		t.Fatalf(""Expect inspect opts: %v, got: %v"", expected, opts)
	}
}
func TestInspectCommand_SecretsFromEnv(t *testing.T) {
	t.Setenv(defaultUsernameEnv, ""user"")
	t.Setenv(defaultPasswordEnv, ""password"")
	opts := &inspectOpts{}
	expected := &inspectOpts{
		reference: ""ref"",
		SecureFlagOpts: SecureFlagOpts{
			Password: ""password"",
			Username: ""user"",
		},
		outputFormat:  cmd.OutputJSON,
		maxSignatures: 100,
	}
	command := inspectCommand(opts)
	if err := command.ParseFlags([]string{
		expected.reference,
		""--output"", ""json""}); err != nil {
		t.Fatalf(""Parse Flag failed: %v"", err)
	}
	if err := command.Args(command, command.Flags().Args()); err != nil {
		t.Fatalf(""Parse Args failed: %v"", err)
	}
	if *opts != *expected {
		t.Fatalf(""Expect inspect opts: %v, got: %v"", expected, opts)
	}
}
func TestInspectCommand_MissingArgs(t *testing.T) {
	command := inspectCommand(nil)
	if err := command.ParseFlags(nil); err != nil {
		t.Fatalf(""Parse Flag failed: %v"", err)
	}
	if err := command.Args(command, command.Flags().Args()); err == nil {
		t.Fatal(""Parse Args expected error, but ok"")
	}
}
",CWE-400,74.0,0
"package errors
import ""fmt""
// ErrorReferrersAPINotSupported is used when the target registry does not
// support the Referrers API
type ErrorReferrersAPINotSupported struct {
	Msg string
}
func (e ErrorReferrersAPINotSupported) Error() string {
	if e.Msg != """" {
		return e.Msg
	}
	return ""referrers API not supported""
}
// ErrorOCILayoutMissingReference is used when signing local content in oci
// layout folder but missing input tag or digest.
type ErrorOCILayoutMissingReference struct {
	Msg string
}
func (e ErrorOCILayoutMissingReference) Error() string {
	if e.Msg != """" {
		return e.Msg
	}
	return ""reference is missing either digest or tag""
}
// ErrorExceedMaxSignatures is used when the number of signatures has surpassed
// the maximum limit that can be evaluated.
type ErrorExceedMaxSignatures struct {
	MaxSignatures int
}
func (e ErrorExceedMaxSignatures) Error() string {
	return fmt.Sprintf(""exceeded configured limit of max signatures %d to examine"", e.MaxSignatures)
}
",CWE-400,40.0,0
"package main
import (
	""context""
	""errors""
	""fmt""
	notationregistry ""github.com/notaryproject/notation-go/registry""
	cmderr ""github.com/notaryproject/notation/cmd/notation/internal/errors""
	""github.com/notaryproject/notation/cmd/notation/internal/experimental""
	""github.com/notaryproject/notation/internal/cmd""
	""github.com/opencontainers/go-digest""
	ocispec ""github.com/opencontainers/image-spec/specs-go/v1""
	""github.com/spf13/cobra""
)
type listOpts struct {
	cmd.LoggingFlagOpts
	SecureFlagOpts
	reference         string
	allowReferrersAPI bool
	ociLayout         bool
	inputType         inputType
	maxSignatures     int
}
func listCommand(opts *listOpts) *cobra.Command {
	if opts == nil {
		opts = &listOpts{
			inputType: inputTypeRegistry, // remote registry by default
		}
	}
	command := &cobra.Command{
		Use:     ""list [flags] <reference>"",
		Aliases: []string{""ls""},
		Short:   ""List signatures of the signed artifact"",
		Long:    ""List all the signatures associated with signed artifact"",
		Args: func(cmd *cobra.Command, args []string) error {
			if len(args) == 0 {
				return errors.New(""no reference specified"")
			}
			opts.reference = args[0]
			return nil
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if opts.ociLayout {
				opts.inputType = inputTypeOCILayout
			}
			return experimental.CheckFlagsAndWarn(cmd, ""allow-referrers-api"", ""oci-layout"")
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			if opts.maxSignatures <= 0 {
				return fmt.Errorf(""max-signatures value %d must be a positive number"", opts.maxSignatures)
			}
			return runList(cmd.Context(), opts)
		},
	}
	opts.LoggingFlagOpts.ApplyFlags(command.Flags())
	opts.SecureFlagOpts.ApplyFlags(command.Flags())
	cmd.SetPflagReferrersAPI(command.Flags(), &opts.allowReferrersAPI, fmt.Sprintf(cmd.PflagReferrersUsageFormat, ""list""))
	command.Flags().BoolVar(&opts.ociLayout, ""oci-layout"", false, ""[Experimental] list signatures stored in OCI image layout"")
	experimental.HideFlags(command, """", []string{""allow-referrers-api"", ""oci-layout""})
	command.Flags().IntVar(&opts.maxSignatures, ""max-signatures"", 100, ""maximum number of signatures to evaluate or examine"")
	return command
}
func runList(ctx context.Context, opts *listOpts) error {
	// set log level
	ctx = opts.LoggingFlagOpts.SetLoggerLevel(ctx)
	// initialize
	reference := opts.reference
	sigRepo, err := getRepository(ctx, opts.inputType, reference, &opts.SecureFlagOpts, opts.allowReferrersAPI)
	if err != nil {
		return err
	}
	targetDesc, resolvedRef, err := resolveReferenceWithWarning(ctx, opts.inputType, reference, sigRepo, ""list"")
	if err != nil {
		return err
	}
	// print all signature manifest digests
	return printSignatureManifestDigests(ctx, targetDesc, sigRepo, resolvedRef, opts.maxSignatures)
}
// printSignatureManifestDigests returns the signature manifest digests of
// the subject manifest.
func printSignatureManifestDigests(ctx context.Context, targetDesc ocispec.Descriptor, sigRepo notationregistry.Repository, ref string, maxSigs int) error {
	titlePrinted := false
	printTitle := func() {
		if !titlePrinted {
			fmt.Println(ref)
			fmt.Printf(""└── %s\n"", notationregistry.ArtifactTypeNotation)
			titlePrinted = true
		}
	}
	var prevDigest digest.Digest
	err := listSignatures(ctx, sigRepo, targetDesc, maxSigs, func(sigManifestDesc ocispec.Descriptor) error {
		// print the previous signature digest
		if prevDigest != """" {
			printTitle()
			fmt.Printf(""    ├── %s\n"", prevDigest)
		}
		prevDigest = sigManifestDesc.Digest
		return nil
	})
	// print the last signature digest
	if prevDigest != """" {
		printTitle()
		fmt.Printf(""    └── %s\n"", prevDigest)
	}
	if err != nil {
		var errExceedMaxSignatures cmderr.ErrorExceedMaxSignatures
		if !errors.As(err, &errExceedMaxSignatures) {
			return err
		}
		fmt.Println(""Warning:"", errExceedMaxSignatures)
	}
	if !titlePrinted {
		fmt.Printf(""%s has no associated signature\n"", ref)
	}
	return nil
}
// listSignatures lists signatures associated with manifestDesc with number of
// signatures limited by maxSig
func listSignatures(ctx context.Context, sigRepo notationregistry.Repository, manifestDesc ocispec.Descriptor, maxSig int, fn func(sigManifest ocispec.Descriptor) error) error {
	numOfSignatureProcessed := 0
	return sigRepo.ListSignatures(ctx, manifestDesc, func(signatureManifests []ocispec.Descriptor) error {
		for _, sigManifestDesc := range signatureManifests {
			if numOfSignatureProcessed >= maxSig {
				return cmderr.ErrorExceedMaxSignatures{MaxSignatures: maxSig}
			}
			numOfSignatureProcessed++
			if err := fn(sigManifestDesc); err != nil {
				return err
			}
		}
		return nil
	})
}
",CWE-400,143.0,0
"package main
import (
	""testing""
)
func TestListCommand_SecretsFromArgs(t *testing.T) {
	opts := &listOpts{}
	cmd := listCommand(opts)
	expected := &listOpts{
		reference: ""ref"",
		SecureFlagOpts: SecureFlagOpts{
			Password:         ""password"",
			InsecureRegistry: true,
			Username:         ""user"",
		},
		maxSignatures: 100,
	}
	if err := cmd.ParseFlags([]string{
		""--password"", expected.Password,
		expected.reference,
		""-u"", expected.Username,
		""--insecure-registry""}); err != nil {
		t.Fatalf(""Parse Flag failed: %v"", err)
	}
	if err := cmd.Args(cmd, cmd.Flags().Args()); err != nil {
		t.Fatalf(""Parse Args failed: %v"", err)
	}
	if *opts != *expected {
		t.Fatalf(""Expect list opts: %v, got: %v"", expected, opts)
	}
}
func TestListCommand_SecretsFromEnv(t *testing.T) {
	t.Setenv(defaultUsernameEnv, ""user"")
	t.Setenv(defaultPasswordEnv, ""password"")
	opts := &listOpts{}
	expected := &listOpts{
		reference: ""ref"",
		SecureFlagOpts: SecureFlagOpts{
			Password: ""password"",
			Username: ""user"",
		},
		maxSignatures: 100,
	}
	cmd := listCommand(opts)
	if err := cmd.ParseFlags([]string{
		expected.reference}); err != nil {
		t.Fatalf(""Parse Flag failed: %v"", err)
	}
	if err := cmd.Args(cmd, cmd.Flags().Args()); err != nil {
		t.Fatalf(""Parse Args failed: %v"", err)
	}
	if *opts != *expected {
		t.Fatalf(""Expect list opts: %v, got: %v"", expected, opts)
	}
}
func TestListCommand_MissingArgs(t *testing.T) {
	cmd := listCommand(nil)
	if err := cmd.ParseFlags(nil); err != nil {
		t.Fatalf(""Parse Flag failed: %v"", err)
	}
	if err := cmd.Args(cmd, cmd.Flags().Args()); err == nil {
		t.Fatal(""Parse Args expected error, but ok"")
	}
}
",CWE-400,68.0,0
"package main
import (
	""errors""
	""fmt""
	""os""
	""reflect""
	""github.com/notaryproject/notation-go""
	""github.com/notaryproject/notation-go/verifier""
	""github.com/notaryproject/notation-go/verifier/trustpolicy""
	""github.com/notaryproject/notation/cmd/notation/internal/experimental""
	""github.com/notaryproject/notation/internal/cmd""
	""github.com/notaryproject/notation/internal/ioutil""
	""github.com/spf13/cobra""
)
type verifyOpts struct {
	cmd.LoggingFlagOpts
	SecureFlagOpts
	reference            string
	pluginConfig         []string
	userMetadata         []string
	allowReferrersAPI    bool
	ociLayout            bool
	trustPolicyScope     string
	inputType            inputType
	maxSignatureAttempts int
}
func verifyCommand(opts *verifyOpts) *cobra.Command {
	if opts == nil {
		opts = &verifyOpts{
			inputType: inputTypeRegistry, // remote registry by default
		}
	}
	longMessage := `Verify OCI artifacts
Prerequisite: added a certificate into trust store and created a trust policy.
Example - Verify a signature on an OCI artifact identified by a digest:
  notation verify <registry>/<repository>@<digest>
Example - Verify a signature on an OCI artifact identified by a tag  (Notation will resolve tag to digest):
  notation verify <registry>/<repository>:<tag>
`
	experimentalExamples := `
Example - [Experimental] Verify an OCI artifact using the Referrers API, if not supported (returns 404), fallback to the Referrers tag schema
  notation verify --allow-referrers-api <registry>/<repository>@<digest>
Example - [Experimental] Verify a signature on an OCI artifact referenced in an OCI layout using trust policy statement specified by scope.
  notation verify --oci-layout <registry>/<repository>@<digest> --scope <trust_policy_scope>
Example - [Experimental] Verify a signature on an OCI artifact identified by a tag and referenced in an OCI layout using trust policy statement specified by scope.
  notation verify --oci-layout <registry>/<repository>:<tag> --scope <trust_policy_scope>
`
	command := &cobra.Command{
		Use:   ""verify [reference]"",
		Short: ""Verify OCI artifacts"",
		Long:  longMessage,
		Args: func(cmd *cobra.Command, args []string) error {
			if len(args) == 0 {
				return errors.New(""missing reference"")
			}
			opts.reference = args[0]
			return nil
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if opts.ociLayout {
				opts.inputType = inputTypeOCILayout
			}
			return experimental.CheckFlagsAndWarn(cmd, ""allow-referrers-api"", ""oci-layout"", ""scope"")
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			if opts.maxSignatureAttempts <= 0 {
				return fmt.Errorf(""max-signatures value %d must be a positive number"", opts.maxSignatureAttempts)
			}
			return runVerify(cmd, opts)
		},
	}
	opts.LoggingFlagOpts.ApplyFlags(command.Flags())
	opts.SecureFlagOpts.ApplyFlags(command.Flags())
	command.Flags().StringArrayVar(&opts.pluginConfig, ""plugin-config"", nil, ""{key}={value} pairs that are passed as it is to a plugin, if the verification is associated with a verification plugin, refer plugin documentation to set appropriate values"")
	cmd.SetPflagUserMetadata(command.Flags(), &opts.userMetadata, cmd.PflagUserMetadataVerifyUsage)
	command.Flags().IntVar(&opts.maxSignatureAttempts, ""max-signatures"", 100, ""maximum number of signatures to evaluate or examine"")
	cmd.SetPflagReferrersAPI(command.Flags(), &opts.allowReferrersAPI, fmt.Sprintf(cmd.PflagReferrersUsageFormat, ""verify""))
	command.Flags().BoolVar(&opts.ociLayout, ""oci-layout"", false, ""[Experimental] verify the artifact stored as OCI image layout"")
	command.Flags().StringVar(&opts.trustPolicyScope, ""scope"", """", ""[Experimental] set trust policy scope for artifact verification, required and can only be used when flag \""--oci-layout\"" is set"")
	command.MarkFlagsRequiredTogether(""oci-layout"", ""scope"")
	experimental.HideFlags(command, experimentalExamples, []string{""allow-referrers-api"", ""oci-layout"", ""scope""})
	return command
}
func runVerify(command *cobra.Command, opts *verifyOpts) error {
	// set log level
	ctx := opts.LoggingFlagOpts.SetLoggerLevel(command.Context())
	// initialize
	sigVerifier, err := verifier.NewFromConfig()
	if err != nil {
		return err
	}
	// set up verification plugin config.
	configs, err := cmd.ParseFlagMap(opts.pluginConfig, cmd.PflagPluginConfig.Name)
	if err != nil {
		return err
	}
	// set up user metadata
	userMetadata, err := cmd.ParseFlagMap(opts.userMetadata, cmd.PflagUserMetadata.Name)
	if err != nil {
		return err
	}
	// core verify process
	reference := opts.reference
	sigRepo, err := getRepository(ctx, opts.inputType, reference, &opts.SecureFlagOpts, opts.allowReferrersAPI)
	if err != nil {
		return err
	}
	// resolve the given reference and set the digest
	_, resolvedRef, err := resolveReferenceWithWarning(ctx, opts.inputType, reference, sigRepo, ""verify"")
	if err != nil {
		return err
	}
	intendedRef := resolveArtifactDigestReference(resolvedRef, opts.trustPolicyScope)
	verifyOpts := notation.VerifyOptions{
		ArtifactReference:    intendedRef,
		PluginConfig:         configs,
		MaxSignatureAttempts: opts.maxSignatureAttempts,
		UserMetadata:         userMetadata,
	}
	_, outcomes, err := notation.Verify(ctx, sigVerifier, sigRepo, verifyOpts)
	err = checkVerificationFailure(outcomes, resolvedRef, err)
	if err != nil {
		return err
	}
	reportVerificationSuccess(outcomes, resolvedRef)
	return nil
}
func checkVerificationFailure(outcomes []*notation.VerificationOutcome, printOut string, err error) error {
	// write out on failure
	if err != nil || len(outcomes) == 0 {
		if err != nil {
			var errorVerificationFailed notation.ErrorVerificationFailed
			if !errors.As(err, &errorVerificationFailed) {
				return fmt.Errorf(""signature verification failed: %w"", err)
			}
		}
		return fmt.Errorf(""signature verification failed for all the signatures associated with %s"", printOut)
	}
	return nil
}
func reportVerificationSuccess(outcomes []*notation.VerificationOutcome, printout string) {
	// write out on success
	outcome := outcomes[0]
	// print out warning for any failed result with logged verification action
	for _, result := range outcome.VerificationResults {
		if result.Error != nil {
			// at this point, the verification action has to be logged and
			// it's failed
			fmt.Fprintf(os.Stderr, ""Warning: %v was set to %q and failed with error: %v\n"", result.Type, result.Action, result.Error)
		}
	}
	if reflect.DeepEqual(outcome.VerificationLevel, trustpolicy.LevelSkip) {
		fmt.Println(""Trust policy is configured to skip signature verification for"", printout)
	} else {
		fmt.Println(""Successfully verified signature for"", printout)
		printMetadataIfPresent(outcome)
	}
}
func printMetadataIfPresent(outcome *notation.VerificationOutcome) {
	// the signature envelope is parsed as part of verification.
	// since user metadata is only printed on successful verification,
	// this error can be ignored
	metadata, _ := outcome.UserMetadata()
	if len(metadata) > 0 {
		fmt.Println(""\nThe artifact was signed with the following user metadata."")
		ioutil.PrintMetadataMap(os.Stdout, metadata)
	}
}
",CWE-400,187.0,0
"package main
import (
	""reflect""
	""testing""
)
func TestVerifyCommand_BasicArgs(t *testing.T) {
	opts := &verifyOpts{}
	command := verifyCommand(opts)
	expected := &verifyOpts{
		reference: ""ref"",
		SecureFlagOpts: SecureFlagOpts{
			Username: ""user"",
			Password: ""password"",
		},
		pluginConfig:         []string{""key1=val1""},
		maxSignatureAttempts: 100,
	}
	if err := command.ParseFlags([]string{
		expected.reference,
		""--username"", expected.Username,
		""--password"", expected.Password,
		""--plugin-config"", ""key1=val1""}); err != nil {
		t.Fatalf(""Parse Flag failed: %v"", err)
	}
	if err := command.Args(command, command.Flags().Args()); err != nil {
		t.Fatalf(""Parse args failed: %v"", err)
	}
	if !reflect.DeepEqual(*expected, *opts) {
		t.Fatalf(""Expect verify opts: %v, got: %v"", expected, opts)
	}
}
func TestVerifyCommand_MoreArgs(t *testing.T) {
	opts := &verifyOpts{}
	command := verifyCommand(opts)
	expected := &verifyOpts{
		reference: ""ref"",
		SecureFlagOpts: SecureFlagOpts{
			InsecureRegistry: true,
		},
		pluginConfig:         []string{""key1=val1"", ""key2=val2""},
		maxSignatureAttempts: 100,
	}
	if err := command.ParseFlags([]string{
		expected.reference,
		""--insecure-registry"",
		""--plugin-config"", ""key1=val1"",
		""--plugin-config"", ""key2=val2""}); err != nil {
		t.Fatalf(""Parse Flag failed: %v"", err)
	}
	if err := command.Args(command, command.Flags().Args()); err != nil {
		t.Fatalf(""Parse args failed: %v"", err)
	}
	if !reflect.DeepEqual(*expected, *opts) {
		t.Fatalf(""Expect verify opts: %v, got: %v"", expected, opts)
	}
}
func TestVerifyCommand_MissingArgs(t *testing.T) {
	cmd := verifyCommand(nil)
	if err := cmd.ParseFlags(nil); err != nil {
		t.Fatalf(""Parse Flag failed: %v"", err)
	}
	if err := cmd.Args(cmd, cmd.Flags().Args()); err == nil {
		t.Fatal(""Parse Args expected error, but ok"")
	}
}
",CWE-400,70.0,0
"/*
 * Copyright (c) 2022, MegaEase
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Package mysql is the client probe for MySQL.
package mysql
import (
	""crypto/tls""
	""database/sql""
	""fmt""
	""strconv""
	""strings""
	""time""
	""github.com/go-sql-driver/mysql""
	""github.com/megaease/easeprobe/global""
	""github.com/megaease/easeprobe/probe/client/conf""
	log ""github.com/sirupsen/logrus""
)
// Kind is the type of driver
const Kind string = ""MySQL""
// MySQL is the MySQL client
type MySQL struct {
	conf.Options `yaml:"",inline""`
	tls          *tls.Config `yaml:""-"" json:""-""`
	ConnStr      string      `yaml:""conn_str,omitempty"" json:""conn_str,omitempty""`
}
// New create a Mysql client
func New(opt conf.Options) (*MySQL, error) {
	var conn string
	if len(opt.Password) > 0 {
		conn = fmt.Sprintf(""%s:%s@tcp(%s)/?timeout=%s"",
			opt.Username, opt.Password, opt.Host, opt.Timeout().Round(time.Second))
	} else {
		conn = fmt.Sprintf(""%s@tcp(%s)/?timeout=%s"",
			opt.Username, opt.Host, opt.Timeout().Round(time.Second))
	}
	tls, err := opt.TLS.Config()
	if err != nil {
		log.Errorf(""[%s / %s / %s] - TLS Config Error - %v"", opt.ProbeKind, opt.ProbeName, opt.ProbeTag, err)
		return nil, fmt.Errorf(""TLS Config Error - %v"", err)
	} else if tls != nil {
		conn += ""&tls="" + global.DefaultProg
	}
	m := &MySQL{
		Options: opt,
		tls:     tls,
		ConnStr: conn,
	}
	if err := m.checkData(); err != nil {
		return nil, err
	}
	return m, nil
}
// Kind return the name of client
func (r *MySQL) Kind() string {
	return Kind
}
// checkData do the data checking
func (r *MySQL) checkData() error {
	for k := range r.Data {
		if _, err := r.getSQL(k); err != nil {
			return err
		}
	}
	return nil
}
// Probe do the health check
func (r *MySQL) Probe() (bool, string) {
	if r.tls != nil {
		mysql.RegisterTLSConfig(global.DefaultProg, r.tls)
	}
	db, err := sql.Open(""mysql"", r.ConnStr)
	if err != nil {
		return false, err.Error()
	}
	defer db.Close()
	// Check if we need to query specific data
	if len(r.Data) > 0 {
		if err := r.ProbeWithDataVerification(db); err != nil {
			return false, err.Error()
		}
	} else {
		if err := r.ProbeWithPing(db); err != nil {
			return false, err.Error()
		}
	}
	return true, ""Check MySQL Server Successfully!""
}
// ProbeWithPing do the health check with ping
func (r *MySQL) ProbeWithPing(db *sql.DB) error {
	if err := db.Ping(); err != nil {
		return err
	}
	row, err := db.Query(""show status like \""uptime\"""") // run a SQL to test
	if err != nil {
		return err
	}
	defer row.Close()
	return nil
}
// ProbeWithDataVerification do the health check with data verification
func (r *MySQL) ProbeWithDataVerification(db *sql.DB) error {
	for k, v := range r.Data {
		log.Debugf(""[%s / %s / %s] - Verifying Data - [%s] : [%s]"", r.ProbeKind, r.ProbeName, r.ProbeTag, k, v)
		sql, err := r.getSQL(k)
		if err != nil {
			return err
		}
		log.Debugf(""[%s / %s / %s] - SQL - [%s]"", r.ProbeKind, r.ProbeName, r.ProbeTag, sql)
		rows, err := db.Query(sql)
		if err != nil {
			return err
		}
		if !rows.Next() {
			rows.Close()
			return fmt.Errorf(""No data found for [%s]"", k)
		}
		//check the value is equal to the value in data
		var value string
		if err := rows.Scan(&value); err != nil {
			rows.Close()
			return err
		}
		if value != v {
			rows.Close()
			return fmt.Errorf(""Value not match for [%s] expected [%s] got [%s] "", k, v, value)
		}
		rows.Close()
		log.Debugf(""[%s / %s / %s] - Data Verified Successfully! - [%s] : [%s]"", r.ProbeKind, r.ProbeName, r.ProbeTag, k, v)
	}
	return nil
}
// getSQL get the SQL statement
// input: database:table:column:key:value
// output: SELECT column FROM database.table WHERE key = value
func (r *MySQL) getSQL(str string) (string, error) {
	if len(strings.TrimSpace(str)) == 0 {
		return """", fmt.Errorf(""Empty SQL data"")
	}
	fields := strings.Split(str, "":"")
	if len(fields) != 5 {
		return """", fmt.Errorf(""Invalid SQL data - [%s]. (syntax: database:table:field:key:value)"", str)
	}
	db := global.EscapeQuote(fields[0])
	table := global.EscapeQuote(fields[1])
	field := global.EscapeQuote(fields[2])
	key := global.EscapeQuote(fields[3])
	value := global.EscapeQuote(fields[4])
	//check value is int or not
	if _, err := strconv.Atoi(value); err != nil {
		return """", fmt.Errorf(""Invalid SQL data - [%s], the value must be int"", str)
	}
	sql := fmt.Sprintf(""SELECT `%s` FROM `%s`.`%s` WHERE `%s` = %s"", field, db, table, key, value)
	return sql, nil
}
",CWE-89,192.0,0
"package gosnowflake
import (
	""net/url""
	""regexp""
)
var (
	matcher, _ = regexp.Compile(`^http(s?)\:\/\/[0-9a-zA-Z]([-.\w]*[0-9a-zA-Z@:])*(:(0-9)*)*(\/?)([a-zA-Z0-9\-\.\?\,\&\(\)\/\\\+&%\$
)
func isValidURL(targetURL string) bool {
	if !matcher.MatchString(targetURL) {
		logger.Infof("" The provided URL is not a valid URL - "" + targetURL)
		return false
	}
	return true
}
func urlEncode(targetString string) string {
	// We use QueryEscape instead of PathEscape here
	// for consistency across Drivers. For example:
	// QueryEscape escapes space as ""+"" whereas PE
	// it as %20F. PE also does not escape @ or &
	// either but QE does.
	// The behavior of QE in Golang is more in sync
	// with URL encoders in Python and Java hence the choice
	return url.QueryEscape(targetString)
}
",CWE-77,30.0,0
"package runner
import (
	""context""
	""errors""
	""fmt""
	""io""
	""github.com/hashicorp/terraform-exec/tfexec""
	tfjson ""github.com/hashicorp/terraform-json""
	""google.golang.org/grpc/codes""
	""google.golang.org/grpc/status""
	""sigs.k8s.io/controller-runtime""
	ctrl ""sigs.k8s.io/controller-runtime""
)
func (r *TerraformRunnerServer) tfShowPlanFile(ctx context.Context, planPath string, opts ...tfexec.ShowOption) (*tfjson.Plan, error) {
	log := ctrl.LoggerFrom(ctx, ""instance-id"", r.InstanceID).WithName(loggerName)
	// This is the only place where we disable the logger
	r.tf.SetStdout(io.Discard)
	r.tf.SetStderr(io.Discard)
	defer r.initLogger(log)
	return r.tf.ShowPlanFile(ctx, planPath, opts...)
}
func (r *TerraformRunnerServer) tfShowPlanFileRaw(ctx context.Context, planPath string, opts ...tfexec.ShowOption) (string, error) {
	log := ctrl.LoggerFrom(ctx, ""instance-id"", r.InstanceID).WithName(loggerName)
	// This is the only place where we disable the logger
	r.tf.SetStdout(io.Discard)
	r.tf.SetStderr(io.Discard)
	defer r.initLogger(log)
	return r.tf.ShowPlanFileRaw(ctx, planPath, opts...)
}
func (r *TerraformRunnerServer) Plan(ctx context.Context, req *PlanRequest) (*PlanReply, error) {
	log := controllerruntime.LoggerFrom(ctx, ""instance-id"", r.InstanceID).WithName(loggerName)
	log.Info(""creating a plan"")
	ctx, cancel := context.WithCancel(ctx)
	go func() {
		select {
		case <-r.Done:
			cancel()
		case <-ctx.Done():
		}
	}()
	if req.TfInstance != r.InstanceID {
		err := fmt.Errorf(""no TF instance found"")
		log.Error(err, ""no terraform"")
		return nil, err
	}
	var planOpt []tfexec.PlanOption
	if req.Out != """" {
		planOpt = append(planOpt, tfexec.Out(req.Out))
	} else {
		// if backend is disabled completely, there will be no plan output file (req.Out = """")
		log.Info(""backend seems to be disabled completely, so there will be no plan output file"")
	}
	if req.Refresh == false {
		planOpt = append(planOpt, tfexec.Refresh(req.Refresh))
	}
	if req.Destroy {
		planOpt = append(planOpt, tfexec.Destroy(req.Destroy))
	}
	for _, target := range req.Targets {
		planOpt = append(planOpt, tfexec.Target(target))
	}
	drifted, err := r.tf.Plan(ctx, planOpt...)
	if err != nil {
		st := status.New(codes.Internal, err.Error())
		var stateErr *tfexec.ErrStateLocked
		if errors.As(err, &stateErr) {
			st, err = st.WithDetails(&PlanReply{Message: ""not ok"", StateLockIdentifier: stateErr.ID})
			if err != nil {
				return nil, err
			}
		}
		log.Error(err, ""error creating the plan"")
		return nil, st.Err()
	}
	planCreated := false
	if req.Out != """" {
		planCreated = true
		plan, err := r.tfShowPlanFile(ctx, req.Out)
		if err != nil {
			return nil, err
		}
		// This is the case when the plan is empty.
		if plan.PlannedValues.Outputs == nil &&
			plan.PlannedValues.RootModule.Resources == nil &&
			plan.ResourceChanges == nil &&
			plan.PriorState == nil &&
			plan.OutputChanges == nil {
			planCreated = false
		}
	}
	return &PlanReply{Message: ""ok"", Drifted: drifted, PlanCreated: planCreated}, nil
}
",CWE-200,118.0,0
"package runner
import (
	""context""
	""encoding/json""
	""fmt""
	""sigs.k8s.io/controller-runtime""
)
func (r *TerraformRunnerServer) ShowPlanFileRaw(ctx context.Context, req *ShowPlanFileRawRequest) (*ShowPlanFileRawReply, error) {
	log := controllerruntime.LoggerFrom(ctx, ""instance-id"", r.InstanceID).WithName(loggerName)
	log.Info(""show the raw plan file"")
	if req.TfInstance != r.InstanceID {
		err := fmt.Errorf(""no TF instance found"")
		log.Error(err, ""no terraform"")
		return nil, err
	}
	rawOutput, err := r.tfShowPlanFileRaw(ctx, req.Filename)
	if err != nil {
		log.Error(err, ""unable to get the raw plan output"")
		return nil, err
	}
	return &ShowPlanFileRawReply{RawOutput: rawOutput}, nil
}
func (r *TerraformRunnerServer) ShowPlanFile(ctx context.Context, req *ShowPlanFileRequest) (*ShowPlanFileReply, error) {
	log := controllerruntime.LoggerFrom(ctx, ""instance-id"", r.InstanceID).WithName(loggerName)
	log.Info(""show the raw plan file"")
	if req.TfInstance != r.InstanceID {
		err := fmt.Errorf(""no TF instance found"")
		log.Error(err, ""no terraform"")
		return nil, err
	}
	plan, err := r.tfShowPlanFile(ctx, req.Filename)
	if err != nil {
		log.Error(err, ""unable to get the json plan output"")
		return nil, err
	}
	jsonBytes, err := json.Marshal(plan)
	if err != nil {
		log.Error(err, ""unable to marshal the plan to json"")
		return nil, err
	}
	return &ShowPlanFileReply{JsonOutput: jsonBytes}, nil
}
",CWE-200,51.0,0
"package runner
import (
	""context""
	""fmt""
	""io""
	""reflect""
	""github.com/hashicorp/terraform-exec/tfexec""
	infrav1 ""github.com/weaveworks/tf-controller/api/v1alpha2""
	corev1 ""k8s.io/api/core/v1""
	apierrors ""k8s.io/apimachinery/pkg/api/errors""
	metav1 ""k8s.io/apimachinery/pkg/apis/meta/v1""
	""k8s.io/apimachinery/pkg/types""
	ctrl ""sigs.k8s.io/controller-runtime""
)
func (r *TerraformRunnerServer) tfOutput(ctx context.Context, opts ...tfexec.OutputOption) (map[string]tfexec.OutputMeta, error) {
	log := ctrl.LoggerFrom(ctx, ""instance-id"", r.InstanceID).WithName(loggerName)
	// This is the only place where we disable the logger
	r.tf.SetStdout(io.Discard)
	r.tf.SetStderr(io.Discard)
	defer r.initLogger(log)
	return r.tf.Output(ctx, opts...)
}
func (r *TerraformRunnerServer) Output(ctx context.Context, req *OutputRequest) (*OutputReply, error) {
	log := ctrl.LoggerFrom(ctx, ""instance-id"", r.InstanceID).WithName(loggerName)
	log.Info(""creating outputs"")
	if req.TfInstance != r.InstanceID {
		err := fmt.Errorf(""no TF instance found"")
		log.Error(err, ""no terraform"")
		return nil, err
	}
	outputs, err := r.tfOutput(ctx)
	if err != nil {
		log.Error(err, ""unable to get outputs"")
		return nil, err
	}
	outputReply := &OutputReply{Outputs: map[string]*OutputMeta{}}
	for k, v := range outputs {
		outputReply.Outputs[k] = &OutputMeta{
			Sensitive: v.Sensitive,
			Type:      v.Type,
			Value:     v.Value,
		}
	}
	return outputReply, nil
}
func (r *TerraformRunnerServer) WriteOutputs(ctx context.Context, req *WriteOutputsRequest) (*WriteOutputsReply, error) {
	log := ctrl.LoggerFrom(ctx, ""instance-id"", r.InstanceID).WithName(loggerName)
	log.Info(""write outputs to secret"")
	objectKey := types.NamespacedName{Namespace: req.Namespace, Name: req.SecretName}
	var outputSecret corev1.Secret
	drift := true
	create := true
	if err := r.Client.Get(ctx, objectKey, &outputSecret); err == nil {
		// if everything is there, we don't write anything
		if reflect.DeepEqual(outputSecret.Data, req.Data) {
			drift = false
		} else {
			// found, but need update
			create = false
		}
	} else if apierrors.IsNotFound(err) == false {
		log.Error(err, ""unable to get output secret"")
		return nil, err
	}
	if drift {
		if create {
			vTrue := true
			outputSecret = corev1.Secret{
				ObjectMeta: metav1.ObjectMeta{
					Name:        req.SecretName,
					Namespace:   req.Namespace,
					Labels:      req.Labels,
					Annotations: req.Annotations,
					OwnerReferences: []metav1.OwnerReference{
						{
							APIVersion: infrav1.GroupVersion.Group + ""/"" + infrav1.GroupVersion.Version,
							Kind:       infrav1.TerraformKind,
							Name:       req.Name,
							UID:        types.UID(req.Uuid),
							Controller: &vTrue,
						},
					},
				},
				Type: corev1.SecretTypeOpaque,
				Data: req.Data,
			}
			err := r.Client.Create(ctx, &outputSecret)
			if err != nil {
				log.Error(err, ""unable to create secret"")
				return nil, err
			}
		} else {
			outputSecret.Data = req.Data
			err := r.Client.Update(ctx, &outputSecret)
			if err != nil {
				log.Error(err, ""unable to update secret"")
				return nil, err
			}
		}
		return &WriteOutputsReply{Message: ""ok"", Changed: true}, nil
	}
	return &WriteOutputsReply{Message: ""ok"", Changed: false}, nil
}
func (r *TerraformRunnerServer) GetOutputs(ctx context.Context, req *GetOutputsRequest) (*GetOutputsReply, error) {
	log := ctrl.LoggerFrom(ctx, ""instance-id"", r.InstanceID).WithName(loggerName)
	log.Info(""get outputs"")
	outputKey := types.NamespacedName{Namespace: req.Namespace, Name: req.SecretName}
	outputSecret := corev1.Secret{}
	err := r.Client.Get(ctx, outputKey, &outputSecret)
	if err != nil {
		err = fmt.Errorf(""error getting terraform output for health checks: %s"", err)
		log.Error(err, ""unable to check terraform health"")
		return nil, err
	}
	outputs := map[string]string{}
	// parse map[string][]byte to map[string]string for go template parsing
	if len(outputSecret.Data) > 0 {
		for k, v := range outputSecret.Data {
			outputs[k] = string(v)
		}
	}
	return &GetOutputsReply{Outputs: outputs}, nil
}
",CWE-200,143.0,0
"// Copyright (c) 2022 Gobalsky Labs Limited
//
// Use of this software is governed by the Business Source License included
// in the LICENSE.VEGA file and at https://www.mariadb.com/bsl11.
//
// Change Date: 18 months from the later of the date of the first publicly
// available Distribution of this version of the repository, and 25 June 2022.
//
// On the date above, in accordance with the Business Source License, use
// of this software will be governed by version 3 or later of the GNU General
// Public License.
package stubs
import (
	""code.vegaprotocol.io/vega/core/types""
)
type BridgeViewStub struct{}
func NewBridgeViewStub() *BridgeViewStub {
	return &BridgeViewStub{}
}
func (*BridgeViewStub) FindAssetList(al *types.ERC20AssetList, blockNumber, logIndex uint64, txHash string) error {
	return nil
}
func (*BridgeViewStub) FindBridgeStopped(al *types.ERC20EventBridgeStopped, blockNumber, logIndex uint64, txHash string) error {
	return nil
}
func (*BridgeViewStub) FindBridgeResumed(al *types.ERC20EventBridgeResumed, blockNumber, logIndex uint64, txHash string) error {
	return nil
}
func (*BridgeViewStub) FindDeposit(d *types.ERC20Deposit, blockNumber, logIndex uint64, ethAssetAddress string, txHash string) error {
	return nil
}
func (*BridgeViewStub) FindAssetLimitsUpdated(w *types.ERC20AssetLimitsUpdated, blockNumber, logIndex uint64, ethAssetAddress string, txHash string) error {
	return nil
}
",CWE-20,44.0,0
"package route
import (
	""net/http""
	""strings""
	""github.com/IceWhaleTech/CasaOS-Common/utils/logger""
	""github.com/IceWhaleTech/CasaOS-Gateway/service""
	""go.uber.org/zap""
)
type GatewayRoute struct {
	management *service.Management
}
func NewGatewayRoute(management *service.Management) *GatewayRoute {
	return &GatewayRoute{
		management: management,
	}
}
// the function is to ensure the request source IP is correct.
func rewriteRequestSourceIP(r *http.Request) {
	// we may receive two kinds of requests. a request from reverse proxy. a request from client.
	// in reverse proxy, X-Forwarded-For will like
	// `X-Forwarded-For:[192.168.6.102]`(normal)
	// `X-Forwarded-For:[::1, 192.168.6.102]`(hacked) Note: the ::1 is inject by attacker.
	// `X-Forwarded-For:[::1]`(normal or hacked) local request. But it from browser have JWT. So we can and need to verify it
	// `X-Forwarded-For:[::1,::1]`(normal or hacked) attacker can build the request to bypass the verification.
	// But in the case. the remoteAddress should be the real ip. So we can use remoteAddress to verify it.
	ipList := strings.Split(r.Header.Get(""X-Forwarded-For""), "","")
	r.Header.Del(""X-Forwarded-For"")
	r.Header.Del(""X-Real-IP"")
	// Note: the X-Forwarded-For depend the correct config from reverse proxy.
	// otherwise the X-Forwarded-For may be empty.
	remoteIP := r.RemoteAddr[:strings.LastIndex(r.RemoteAddr, "":"")]
	if len(ipList) > 0 && (remoteIP == ""127.0.0.1"" || remoteIP == ""::1"") {
		// to process the request from reverse proxy
		// in reverse proxy, X-Forwarded-For will container multiple IPs.
		// if the request is from reverse proxy, the r.RemoteAddr will be 127.0.0.1.
		// So we need get ip from X-Forwarded-For
		r.Header.Add(""X-Forwarded-For"", ipList[len(ipList)-1])
	}
	// to process the request from client.
	// the gateway will add the X-Forwarded-For to request header.
	// So we didn't need to add it.
}
func (g *GatewayRoute) GetRoute() *http.ServeMux {
	gatewayMux := http.NewServeMux()
	gatewayMux.HandleFunc(""/"", func(w http.ResponseWriter, r *http.Request) {
		if r.URL.Path == ""/ping"" {
			w.WriteHeader(http.StatusOK)
			if _, err := w.Write([]byte(""pong from gateway service"")); err != nil {
				logger.Error(""Failed to `pong` in resposne to `ping`"", zap.Any(""error"", err))
			}
			return
		}
		proxy := g.management.GetProxy(r.URL.Path)
		if proxy == nil {
			w.WriteHeader(http.StatusNotFound)
			return
		}
		// to fix https://github.com/IceWhaleTech/CasaOS/security/advisories/GHSA-32h8-rgcj-2g3c
		// API V1 and V2 both read ip from request header. So the fix is effective for v1 and v2.
		rewriteRequestSourceIP(r)
		proxy.ServeHTTP(w, r)
	})
	return gatewayMux
}
",CWE-306,81.0,0
"package constant
import (
	""errors""
)
const (
	CodeSuccess           = 200
	CodeErrBadRequest     = 400
	CodeErrUnauthorized   = 401
	CodeErrUnSafety       = 402
	CodeErrForbidden      = 403
	CodeErrNotFound       = 404
	CodePasswordExpired   = 405
	CodeAuth              = 406
	CodeGlobalLoading     = 407
	CodeErrIP             = 408
	CodeErrDomain         = 409
	CodeErrInternalServer = 500
	CodeErrHeader         = 406
)
// internal
var (
	ErrCaptchaCode     = errors.New(""ErrCaptchaCode"")
	ErrAuth            = errors.New(""ErrAuth"")
	ErrRecordExist     = errors.New(""ErrRecordExist"")
	ErrRecordNotFound  = errors.New(""ErrRecordNotFound"")
	ErrStructTransform = errors.New(""ErrStructTransform"")
	ErrInitialPassword = errors.New(""ErrInitialPassword"")
	ErrNotSupportType  = errors.New(""ErrNotSupportType"")
	ErrInvalidParams   = errors.New(""ErrInvalidParams"")
	ErrTokenParse = errors.New(""ErrTokenParse"")
)
// api
var (
	ErrTypeInternalServer  = ""ErrInternalServer""
	ErrTypeInvalidParams   = ""ErrInvalidParams""
	ErrTypeNotLogin        = ""ErrNotLogin""
	ErrTypePasswordExpired = ""ErrPasswordExpired""
	ErrNameIsExist         = ""ErrNameIsExist""
	ErrDemoEnvironment     = ""ErrDemoEnvironment""
	ErrCmdIllegal          = ""ErrCmdIllegal""
)
// app
var (
	ErrPortInUsed          = ""ErrPortInUsed""
	ErrAppLimit            = ""ErrAppLimit""
	ErrFileToLarge         = ""ErrFileToLarge""
	ErrFileCanNotRead      = ""ErrFileCanNotRead""
	ErrNotInstall          = ""ErrNotInstall""
	ErrPortInOtherApp      = ""ErrPortInOtherApp""
	ErrDbUserNotValid      = ""ErrDbUserNotValid""
	ErrUpdateBuWebsite     = ""ErrUpdateBuWebsite""
	Err1PanelNetworkFailed = ""Err1PanelNetworkFailed""
	ErrCmdTimeout          = ""ErrCmdTimeout""
	ErrFileParse           = ""ErrFileParse""
	ErrInstallDirNotFound  = ""ErrInstallDirNotFound""
	ErrContainerName       = ""ErrContainerName""
)
// website
var (
	ErrDomainIsExist      = ""ErrDomainIsExist""
	ErrAliasIsExist       = ""ErrAliasIsExist""
	ErrGroupIsUsed        = ""ErrGroupIsUsed""
	ErrUsernameIsExist    = ""ErrUsernameIsExist""
	ErrUsernameIsNotExist = ""ErrUsernameIsNotExist""
	ErrBackupMatch        = ""ErrBackupMatch""
	ErrBackupExist        = ""ErrBackupExist""
)
// ssl
var (
	ErrSSLCannotDelete     = ""ErrSSLCannotDelete""
	ErrAccountCannotDelete = ""ErrAccountCannotDelete""
	ErrSSLApply            = ""ErrSSLApply""
	ErrEmailIsExist        = ""ErrEmailIsExist""
)
// file
var (
	ErrPathNotFound     = ""ErrPathNotFound""
	ErrMovePathFailed   = ""ErrMovePathFailed""
	ErrLinkPathNotFound = ""ErrLinkPathNotFound""
	ErrFileIsExit       = ""ErrFileIsExit""
	ErrFileUpload       = ""ErrFileUpload""
	ErrFileDownloadDir  = ""ErrFileDownloadDir""
)
// mysql
var (
	ErrUserIsExist     = ""ErrUserIsExist""
	ErrDatabaseIsExist = ""ErrDatabaseIsExist""
	ErrExecTimeOut     = ""ErrExecTimeOut""
)
// redis
var (
	ErrTypeOfRedis = ""ErrTypeOfRedis""
)
// container
var (
	ErrInUsed       = ""ErrInUsed""
	ErrObjectInUsed = ""ErrObjectInUsed""
	ErrPortRules    = ""ErrPortRules""
)
// runtime
var (
	ErrDirNotFound    = ""ErrDirNotFound""
	ErrFileNotExist   = ""ErrFileNotExist""
	ErrImageBuildErr  = ""ErrImageBuildErr""
	ErrImageExist     = ""ErrImageExist""
	ErrDelWithWebsite = ""ErrDelWithWebsite""
)
var (
	ErrBackupInUsed = ""ErrBackupInUsed""
	ErrOSSConn      = ""ErrOSSConn""
)
",CWE-78,126.0,0
"package service
import (
	""strconv""
	""github.com/1Panel-dev/1Panel/backend/app/dto""
	""github.com/1Panel-dev/1Panel/backend/buserr""
	""github.com/1Panel-dev/1Panel/backend/constant""
	""github.com/1Panel-dev/1Panel/backend/global""
	""github.com/1Panel-dev/1Panel/backend/utils/encrypt""
	""github.com/1Panel-dev/1Panel/backend/utils/jwt""
	""github.com/1Panel-dev/1Panel/backend/utils/mfa""
	""github.com/gin-gonic/gin""
	""github.com/google/uuid""
	""github.com/pkg/errors""
)
type AuthService struct{}
type IAuthService interface {
	CheckIsSafety(code string) (string, error)
	VerifyCode(code string) (bool, error)
	Login(c *gin.Context, info dto.Login, entrance string) (*dto.UserLoginInfo, error)
	LogOut(c *gin.Context) error
	MFALogin(c *gin.Context, info dto.MFALogin, entrance string) (*dto.UserLoginInfo, error)
}
func NewIAuthService() IAuthService {
	return &AuthService{}
}
func (u *AuthService) Login(c *gin.Context, info dto.Login, entrance string) (*dto.UserLoginInfo, error) {
	nameSetting, err := settingRepo.Get(settingRepo.WithByKey(""UserName""))
	if err != nil {
		return nil, errors.WithMessage(constant.ErrRecordNotFound, err.Error())
	}
	passwordSetting, err := settingRepo.Get(settingRepo.WithByKey(""Password""))
	if err != nil {
		return nil, errors.WithMessage(constant.ErrRecordNotFound, err.Error())
	}
	pass, err := encrypt.StringDecrypt(passwordSetting.Value)
	if err != nil {
		return nil, constant.ErrAuth
	}
	if info.Password != pass || nameSetting.Value != info.Name {
		return nil, constant.ErrAuth
	}
	entranceSetting, err := settingRepo.Get(settingRepo.WithByKey(""SecurityEntrance""))
	if err != nil {
		return nil, err
	}
	if len(entranceSetting.Value) != 0 && entranceSetting.Value != entrance {
		return nil, buserr.New(constant.ErrEntrance)
	}
	mfa, err := settingRepo.Get(settingRepo.WithByKey(""MFAStatus""))
	if err != nil {
		return nil, err
	}
	if err = settingRepo.Update(""Language"", info.Language); err != nil {
		return nil, err
	}
	if mfa.Value == ""enable"" {
		return &dto.UserLoginInfo{Name: nameSetting.Value, MfaStatus: mfa.Value}, nil
	}
	return u.generateSession(c, info.Name, info.AuthMethod)
}
func (u *AuthService) MFALogin(c *gin.Context, info dto.MFALogin, entrance string) (*dto.UserLoginInfo, error) {
	nameSetting, err := settingRepo.Get(settingRepo.WithByKey(""UserName""))
	if err != nil {
		return nil, errors.WithMessage(constant.ErrRecordNotFound, err.Error())
	}
	passwordSetting, err := settingRepo.Get(settingRepo.WithByKey(""Password""))
	if err != nil {
		return nil, errors.WithMessage(constant.ErrRecordNotFound, err.Error())
	}
	pass, err := encrypt.StringDecrypt(passwordSetting.Value)
	if err != nil {
		return nil, err
	}
	if info.Password != pass || nameSetting.Value != info.Name {
		return nil, constant.ErrAuth
	}
	entranceSetting, err := settingRepo.Get(settingRepo.WithByKey(""SecurityEntrance""))
	if err != nil {
		return nil, err
	}
	if len(entranceSetting.Value) != 0 && entranceSetting.Value != entrance {
		return nil, buserr.New(constant.ErrEntrance)
	}
	mfaSecret, err := settingRepo.Get(settingRepo.WithByKey(""MFASecret""))
	if err != nil {
		return nil, err
	}
	mfaInterval, err := settingRepo.Get(settingRepo.WithByKey(""MFAInterval""))
	if err != nil {
		return nil, err
	}
	success := mfa.ValidCode(info.Code, mfaInterval.Value, mfaSecret.Value)
	if !success {
		return nil, constant.ErrAuth
	}
	return u.generateSession(c, info.Name, info.AuthMethod)
}
func (u *AuthService) generateSession(c *gin.Context, name, authMethod string) (*dto.UserLoginInfo, error) {
	setting, err := settingRepo.Get(settingRepo.WithByKey(""SessionTimeout""))
	if err != nil {
		return nil, err
	}
	httpsSetting, err := settingRepo.Get(settingRepo.WithByKey(""SSL""))
	if err != nil {
		return nil, err
	}
	lifeTime, err := strconv.Atoi(setting.Value)
	if err != nil {
		return nil, err
	}
	if authMethod == constant.AuthMethodJWT {
		j := jwt.NewJWT()
		claims := j.CreateClaims(jwt.BaseClaims{
			Name: name,
		})
		token, err := j.CreateToken(claims)
		if err != nil {
			return nil, err
		}
		return &dto.UserLoginInfo{Name: name, Token: token}, nil
	}
	sID, _ := c.Cookie(constant.SessionName)
	sessionUser, err := global.SESSION.Get(sID)
	if err != nil {
		sID = uuid.New().String()
		c.SetCookie(constant.SessionName, sID, 0, """", """", httpsSetting.Value == ""enable"", false)
		err := global.SESSION.Set(sID, sessionUser, lifeTime)
		if err != nil {
			return nil, err
		}
		return &dto.UserLoginInfo{Name: name}, nil
	}
	if err := global.SESSION.Set(sID, sessionUser, lifeTime); err != nil {
		return nil, err
	}
	return &dto.UserLoginInfo{Name: name}, nil
}
func (u *AuthService) LogOut(c *gin.Context) error {
	httpsSetting, err := settingRepo.Get(settingRepo.WithByKey(""SSL""))
	if err != nil {
		return err
	}
	sID, _ := c.Cookie(constant.SessionName)
	if sID != """" {
		c.SetCookie(constant.SessionName, sID, -1, """", """", httpsSetting.Value == ""enable"", false)
		err := global.SESSION.Delete(sID)
		if err != nil {
			return err
		}
	}
	return nil
}
func (u *AuthService) VerifyCode(code string) (bool, error) {
	setting, err := settingRepo.Get(settingRepo.WithByKey(""SecurityEntrance""))
	if err != nil {
		return false, err
	}
	return setting.Value == code, nil
}
func (u *AuthService) CheckIsSafety(code string) (string, error) {
	status, err := settingRepo.Get(settingRepo.WithByKey(""SecurityEntrance""))
	if err != nil {
		return """", err
	}
	if len(status.Value) == 0 {
		return ""disable"", nil
	}
	if status.Value == code {
		return ""pass"", nil
	}
	return ""unpass"", nil
}
",CWE-311,187.0,0
"/*
Copyright 2022 The Dapr Authors
Licensed under the Apache License, Version 2.0 (the ""License"");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an ""AS IS"" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package security
import (
	""os""
	""github.com/dapr/dapr/pkg/runtime/security/consts""
)
// GetAPIToken returns the value of the api token from an environment variable.
func GetAPIToken() string {
	return os.Getenv(consts.APITokenEnvVar)
}
// GetAppToken returns the value of the app api token from an environment variable.
func GetAppToken() string {
	return os.Getenv(consts.AppAPITokenEnvVar)
}
",CWE-287,31.0,0
"/*
Copyright 2022 The Dapr Authors
Licensed under the Apache License, Version 2.0 (the ""License"");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
	http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an ""AS IS"" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package security
import (
	""testing""
	""github.com/stretchr/testify/assert""
	""github.com/dapr/dapr/pkg/runtime/security/consts""
)
func TestAPIToken(t *testing.T) {
	t.Run(""existing token"", func(t *testing.T) {
		/* 
		token := ""eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJPbmxpbmUgSldUIEJ1aWxkZXIiLCJpYXQiOjE1OTA1NTQ1NzMsImV4cCI6MTYyMjA5MDU3MywiYXVkIjoid3d3LmV4YW1wbGUuY29tIiwic3ViIjoianJvY2tldEBleGFtcGxlLmNvbSIsIkdpdmVuTmFtZSI6IkpvaG5ueSIsIlN1cm5hbWUiOiJSb2NrZXQiLCJFbWFpbCI6Impyb2NrZXRAZXhhbXBsZS5jb20iLCJSb2xlIjpbIk1hbmFnZXIiLCJQcm9qZWN0IEFkbWluaXN0cmF0b3IiXX0.QLFl8ZqC48DOsT7SmXA794nivmqGgylzjrUu6JhXPW4""
		t.Setenv(consts.APITokenEnvVar, token)
		apitoken := GetAPIToken()
		assert.Equal(t, token, apitoken)
	})
	t.Run(""non-existent token"", func(t *testing.T) {
		token := GetAPIToken()
		assert.Equal(t, """", token)
	})
}
func TestAppToken(t *testing.T) {
	t.Run(""existing token"", func(t *testing.T) {
		/* 
		token := ""eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJPbmxpbmUgSldUIEJ1aWxkZXIiLCJpYXQiOjE1OTA1NTQ1NzMsImV4cCI6MTYyMjA5MDU3MywiYXVkIjoid3d3LmV4YW1wbGUuY29tIiwic3ViIjoianJvY2tldEBleGFtcGxlLmNvbSIsIkdpdmVuTmFtZSI6IkpvaG5ueSIsIlN1cm5hbWUiOiJSb2NrZXQiLCJFbWFpbCI6Impyb2NrZXRAZXhhbXBsZS5jb20iLCJSb2xlIjpbIk1hbmFnZXIiLCJQcm9qZWN0IEFkbWluaXN0cmF0b3IiXX0.QLFl8ZqC48DOsT7SmXA794nivmqGgylzjrUu6JhXPW4""
		t.Setenv(consts.AppAPITokenEnvVar, token)
		apitoken := GetAppToken()
		assert.Equal(t, token, apitoken)
	})
	t.Run(""non-existent token"", func(t *testing.T) {
		token := GetAppToken()
		assert.Equal(t, """", token)
	})
}
",CWE-287,57.0,0
"// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @file RTPSReader.h
 */
namespace eprosima {
namespace fastrtps {
namespace rtps {
class RTPSReader
{
    public:
        virtual bool matched_writer_add(RemoteWriterAttributes& wdata) = 0;
        virtual bool matched_writer_remove(RemoteWriterAttributes& wdata) = 0;
};
} // namespace rtps
} // namespace fastrtps
} // namespace eprosima
",CWE-284,40.0,0
"// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @file ReaderHistory.h
 */
namespace eprosima {
namespace fastrtps {
namespace rtps {
class ReaderHistory
{
    public:
        ReaderHistory(const HistoryAttributes& /*att*/){}
};
} // namespace rtps
} // namespace fastrtps
} // namespace eprosima
",CWE-284,40.0,0
"// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @file WriterHistory.h
 */
namespace eprosima {
namespace fastrtps {
namespace rtps {
class WriterHistory
{
    public:
        WriterHistory(const HistoryAttributes& /*att*/){}
};
} // namespace rtps
} // namespace fastrtps
} // namespace eprosima
",CWE-284,41.0,0
"package util
import (
	""mime""
	""strings""
)
func FixContentType(ct string) string {
	return strings.Split(ct, "";"")[0]
}
func ExtensionForContentType(ct string) string {
	exts, _ := mime.ExtensionsByType(ct)
	if len(exts) > 0 {
		return exts[0]
	}
	return "".bin""
}
func CanInline(ct string) bool {
	ct = FixContentType(ct)
	return ArrayContains(InlineContentTypes, ct)
}
var InlineContentTypes = []string{
	// Types are inherited from https://github.com/matrix-org/synapse/pull/15988
	""text/css"",
	""text/plain"",
	""text/csv"",
	""application/json"",
	""application/ld+json"",
	""image/jpeg"",
	""image/gif"",
	""image/png"",
	""image/apng"",
	""image/webp"",
	""image/avif"",
	""video/mp4"",
	""video/webm"",
	""video/ogg"",
	""video/quicktime"",
	""audio/mp4"",
	""audio/webm"",
	""audio/aac"",
	""audio/mpeg"",
	""audio/ogg"",
	""audio/wave"",
	""audio/wav"",
	""audio/x-wav"",
	""audio/x-pn-wav"",
	""audio/flac"",
	""audio/x-flac"",
}
",CWE-79,55.0,0
"package csrf
import (
	""errors""
	""github.com/gofiber/fiber/v2""
)
var (
	ErrMissingHeader = errors.New(""missing csrf token in header"")
	ErrMissingQuery  = errors.New(""missing csrf token in query"")
	ErrMissingParam  = errors.New(""missing csrf token in param"")
	ErrMissingForm   = errors.New(""missing csrf token in form"")
	ErrMissingCookie = errors.New(""missing csrf token in cookie"")
)
// csrfFromParam returns a function that extracts token from the url param string.
func CsrfFromParam(param string) func(c *fiber.Ctx) (string, error) {
	return func(c *fiber.Ctx) (string, error) {
		token := c.Params(param)
		if token == """" {
			return """", ErrMissingParam
		}
		return token, nil
	}
}
// csrfFromForm returns a function that extracts a token from a multipart-form.
func CsrfFromForm(param string) func(c *fiber.Ctx) (string, error) {
	return func(c *fiber.Ctx) (string, error) {
		token := c.FormValue(param)
		if token == """" {
			return """", ErrMissingForm
		}
		return token, nil
	}
}
// csrfFromCookie returns a function that extracts token from the cookie header.
func CsrfFromCookie(param string) func(c *fiber.Ctx) (string, error) {
	return func(c *fiber.Ctx) (string, error) {
		token := c.Cookies(param)
		if token == """" {
			return """", ErrMissingCookie
		}
		return token, nil
	}
}
// csrfFromHeader returns a function that extracts token from the request header.
func CsrfFromHeader(param string) func(c *fiber.Ctx) (string, error) {
	return func(c *fiber.Ctx) (string, error) {
		token := c.Get(param)
		if token == """" {
			return """", ErrMissingHeader
		}
		return token, nil
	}
}
// csrfFromQuery returns a function that extracts token from the query string.
func CsrfFromQuery(param string) func(c *fiber.Ctx) (string, error) {
	return func(c *fiber.Ctx) (string, error) {
		token := c.Query(param)
		if token == """" {
			return """", ErrMissingQuery
		}
		return token, nil
	}
}
",CWE-352,71.0,0
"package csrf
import (
	""errors""
	""github.com/gofiber/fiber/v2""
)
var (
	ErrMissingHeader = errors.New(""missing csrf token in header"")
	ErrMissingQuery  = errors.New(""missing csrf token in query"")
	ErrMissingParam  = errors.New(""missing csrf token in param"")
	ErrMissingForm   = errors.New(""missing csrf token in form"")
	ErrMissingCookie = errors.New(""missing csrf token in cookie"")
)
// csrfFromParam returns a function that extracts token from the url param string.
func CsrfFromParam(param string) func(c *fiber.Ctx) (string, error) {
	return func(c *fiber.Ctx) (string, error) {
		token := c.Params(param)
		if token == """" {
			return """", ErrMissingParam
		}
		return token, nil
	}
}
// csrfFromForm returns a function that extracts a token from a multipart-form.
func CsrfFromForm(param string) func(c *fiber.Ctx) (string, error) {
	return func(c *fiber.Ctx) (string, error) {
		token := c.FormValue(param)
		if token == """" {
			return """", ErrMissingForm
		}
		return token, nil
	}
}
// csrfFromCookie returns a function that extracts token from the cookie header.
func CsrfFromCookie(param string) func(c *fiber.Ctx) (string, error) {
	return func(c *fiber.Ctx) (string, error) {
		token := c.Cookies(param)
		if token == """" {
			return """", ErrMissingCookie
		}
		return token, nil
	}
}
// csrfFromHeader returns a function that extracts token from the request header.
func CsrfFromHeader(param string) func(c *fiber.Ctx) (string, error) {
	return func(c *fiber.Ctx) (string, error) {
		token := c.Get(param)
		if token == """" {
			return """", ErrMissingHeader
		}
		return token, nil
	}
}
// csrfFromQuery returns a function that extracts token from the query string.
func CsrfFromQuery(param string) func(c *fiber.Ctx) (string, error) {
	return func(c *fiber.Ctx) (string, error) {
		token := c.Query(param)
		if token == """" {
			return """", ErrMissingQuery
		}
		return token, nil
	}
}
",CWE-20,71.0,0
"package csrf
import (
	""errors""
	""github.com/gofiber/fiber/v2""
)
var (
	ErrMissingHeader = errors.New(""missing csrf token in header"")
	ErrMissingQuery  = errors.New(""missing csrf token in query"")
	ErrMissingParam  = errors.New(""missing csrf token in param"")
	ErrMissingForm   = errors.New(""missing csrf token in form"")
	ErrMissingCookie = errors.New(""missing csrf token in cookie"")
)
// csrfFromParam returns a function that extracts token from the url param string.
func CsrfFromParam(param string) func(c *fiber.Ctx) (string, error) {
	return func(c *fiber.Ctx) (string, error) {
		token := c.Params(param)
		if token == """" {
			return """", ErrMissingParam
		}
		return token, nil
	}
}
// csrfFromForm returns a function that extracts a token from a multipart-form.
func CsrfFromForm(param string) func(c *fiber.Ctx) (string, error) {
	return func(c *fiber.Ctx) (string, error) {
		token := c.FormValue(param)
		if token == """" {
			return """", ErrMissingForm
		}
		return token, nil
	}
}
// csrfFromCookie returns a function that extracts token from the cookie header.
func CsrfFromCookie(param string) func(c *fiber.Ctx) (string, error) {
	return func(c *fiber.Ctx) (string, error) {
		token := c.Cookies(param)
		if token == """" {
			return """", ErrMissingCookie
		}
		return token, nil
	}
}
// csrfFromHeader returns a function that extracts token from the request header.
func CsrfFromHeader(param string) func(c *fiber.Ctx) (string, error) {
	return func(c *fiber.Ctx) (string, error) {
		token := c.Get(param)
		if token == """" {
			return """", ErrMissingHeader
		}
		return token, nil
	}
}
// csrfFromQuery returns a function that extracts token from the query string.
func CsrfFromQuery(param string) func(c *fiber.Ctx) (string, error) {
	return func(c *fiber.Ctx) (string, error) {
		token := c.Query(param)
		if token == """" {
			return """", ErrMissingQuery
		}
		return token, nil
	}
}
",CWE-565,71.0,0
"package csrf
import (
	""errors""
	""github.com/gofiber/fiber/v2""
)
var (
	ErrMissingHeader = errors.New(""missing csrf token in header"")
	ErrMissingQuery  = errors.New(""missing csrf token in query"")
	ErrMissingParam  = errors.New(""missing csrf token in param"")
	ErrMissingForm   = errors.New(""missing csrf token in form"")
	ErrMissingCookie = errors.New(""missing csrf token in cookie"")
)
// csrfFromParam returns a function that extracts token from the url param string.
func CsrfFromParam(param string) func(c *fiber.Ctx) (string, error) {
	return func(c *fiber.Ctx) (string, error) {
		token := c.Params(param)
		if token == """" {
			return """", ErrMissingParam
		}
		return token, nil
	}
}
// csrfFromForm returns a function that extracts a token from a multipart-form.
func CsrfFromForm(param string) func(c *fiber.Ctx) (string, error) {
	return func(c *fiber.Ctx) (string, error) {
		token := c.FormValue(param)
		if token == """" {
			return """", ErrMissingForm
		}
		return token, nil
	}
}
// csrfFromCookie returns a function that extracts token from the cookie header.
func CsrfFromCookie(param string) func(c *fiber.Ctx) (string, error) {
	return func(c *fiber.Ctx) (string, error) {
		token := c.Cookies(param)
		if token == """" {
			return """", ErrMissingCookie
		}
		return token, nil
	}
}
// csrfFromHeader returns a function that extracts token from the request header.
func CsrfFromHeader(param string) func(c *fiber.Ctx) (string, error) {
	return func(c *fiber.Ctx) (string, error) {
		token := c.Get(param)
		if token == """" {
			return """", ErrMissingHeader
		}
		return token, nil
	}
}
// csrfFromQuery returns a function that extracts token from the query string.
func CsrfFromQuery(param string) func(c *fiber.Ctx) (string, error) {
	return func(c *fiber.Ctx) (string, error) {
		token := c.Query(param)
		if token == """" {
			return """", ErrMissingQuery
		}
		return token, nil
	}
}
",CWE-807,71.0,0
"package csrf
import (
	""crypto/subtle""
)
func compareTokens(a, b []byte) bool {
	return subtle.ConstantTimeCompare(a, b) == 1
}
func compareStrings(a, b string) bool {
	return subtle.ConstantTimeCompare([]byte(a), []byte(b)) == 1
}
",CWE-352,14.0,0
"package csrf
import (
	""crypto/subtle""
)
func compareTokens(a, b []byte) bool {
	return subtle.ConstantTimeCompare(a, b) == 1
}
func compareStrings(a, b string) bool {
	return subtle.ConstantTimeCompare([]byte(a), []byte(b)) == 1
}
",CWE-20,14.0,0
"package csrf
import (
	""crypto/subtle""
)
func compareTokens(a, b []byte) bool {
	return subtle.ConstantTimeCompare(a, b) == 1
}
func compareStrings(a, b string) bool {
	return subtle.ConstantTimeCompare([]byte(a), []byte(b)) == 1
}
",CWE-565,14.0,0
"package csrf
import (
	""crypto/subtle""
)
func compareTokens(a, b []byte) bool {
	return subtle.ConstantTimeCompare(a, b) == 1
}
func compareStrings(a, b string) bool {
	return subtle.ConstantTimeCompare([]byte(a), []byte(b)) == 1
}
",CWE-807,14.0,0
"package parser
import (
	""bytes""
	""github.com/gomarkdown/markdown/ast""
)
// citation parses a citation. In its most simple form [@ref], we allow multiple
// being separated by semicolons and a sub reference inside ala pandoc: [@ref, p. 23].
// Each citation can have a modifier: !, ? or - wich mean:
//
// ! - normative
// ? - formative
// - - suppressed
//
// The suffix starts after a comma, we strip any whitespace before and after. If the output
// allows for it, this can be rendered.
func citation(p *Parser, data []byte, offset int) (int, ast.Node) {
	// look for the matching closing bracket
	i := offset + 1
	for level := 1; level > 0 && i < len(data); i++ {
		switch {
		case data[i] == '\n':
			// no newlines allowed.
			return 0, nil
		case data[i-1] == '\\':
			continue
		case data[i] == '[':
			level++
		case data[i] == ']':
			level--
			if level <= 0 {
				i-- // compensate for extra i++ in for loop
			}
		}
	}
	if i >= len(data) {
		return 0, nil
	}
	node := &ast.Citation{}
	citations := bytes.Split(data[1:i], []byte("";""))
	for _, citation := range citations {
		var suffix []byte
		citation = bytes.TrimSpace(citation)
		j := 0
		if citation[j] != '@' {
			// not a citation, drop out entirely.
			return 0, nil
		}
		if c := bytes.Index(citation, []byte("","")); c > 0 {
			part := citation[:c]
			suff := citation[c+1:]
			part = bytes.TrimSpace(part)
			suff = bytes.TrimSpace(suff)
			citation = part
			suffix = suff
		}
		citeType := ast.CitationTypeInformative
		if len(citation) < 2 {
			continue
		}
		j = 1
		switch citation[j] {
		case '!':
			citeType = ast.CitationTypeNormative
			j++
		case '?':
			citeType = ast.CitationTypeInformative
			j++
		case '-':
			citeType = ast.CitationTypeSuppressed
			j++
		}
		node.Destination = append(node.Destination, citation[j:])
		node.Type = append(node.Type, citeType)
		node.Suffix = append(node.Suffix, suffix)
	}
	return i + 1, node
}
",CWE-125,92.0,0
"package ssh
import (
	""fmt""
	""time""
	""github.com/charmbracelet/log""
	""github.com/charmbracelet/soft-serve/server/backend""
	""github.com/charmbracelet/soft-serve/server/config""
	""github.com/charmbracelet/soft-serve/server/db""
	""github.com/charmbracelet/soft-serve/server/proto""
	""github.com/charmbracelet/soft-serve/server/ssh/cmd""
	""github.com/charmbracelet/soft-serve/server/sshutils""
	""github.com/charmbracelet/soft-serve/server/store""
	""github.com/charmbracelet/ssh""
	""github.com/charmbracelet/wish""
	""github.com/prometheus/client_golang/prometheus""
	""github.com/prometheus/client_golang/prometheus/promauto""
	""github.com/spf13/cobra""
	gossh ""golang.org/x/crypto/ssh""
)
// ErrPermissionDenied is returned when a user is not allowed connect.
var ErrPermissionDenied = fmt.Errorf(""permission denied"")
// AuthenticationMiddleware handles authentication.
func AuthenticationMiddleware(sh ssh.Handler) ssh.Handler {
	return func(s ssh.Session) {
		// XXX: The authentication key is set in the context but gossh doesn't
		// validate the authentication. We need to verify that the _last_ key
		// that was approved is the one that's being used.
		pk := s.PublicKey()
		if pk != nil {
			// There is no public key stored in the context, public-key auth
			// was never requested, skip
			perms := s.Permissions().Permissions
			if perms == nil {
				wish.Fatalln(s, ErrPermissionDenied)
				return
			}
			// Check if the key is the same as the one we have in context
			fp := perms.Extensions[""pubkey-fp""]
			if fp != gossh.FingerprintSHA256(pk) {
				wish.Fatalln(s, ErrPermissionDenied)
				return
			}
		}
		sh(s)
	}
}
// ContextMiddleware adds the config, backend, and logger to the session context.
func ContextMiddleware(cfg *config.Config, dbx *db.DB, datastore store.Store, be *backend.Backend, logger *log.Logger) func(ssh.Handler) ssh.Handler {
	return func(sh ssh.Handler) ssh.Handler {
		return func(s ssh.Session) {
			s.Context().SetValue(sshutils.ContextKeySession, s)
			s.Context().SetValue(config.ContextKey, cfg)
			s.Context().SetValue(db.ContextKey, dbx)
			s.Context().SetValue(store.ContextKey, datastore)
			s.Context().SetValue(backend.ContextKey, be)
			s.Context().SetValue(log.ContextKey, logger.WithPrefix(""ssh""))
			sh(s)
		}
	}
}
var cliCommandCounter = promauto.NewCounterVec(prometheus.CounterOpts{
	Namespace: ""soft_serve"",
	Subsystem: ""cli"",
	Name:      ""commands_total"",
	Help:      ""Total times each command was called"",
}, []string{""command""})
// CommandMiddleware handles git commands and CLI commands.
// This middleware must be run after the ContextMiddleware.
func CommandMiddleware(sh ssh.Handler) ssh.Handler {
	return func(s ssh.Session) {
		func() {
			_, _, ptyReq := s.Pty()
			if ptyReq {
				return
			}
			ctx := s.Context()
			cfg := config.FromContext(ctx)
			args := s.Command()
			cliCommandCounter.WithLabelValues(cmd.CommandName(args)).Inc()
			rootCmd := &cobra.Command{
				Short:        ""Soft Serve is a self-hostable Git server for the command line."",
				SilenceUsage: true,
			}
			rootCmd.CompletionOptions.DisableDefaultCmd = true
			rootCmd.SetUsageTemplate(cmd.UsageTemplate)
			rootCmd.SetUsageFunc(cmd.UsageFunc)
			rootCmd.AddCommand(
				cmd.GitUploadPackCommand(),
				cmd.GitUploadArchiveCommand(),
				cmd.GitReceivePackCommand(),
				cmd.RepoCommand(),
				cmd.SettingsCommand(),
				cmd.UserCommand(),
				cmd.InfoCommand(),
				cmd.PubkeyCommand(),
				cmd.SetUsernameCommand(),
				cmd.JWTCommand(),
				cmd.TokenCommand(),
			)
			if cfg.LFS.Enabled {
				rootCmd.AddCommand(
					cmd.GitLFSAuthenticateCommand(),
				)
				if cfg.LFS.SSHEnabled {
					rootCmd.AddCommand(
						cmd.GitLFSTransfer(),
					)
				}
			}
			rootCmd.SetArgs(args)
			if len(args) == 0 {
				// otherwise it'll default to os.Args, which is not what we want.
				rootCmd.SetArgs([]string{""--help""})
			}
			rootCmd.SetIn(s)
			rootCmd.SetOut(s)
			rootCmd.SetErr(s.Stderr())
			rootCmd.SetContext(ctx)
			if err := rootCmd.ExecuteContext(ctx); err != nil {
				s.Exit(1) // nolint: errcheck
				return
			}
		}()
		sh(s)
	}
}
// LoggingMiddleware logs the ssh connection and command.
func LoggingMiddleware(sh ssh.Handler) ssh.Handler {
	return func(s ssh.Session) {
		ctx := s.Context()
		logger := log.FromContext(ctx).WithPrefix(""ssh"")
		ct := time.Now()
		hpk := sshutils.MarshalAuthorizedKey(s.PublicKey())
		ptyReq, _, isPty := s.Pty()
		addr := s.RemoteAddr().String()
		user := proto.UserFromContext(ctx)
		logArgs := []interface{}{
			""addr"",
			addr,
			""cmd"",
			s.Command(),
		}
		if user != nil {
			logArgs = append([]interface{}{
				""username"",
				user.Username(),
			}, logArgs...)
		}
		if isPty {
			logArgs = []interface{}{
				""term"", ptyReq.Term,
				""width"", ptyReq.Window.Width,
				""height"", ptyReq.Window.Height,
			}
		}
		if config.IsVerbose() {
			logArgs = append(logArgs,
				""key"", hpk,
				""envs"", s.Environ(),
			)
		}
		msg := fmt.Sprintf(""user %q"", s.User())
		logger.Debug(msg+"" connected"", logArgs...)
		sh(s)
		logger.Debug(msg+"" disconnected"", append(logArgs, ""duration"", time.Since(ct))...)
	}
}
",CWE-287,190.0,0
"/*
Copyright © 2021 ConsenSys Software Inc.
Licensed under the Apache License, Version 2.0 (the ""License"");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an ""AS IS"" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package frontend
import (
	""math/big""
	""github.com/consensys/gnark/constraint/solver""
)
// API represents the available functions to circuit developers
type API interface {
	// ---------------------------------------------------------------------------------------------
	// Arithmetic
	// Add returns res = i1+i2+...in
	Add(i1, i2 Variable, in ...Variable) Variable
	// MulAcc sets and return a = a + (b*c).
	//
	// ! The method may mutate a without allocating a new result. If the input
	// is used elsewhere, then first initialize new variable, for example by
	// doing:
	//
	//     acopy := api.Mul(a, 1)
	//     acopy = MulAcc(acopy, b, c)
	//
	// ! But it may not modify a, always use MulAcc(...) result for correctness.
	MulAcc(a, b, c Variable) Variable
	// Neg returns -i
	Neg(i1 Variable) Variable
	// Sub returns res = i1 - i2 - ...in
	Sub(i1, i2 Variable, in ...Variable) Variable
	// Mul returns res = i1 * i2 * ... in
	Mul(i1, i2 Variable, in ...Variable) Variable
	// DivUnchecked returns i1 / i2 . if i1 == i2 == 0, returns 0
	DivUnchecked(i1, i2 Variable) Variable
	// Div returns i1 / i2
	Div(i1, i2 Variable) Variable
	// Inverse returns res = 1 / i1
	Inverse(i1 Variable) Variable
	// ---------------------------------------------------------------------------------------------
	// Bit operations
	// TODO @gbotrel move bit operations in std/math/bits
	// ToBinary unpacks a Variable in binary,
	// n is the number of bits to select (starting from lsb)
	// n default value is fr.Bits the number of bits needed to represent a field element
	//
	// The result in little endian (first bit= lsb)
	ToBinary(i1 Variable, n ...int) []Variable
	// FromBinary packs b, seen as a fr.Element in little endian
	FromBinary(b ...Variable) Variable
	// Xor returns a ^ b
	// a and b must be 0 or 1
	Xor(a, b Variable) Variable
	// Or returns a | b
	// a and b must be 0 or 1
	Or(a, b Variable) Variable
	// Or returns a & b
	// a and b must be 0 or 1
	And(a, b Variable) Variable
	// ---------------------------------------------------------------------------------------------
	// Conditionals
	// Select if b is true, yields i1 else yields i2
	Select(b Variable, i1, i2 Variable) Variable
	// Lookup2 performs a 2-bit lookup between i1, i2, i3, i4 based on bits b0
	// and b1. Returns i0 if b0=b1=0, i1 if b0=1 and b1=0, i2 if b0=0 and b1=1
	// and i3 if b0=b1=1.
	Lookup2(b0, b1 Variable, i0, i1, i2, i3 Variable) Variable
	// IsZero returns 1 if a is zero, 0 otherwise
	IsZero(i1 Variable) Variable
	// Cmp returns:
	//  * 1 if i1>i2,
	//  * 0 if i1=i2,
	//  * -1 if i1<i2.
	//
	// If the absolute difference between the variables i1 and i2 is known, then
	// it is more efficient to use the bounded methdods in package
	// [github.com/consensys/gnark/std/math/bits].
	Cmp(i1, i2 Variable) Variable
	// ---------------------------------------------------------------------------------------------
	// Assertions
	// AssertIsEqual fails if i1 != i2
	AssertIsEqual(i1, i2 Variable)
	// AssertIsDifferent fails if i1 == i2
	AssertIsDifferent(i1, i2 Variable)
	// AssertIsBoolean fails if v != 0 ∥ v != 1
	AssertIsBoolean(i1 Variable)
	// AssertIsLessOrEqual fails if v > bound.
	//
	// If the absolute difference between the variables b and bound is known, then
	// it is more efficient to use the bounded methdods in package
	// [github.com/consensys/gnark/std/math/bits].
	AssertIsLessOrEqual(v Variable, bound Variable)
	// Println behaves like fmt.Println but accepts cd.Variable as parameter
	// whose value will be resolved at runtime when computed by the solver
	Println(a ...Variable)
	// Compiler returns the compiler object for advanced circuit development
	Compiler() Compiler
	// Deprecated APIs
	// NewHint is a shortcut to api.Compiler().NewHint()
	// Deprecated: use api.Compiler().NewHint() instead
	NewHint(f solver.Hint, nbOutputs int, inputs ...Variable) ([]Variable, error)
	// ConstantValue is a shortcut to api.Compiler().ConstantValue()
	// Deprecated: use api.Compiler().ConstantValue() instead
	ConstantValue(v Variable) (*big.Int, bool)
}
// BatchInvert returns a slice of variables containing the inverse of each element in i1
// This is a temporary API, do not use it in your circuit
type BatchInverter interface {
	// BatchInvert returns a slice of variables containing the inverse of each element in i1
	// This is a temporary API, do not use it in your circuit
	BatchInvert(i1 []Variable) []Variable
}
",CWE-191,157.0,0
"/*
Copyright © 2021 ConsenSys Software Inc.
Licensed under the Apache License, Version 2.0 (the ""License"");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an ""AS IS"" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package frontend
import (
	""math/big""
	""github.com/consensys/gnark/constraint/solver""
)
// API represents the available functions to circuit developers
type API interface {
	// ---------------------------------------------------------------------------------------------
	// Arithmetic
	// Add returns res = i1+i2+...in
	Add(i1, i2 Variable, in ...Variable) Variable
	// MulAcc sets and return a = a + (b*c).
	//
	// ! The method may mutate a without allocating a new result. If the input
	// is used elsewhere, then first initialize new variable, for example by
	// doing:
	//
	//     acopy := api.Mul(a, 1)
	//     acopy = MulAcc(acopy, b, c)
	//
	// ! But it may not modify a, always use MulAcc(...) result for correctness.
	MulAcc(a, b, c Variable) Variable
	// Neg returns -i
	Neg(i1 Variable) Variable
	// Sub returns res = i1 - i2 - ...in
	Sub(i1, i2 Variable, in ...Variable) Variable
	// Mul returns res = i1 * i2 * ... in
	Mul(i1, i2 Variable, in ...Variable) Variable
	// DivUnchecked returns i1 / i2 . if i1 == i2 == 0, returns 0
	DivUnchecked(i1, i2 Variable) Variable
	// Div returns i1 / i2
	Div(i1, i2 Variable) Variable
	// Inverse returns res = 1 / i1
	Inverse(i1 Variable) Variable
	// ---------------------------------------------------------------------------------------------
	// Bit operations
	// TODO @gbotrel move bit operations in std/math/bits
	// ToBinary unpacks a Variable in binary,
	// n is the number of bits to select (starting from lsb)
	// n default value is fr.Bits the number of bits needed to represent a field element
	//
	// The result in little endian (first bit= lsb)
	ToBinary(i1 Variable, n ...int) []Variable
	// FromBinary packs b, seen as a fr.Element in little endian
	FromBinary(b ...Variable) Variable
	// Xor returns a ^ b
	// a and b must be 0 or 1
	Xor(a, b Variable) Variable
	// Or returns a | b
	// a and b must be 0 or 1
	Or(a, b Variable) Variable
	// Or returns a & b
	// a and b must be 0 or 1
	And(a, b Variable) Variable
	// ---------------------------------------------------------------------------------------------
	// Conditionals
	// Select if b is true, yields i1 else yields i2
	Select(b Variable, i1, i2 Variable) Variable
	// Lookup2 performs a 2-bit lookup between i1, i2, i3, i4 based on bits b0
	// and b1. Returns i0 if b0=b1=0, i1 if b0=1 and b1=0, i2 if b0=0 and b1=1
	// and i3 if b0=b1=1.
	Lookup2(b0, b1 Variable, i0, i1, i2, i3 Variable) Variable
	// IsZero returns 1 if a is zero, 0 otherwise
	IsZero(i1 Variable) Variable
	// Cmp returns:
	//  * 1 if i1>i2,
	//  * 0 if i1=i2,
	//  * -1 if i1<i2.
	//
	// If the absolute difference between the variables i1 and i2 is known, then
	// it is more efficient to use the bounded methdods in package
	// [github.com/consensys/gnark/std/math/bits].
	Cmp(i1, i2 Variable) Variable
	// ---------------------------------------------------------------------------------------------
	// Assertions
	// AssertIsEqual fails if i1 != i2
	AssertIsEqual(i1, i2 Variable)
	// AssertIsDifferent fails if i1 == i2
	AssertIsDifferent(i1, i2 Variable)
	// AssertIsBoolean fails if v != 0 ∥ v != 1
	AssertIsBoolean(i1 Variable)
	// AssertIsLessOrEqual fails if v > bound.
	//
	// If the absolute difference between the variables b and bound is known, then
	// it is more efficient to use the bounded methdods in package
	// [github.com/consensys/gnark/std/math/bits].
	AssertIsLessOrEqual(v Variable, bound Variable)
	// Println behaves like fmt.Println but accepts cd.Variable as parameter
	// whose value will be resolved at runtime when computed by the solver
	Println(a ...Variable)
	// Compiler returns the compiler object for advanced circuit development
	Compiler() Compiler
	// Deprecated APIs
	// NewHint is a shortcut to api.Compiler().NewHint()
	// Deprecated: use api.Compiler().NewHint() instead
	NewHint(f solver.Hint, nbOutputs int, inputs ...Variable) ([]Variable, error)
	// ConstantValue is a shortcut to api.Compiler().ConstantValue()
	// Deprecated: use api.Compiler().ConstantValue() instead
	ConstantValue(v Variable) (*big.Int, bool)
}
// BatchInvert returns a slice of variables containing the inverse of each element in i1
// This is a temporary API, do not use it in your circuit
type BatchInverter interface {
	// BatchInvert returns a slice of variables containing the inverse of each element in i1
	// This is a temporary API, do not use it in your circuit
	BatchInvert(i1 []Variable) []Variable
}
",CWE-697,157.0,0
"package circuits
import (
	""fmt""
	""math/big""
	""github.com/consensys/gnark/frontend""
	""github.com/consensys/gnark/std/math/bits""
)
type hintCircuit struct {
	A, B frontend.Variable
}
func (circuit *hintCircuit) Define(api frontend.API) error {
	res, err := api.Compiler().NewHint(mulBy7, 1, circuit.A)
	if err != nil {
		return fmt.Errorf(""mulBy7: %w"", err)
	}
	a7 := res[0]
	_a7 := api.Mul(circuit.A, 7)
	api.AssertIsEqual(a7, _a7)
	api.AssertIsEqual(a7, circuit.B)
	res, err = api.Compiler().NewHint(make3, 1)
	if err != nil {
		return fmt.Errorf(""make3: %w"", err)
	}
	c := res[0]
	c = api.Mul(c, c)
	api.AssertIsEqual(c, 9)
	return nil
}
type vectorDoubleCircuit struct {
	A []frontend.Variable
	B []frontend.Variable
}
func (c *vectorDoubleCircuit) Define(api frontend.API) error {
	res, err := api.Compiler().NewHint(dvHint, len(c.B), c.A...)
	if err != nil {
		return fmt.Errorf(""double newhint: %w"", err)
	}
	if len(res) != len(c.B) {
		return fmt.Errorf(""expected len %d, got %d"", len(c.B), len(res))
	}
	for i := range res {
		api.AssertIsEqual(api.Mul(2, c.A[i]), c.B[i])
		api.AssertIsEqual(res[i], c.B[i])
	}
	return nil
}
type recursiveHint struct {
	A frontend.Variable
}
func (circuit *recursiveHint) Define(api frontend.API) error {
	// first hint produces wire w1
	w1, _ := api.Compiler().NewHint(make3, 1)
	// this linear expression is not recorded in a R1CS just yet
	linearExpression := api.Add(circuit.A, w1[0])
	// api.ToBinary calls another hint (bits.NBits) with linearExpression as input
	// however, when the solver will resolve bits[...] it will need to detect w1 as a dependency
	// in order to compute the correct linearExpression value
	bits := api.ToBinary(linearExpression, 6)
	a := api.FromBinary(bits...)
	api.AssertIsEqual(a, 45)
	return nil
}
func init() {
	{
		good := []frontend.Circuit{
			&recursiveHint{
				A: 42,
			},
		}
		bad := []frontend.Circuit{
			&recursiveHint{
				A: 1,
			},
		}
		addNewEntry(""recursive_hint"", &recursiveHint{}, good, bad, nil, make3, bits.GetHints()[1])
	}
	{
		good := []frontend.Circuit{
			&hintCircuit{
				A: 42,
				B: 42 * 7,
			},
		}
		bad := []frontend.Circuit{
			&hintCircuit{
				A: 42,
				B: 42,
			},
		}
		addNewEntry(""hint"", &hintCircuit{}, good, bad, nil, mulBy7, make3)
	}
	{
		good := []frontend.Circuit{
			&vectorDoubleCircuit{
				A: []frontend.Variable{
					1, 2, 3, 4, 5, 6, 7, 8,
				},
				B: []frontend.Variable{
					2, 4, 6, 8, 10, 12, 14, 16,
				},
			},
		}
		bad := []frontend.Circuit{
			&vectorDoubleCircuit{
				A: []frontend.Variable{
					1, 2, 3, 4, 5, 6, 7, 8,
				},
				B: []frontend.Variable{
					1, 2, 3, 4, 5, 6, 7, 8,
				},
			},
		}
		addNewEntry(""multi-output-hint"", &vectorDoubleCircuit{A: make([]frontend.Variable, 8), B: make([]frontend.Variable, 8)}, good, bad, nil, dvHint)
	}
}
var mulBy7 = func(q *big.Int, inputs []*big.Int, result []*big.Int) error {
	result[0].Mul(inputs[0], big.NewInt(7)).Mod(result[0], q)
	return nil
}
var make3 = func(_ *big.Int, inputs []*big.Int, result []*big.Int) error {
	result[0].SetUint64(3)
	return nil
}
var dvHint = func(_ *big.Int, inputs []*big.Int, res []*big.Int) error {
	two := big.NewInt(2)
	for i := range inputs {
		res[i].Mul(two, inputs[i])
	}
	return nil
}
",CWE-191,157.0,0
"package circuits
import (
	""fmt""
	""math/big""
	""github.com/consensys/gnark/frontend""
	""github.com/consensys/gnark/std/math/bits""
)
type hintCircuit struct {
	A, B frontend.Variable
}
func (circuit *hintCircuit) Define(api frontend.API) error {
	res, err := api.Compiler().NewHint(mulBy7, 1, circuit.A)
	if err != nil {
		return fmt.Errorf(""mulBy7: %w"", err)
	}
	a7 := res[0]
	_a7 := api.Mul(circuit.A, 7)
	api.AssertIsEqual(a7, _a7)
	api.AssertIsEqual(a7, circuit.B)
	res, err = api.Compiler().NewHint(make3, 1)
	if err != nil {
		return fmt.Errorf(""make3: %w"", err)
	}
	c := res[0]
	c = api.Mul(c, c)
	api.AssertIsEqual(c, 9)
	return nil
}
type vectorDoubleCircuit struct {
	A []frontend.Variable
	B []frontend.Variable
}
func (c *vectorDoubleCircuit) Define(api frontend.API) error {
	res, err := api.Compiler().NewHint(dvHint, len(c.B), c.A...)
	if err != nil {
		return fmt.Errorf(""double newhint: %w"", err)
	}
	if len(res) != len(c.B) {
		return fmt.Errorf(""expected len %d, got %d"", len(c.B), len(res))
	}
	for i := range res {
		api.AssertIsEqual(api.Mul(2, c.A[i]), c.B[i])
		api.AssertIsEqual(res[i], c.B[i])
	}
	return nil
}
type recursiveHint struct {
	A frontend.Variable
}
func (circuit *recursiveHint) Define(api frontend.API) error {
	// first hint produces wire w1
	w1, _ := api.Compiler().NewHint(make3, 1)
	// this linear expression is not recorded in a R1CS just yet
	linearExpression := api.Add(circuit.A, w1[0])
	// api.ToBinary calls another hint (bits.NBits) with linearExpression as input
	// however, when the solver will resolve bits[...] it will need to detect w1 as a dependency
	// in order to compute the correct linearExpression value
	bits := api.ToBinary(linearExpression, 6)
	a := api.FromBinary(bits...)
	api.AssertIsEqual(a, 45)
	return nil
}
func init() {
	{
		good := []frontend.Circuit{
			&recursiveHint{
				A: 42,
			},
		}
		bad := []frontend.Circuit{
			&recursiveHint{
				A: 1,
			},
		}
		addNewEntry(""recursive_hint"", &recursiveHint{}, good, bad, nil, make3, bits.GetHints()[1])
	}
	{
		good := []frontend.Circuit{
			&hintCircuit{
				A: 42,
				B: 42 * 7,
			},
		}
		bad := []frontend.Circuit{
			&hintCircuit{
				A: 42,
				B: 42,
			},
		}
		addNewEntry(""hint"", &hintCircuit{}, good, bad, nil, mulBy7, make3)
	}
	{
		good := []frontend.Circuit{
			&vectorDoubleCircuit{
				A: []frontend.Variable{
					1, 2, 3, 4, 5, 6, 7, 8,
				},
				B: []frontend.Variable{
					2, 4, 6, 8, 10, 12, 14, 16,
				},
			},
		}
		bad := []frontend.Circuit{
			&vectorDoubleCircuit{
				A: []frontend.Variable{
					1, 2, 3, 4, 5, 6, 7, 8,
				},
				B: []frontend.Variable{
					1, 2, 3, 4, 5, 6, 7, 8,
				},
			},
		}
		addNewEntry(""multi-output-hint"", &vectorDoubleCircuit{A: make([]frontend.Variable, 8), B: make([]frontend.Variable, 8)}, good, bad, nil, dvHint)
	}
}
var mulBy7 = func(q *big.Int, inputs []*big.Int, result []*big.Int) error {
	result[0].Mul(inputs[0], big.NewInt(7)).Mod(result[0], q)
	return nil
}
var make3 = func(_ *big.Int, inputs []*big.Int, result []*big.Int) error {
	result[0].SetUint64(3)
	return nil
}
var dvHint = func(_ *big.Int, inputs []*big.Int, res []*big.Int) error {
	two := big.NewInt(2)
	for i := range inputs {
		res[i].Mul(two, inputs[i])
	}
	return nil
}
",CWE-697,157.0,0
"package regressiontests
import (
	""fmt""
	""math/big""
	""testing""
	""github.com/consensys/gnark/constraint/solver""
	""github.com/consensys/gnark/frontend""
	""github.com/consensys/gnark/std/math/cmp""
	""github.com/consensys/gnark/test""
)
type CmpCircuit struct {
	Left      frontend.Variable
	Right     frontend.Variable
	ExpCmpRes frontend.Variable
}
func (c *CmpCircuit) Define(api frontend.API) error {
	r := api.Cmp(c.Left, c.Right)
	api.AssertIsEqual(r, c.ExpCmpRes)
	return nil
}
type AssertIsLessOrEqCircuit struct {
	Smaller, Bigger frontend.Variable
}
func (c *AssertIsLessOrEqCircuit) Define(api frontend.API) error {
	api.AssertIsLessOrEqual(c.Smaller, c.Bigger)
	return nil
}
type MathCmpAssertIsLessOrEqCircuitBounded struct {
	Left  frontend.Variable
	Right frontend.Variable
}
func (c *MathCmpAssertIsLessOrEqCircuitBounded) Define(api frontend.API) error {
	cmper := cmp.NewBoundedComparator(api, big.NewInt(6), false)
	cmper.AssertIsLessEq(c.Left, c.Right)
	return nil
}
type MathCmpAssertIsLessOrEqCircuitFull struct {
	Left  frontend.Variable
	Right frontend.Variable
}
func (c *MathCmpAssertIsLessOrEqCircuitFull) Define(api frontend.API) error {
	api.AssertIsEqual(1, cmp.IsLessOrEqual(api, c.Left, c.Right))
	return nil
}
func getNBitsHint() (solver.HintID, error) {
	for _, v := range solver.GetRegisteredHints() {
		if solver.GetHintName(v) == ""github.com/consensys/gnark/std/math/bits.nBits"" {
			return solver.GetHintID(v), nil
		}
	}
	return 0, fmt.Errorf(""nBits hint not found"")
}
func TestIssue836Cmp(t *testing.T) {
	assert := test.NewAssert(t)
	assignmentNoHintGood := CmpCircuit{
		Left:      10,
		Right:     5,
		ExpCmpRes: 1,
	}
	assignmentNoHintBad := CmpCircuit{
		Left:      5,
		Right:     10,
		ExpCmpRes: 1,
	}
	assignmentHintBad := CmpCircuit{
		Left:      10,
		Right:     5,
		ExpCmpRes: -1,
	}
	toReplaceHint, err := getNBitsHint()
	if err != nil {
		t.Fatalf(""couldn't find hint to replace: %v"", err)
	}
	assert.CheckCircuit(&CmpCircuit{}, test.WithValidAssignment(&assignmentNoHintGood), test.WithInvalidAssignment(&assignmentNoHintBad))
	assert.CheckCircuit(&CmpCircuit{}, test.WithInvalidAssignment(&assignmentHintBad), test.NoTestEngine(), test.WithSolverOpts(solver.OverrideHint(toReplaceHint, maliciousNbitsHint)))
}
func TestIssue836AssertIsLess(t *testing.T) {
	assert := test.NewAssert(t)
	assignmentNoHintGood := AssertIsLessOrEqCircuit{
		Smaller: 5,
		Bigger:  10,
	}
	assignmentNoHintBad := AssertIsLessOrEqCircuit{
		Smaller: 11,
		Bigger:  10,
	}
	assignmentHintBad := AssertIsLessOrEqCircuit{
		Smaller: 10,
		Bigger:  5,
	}
	toReplaceHint, err := getNBitsHint()
	if err != nil {
		t.Fatalf(""couldn't find hint to replace: %v"", err)
	}
	assert.CheckCircuit(&AssertIsLessOrEqCircuit{}, test.WithValidAssignment(&assignmentNoHintGood), test.WithInvalidAssignment(&assignmentNoHintBad))
	assert.CheckCircuit(&AssertIsLessOrEqCircuit{}, test.WithInvalidAssignment(&assignmentHintBad), test.NoTestEngine(), test.WithSolverOpts(solver.OverrideHint(toReplaceHint, maliciousNbitsHint)))
}
func TestIssue836MathCmpAssertIsLessEqBounded(t *testing.T) {
	assert := test.NewAssert(t)
	assignmentNoHintGood := MathCmpAssertIsLessOrEqCircuitBounded{
		Left:  5,
		Right: 10,
	}
	assignmentNoHintBad := MathCmpAssertIsLessOrEqCircuitBounded{
		Left:  11,
		Right: 10,
	}
	assignmentHintBad := MathCmpAssertIsLessOrEqCircuitBounded{
		Left:  10,
		Right: 5,
	}
	toReplaceHint, err := getNBitsHint()
	if err != nil {
		t.Fatalf(""couldn't find hint to replace: %v"", err)
	}
	assert.CheckCircuit(&MathCmpAssertIsLessOrEqCircuitBounded{}, test.WithValidAssignment(&assignmentNoHintGood), test.WithInvalidAssignment(&assignmentNoHintBad))
	assert.CheckCircuit(&MathCmpAssertIsLessOrEqCircuitBounded{}, test.WithInvalidAssignment(&assignmentHintBad), test.NoTestEngine(), test.WithSolverOpts(solver.OverrideHint(toReplaceHint, maliciousNbitsHint)))
}
func TestIssueXXXMathCmpAssertIsLessEqFull(t *testing.T) {
	assert := test.NewAssert(t)
	assignmentNoHintGood := MathCmpAssertIsLessOrEqCircuitFull{
		Left:  5,
		Right: 10,
	}
	assignmentNoHintBad := MathCmpAssertIsLessOrEqCircuitFull{
		Left:  11,
		Right: 10,
	}
	assignmentHintBad := MathCmpAssertIsLessOrEqCircuitFull{
		Left:  10,
		Right: 5,
	}
	toReplaceHint, err := getNBitsHint()
	if err != nil {
		t.Fatalf(""couldn't find hint to replace: %v"", err)
	}
	assert.CheckCircuit(&MathCmpAssertIsLessOrEqCircuitFull{}, test.WithValidAssignment(&assignmentNoHintGood), test.WithInvalidAssignment(&assignmentNoHintBad))
	assert.CheckCircuit(&MathCmpAssertIsLessOrEqCircuitFull{}, test.WithInvalidAssignment(&assignmentHintBad), test.NoTestEngine(), test.WithSolverOpts(solver.OverrideHint(toReplaceHint, maliciousNbitsHint)))
}
func maliciousNbitsHint(mod *big.Int, inputs []*big.Int, results []*big.Int) error {
	n := inputs[0]
	// This is a malicious hint. If n is less equal than 5, then add the
	// modulus. This creates a non-unique binary decomposition of the value.
	if n.Cmp(big.NewInt(5)) <= 0 {
		n = n.Add(n, mod)
	}
	for i := 0; i < len(results); i++ {
		results[i].SetUint64(uint64(n.Bit(i)))
	}
	return nil
}
",CWE-191,168.0,0
"package regressiontests
import (
	""fmt""
	""math/big""
	""testing""
	""github.com/consensys/gnark/constraint/solver""
	""github.com/consensys/gnark/frontend""
	""github.com/consensys/gnark/std/math/cmp""
	""github.com/consensys/gnark/test""
)
type CmpCircuit struct {
	Left      frontend.Variable
	Right     frontend.Variable
	ExpCmpRes frontend.Variable
}
func (c *CmpCircuit) Define(api frontend.API) error {
	r := api.Cmp(c.Left, c.Right)
	api.AssertIsEqual(r, c.ExpCmpRes)
	return nil
}
type AssertIsLessOrEqCircuit struct {
	Smaller, Bigger frontend.Variable
}
func (c *AssertIsLessOrEqCircuit) Define(api frontend.API) error {
	api.AssertIsLessOrEqual(c.Smaller, c.Bigger)
	return nil
}
type MathCmpAssertIsLessOrEqCircuitBounded struct {
	Left  frontend.Variable
	Right frontend.Variable
}
func (c *MathCmpAssertIsLessOrEqCircuitBounded) Define(api frontend.API) error {
	cmper := cmp.NewBoundedComparator(api, big.NewInt(6), false)
	cmper.AssertIsLessEq(c.Left, c.Right)
	return nil
}
type MathCmpAssertIsLessOrEqCircuitFull struct {
	Left  frontend.Variable
	Right frontend.Variable
}
func (c *MathCmpAssertIsLessOrEqCircuitFull) Define(api frontend.API) error {
	api.AssertIsEqual(1, cmp.IsLessOrEqual(api, c.Left, c.Right))
	return nil
}
func getNBitsHint() (solver.HintID, error) {
	for _, v := range solver.GetRegisteredHints() {
		if solver.GetHintName(v) == ""github.com/consensys/gnark/std/math/bits.nBits"" {
			return solver.GetHintID(v), nil
		}
	}
	return 0, fmt.Errorf(""nBits hint not found"")
}
func TestIssue836Cmp(t *testing.T) {
	assert := test.NewAssert(t)
	assignmentNoHintGood := CmpCircuit{
		Left:      10,
		Right:     5,
		ExpCmpRes: 1,
	}
	assignmentNoHintBad := CmpCircuit{
		Left:      5,
		Right:     10,
		ExpCmpRes: 1,
	}
	assignmentHintBad := CmpCircuit{
		Left:      10,
		Right:     5,
		ExpCmpRes: -1,
	}
	toReplaceHint, err := getNBitsHint()
	if err != nil {
		t.Fatalf(""couldn't find hint to replace: %v"", err)
	}
	assert.CheckCircuit(&CmpCircuit{}, test.WithValidAssignment(&assignmentNoHintGood), test.WithInvalidAssignment(&assignmentNoHintBad))
	assert.CheckCircuit(&CmpCircuit{}, test.WithInvalidAssignment(&assignmentHintBad), test.NoTestEngine(), test.WithSolverOpts(solver.OverrideHint(toReplaceHint, maliciousNbitsHint)))
}
func TestIssue836AssertIsLess(t *testing.T) {
	assert := test.NewAssert(t)
	assignmentNoHintGood := AssertIsLessOrEqCircuit{
		Smaller: 5,
		Bigger:  10,
	}
	assignmentNoHintBad := AssertIsLessOrEqCircuit{
		Smaller: 11,
		Bigger:  10,
	}
	assignmentHintBad := AssertIsLessOrEqCircuit{
		Smaller: 10,
		Bigger:  5,
	}
	toReplaceHint, err := getNBitsHint()
	if err != nil {
		t.Fatalf(""couldn't find hint to replace: %v"", err)
	}
	assert.CheckCircuit(&AssertIsLessOrEqCircuit{}, test.WithValidAssignment(&assignmentNoHintGood), test.WithInvalidAssignment(&assignmentNoHintBad))
	assert.CheckCircuit(&AssertIsLessOrEqCircuit{}, test.WithInvalidAssignment(&assignmentHintBad), test.NoTestEngine(), test.WithSolverOpts(solver.OverrideHint(toReplaceHint, maliciousNbitsHint)))
}
func TestIssue836MathCmpAssertIsLessEqBounded(t *testing.T) {
	assert := test.NewAssert(t)
	assignmentNoHintGood := MathCmpAssertIsLessOrEqCircuitBounded{
		Left:  5,
		Right: 10,
	}
	assignmentNoHintBad := MathCmpAssertIsLessOrEqCircuitBounded{
		Left:  11,
		Right: 10,
	}
	assignmentHintBad := MathCmpAssertIsLessOrEqCircuitBounded{
		Left:  10,
		Right: 5,
	}
	toReplaceHint, err := getNBitsHint()
	if err != nil {
		t.Fatalf(""couldn't find hint to replace: %v"", err)
	}
	assert.CheckCircuit(&MathCmpAssertIsLessOrEqCircuitBounded{}, test.WithValidAssignment(&assignmentNoHintGood), test.WithInvalidAssignment(&assignmentNoHintBad))
	assert.CheckCircuit(&MathCmpAssertIsLessOrEqCircuitBounded{}, test.WithInvalidAssignment(&assignmentHintBad), test.NoTestEngine(), test.WithSolverOpts(solver.OverrideHint(toReplaceHint, maliciousNbitsHint)))
}
func TestIssueXXXMathCmpAssertIsLessEqFull(t *testing.T) {
	assert := test.NewAssert(t)
	assignmentNoHintGood := MathCmpAssertIsLessOrEqCircuitFull{
		Left:  5,
		Right: 10,
	}
	assignmentNoHintBad := MathCmpAssertIsLessOrEqCircuitFull{
		Left:  11,
		Right: 10,
	}
	assignmentHintBad := MathCmpAssertIsLessOrEqCircuitFull{
		Left:  10,
		Right: 5,
	}
	toReplaceHint, err := getNBitsHint()
	if err != nil {
		t.Fatalf(""couldn't find hint to replace: %v"", err)
	}
	assert.CheckCircuit(&MathCmpAssertIsLessOrEqCircuitFull{}, test.WithValidAssignment(&assignmentNoHintGood), test.WithInvalidAssignment(&assignmentNoHintBad))
	assert.CheckCircuit(&MathCmpAssertIsLessOrEqCircuitFull{}, test.WithInvalidAssignment(&assignmentHintBad), test.NoTestEngine(), test.WithSolverOpts(solver.OverrideHint(toReplaceHint, maliciousNbitsHint)))
}
func maliciousNbitsHint(mod *big.Int, inputs []*big.Int, results []*big.Int) error {
	n := inputs[0]
	// This is a malicious hint. If n is less equal than 5, then add the
	// modulus. This creates a non-unique binary decomposition of the value.
	if n.Cmp(big.NewInt(5)) <= 0 {
		n = n.Add(n, mod)
	}
	for i := 0; i < len(results); i++ {
		results[i].SetUint64(uint64(n.Bit(i)))
	}
	return nil
}
",CWE-697,168.0,0
"package bits
import (
	""errors""
	""github.com/consensys/gnark/frontend""
)
// Base defines the base for decomposing the scalar into digits.
type Base uint8
const (
	// Binary base decomposes scalar into bits (0-1)
	Binary Base = 2
	// Ternary base decomposes scalar into trits (0-1-2)
	Ternary Base = 3
)
// ToBase decomposes scalar v into digits in given base using options opts. The
// decomposition is in little-endian order.
func ToBase(api frontend.API, base Base, v frontend.Variable, opts ...BaseConversionOption) []frontend.Variable {
	switch base {
	case Binary:
		return toBinary(api, v, opts...)
	case Ternary:
		return toTernary(api, v, opts...)
	default:
		panic(""not implemented"")
	}
}
// FromBase compute from a set of digits its canonical representation in
// little-endian order.
// For example for base 2, it returns Σbi = Σ (2**i * digits[i])
func FromBase(api frontend.API, base Base, digits []frontend.Variable, opts ...BaseConversionOption) frontend.Variable {
	if len(digits) == 0 {
		panic(""FromBase needs at least 1 digit"")
	}
	switch base {
	case Binary:
		return fromBinary(api, digits, opts...)
	case Ternary:
		return fromTernary(api, digits, opts...)
	default:
		panic(""not implemented"")
	}
}
type baseConversionConfig struct {
	NbDigits             int
	UnconstrainedOutputs bool
	UnconstrainedInputs  bool
	omitModulusCheck bool
}
// BaseConversionOption configures the behaviour of scalar decomposition.
type BaseConversionOption func(opt *baseConversionConfig) error
// WithNbDigits sets the resulting number of digits (nbDigits) to be used in the
// base conversion.
//
// nbDigits must be > 0. If nbDigits is lower than the length of full
// decomposition and [WithUnconstrainedOutputs] option is not used, then the
// conversion functions will generate an unsatisfiable constraint.
//
// If nbDigits is larger than the bitlength of the modulus, then the returned
// slice has length nbDigits with excess bits being 0.
//
// If WithNbDigits option is not set, then the full decomposition is returned.
func WithNbDigits(nbDigits int) BaseConversionOption {
	return func(opt *baseConversionConfig) error {
		if nbDigits <= 0 {
			return errors.New(""nbDigits <= 0"")
		}
		opt.NbDigits = nbDigits
		return nil
	}
}
// WithUnconstrainedOutputs sets the bit conversion API to NOT constrain the output bits.
// This is UNSAFE but is useful when the outputs are already constrained by other circuit
// constraints.
// The sum of the digits will is constrained like so Σbi = Σ (base**i * digits[i])
// But the individual digits are not constrained to be valid digits in base b.
func WithUnconstrainedOutputs() BaseConversionOption {
	return func(opt *baseConversionConfig) error {
		opt.UnconstrainedOutputs = true
		return nil
	}
}
// WithUnconstrainedInputs indicates to the FromBase apis to constrain its inputs (digits) to
// ensure they are valid digits in base b. For example, FromBinary without this option will add
// 1 constraint per bit to ensure it is either 0 or 1.
func WithUnconstrainedInputs() BaseConversionOption {
	return func(opt *baseConversionConfig) error {
		opt.UnconstrainedInputs = true
		return nil
	}
}
// OmitModulusCheck omits the comparison against native field modulus in
// case the bitlength of the decomposed value (if [WithNbDigits] not set or set
// to bitlength of the native modulus) eqals bitlength of the modulus.
//
// The check is otherwise required as there are possibly multiple correct binary
// decompositions. For example, when decomposing small a the decomposition could
// return the slices for both a or a+r, where r is the native modulus and the
// enforced constraints are correct due to implicit modular reduction by r.
//
// This option can be used in case the decomposed output is manually checked to
// be unique or if uniqueness is not required.
func OmitModulusCheck() BaseConversionOption {
	return func(opt *baseConversionConfig) error {
		opt.omitModulusCheck = true
		return nil
	}
}
",CWE-191,121.0,0
"package bits
import (
	""errors""
	""github.com/consensys/gnark/frontend""
)
// Base defines the base for decomposing the scalar into digits.
type Base uint8
const (
	// Binary base decomposes scalar into bits (0-1)
	Binary Base = 2
	// Ternary base decomposes scalar into trits (0-1-2)
	Ternary Base = 3
)
// ToBase decomposes scalar v into digits in given base using options opts. The
// decomposition is in little-endian order.
func ToBase(api frontend.API, base Base, v frontend.Variable, opts ...BaseConversionOption) []frontend.Variable {
	switch base {
	case Binary:
		return toBinary(api, v, opts...)
	case Ternary:
		return toTernary(api, v, opts...)
	default:
		panic(""not implemented"")
	}
}
// FromBase compute from a set of digits its canonical representation in
// little-endian order.
// For example for base 2, it returns Σbi = Σ (2**i * digits[i])
func FromBase(api frontend.API, base Base, digits []frontend.Variable, opts ...BaseConversionOption) frontend.Variable {
	if len(digits) == 0 {
		panic(""FromBase needs at least 1 digit"")
	}
	switch base {
	case Binary:
		return fromBinary(api, digits, opts...)
	case Ternary:
		return fromTernary(api, digits, opts...)
	default:
		panic(""not implemented"")
	}
}
type baseConversionConfig struct {
	NbDigits             int
	UnconstrainedOutputs bool
	UnconstrainedInputs  bool
	omitModulusCheck bool
}
// BaseConversionOption configures the behaviour of scalar decomposition.
type BaseConversionOption func(opt *baseConversionConfig) error
// WithNbDigits sets the resulting number of digits (nbDigits) to be used in the
// base conversion.
//
// nbDigits must be > 0. If nbDigits is lower than the length of full
// decomposition and [WithUnconstrainedOutputs] option is not used, then the
// conversion functions will generate an unsatisfiable constraint.
//
// If nbDigits is larger than the bitlength of the modulus, then the returned
// slice has length nbDigits with excess bits being 0.
//
// If WithNbDigits option is not set, then the full decomposition is returned.
func WithNbDigits(nbDigits int) BaseConversionOption {
	return func(opt *baseConversionConfig) error {
		if nbDigits <= 0 {
			return errors.New(""nbDigits <= 0"")
		}
		opt.NbDigits = nbDigits
		return nil
	}
}
// WithUnconstrainedOutputs sets the bit conversion API to NOT constrain the output bits.
// This is UNSAFE but is useful when the outputs are already constrained by other circuit
// constraints.
// The sum of the digits will is constrained like so Σbi = Σ (base**i * digits[i])
// But the individual digits are not constrained to be valid digits in base b.
func WithUnconstrainedOutputs() BaseConversionOption {
	return func(opt *baseConversionConfig) error {
		opt.UnconstrainedOutputs = true
		return nil
	}
}
// WithUnconstrainedInputs indicates to the FromBase apis to constrain its inputs (digits) to
// ensure they are valid digits in base b. For example, FromBinary without this option will add
// 1 constraint per bit to ensure it is either 0 or 1.
func WithUnconstrainedInputs() BaseConversionOption {
	return func(opt *baseConversionConfig) error {
		opt.UnconstrainedInputs = true
		return nil
	}
}
// OmitModulusCheck omits the comparison against native field modulus in
// case the bitlength of the decomposed value (if [WithNbDigits] not set or set
// to bitlength of the native modulus) eqals bitlength of the modulus.
//
// The check is otherwise required as there are possibly multiple correct binary
// decompositions. For example, when decomposing small a the decomposition could
// return the slices for both a or a+r, where r is the native modulus and the
// enforced constraints are correct due to implicit modular reduction by r.
//
// This option can be used in case the decomposed output is manually checked to
// be unique or if uniqueness is not required.
func OmitModulusCheck() BaseConversionOption {
	return func(opt *baseConversionConfig) error {
		opt.omitModulusCheck = true
		return nil
	}
}
",CWE-697,121.0,0
"package bits
import (
	""math/big""
	""github.com/consensys/gnark/frontend""
)
// ToBinary is an alias of ToBase(api, Binary, v, opts)
func ToBinary(api frontend.API, v frontend.Variable, opts ...BaseConversionOption) []frontend.Variable {
	return ToBase(api, Binary, v, opts...)
}
// FromBinary is an alias of FromBase(api, Binary, digits)
func FromBinary(api frontend.API, digits []frontend.Variable, opts ...BaseConversionOption) frontend.Variable {
	return FromBase(api, Binary, digits, opts...)
}
func fromBinary(api frontend.API, digits []frontend.Variable, opts ...BaseConversionOption) frontend.Variable {
	cfg := baseConversionConfig{}
	for _, o := range opts {
		if err := o(&cfg); err != nil {
			panic(err)
		}
	}
	// Σbi = Σ (2**i * b[i])
	Σbi := frontend.Variable(0)
	c := big.NewInt(1)
	for i := 0; i < len(digits); i++ {
		if !cfg.UnconstrainedInputs {
			api.AssertIsBoolean(digits[i]) // ensures the digits are actual bits
		}
		Σbi = api.Add(Σbi, api.Mul(c, digits[i])) // no constraint is recorded
		c.Lsh(c, 1)
	}
	return Σbi
}
func toBinary(api frontend.API, v frontend.Variable, opts ...BaseConversionOption) []frontend.Variable {
	// parse options
	cfg := baseConversionConfig{
		NbDigits:             api.Compiler().FieldBitLen(),
		UnconstrainedOutputs: false,
	}
	for _, o := range opts {
		if err := o(&cfg); err != nil {
			panic(err)
		}
	}
	// by default we also check that the value to be decomposed is less than the
	// modulus. However, we can omit the check when the number of bits we want
	// to decompose to is less than the modulus or it was strictly requested.
	omitReducednessCheck := cfg.omitModulusCheck || cfg.NbDigits < api.Compiler().FieldBitLen()
	// when cfg.NbDigits == 1, v itself has to be a binary digit. This if clause
	// saves one constraint.
	if cfg.NbDigits == 1 {
		api.AssertIsBoolean(v)
		return []frontend.Variable{v}
	}
	// if we decompose into more bits than fieldbitlen then the rest would be
	// always zeros. Reduce the always-zeros to have fewer edge-cases elsewhere.
	var paddingBits int
	if cfg.NbDigits > api.Compiler().FieldBitLen() {
		paddingBits = cfg.NbDigits - api.Compiler().FieldBitLen()
		cfg.NbDigits = api.Compiler().FieldBitLen()
	}
	c := big.NewInt(1)
	bits, err := api.Compiler().NewHint(nBits, cfg.NbDigits, v)
	if err != nil {
		panic(err)
	}
	var Σbi frontend.Variable
	Σbi = 0
	for i := 0; i < cfg.NbDigits; i++ {
		Σbi = api.Add(Σbi, api.Mul(bits[i], c))
		c.Lsh(c, 1)
		if !cfg.UnconstrainedOutputs {
			api.AssertIsBoolean(bits[i])
		}
	}
	// record the constraint Σ (2**i * b[i]) == a
	api.AssertIsEqual(Σbi, v)
	if !omitReducednessCheck {
		if cmper, ok := api.Compiler().(bitsComparatorConstant); ok {
			bound := new(big.Int).Sub(api.Compiler().Field(), big.NewInt(1))
			cmper.MustBeLessOrEqCst(bits, api.Compiler().Field(), bound)
		} else {
			panic(""builder does not expose comparison to constant"")
		}
	}
	// restore the zero bits which exceed the field bit-length when requested by
	// setting WithNbDigits larger than the field bitlength.
	bits = append(bits, make([]frontend.Variable, paddingBits)...)
	for i := cfg.NbDigits; i < len(bits); i++ {
		bits[i] = 0 // frontend.Variable is interface{}, we get nil pointer err if trying to access it.
	}
	return bits
}
",CWE-191,115.0,0
"package bits
import (
	""math/big""
	""github.com/consensys/gnark/frontend""
)
// ToBinary is an alias of ToBase(api, Binary, v, opts)
func ToBinary(api frontend.API, v frontend.Variable, opts ...BaseConversionOption) []frontend.Variable {
	return ToBase(api, Binary, v, opts...)
}
// FromBinary is an alias of FromBase(api, Binary, digits)
func FromBinary(api frontend.API, digits []frontend.Variable, opts ...BaseConversionOption) frontend.Variable {
	return FromBase(api, Binary, digits, opts...)
}
func fromBinary(api frontend.API, digits []frontend.Variable, opts ...BaseConversionOption) frontend.Variable {
	cfg := baseConversionConfig{}
	for _, o := range opts {
		if err := o(&cfg); err != nil {
			panic(err)
		}
	}
	// Σbi = Σ (2**i * b[i])
	Σbi := frontend.Variable(0)
	c := big.NewInt(1)
	for i := 0; i < len(digits); i++ {
		if !cfg.UnconstrainedInputs {
			api.AssertIsBoolean(digits[i]) // ensures the digits are actual bits
		}
		Σbi = api.Add(Σbi, api.Mul(c, digits[i])) // no constraint is recorded
		c.Lsh(c, 1)
	}
	return Σbi
}
func toBinary(api frontend.API, v frontend.Variable, opts ...BaseConversionOption) []frontend.Variable {
	// parse options
	cfg := baseConversionConfig{
		NbDigits:             api.Compiler().FieldBitLen(),
		UnconstrainedOutputs: false,
	}
	for _, o := range opts {
		if err := o(&cfg); err != nil {
			panic(err)
		}
	}
	// by default we also check that the value to be decomposed is less than the
	// modulus. However, we can omit the check when the number of bits we want
	// to decompose to is less than the modulus or it was strictly requested.
	omitReducednessCheck := cfg.omitModulusCheck || cfg.NbDigits < api.Compiler().FieldBitLen()
	// when cfg.NbDigits == 1, v itself has to be a binary digit. This if clause
	// saves one constraint.
	if cfg.NbDigits == 1 {
		api.AssertIsBoolean(v)
		return []frontend.Variable{v}
	}
	// if we decompose into more bits than fieldbitlen then the rest would be
	// always zeros. Reduce the always-zeros to have fewer edge-cases elsewhere.
	var paddingBits int
	if cfg.NbDigits > api.Compiler().FieldBitLen() {
		paddingBits = cfg.NbDigits - api.Compiler().FieldBitLen()
		cfg.NbDigits = api.Compiler().FieldBitLen()
	}
	c := big.NewInt(1)
	bits, err := api.Compiler().NewHint(nBits, cfg.NbDigits, v)
	if err != nil {
		panic(err)
	}
	var Σbi frontend.Variable
	Σbi = 0
	for i := 0; i < cfg.NbDigits; i++ {
		Σbi = api.Add(Σbi, api.Mul(bits[i], c))
		c.Lsh(c, 1)
		if !cfg.UnconstrainedOutputs {
			api.AssertIsBoolean(bits[i])
		}
	}
	// record the constraint Σ (2**i * b[i]) == a
	api.AssertIsEqual(Σbi, v)
	if !omitReducednessCheck {
		if cmper, ok := api.Compiler().(bitsComparatorConstant); ok {
			bound := new(big.Int).Sub(api.Compiler().Field(), big.NewInt(1))
			cmper.MustBeLessOrEqCst(bits, api.Compiler().Field(), bound)
		} else {
			panic(""builder does not expose comparison to constant"")
		}
	}
	// restore the zero bits which exceed the field bit-length when requested by
	// setting WithNbDigits larger than the field bitlength.
	bits = append(bits, make([]frontend.Variable, paddingBits)...)
	for i := cfg.NbDigits; i < len(bits); i++ {
		bits[i] = 0 // frontend.Variable is interface{}, we get nil pointer err if trying to access it.
	}
	return bits
}
",CWE-697,115.0,0
"package bits
import (
	""math/big""
	""github.com/consensys/gnark/frontend""
)
// bitsComparatorConstant allows to use the built-in comparison against a
// constant bound. We use the direct implementation due to the added efficiency
// of directly creating constraints instead of using API.
type bitsComparatorConstant interface {
	MustBeLessOrEqCst(aBits []frontend.Variable, bound *big.Int, aForDebug frontend.Variable)
}
",CWE-191,15.0,0
"package bits
import (
	""math/big""
	""github.com/consensys/gnark/frontend""
)
// bitsComparatorConstant allows to use the built-in comparison against a
// constant bound. We use the direct implementation due to the added efficiency
// of directly creating constraints instead of using API.
type bitsComparatorConstant interface {
	MustBeLessOrEqCst(aBits []frontend.Variable, bound *big.Int, aForDebug frontend.Variable)
}
",CWE-697,15.0,0
"// Copyright 2017 Eric Zhou. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package base64Captcha
import (
	""container/list""
	""sync""
	""time""
)
// expValue stores timestamp and id of captchas. It is used in the list inside
// memoryStore for indexing generated captchas by timestamp to enable garbage
// collection of expired captchas.
type idByTimeValue struct {
	timestamp time.Time
	id        string
}
// memoryStore is an internal store for captcha ids and their values.
type memoryStore struct {
	sync.RWMutex
	digitsById map[string]string
	idByTime   *list.List
	// Number of items stored since last collection.
	numStored int
	// Number of saved items that triggers collection.
	collectNum int
	// Expiration time of captchas.
	expiration time.Duration
}
// NewMemoryStore returns a new standard memory store for captchas with the
// given collection threshold and expiration time (duration). The returned
// store must be registered with SetCustomStore to replace the default one.
func NewMemoryStore(collectNum int, expiration time.Duration) Store {
	s := new(memoryStore)
	s.digitsById = make(map[string]string)
	s.idByTime = list.New()
	s.collectNum = collectNum
	s.expiration = expiration
	return s
}
func (s *memoryStore) Set(id string, value string) error {
	s.Lock()
	s.digitsById[id] = value
	s.idByTime.PushBack(idByTimeValue{time.Now(), id})
	s.numStored++
	s.Unlock()
	if s.numStored > s.collectNum {
		go s.collect()
	}
	return nil
}
func (s *memoryStore) Verify(id, answer string, clear bool) bool {
	v := s.Get(id, clear)
	return v != """" && v == answer
}
func (s *memoryStore) Get(id string, clear bool) (value string) {
	if !clear {
		// When we don't need to clear captcha, acquire read lock.
		s.RLock()
		defer s.RUnlock()
	} else {
		s.Lock()
		defer s.Unlock()
	}
	value, ok := s.digitsById[id]
	if !ok {
		return
	}
	if clear {
		delete(s.digitsById, id)
	}
	return
}
func (s *memoryStore) collect() {
	now := time.Now()
	s.Lock()
	defer s.Unlock()
	for e := s.idByTime.Front(); e != nil; {
		e = s.collectOne(e, now)
	}
}
func (s *memoryStore) collectOne(e *list.Element, specifyTime time.Time) *list.Element {
	ev, ok := e.Value.(idByTimeValue)
	if !ok {
		return nil
	}
	if ev.timestamp.Add(s.expiration).Before(specifyTime) {
		delete(s.digitsById, ev.id)
		next := e.Next()
		s.idByTime.Remove(e)
		s.numStored--
		return next
	}
	return nil
}
",CWE-345,117.0,0
"// Copyright 2017 Eric Zhou. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package base64Captcha
import (
	""container/list""
	""sync""
	""time""
)
// expValue stores timestamp and id of captchas. It is used in the list inside
// memoryStore for indexing generated captchas by timestamp to enable garbage
// collection of expired captchas.
type idByTimeValue struct {
	timestamp time.Time
	id        string
}
// memoryStore is an internal store for captcha ids and their values.
type memoryStore struct {
	sync.RWMutex
	digitsById map[string]string
	idByTime   *list.List
	// Number of items stored since last collection.
	numStored int
	// Number of saved items that triggers collection.
	collectNum int
	// Expiration time of captchas.
	expiration time.Duration
}
// NewMemoryStore returns a new standard memory store for captchas with the
// given collection threshold and expiration time (duration). The returned
// store must be registered with SetCustomStore to replace the default one.
func NewMemoryStore(collectNum int, expiration time.Duration) Store {
	s := new(memoryStore)
	s.digitsById = make(map[string]string)
	s.idByTime = list.New()
	s.collectNum = collectNum
	s.expiration = expiration
	return s
}
func (s *memoryStore) Set(id string, value string) error {
	s.Lock()
	s.digitsById[id] = value
	s.idByTime.PushBack(idByTimeValue{time.Now(), id})
	s.numStored++
	s.Unlock()
	if s.numStored > s.collectNum {
		go s.collect()
	}
	return nil
}
func (s *memoryStore) Verify(id, answer string, clear bool) bool {
	if id == """" || answer == """" {
		return false
	}
	v := s.Get(id, clear)
	return v != """" && v == answer
}
func (s *memoryStore) Get(id string, clear bool) (value string) {
	if !clear {
		// When we don't need to clear captcha, acquire read lock.
		s.RLock()
		defer s.RUnlock()
	} else {
		s.Lock()
		defer s.Unlock()
	}
	value, ok := s.digitsById[id]
	if !ok {
		return
	}
	if clear {
		delete(s.digitsById, id)
	}
	return
}
func (s *memoryStore) collect() {
	now := time.Now()
	s.Lock()
	defer s.Unlock()
	for e := s.idByTime.Front(); e != nil; {
		e = s.collectOne(e, now)
	}
}
func (s *memoryStore) collectOne(e *list.Element, specifyTime time.Time) *list.Element {
	ev, ok := e.Value.(idByTimeValue)
	if !ok {
		return nil
	}
	if ev.timestamp.Add(s.expiration).Before(specifyTime) {
		delete(s.digitsById, ev.id)
		next := e.Next()
		s.idByTime.Remove(e)
		s.numStored--
		return next
	}
	return nil
}
",CWE-345,120.0,0
"// Copyright 2017 Eric Zhou. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package base64Captcha
import (
	""fmt""
	""math/rand""
	""testing""
	""time""
)
func TestSetGet(t *testing.T) {
	s := NewMemoryStore(GCLimitNumber, Expiration)
	id := ""captcha id""
	d := ""random-string""
	_ = s.Set(id, d)
	d2 := s.Get(id, false)
	if d2 != d {
		t.Errorf(""saved %v, getDigits returned got %v"", d, d2)
	}
}
func TestGetClear(t *testing.T) {
	s := NewMemoryStore(GCLimitNumber, Expiration)
	id := ""captcha id""
	d := ""932839jfffjkdss""
	_ = s.Set(id, d)
	d2 := s.Get(id, true)
	if d != d2 {
		t.Errorf(""saved %v, getDigitsClear returned got %v"", d, d2)
	}
	d2 = s.Get(id, false)
	if d2 != """" {
		t.Errorf(""getDigitClear didn't clear (%q=%v)"", id, d2)
	}
}
func BenchmarkSetCollect(b *testing.B) {
	b.StopTimer()
	d := ""fdskfew9832232r""
	s := NewMemoryStore(9999, -1)
	ids := make([]string, 1000)
	for i := range ids {
		ids[i] = fmt.Sprintf(""%d"", rand.Int63())
	}
	b.StartTimer()
	for i := 0; i < b.N; i++ {
		for j := 0; j < 1000; j++ {
			_ = s.Set(ids[j], d)
		}
	}
}
func TestMemoryStore_SetGoCollect(t *testing.T) {
	s := NewMemoryStore(10, -1)
	for i := 0; i <= 100; i++ {
		_ = s.Set(fmt.Sprint(i), fmt.Sprint(i))
	}
}
func TestMemoryStore_CollectNotExpire(t *testing.T) {
	s := NewMemoryStore(10, time.Hour)
	for i := 0; i < 50; i++ {
		_ = s.Set(fmt.Sprint(i), fmt.Sprint(i))
	}
	// let background goroutine to go
	time.Sleep(time.Second)
	if v := s.Get(""0"", false); v != ""0"" {
		t.Error(""mem store get failed"")
	}
}
func TestNewMemoryStore(t *testing.T) {
	type args struct {
		collectNum int
		expiration time.Duration
	}
	tests := []struct {
		name string
		args args
		want Store
	}{
		{"""", args{20, time.Hour}, nil},
		{"""", args{20, time.Hour * 5}, nil},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := NewMemoryStore(tt.args.collectNum, tt.args.expiration); got == nil {
				t.Errorf(""NewMemoryStore() = %v, want %v"", got, tt.want)
			}
		})
	}
}
func Test_memoryStore_Set(t *testing.T) {
	thisStore := NewMemoryStore(10, time.Hour)
	type args struct {
		id    string
		value string
	}
	tests := []struct {
		name string
		s    Store
		args args
	}{
		{"""", thisStore, args{RandomId(), RandomId()}},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			_ = tt.s.Set(tt.args.id, tt.args.value)
		})
	}
}
func Test_memoryStore_Verify(t *testing.T) {
	thisStore := NewMemoryStore(10, time.Hour)
	_ = thisStore.Set(""xx"", ""xx"")
	got := thisStore.Verify(""xx"", ""xx"", false)
	if !got {
		t.Error(""failed1"")
	}
	got = thisStore.Verify(""xx"", ""xx"", true)
	if !got {
		t.Error(""failed2"")
	}
	got = thisStore.Verify(""xx"", ""xx"", true)
	if got {
		t.Error(""failed3"")
	}
	got = DefaultMemStore.Verify(""saaf"", """", true)
	if got {
		t.Error(""CVE-2023-45292 GO-2023-2386"")
	}
}
func Test_memoryStore_Get(t *testing.T) {
	thisStore := NewMemoryStore(10, time.Hour)
	_ = thisStore.Set(""xx"", ""xx"")
	got := thisStore.Get(""xx"", false)
	if got != ""xx"" {
		t.Error(""failed1"")
	}
	got = thisStore.Get(""xx"", true)
	if got != ""xx"" {
		t.Error(""failed2"")
	}
	got = thisStore.Get(""xx"", false)
	if got == ""xx"" {
		t.Error(""failed3"")
	}
}
",CWE-345,169.0,0
"// Copyright 2020-2023 Project Capsule Authors.
// SPDX-License-Identifier: Apache-2.0
package request
import (
	""fmt""
	h ""net/http""
	""strings""
	authenticationv1 ""k8s.io/api/authentication/v1""
	authorizationv1 ""k8s.io/api/authorization/v1""
	""sigs.k8s.io/controller-runtime/pkg/client""
)
type http struct {
	*h.Request
	authTypes          []AuthType
	usernameClaimField string
	client             client.Writer
}
func NewHTTP(request *h.Request, authTypes []AuthType, usernameClaimField string, client client.Writer) Request {
	return &http{Request: request, authTypes: authTypes, usernameClaimField: usernameClaimField, client: client}
}
func (h http) GetHTTPRequest() *h.Request {
	return h.Request
}
//nolint:funlen
func (h http) GetUserAndGroups() (username string, groups []string, err error) {
	for _, fn := range h.authenticationFns() {
		// User authentication data is extracted according to the preferred order:
		// in case of first match blocking the iteration
		if username, groups, err = fn(); err == nil {
			break
		}
	}
	// In case of error, we're blocking the request flow here
	if err != nil {
		return """", nil, err
	}
	// In case the requester is asking for impersonation, we have to be sure that's allowed by creating a
	// SubjectAccessReview with the requested data, before proceeding.
	if impersonateGroups := GetImpersonatingGroups(h.Request); len(impersonateGroups) > 0 {
		for _, impersonateGroup := range impersonateGroups {
			ac := &authorizationv1.SubjectAccessReview{
				Spec: authorizationv1.SubjectAccessReviewSpec{
					ResourceAttributes: &authorizationv1.ResourceAttributes{
						Verb:     ""impersonate"",
						Resource: ""groups"",
						Name:     impersonateGroup,
					},
					User:   username,
					Groups: groups,
				},
			}
			if err = h.client.Create(h.Request.Context(), ac); err != nil {
				return """", nil, err
			}
			if !ac.Status.Allowed {
				return """", nil, NewErrUnauthorized(fmt.Sprintf(""the current user %s cannot impersonate the group %s"", username, impersonateGroup))
			}
		}
		defer func() {
			groups = impersonateGroups
		}()
	}
	if impersonateUser := GetImpersonatingUser(h.Request); len(impersonateUser) > 0 {
		ac := &authorizationv1.SubjectAccessReview{
			Spec: authorizationv1.SubjectAccessReviewSpec{
				ResourceAttributes: &authorizationv1.ResourceAttributes{
					Verb:     ""impersonate"",
					Resource: ""users"",
					Name:     impersonateUser,
				},
				User:   username,
				Groups: groups,
			},
		}
		if err = h.client.Create(h.Request.Context(), ac); err != nil {
			return """", nil, err
		}
		if !ac.Status.Allowed {
			return """", nil, NewErrUnauthorized(fmt.Sprintf(""the current user %s cannot impersonate the user %s"", username, impersonateUser))
		}
		// Assign impersonate user after group impersonation with current user
		// As defer func works in LIFO, if user is also impersonating groups, they will be set to correct value in the previous defer func.
		// Otherwise, groups will be set to nil, meaning we are checking just user permissions.
		defer func() {
			username = impersonateUser
			groups = nil
		}()
	}
	return username, groups, nil
}
func (h http) processBearerToken() (username string, groups []string, err error) {
	tr := &authenticationv1.TokenReview{
		Spec: authenticationv1.TokenReviewSpec{
			Token: h.bearerToken(),
		},
	}
	if err = h.client.Create(h.Request.Context(), tr); err != nil {
		return """", nil, fmt.Errorf(""cannot create TokenReview"")
	}
	if !tr.Status.Authenticated {
		return """", nil, fmt.Errorf(""cannot verify the token due to error"")
	}
	if statusErr := tr.Status.Error; len(statusErr) > 0 {
		return """", nil, fmt.Errorf(""cannot verify the token due to error"")
	}
	return tr.Status.User.Username, tr.Status.User.Groups, nil
}
func (h http) bearerToken() string {
	return strings.ReplaceAll(h.Header.Get(""Authorization""), ""Bearer "", """")
}
type authenticationFn func() (username string, groups []string, err error)
func (h http) authenticationFns() []authenticationFn {
	fns := make([]authenticationFn, 0, len(h.authTypes)+1)
	for _, authType := range h.authTypes {
		//nolint:exhaustive
		switch authType {
		case BearerToken:
			fns = append(fns, func() (username string, groups []string, err error) {
				if len(h.bearerToken()) == 0 {
					return """", nil, NewErrUnauthorized(""unauthenticated users not supported"")
				}
				return h.processBearerToken()
			})
		case TLSCertificate:
			// If the proxy is handling a non TLS connection, we have to skip the authentication strategy,
			// since the TLS section of the request would be nil.
			if h.TLS == nil {
				break
			}
			fns = append(fns, func() (username string, groups []string, err error) {
				if pc := h.TLS.PeerCertificates; len(pc) == 0 {
					err = NewErrUnauthorized(""no provided peer certificates"")
				} else {
					username, groups = pc[0].Subject.CommonName, pc[0].Subject.Organization
				}
				return
			})
		}
	}
	// Dead man switch, if no strategy worked, the proxy cannot work
	fns = append(fns, func() (string, []string, error) {
		return """", nil, NewErrUnauthorized(""unauthenticated users not supported"")
	})
	return fns
}
",CWE-287,173.0,0
"package models
import (
	""encoding/json""
	""strings""
	""github.com/gofrs/uuid""
	""github.com/layer5io/meshkit/database""
)
// MesheryApplicationPersister is the persister for persisting
// applications on the database
type MesheryApplicationPersister struct {
	DB *database.Handler
}
// MesheryApplicationPage represents a page of applications
type MesheryApplicationPage struct {
	Page         uint64                `json:""page""`
	PageSize     uint64                `json:""page_size""`
	TotalCount   int                   `json:""total_count""`
	Applications []*MesheryApplication `json:""applications""`
}
// GetMesheryApplications returns all of the applications
func (maap *MesheryApplicationPersister) GetMesheryApplications(search, order string, page, pageSize uint64, updatedAfter string) ([]byte, error) {
	order = SanitizeOrderInput(order, []string{""created_at"", ""updated_at"", ""name""})
	if order == """" {
		order = ""updated_at desc""
	}
	count := int64(0)
	applications := []*MesheryApplication{}
	query := maap.DB.Where(""updated_at > ?"", updatedAfter).Order(order)
	if search != """" {
		like := ""%"" + strings.ToLower(search) + ""%""
		query = query.Where(""(lower(meshery_applications.name) like ?)"", like)
	}
	query.Table(""meshery_applications"").Count(&count)
	Paginate(uint(page), uint(pageSize))(query).Find(&applications)
	mesheryApplicationPage := &MesheryApplicationPage{
		Page:         page,
		PageSize:     pageSize,
		TotalCount:   int(count),
		Applications: applications,
	}
	return marshalMesheryApplicationPage(mesheryApplicationPage), nil
}
// DeleteMesheryApplication takes in an application id and delete it if it already exists
func (maap *MesheryApplicationPersister) DeleteMesheryApplication(id uuid.UUID) ([]byte, error) {
	application := MesheryApplication{ID: &id}
	err := maap.DB.Delete(&application).Error
	return marshalMesheryApplication(&application), err
}
func (maap *MesheryApplicationPersister) SaveMesheryApplication(application *MesheryApplication) ([]byte, error) {
	if application.ID == nil {
		id, err := uuid.NewV4()
		if err != nil {
			return nil, ErrGenerateUUID(err)
		}
		application.ID = &id
	}
	return marshalMesheryApplications([]MesheryApplication{*application}), maap.DB.Save(application).Error
}
// SaveMesheryApplications batch inserts the given applications
func (maap *MesheryApplicationPersister) SaveMesheryApplications(applications []MesheryApplication) ([]byte, error) {
	finalApplications := []MesheryApplication{}
	for _, application := range applications {
		if application.ID == nil {
			id, err := uuid.NewV4()
			if err != nil {
				return nil, ErrGenerateUUID(err)
			}
			application.ID = &id
		}
		finalApplications = append(finalApplications, application)
	}
	return marshalMesheryApplications(finalApplications), maap.DB.Create(finalApplications).Error
}
func (maap *MesheryApplicationPersister) GetMesheryApplication(id uuid.UUID) ([]byte, error) {
	var mesheryApplication MesheryApplication
	err := maap.DB.First(&mesheryApplication, id).Error
	return marshalMesheryApplication(&mesheryApplication), err
}
func (maap *MesheryApplicationPersister) GetMesheryApplicationSource(id uuid.UUID) ([]byte, error) {
	var mesheryApplication MesheryApplication
	err := maap.DB.First(&mesheryApplication, id).Error
	return mesheryApplication.SourceContent, err
}
func marshalMesheryApplicationPage(maap *MesheryApplicationPage) []byte {
	res, _ := json.Marshal(maap)
	return res
}
func marshalMesheryApplication(ma *MesheryApplication) []byte {
	res, _ := json.Marshal(ma)
	return res
}
func marshalMesheryApplications(mas []MesheryApplication) []byte {
	res, _ := json.Marshal(mas)
	return res
}
",CWE-89,126.0,0
"package models
import (
	""encoding/json""
	""strings""
	""github.com/layer5io/meshery/server/models/connections""
	""github.com/layer5io/meshkit/database""
	""gorm.io/gorm""
)
// MesheryK8sContextPersister is the persister for persisting
// applications on the database
type MesheryK8sContextPersister struct {
	DB *database.Handler
}
// MesheryK8sContextPage represents a page of contexts
type MesheryK8sContextPage struct {
	Page       uint64        `json:""page""`
	PageSize   uint64        `json:""page_size""`
	TotalCount int           `json:""total_count""`
	Contexts   []*K8sContext `json:""contexts""`
}
// GetMesheryK8sContexts returns all of the contexts
func (mkcp *MesheryK8sContextPersister) GetMesheryK8sContexts(search, order string, page, pageSize uint64) ([]byte, error) {
	order = SanitizeOrderInput(order, []string{""created_at"", ""updated_at"", ""name""})
	if order == """" {
		order = ""updated_at desc""
	}
	count := int64(0)
	contexts := []*K8sContext{}
	query := mkcp.DB.Order(order)
	if search != """" {
		like := ""%"" + strings.ToLower(search) + ""%""
		query = query.Where(""(lower(name) like ?)"", like)
	}
	query.Model(K8sContext{}).Count(&count)
	Paginate(uint(page), uint(pageSize))(query).Find(&contexts)
	mesheryK8sContextPage := MesheryK8sContextPage{
		Page:       page,
		PageSize:   pageSize,
		TotalCount: int(count),
		Contexts:   contexts,
	}
	resp, _ := json.Marshal(mesheryK8sContextPage)
	return resp, nil
}
// DeleteMesheryK8sContext takes in an application id and delete it if it already exists
func (mkcp *MesheryK8sContextPersister) DeleteMesheryK8sContext(id string) (K8sContext, error) {
	context := K8sContext{ID: id}
	mkcp.DB.Delete(&context)
	return context, nil
}
func (mkcp *MesheryK8sContextPersister) SaveMesheryK8sContext(mkc K8sContext) (connections.Connection, error) {
	conn := connections.Connection{}
	if mkc.ID == """" {
		id, err := K8sContextGenerateID(mkc)
		if err != nil {
			return conn, ErrContextID
		}
		mkc.ID = id
	}
	// Perform the operation in a transaction
	err := mkcp.DB.Transaction(func(tx *gorm.DB) error {
		var mesheryK8sContext K8sContext
		// Check if there is already an entry for this context
		if err := tx.First(&mesheryK8sContext, ""id = ?"", mkc.ID).Error; err == nil {
			return ErrContextAlreadyPersisted
		}
		return tx.Save(&mkc).Error
	})
	return conn, err
}
func (mkcp *MesheryK8sContextPersister) GetMesheryK8sContext(id string) (K8sContext, error) {
	var mesheryK8sContext K8sContext
	err := mkcp.DB.First(&mesheryK8sContext, ""id = ?"", id).Error
	return mesheryK8sContext, err
}
// func (mkcp *MesheryK8sContextPersister) SetMesheryK8sCurrentContext(id string) error {
// 	// Perform the operation in a transaction
// 	return mkcp.DB.Transaction(func(tx *gorm.DB) error {
// 		var mesheryK8sContext K8sContext
// 		// Get context which is currently in use
// 		if err := tx.First(&mesheryK8sContext, ""is_current_context = true"").Error; err != nil {
// 			return err
// 		}
// 		// If the context id matches with the provided id then skip the next steps
// 		if mesheryK8sContext.ID == id {
// 			return nil
// 		}
// 		if err := tx.Save(&mesheryK8sContext).Error; err != nil {
// 			return err
// 		}
// 		// Set the specified context as active
// 		return tx.Model(K8sContext{}).Where(""id = ?"", id).Update(""is_current_context"", true).Error
// 	})
// }
// func (mkcp *MesheryK8sContextPersister) GetMesheryK8sCurrentContext() (K8sContext, error) {
// 	var mesheryK8sContext K8sContext
// 	err := mkcp.DB.First(&mesheryK8sContext, ""is_current_context = true"").Error
// 	return mesheryK8sContext, err
// }
",CWE-89,131.0,0
"package models
import (
	""strings""
	""github.com/gofrs/uuid""
	""github.com/layer5io/meshkit/database""
)
type PatternResourcePersister struct {
	DB *database.Handler
}
type PatternResourcePage struct {
	Page       uint64             `json:""page,omitempty""`
	PageSize   uint64             `json:""page_size,omitempty""`
	TotalCount int                `json:""total_count,omitempty""`
	Resources  []*PatternResource `json:""resources,omitempty""`
}
func (prp *PatternResourcePersister) SavePatternResource(pr *PatternResource) (*PatternResource, error) {
	if pr.ID == nil {
		id, err := uuid.NewV4()
		if err != nil {
			return nil, ErrGenerateUUID(err)
		}
		pr.ID = &id
	}
	return pr, prp.DB.Create(pr).Error
}
func (prp *PatternResourcePersister) DeletePatternResource(id uuid.UUID) error {
	return prp.DB.Model(&PatternResource{}).Where(""id = ?"", id).Update(""deleted"", true).Error
}
func (prp *PatternResourcePersister) GetPatternResource(id uuid.UUID) (*PatternResource, error) {
	var pr PatternResource
	err := prp.DB.First(&pr, id).Error
	return &pr, err
}
func (prp *PatternResourcePersister) GetPatternResourceByAttributes(name, namespace, typ, oamType string) (*PatternResource, error) {
	var pr PatternResource
	err := Paginate(0, 1)(prp.DB.Model(&PatternResource{}).Where(
		""name = ? AND namespace = ? AND type = ? AND oam_type = ? AND deleted = false"",
		name,
		namespace,
		typ,
		oamType,
	)).Scan(&pr).Error
	return &pr, err
}
func (prp *PatternResourcePersister) GetPatternResources(search, order, name, namespace, typ, oamType string, page, pageSize uint64) (*PatternResourcePage, error) {
	order = SanitizeOrderInput(order, []string{""created_at"", ""updated_at"", ""name""})
	if order == """" {
		order = ""updated_at desc""
	}
	count := int64(0)
	resources := []*PatternResource{}
	query := prp.DB.Order(order).Where(""deleted = false"")
	if search != """" {
		like := ""%"" + strings.ToLower(search) + ""%""
		query = query.Where(""(lower(pattern_resources.name) like ?)"", like)
	}
	if name != """" {
		query = query.Where(""name = ?"", name)
	}
	if namespace != """" {
		query = query.Where(""namespace = ?"", namespace)
	}
	if typ != """" {
		query = query.Where(""type = ?"", typ)
	}
	if oamType != """" {
		query = query.Where(""oam_type = ?"", oamType)
	}
	query.Model(&PatternResource{}).Count(&count)
	Paginate(uint(page), uint(pageSize))(query).Find(&resources)
	patternResourcePage := &PatternResourcePage{
		Page:       page,
		PageSize:   pageSize,
		TotalCount: int(count),
		Resources:  resources,
	}
	return patternResourcePage, nil
}
func (prp *PatternResourcePersister) Exists(name, namespace, typ, oamType string) bool {
	var result struct {
		Found bool
	}
	prp.DB.
		Raw(`
	SELECT
		EXISTS(SELECT 1 FROM pattern_resources WHERE name = ? AND namespace = ? AND type = ? AND oam_type = ? AND deleted = false) AS ""found""`,
			name,
			namespace,
			typ,
			oamType,
		).
		Scan(&result)
	return result.Found
}
",CWE-89,120.0,0
"package models
import (
	""encoding/json""
	""strings""
	""github.com/gofrs/uuid""
	""github.com/layer5io/meshkit/database""
)
// PerformanceProfilePersister is the persister for persisting
// performance profiles on the database
type PerformanceProfilePersister struct {
	DB *database.Handler
}
// PerformanceProfilePage represents a page of performance profiles
type PerformanceProfilePage struct {
	Page       uint64                `json:""page""`
	PageSize   uint64                `json:""page_size""`
	TotalCount int                   `json:""total_count""`
	Profiles   []*PerformanceProfile `json:""profiles""`
}
// GetPerformanceProfiles returns all of the performance profiles
func (ppp *PerformanceProfilePersister) GetPerformanceProfiles(_, search, order string, page, pageSize uint64) ([]byte, error) {
	order = SanitizeOrderInput(order, []string{""updated_at"", ""created_at"", ""name"", ""last_run""})
	if order == """" {
		order = ""updated_at desc""
	}
	count := int64(0)
	profiles := []*PerformanceProfile{}
	query := ppp.DB.
		Select(`
		id, name, load_generators,
		endpoints, qps, service_mesh,
		duration, request_headers, request_cookies,
		request_body, content_type, created_at,
		updated_at, (?) as last_run, (?) as total_results`,
			ppp.DB.Table(""meshery_results"").Select(""DATETIME(MAX(meshery_results.test_start_time))"").Where(""performance_profile = performance_profiles.id""),
			ppp.DB.Table(""meshery_results"").Select(""COUNT(meshery_results.name)"").Where(""performance_profile = performance_profiles.id""),
		).
		Order(order)
	if search != """" {
		like := ""%"" + strings.ToLower(search) + ""%""
		query = query.Where(""(lower(performance_profiles.name) like ?)"", like)
	}
	query.Table(""performance_profiles"").Count(&count)
	Paginate(uint(page), uint(pageSize))(query).Find(&profiles)
	performanceProfilePage := &PerformanceProfilePage{
		Page:       page,
		PageSize:   pageSize,
		TotalCount: int(count),
		Profiles:   profiles,
	}
	return marshalPerformanceProfilePage(performanceProfilePage), nil
}
// DeletePerformanceProfile takes in a profile id and delete it if it already exists
func (ppp *PerformanceProfilePersister) DeletePerformanceProfile(id uuid.UUID) ([]byte, error) {
	profile := PerformanceProfile{ID: &id}
	ppp.DB.Delete(profile)
	return marshalPerformanceProfile(&profile), nil
}
func (ppp *PerformanceProfilePersister) SavePerformanceProfile(_ uuid.UUID, profile *PerformanceProfile) error {
	return ppp.DB.Save(profile).Error
}
func (ppp *PerformanceProfilePersister) GetPerformanceProfile(id uuid.UUID) (*PerformanceProfile, error) {
	var performanceProfile PerformanceProfile
	err := ppp.DB.First(&performanceProfile, id).Error
	return &performanceProfile, err
}
func marshalPerformanceProfilePage(ppp *PerformanceProfilePage) []byte {
	res, _ := json.Marshal(ppp)
	return res
}
func marshalPerformanceProfile(pp *PerformanceProfile) []byte {
	res, _ := json.Marshal(pp)
	return res
}
",CWE-89,96.0,0
"package models
import (
	""fmt""
	""os""
	""strings""
	""sync""
	""github.com/layer5io/meshkit/database""
	""github.com/layer5io/meshkit/logger""
	""github.com/sirupsen/logrus""
	""github.com/spf13/viper""
)
// SanitizeOrderInput takes in the ""order by"" query, a validColums
// string slice and returns a sanitized query
//
// it will allow to run order by query only on the columns that are present
// in the validColumns string slice, if any other column is requested in the
// query then it will be IGNORED and an empty query would be returned instead
//
// SanitizeOrderInput also expects the query to be no longer than two words, that is
// the query may look like ""updated_at DESC"" or ""name ASC""
func SanitizeOrderInput(order string, validColumns []string) string {
	parsedOrderStr := strings.Split(order, "" "")
	if len(parsedOrderStr) != 2 {
		return """"
	}
	inputCol := parsedOrderStr[0]
	typ := strings.ToLower(parsedOrderStr[1])
	for _, col := range validColumns {
		if col == inputCol {
			if typ == ""desc"" {
				return fmt.Sprintf(""%s desc"", col)
			}
			return fmt.Sprintf(""%s asc"", col)
		}
	}
	return """"
}
var (
	dbHandler database.Handler
	mx        sync.Mutex
)
func setNewDBInstance() {
	mx.Lock()
	defer mx.Unlock()
	// Initialize Logger instance
	log, err := logger.New(""meshery"", logger.Options{
		Format: logger.SyslogLogFormat,
	})
	if err != nil {
		log.Error(err)
		os.Exit(1)
	}
	dbHandler, err = database.New(database.Options{
		Filename: fmt.Sprintf(""file:%s/mesherydb.sql?cache=private&mode=rwc&_busy_timeout=10000&_journal_mode=WAL"", viper.GetString(""USER_DATA_FOLDER"")),
		Engine:   database.SQLITE,
		Logger:   log,
	})
	if err != nil {
		logrus.Fatal(err)
	}
}
func GetNewDBInstance() *database.Handler {
	setNewDBInstance()
	return &dbHandler
}
",CWE-89,77.0,0
"// Copyright 2019 The CubeFS Authors.
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
// implied. See the License for the specific language governing
// permissions and limitations under the License.
package objectnode
import ""os""
const (
	MaxRetry = 3
)
const (
	S3Namespace        = ""http://s3.amazonaws.com/doc/2006-03-01/""
	Server             = ""Server""
	Host               = ""Host""
	LastModified       = ""Last-Modified""
	ETag               = ""ETag""
	Date               = ""Date""
	ContentMD5         = ""Content-MD5""
	ContentEncoding    = ""Content-Encoding""
	ContentType        = ""Content-Type""
	ContentLength      = ""Content-Length""
	ContentRange       = ""Content-Range""
	ContentDisposition = ""Content-Disposition""
	Authorization      = ""Authorization""
	AcceptRanges       = ""Accept-Ranges""
	Range              = ""Range""
	Expect             = ""Expect""
	XForwardedExpect   = ""X-Forwarded-Expect""
	Location           = ""Location""
	CacheControl       = ""Cache-Control""
	Expires            = ""Expires""
	Connection         = ""Connection""
	Signature          = ""Signature""
	Origin             = ""Origin""
	AccessControlRequestMethod    = ""Access-Control-Request-Method""
	AccessControlRequestHeaders   = ""Access-Control-Request-Headers""
	AccessControlAllowOrigin      = ""Access-Control-Allow-Origin""
	AccessControlAllowCredentials = ""Access-Control-Allow-Credentials""
	AccessControlMaxAge           = ""Access-Control-Max-Age""
	AccessControlAllowMethods     = ""Access-Control-Allow-Methods""
	AccessControlAllowHeaders     = ""Access-Control-Allow-Headers""
	AccessControlExposeHeaders    = ""Access-Control-Expose-Headers""
	IfMatch           = ""If-Match""
	IfNoneMatch       = ""If-None-Match""
	IfModifiedSince   = ""If-Modified-Since""
	IfUnmodifiedSince = ""If-Unmodified-Since""
	XAmzRequestId                   = ""x-amz-request-id""
	XAmzCopySource                  = ""x-amz-copy-source""
	XAmzCopySourceRange             = ""x-amz-copy-source-range""
	XAmzCopySourceIfMatch           = ""x-amz-copy-source-if-match""
	XAmzCopySourceIfNoneMatch       = ""x-amz-copy-source-if-none-match""
	XAmzCopySourceIfModifiedSince   = ""x-amz-copy-source-if-modified-since""
	XAmzCopySourceIfUnmodifiedSince = ""x-amz-copy-source-if-unmodified-since""
	XAmzDecodedContentLength        = ""x-amz-decoded-content-length""
	XAmzTagging                     = ""x-amz-tagging""
	XAmzMetaPrefix                  = ""x-amz-meta-""
	XAmzMpPartsCount                = ""x-amz-mp-parts-count""
	XAmzMetadataDirective           = ""x-amz-metadata-directive""
	XAmzBucketRegion                = ""x-amz-bucket-region""
	XAmzStorageClass                = ""x-amz-storage-class""
	XAmzTaggingCount                = ""x-amz-tagging-count""
	XAmzContentSha256               = ""X-Amz-Content-Sha256""
	XAmzCredential                  = ""X-Amz-Credential""
	XAmzSignature                   = ""X-Amz-Signature""
	XAmzSignedHeaders               = ""X-Amz-SignedHeaders""
	XAmzAlgorithm                   = ""X-Amz-Algorithm""
	XAmzDate                        = ""X-Amz-Date""
	XAmzExpires                     = ""X-Amz-Expires""
	XAmzSecurityToken               = ""X-Amz-Security-Token""
	XAmzObjectLockMode              = ""X-Amz-Object-Lock-Mode""
	XAmzObjectLockRetainUntilDate   = ""X-Amz-Object-Lock-Retain-Until-Date""
	HeaderNameXAmzDecodedContentLength = ""x-amz-decoded-content-length""
)
const (
	ValueServer               = ""CubeFS""
	ValueAcceptRanges         = ""bytes""
	ValueContentTypeStream    = ""application/octet-stream""
	ValueContentTypeXML       = ""application/xml""
	ValueContentTypeJSON      = ""application/json""
	ValueContentTypeDirectory = ""application/directory""
	ValueMultipartFormData    = ""multipart/form-data""
)
const (
	SubObjectDelete    = ""delete""
	SubMultipartUpload = ""uploads""
)
const (
	ParamUploadId   = ""uploadId""
	ParamPartNumber = ""partNumber""
	ParamKeyMarker  = ""key-marker""
	ParamMarker     = ""marker""
	ParamPrefix     = ""prefix""
	ParamContToken  = ""continuation-token""
	ParamFetchOwner = ""fetch-owner""
	ParamMaxKeys    = ""max-keys""
	ParamStartAfter = ""start-after""
	ParamKey        = ""key""
	ParamMaxParts       = ""max-parts""
	ParamUploadIdMarker = ""upload-id-marker""
	ParamPartNoMarker   = ""part-number-marker""
	ParamPartMaxUploads = ""max-uploads""
	ParamPartDelimiter  = ""delimiter""
	ParamEncodingType   = ""encoding-type""
	ParamResponseCacheControl       = ""response-cache-control""
	ParamResponseContentType        = ""response-content-type""
	ParamResponseContentDisposition = ""response-content-disposition""
	ParamResponseExpires            = ""response-expires""
)
const (
	MaxKeys        = 1000
	MaxParts       = 1000
	MaxUploads     = 1000
	SinglePutLimit = 5 * 1 << 30 // 5G
	BodyLimit      = 1 << 20
)
const (
	StorageClassStandard = ""STANDARD""
)
// XAttr keys for ObjectNode compatible feature
const (
	XAttrKeyOSSPrefix       = ""oss:""
	XAttrKeyOSSETag         = ""oss:etag""
	XAttrKeyOSSTagging      = ""oss:tagging""
	XAttrKeyOSSPolicy       = ""oss:policy""
	XAttrKeyOSSACL          = ""oss:acl""
	XAttrKeyOSSMIME         = ""oss:mime""
	XAttrKeyOSSDISPOSITION  = ""oss:disposition""
	XAttrKeyOSSCORS         = ""oss:cors""
	XAttrKeyOSSLock         = ""oss:lock""
	XAttrKeyOSSCacheControl = ""oss:cache""
	XAttrKeyOSSExpires      = ""oss:expires""
	// Deprecated
	XAttrKeyOSSETagDeprecated = ""oss:tag""
)
const (
	DateLayout              = ""20060102""
	ISO8601Format           = ""20060102T150405Z""
	ISO8601Layout           = ""2006-01-02T15:04:05.000Z""
	ISO8601LayoutCompatible = ""2006-01-02T15:04:05Z""
	RFC1123Format           = ""Mon, 02 Jan 2006 15:04:05 GMT""
)
const (
	EmptyContentMD5String = ""d41d8cd98f00b204e9800998ecf8427e""
)
const (
	DefaultFileMode = 0644
	DefaultDirMode  = DefaultFileMode | os.ModeDir
)
const (
	SplitFileRangeBlockSize     = 10 * 1024 * 1024 // 10MB
	ParallelDownloadPartSize    = 10 * 1024 * 1024
	MinParallelDownloadFileSize = 2 * ParallelDownloadPartSize
)
const (
	MaxCopyObjectSize = 5 * 1024 * 1024 * 1024
)
const (
	MetadataDirectiveCopy    = ""COPY""
	MetadataDirectiveReplace = ""REPLACE""
)
const (
	TaggingCounts         = 10
	TaggingKeyMaxLength   = 128
	TaggingValueMaxLength = 256
)
",CWE-770,198.0,0
"// Copyright 2023 The CubeFS Authors.
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
// implied. See the License for the specific language governing
// permissions and limitations under the License.
package objectnode
import (
	""encoding/xml""
	""io""
	""io/ioutil""
	""net/http""
	""github.com/cubefs/cubefs/proto""
	""github.com/cubefs/cubefs/util/log""
)
// API reference: https://docs.aws.amazon.com/zh_cn/AmazonS3/latest/API/API_GetBucketLifecycleConfiguration.html
func (o *ObjectNode) getBucketLifecycleConfigurationHandler(w http.ResponseWriter, r *http.Request) {
	var err error
	var errorCode *ErrorCode
	defer func() {
		o.errorResponse(w, r, err, errorCode)
	}()
	var param = ParseRequestParam(r)
	if param.Bucket() == """" {
		errorCode = InvalidBucketName
		return
	}
	if _, err = o.vm.Volume(param.Bucket()); err != nil {
		errorCode = NoSuchBucket
		return
	}
	var lcConf *proto.LcConfiguration
	if lcConf, err = o.mc.AdminAPI().GetBucketLifecycle(param.Bucket()); err != nil {
		log.LogErrorf(""getBucketLifecycle failed: bucket[%v] err(%v)"", param.Bucket(), err)
		errorCode = NoSuchLifecycleConfiguration
		return
	}
	var lifeCycle = NewLifeCycle()
	lifeCycle.Rules = make([]*Rule, 0)
	for _, lc := range lcConf.Rules {
		rule := &Rule{
			ID:     lc.ID,
			Status: lc.Status,
		}
		if lc.Expire != nil {
			rule.Expire = &Expiration{}
			if lc.Expire.Date != nil {
				rule.Expire.Date = lc.Expire.Date
			}
			if lc.Expire.Days != 0 {
				rule.Expire.Days = &lc.Expire.Days
			}
		}
		if lc.Filter != nil {
			rule.Filter = &Filter{
				Prefix: lc.Filter.Prefix,
			}
		}
		lifeCycle.Rules = append(lifeCycle.Rules, rule)
	}
	var data []byte
	data, err = xml.Marshal(lifeCycle)
	if err != nil {
		log.LogErrorf(""getBucketLifecycle failed: bucket[%v] err(%v)"", param.Bucket(), err)
		errorCode = NoSuchLifecycleConfiguration
		return
	}
	writeSuccessResponseXML(w, data)
	return
}
// API reference: https://docs.aws.amazon.com/zh_cn/AmazonS3/latest/API/API_PutBucketLifecycleConfiguration.html
func (o *ObjectNode) putBucketLifecycleConfigurationHandler(w http.ResponseWriter, r *http.Request) {
	var err error
	var errorCode *ErrorCode
	defer func() {
		o.errorResponse(w, r, err, errorCode)
	}()
	var param = ParseRequestParam(r)
	if param.Bucket() == """" {
		errorCode = InvalidBucketName
		return
	}
	if _, err = o.vm.Volume(param.Bucket()); err != nil {
		errorCode = NoSuchBucket
		return
	}
	_, errorCode = VerifyContentLength(r, BodyLimit)
	if errorCode != nil {
		return
	}
	var requestBody []byte
	if requestBody, err = ioutil.ReadAll(r.Body); err != nil && err != io.EOF {
		log.LogErrorf(""putBucketLifecycle failed: read request body data err: requestID(%v) err(%v)"", GetRequestID(r), err)
		errorCode = &ErrorCode{
			ErrorCode:    http.StatusText(http.StatusBadRequest),
			ErrorMessage: err.Error(),
			StatusCode:   http.StatusBadRequest,
		}
		return
	}
	var lifeCycle = NewLifeCycle()
	if err = UnmarshalXMLEntity(requestBody, lifeCycle); err != nil {
		log.LogWarnf(""putBucketLifecycle failed: decode request body err: requestID(%v) err(%v)"", GetRequestID(r), err)
		errorCode = LifeCycleErrMalformedXML
		return
	}
	ok, errorCode := lifeCycle.Validate()
	if !ok {
		log.LogErrorf(""putBucketLifecycle failed: validate err: requestID(%v) lifeCycle(%v) err(%v)"", GetRequestID(r), lifeCycle, errorCode)
		return
	}
	req := proto.LcConfiguration{
		VolName: param.Bucket(),
		Rules:   make([]*proto.Rule, 0),
	}
	for _, lr := range lifeCycle.Rules {
		rule := &proto.Rule{
			ID:     lr.ID,
			Status: lr.Status,
		}
		if lr.Expire != nil {
			rule.Expire = &proto.ExpirationConfig{}
			if lr.Expire.Date != nil {
				rule.Expire.Date = lr.Expire.Date
			}
			if lr.Expire.Days != nil {
				rule.Expire.Days = *lr.Expire.Days
			}
		}
		if lr.Filter != nil {
			rule.Filter = &proto.FilterConfig{
				Prefix: lr.Filter.Prefix,
			}
		}
		req.Rules = append(req.Rules, rule)
	}
	if err = o.mc.AdminAPI().SetBucketLifecycle(&req); err != nil {
		log.LogErrorf(""putBucketLifecycle failed: SetBucketLifecycle err: bucket[%v] err(%v)"", param.Bucket(), err)
		return
	}
	log.LogInfof(""putBucketLifecycle success: requestID(%v) volume(%v) lifeCycle(%v)"",
		GetRequestID(r), param.Bucket(), lifeCycle)
}
// API reference: https://docs.aws.amazon.com/zh_cn/AmazonS3/latest/API/API_DeleteBucketLifecycle.html
func (o *ObjectNode) deleteBucketLifecycleConfigurationHandler(w http.ResponseWriter, r *http.Request) {
	var err error
	var errorCode *ErrorCode
	defer func() {
		o.errorResponse(w, r, err, errorCode)
	}()
	var param = ParseRequestParam(r)
	if param.Bucket() == """" {
		errorCode = InvalidBucketName
		return
	}
	if _, err = o.vm.Volume(param.Bucket()); err != nil {
		errorCode = NoSuchBucket
		return
	}
	if err = o.mc.AdminAPI().DelBucketLifecycle(param.Bucket()); err != nil {
		log.LogErrorf(""deleteBucketLifecycle failed: bucket[%v] err(%v)"", param.Bucket(), err)
		return
	}
	w.WriteHeader(http.StatusNoContent)
}
",CWE-770,198.0,0
"// Copyright 2018 The CubeFS Authors.
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
// implied. See the License for the specific language governing
// permissions and limitations under the License.
package util
import (
	""crypto/rand""
	""math/big""
	""strings""
)
func SubString(sourceString string, begin, end int) string {
	bytes := []byte(sourceString)
	stringLength := len(bytes)
	if begin < 0 {
		begin = 0
	}
	if end > stringLength {
		end = stringLength
	}
	return string(bytes[begin:end])
}
type RandomSeed byte
func (s RandomSeed) Runes() []rune {
	sourceBuilder := strings.Builder{}
	if s&Numeric > 0 {
		sourceBuilder.WriteString(""0123456789"")
	}
	if s&LowerLetter > 0 {
		sourceBuilder.WriteString(""abcdefghijklmnopqrstuvwxyz"")
	}
	if s&UpperLetter > 0 {
		sourceBuilder.WriteString(""ABCDEFGHIJKLMNOPQRSTUVWXYZ"")
	}
	return []rune(sourceBuilder.String())
}
const (
	Numeric RandomSeed = 1 << iota
	LowerLetter
	UpperLetter
)
func RandomString(length int, seed RandomSeed) string {
	runs := seed.Runes()
	result := """"
	for i := 0; i < length; i++ {
		lenInt64 := int64(len(runs))
		randNumber, _ := rand.Int(rand.Reader, big.NewInt(lenInt64))
		result += string(runs[randNumber.Uint64()])
	}
	return result
}
",CWE-330,68.0,0
"//
// Copyright 2022 The Sigstore Authors.
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package root
import (
	""bytes""
	""context""
	""errors""
	""fmt""
	""io""
	""os""
	""github.com/sigstore/gitsign/internal/fulcio""
	""github.com/sigstore/gitsign/internal/git""
	""github.com/sigstore/gitsign/internal/gpg""
	gsio ""github.com/sigstore/gitsign/internal/io""
	""github.com/sigstore/gitsign/internal/rekor""
	""github.com/sigstore/gitsign/internal/signature""
)
// commandSign implements gitsign commit signing.
// This is implemented as a root command so that user can specify the
// gitsign binary directly in their gitconfigs.
func commandSign(o *options, s *gsio.Streams, args ...string) error {
	ctx := context.Background()
	// Flag validation
	if o.FlagVerify {
		return errors.New(""specify --help, --sign, or --verify"")
	}
	if len(o.FlagLocalUser) == 0 {
		return errors.New(""specify a USER-ID to sign with"")
	}
	userIdent, err := fulcio.NewIdentity(ctx, o.Config, s.TTYIn, s.TTYOut)
	if err != nil {
		return fmt.Errorf(""failed to get identity: %w"", err)
	}
	// Git is looking for ""\n[GNUPG:] SIG_CREATED "", meaning we need to print a
	// line before SIG_CREATED. BEGIN_SIGNING seems appropriate. GPG emits this,
	// though GPGSM does not.
	gpgout := gpg.NewStatusWriterFromFD(uintptr(o.FlagStatusFD))
	gpgout.Emit(gpg.StatusBeginSigning)
	var f io.Reader
	if len(args) == 1 {
		f2, err := os.Open(args[0])
		if err != nil {
			return fmt.Errorf(""failed to open message file (%s): %w"", args[0], err)
		}
		defer f2.Close()
		f = f2
	} else {
		f = s.In
	}
	dataBuf := new(bytes.Buffer)
	if _, err = io.Copy(dataBuf, f); err != nil {
		return fmt.Errorf(""failed to read message from stdin: %w"", err)
	}
	rekor, err := rekor.NewClientContext(ctx, o.Config.Rekor)
	if err != nil {
		return fmt.Errorf(""failed to create rekor client: %w"", err)
	}
	opts := signature.SignOptions{
		Detached:           o.FlagDetachedSignature,
		TimestampAuthority: o.Config.TimestampURL,
		Armor:              o.FlagArmor,
		IncludeCerts:       o.FlagIncludeCerts,
	}
	if o.Config.MatchCommitter {
		opts.UserName = o.Config.CommitterName
		opts.UserEmail = o.Config.CommitterEmail
	}
	var fn git.SignFunc = git.LegacySHASign
	if o.Config.RekorMode == ""offline"" {
		fn = git.Sign
	}
	resp, err := fn(ctx, rekor, userIdent, dataBuf.Bytes(), opts)
	if err != nil {
		return fmt.Errorf(""failed to sign message: %w"", err)
	}
	if tlog := resp.LogEntry; tlog != nil && tlog.LogIndex != nil {
		fmt.Fprintf(s.TTYOut, ""tlog entry created with index: %d\n"", *tlog.LogIndex)
	}
	gpgout.EmitSigCreated(resp.Cert, o.FlagDetachedSignature)
	if _, err := s.Out.Write(resp.Signature); err != nil {
		return errors.New(""failed to write signature"")
	}
	return nil
}
",CWE-347,113.0,0
"// Copyright 2023 The Sigstore Authors
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package gitsign
import (
	""context""
	""crypto/x509""
	""fmt""
	""os""
	cosignopts ""github.com/sigstore/cosign/v2/cmd/cosign/cli/options""
	""github.com/sigstore/cosign/v2/pkg/cosign""
	""github.com/sigstore/gitsign/internal/cert""
	""github.com/sigstore/gitsign/internal/config""
	""github.com/sigstore/gitsign/internal/fulcio/fulcioroots""
	rekorinternal ""github.com/sigstore/gitsign/internal/rekor""
	""github.com/sigstore/gitsign/pkg/git""
	""github.com/sigstore/gitsign/pkg/rekor""
	""github.com/sigstore/sigstore/pkg/cryptoutils""
)
type Verifier struct {
	git   git.Verifier
	cert  cert.Verifier
	rekor rekor.Verifier
}
// NewVerifierWithCosignOpts implements a Gitsign verifier using Cosign CertVerifyOptions.
// Note: not all options are supported.
//   - cert: This is always taken from the commit.
func NewVerifierWithCosignOpts(ctx context.Context, cfg *config.Config, opts *cosignopts.CertVerifyOptions) (*Verifier, error) {
	root, intermediate, err := fulcioroots.NewFromConfig(ctx, cfg)
	if err != nil {
		return nil, fmt.Errorf(""error getting certificate root: %w"", err)
	}
	tsa, err := x509.SystemCertPool()
	if err != nil {
		return nil, fmt.Errorf(""error getting system root pool: %w"", err)
	}
	if path := cfg.TimestampCert; path != """" {
		f, err := os.Open(path)
		if err != nil {
			return nil, err
		}
		defer f.Close()
		cert, err := cryptoutils.LoadCertificatesFromPEM(f)
		if err != nil {
			return nil, fmt.Errorf(""error loading certs from %s: %w"", path, err)
		}
		for _, c := range cert {
			tsa.AddCert(c)
		}
	}
	gitverifier, err := git.NewCertVerifier(
		git.WithRootPool(root),
		git.WithIntermediatePool(intermediate),
		git.WithTimestampCertPool(tsa),
	)
	if err != nil {
		return nil, fmt.Errorf(""error creating Git verifier: %w"", err)
	}
	rekor, err := rekorinternal.NewClientContext(ctx, cfg.Rekor)
	if err != nil {
		return nil, fmt.Errorf(""failed to create rekor client: %w"", err)
	}
	// Optionally include cert.Verifier.
	// This needs to be optional because when verifying with
	// `git verify-commit` we don't have access to issuer / identity details.
	// In these cases, clients should look for the certificate validated claim
	// and warn if missing.
	var certverifier cert.Verifier
	if opts != nil {
		ctpub, err := cosign.GetCTLogPubs(ctx)
		if err != nil {
			return nil, fmt.Errorf(""error getting CT log public key: %w"", err)
		}
		identities, err := opts.Identities()
		if err != nil {
			return nil, fmt.Errorf(""error parsing identities: %w"", err)
		}
		certverifier = cert.NewCosignVerifier(&cosign.CheckOpts{
			RekorClient:                  rekor.Rekor,
			RootCerts:                    root,
			IntermediateCerts:            intermediate,
			CTLogPubKeys:                 ctpub,
			RekorPubKeys:                 rekor.PublicKeys(),
			CertGithubWorkflowTrigger:    opts.CertGithubWorkflowTrigger,
			CertGithubWorkflowSha:        opts.CertGithubWorkflowSha,
			CertGithubWorkflowName:       opts.CertGithubWorkflowName,
			CertGithubWorkflowRepository: opts.CertGithubWorkflowRepository,
			CertGithubWorkflowRef:        opts.CertGithubWorkflowRef,
			Identities:                   identities,
			IgnoreSCT:                    opts.IgnoreSCT,
		})
	}
	return &Verifier{
		git:   gitverifier,
		cert:  certverifier,
		rekor: rekor,
	}, nil
}
func (v *Verifier) Verify(ctx context.Context, data []byte, sig []byte, detached bool) (*git.VerificationSummary, error) {
	// TODO: we probably want to deprecate git.Verify in favor of this struct.
	summary, err := git.Verify(ctx, v.git, v.rekor, data, sig, detached)
	if err != nil {
		return summary, err
	}
	if v.cert != nil {
		if err := v.cert.Verify(summary.Cert); err != nil {
			summary.Claims = append(summary.Claims, git.NewClaim(git.ClaimValidatedCerificate, false))
			return summary, err
		}
		summary.Claims = append(summary.Claims, git.NewClaim(git.ClaimValidatedCerificate, true))
	} else {
		summary.Claims = append(summary.Claims, git.NewClaim(git.ClaimValidatedCerificate, false))
	}
	return summary, nil
}
",CWE-347,139.0,0
"// Copyright 2022 The Sigstore Authors
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package rekor
import (
	""context""
	gitrekor ""github.com/sigstore/gitsign/pkg/rekor""
	rekor ""github.com/sigstore/rekor/pkg/client""
)
// NewClient returns a new Rekor client with common client options set.
// Deprecated: Use NewClientContext instead.
func NewClient(url string) (*gitrekor.Client, error) {
	return NewClientContext(context.TODO(), url)
}
// NewClientContext returns a new Rekor client with common client options set.
func NewClientContext(ctx context.Context, url string) (*gitrekor.Client, error) {
	return gitrekor.NewWithOptions(ctx, url, gitrekor.WithClientOption(rekor.WithUserAgent(""gitsign"")))
}
",CWE-347,34.0,0
"//
// Copyright 2023 The Sigstore Authors.
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package rekor
import (
	""context""
	""github.com/sigstore/cosign/v2/pkg/cosign""
	""github.com/sigstore/rekor/pkg/client""
)
type Option func(*options)
type options struct {
	rekorPublicKeys CosignRekorKeyProvider
	clientOpts      []client.Option
}
// CosignRekorKeyProvider is a function that returns the Rekor public keys in cosign's specialized format.
type CosignRekorKeyProvider func(ctx context.Context) (*cosign.TrustedTransparencyLogPubKeys, error)
func WithCosignRekorKeyProvider(f CosignRekorKeyProvider) Option {
	return func(o *options) {
		o.rekorPublicKeys = f
	}
}
func WithClientOption(opts ...client.Option) Option {
	return func(o *options) {
		o.clientOpts = opts
	}
}
",CWE-347,46.0,0
"// Code generated by tools/cmd/genoptions/main.go. DO NOT EDIT.
package jwe
import (
	""testing""
	""github.com/stretchr/testify/require""
)
func TestOptionIdent(t *testing.T) {
	require.Equal(t, ""WithCEK"", identCEK{}.String())
	require.Equal(t, ""WithCompress"", identCompress{}.String())
	require.Equal(t, ""WithContentEncryption"", identContentEncryptionAlgorithm{}.String())
	require.Equal(t, ""WithFS"", identFS{}.String())
	require.Equal(t, ""WithKey"", identKey{}.String())
	require.Equal(t, ""WithKeyProvider"", identKeyProvider{}.String())
	require.Equal(t, ""WithKeyUsed"", identKeyUsed{}.String())
	require.Equal(t, ""WithMaxPBES2Count"", identMaxPBES2Count{}.String())
	require.Equal(t, ""WithMergeProtectedHeaders"", identMergeProtectedHeaders{}.String())
	require.Equal(t, ""WithMessage"", identMessage{}.String())
	require.Equal(t, ""WithPerRecipientHeaders"", identPerRecipientHeaders{}.String())
	require.Equal(t, ""WithPretty"", identPretty{}.String())
	require.Equal(t, ""WithProtectedHeaders"", identProtectedHeaders{}.String())
	require.Equal(t, ""WithRequireKid"", identRequireKid{}.String())
	require.Equal(t, ""WithSerialization"", identSerialization{}.String())
}
",CWE-400,28.0,0
"package ffcss
import (
	""fmt""
	""os""
	""path/filepath""
	""regexp""
	""strings""
	""github.com/hbollon/go-edlib""
	""golang.org/x/text/unicode/norm""
)
// Catalog represents a collection of themes
type Catalog map[string]Theme
// Lookup looks up a theme by its name in the theme store.
// It also returns an error starting with ""did you mean:"" when
// a theme name is not found but themes with similar names exist.
func (store Catalog) Lookup(query string) (Theme, error) {
	originalQuery := query
	query = lookupPreprocess(query)
	LogDebug(""using query %q"", query)
	processedThemeNames := make([]string, 0, len(store))
	for _, theme := range store {
		LogDebug(""\tlooking up against %q (%q)"", lookupPreprocess(theme.Name()), theme.Name())
		if lookupPreprocess(theme.Name()) == query {
			return theme, nil
		}
		processedThemeNames = append(processedThemeNames, lookupPreprocess(theme.Name()))
	}
	// Use fuzzy search for did-you-mean errors
	suggestion, _ := edlib.FuzzySearchThreshold(query, processedThemeNames, 0.75, edlib.Levenshtein)
	if suggestion != """" {
		return Theme{}, fmt.Errorf(""theme %q not found. did you mean [blue][bold]%s[reset]?"", originalQuery, suggestion)
	}
	return Theme{}, fmt.Errorf(""theme %q not found"", originalQuery)
}
// lookupPreprocess applies transformations to s so that it can be compared
// to search for something.
// For example, it is used by (ThemeStore).Lookup
func lookupPreprocess(s string) string {
	return strings.ToLower(regexp.MustCompile(`[-_ .]`).ReplaceAllString(norm.NFKD.String(s), """"))
}
// LoadCatalog loads a directory of theme manifests.
// Keys are theme names (files' basenames with the .yaml removed).
func LoadCatalog(storeDirectory string) (themes Catalog, err error) {
	themeNamePattern := regexp.MustCompile(`^(.+)\.ya?ml$`)
	themes = make(Catalog)
	manifests, err := os.ReadDir(storeDirectory)
	if err != nil {
		return
	}
	LogDebug(""loading potential themes %v into catalog"", func() []string {
		dirNames := make([]string, 0, len(manifests))
		for _, dir := range manifests {
			dirNames = append(dirNames, dir.Name())
		}
		return dirNames
	}())
	for _, manifest := range manifests {
		if !themeNamePattern.MatchString(manifest.Name()) {
			continue
		}
		themeName := themeNamePattern.FindStringSubmatch(manifest.Name())[1]
		theme, err := LoadManifest(filepath.Join(storeDirectory, manifest.Name()))
		if err != nil {
			return nil, fmt.Errorf(""while loading theme %q: %w"", themeName, err)
		}
		LogDebug(""\tadding theme from manifest %q"", manifest.Name())
		themes[themeName] = theme
	}
	return
}
",CWE-74,78.0,0
"package main
import (
	""fmt""
	""os""
	""os/exec""
	""path/filepath""
	""github.com/ggerganov/whisper.cpp/bindings/go/pkg/whisper""
	""github.com/go-audio/wav""
	""github.com/go-skynet/LocalAI/core/schema""
)
func runCommand(command []string) (string, error) {
	cmd := exec.Command(command[0], command[1:]...)
	cmd.Env = os.Environ()
	out, err := cmd.CombinedOutput()
	return string(out), err
}
// AudioToWav converts audio to wav for transcribe.
// TODO: use https://github.com/mccoyst/ogg?
func audioToWav(src, dst string) error {
    command := []string{""ffmpeg"", ""-i"", src, ""-format"", ""s16le"", ""-ar"", ""16000"", ""-ac"", ""1"", ""-acodec"", ""pcm_s16le"", dst}
	out, err := runCommand(command)
	if err != nil {
		return fmt.Errorf(""error: %w out: %s"", err, out)
	}
	return nil
}
func Transcript(model whisper.Model, audiopath, language string, threads uint) (schema.Result, error) {
	res := schema.Result{}
	dir, err := os.MkdirTemp("""", ""whisper"")
	if err != nil {
		return res, err
	}
	defer os.RemoveAll(dir)
	convertedPath := filepath.Join(dir, ""converted.wav"")
	if err := audioToWav(audiopath, convertedPath); err != nil {
		return res, err
	}
	// Open samples
	fh, err := os.Open(convertedPath)
	if err != nil {
		return res, err
	}
	defer fh.Close()
	// Read samples
	d := wav.NewDecoder(fh)
	buf, err := d.FullPCMBuffer()
	if err != nil {
		return res, err
	}
	data := buf.AsFloat32Buffer().Data
	// Process samples
	context, err := model.NewContext()
	if err != nil {
		return res, err
	}
	context.SetThreads(threads)
	if language != """" {
		context.SetLanguage(language)
	} else {
		context.SetLanguage(""auto"")
	}
	if err := context.Process(data, nil, nil); err != nil {
		return res, err
	}
	for {
		s, err := context.NextSegment()
		if err != nil {
			break
		}
		var tokens []int
		for _, t := range s.Tokens {
			tokens = append(tokens, t.Id)
		}
		segment := schema.Segment{Id: s.Num, Text: s.Text, Start: s.Start, End: s.End, Tokens: tokens}
		res.Segments = append(res.Segments, segment)
		res.Text += s.Text
	}
	return res, nil
}
",CWE-78,101.0,0
"package config_test
import (
	""io""
	""net/http""
	""os""
	. ""github.com/go-skynet/LocalAI/core/config""
	. ""github.com/onsi/ginkgo/v2""
	. ""github.com/onsi/gomega""
)
var _ = Describe(""Test cases for config related functions"", func() {
	Context(""Test Read configuration functions"", func() {
		It(""Test Validate"", func() {
			tmp, err := os.CreateTemp("""", ""config.yaml"")
			Expect(err).To(BeNil())
			defer os.Remove(tmp.Name())
			_, err = tmp.WriteString(
				`backend: ""foo-bar""
parameters:
  model: ""foo-bar""`)
			Expect(err).ToNot(HaveOccurred())
			config, err := ReadBackendConfig(tmp.Name())
			Expect(err).To(BeNil())
			Expect(config).ToNot(BeNil())
			Expect(config.Validate()).To(BeFalse())
		})
		It(""Test Validate"", func() {
			tmp, err := os.CreateTemp("""", ""config.yaml"")
			Expect(err).To(BeNil())
			defer os.Remove(tmp.Name())
			_, err = tmp.WriteString(
				`name: bar-baz
backend: ""foo-bar""
parameters:
  model: ""foo-bar""`)
			Expect(err).ToNot(HaveOccurred())
			config, err := ReadBackendConfig(tmp.Name())
			Expect(err).To(BeNil())
			Expect(config).ToNot(BeNil())
			// two configs in config.yaml
			Expect(config.Name).To(Equal(""bar-baz""))
			Expect(config.Validate()).To(BeTrue())
			// download https://raw.githubusercontent.com/mudler/LocalAI/master/embedded/models/hermes-2-pro-mistral.yaml
			httpClient := http.Client{}
			resp, err := httpClient.Get(""https://raw.githubusercontent.com/mudler/LocalAI/master/embedded/models/hermes-2-pro-mistral.yaml"")
			Expect(err).To(BeNil())
			defer resp.Body.Close()
			tmp, err = os.CreateTemp("""", ""config.yaml"")
			Expect(err).To(BeNil())
			defer os.Remove(tmp.Name())
			_, err = io.Copy(tmp, resp.Body)
			Expect(err).To(BeNil())
			config, err = ReadBackendConfig(tmp.Name())
			Expect(err).To(BeNil())
			Expect(config).ToNot(BeNil())
			// two configs in config.yaml
			Expect(config.Name).To(Equal(""hermes-2-pro-mistral""))
			Expect(config.Validate()).To(BeTrue())
		})
	})
})
",CWE-78,66.0,0
"package config_test
import (
	""io""
	""net/http""
	""os""
	. ""github.com/go-skynet/LocalAI/core/config""
	. ""github.com/onsi/ginkgo/v2""
	. ""github.com/onsi/gomega""
)
var _ = Describe(""Test cases for config related functions"", func() {
	Context(""Test Read configuration functions"", func() {
		It(""Test Validate"", func() {
			tmp, err := os.CreateTemp("""", ""config.yaml"")
			Expect(err).To(BeNil())
			defer os.Remove(tmp.Name())
			_, err = tmp.WriteString(
				`backend: ""foo-bar""
parameters:
  model: ""foo-bar""`)
			Expect(err).ToNot(HaveOccurred())
			config, err := ReadBackendConfig(tmp.Name())
			Expect(err).To(BeNil())
			Expect(config).ToNot(BeNil())
			Expect(config.Validate()).To(BeFalse())
		})
		It(""Test Validate"", func() {
			tmp, err := os.CreateTemp("""", ""config.yaml"")
			Expect(err).To(BeNil())
			defer os.Remove(tmp.Name())
			_, err = tmp.WriteString(
				`name: bar-baz
backend: ""foo-bar""
parameters:
  model: ""foo-bar""`)
			Expect(err).ToNot(HaveOccurred())
			config, err := ReadBackendConfig(tmp.Name())
			Expect(err).To(BeNil())
			Expect(config).ToNot(BeNil())
			// two configs in config.yaml
			Expect(config.Name).To(Equal(""bar-baz""))
			Expect(config.Validate()).To(BeTrue())
			// download https://raw.githubusercontent.com/mudler/LocalAI/master/embedded/models/hermes-2-pro-mistral.yaml
			httpClient := http.Client{}
			resp, err := httpClient.Get(""https://raw.githubusercontent.com/mudler/LocalAI/master/embedded/models/hermes-2-pro-mistral.yaml"")
			Expect(err).To(BeNil())
			defer resp.Body.Close()
			tmp, err = os.CreateTemp("""", ""config.yaml"")
			Expect(err).To(BeNil())
			defer os.Remove(tmp.Name())
			_, err = io.Copy(tmp, resp.Body)
			Expect(err).To(BeNil())
			config, err = ReadBackendConfig(tmp.Name())
			Expect(err).To(BeNil())
			Expect(config).ToNot(BeNil())
			// two configs in config.yaml
			Expect(config.Name).To(Equal(""hermes-2-pro-mistral""))
			Expect(config.Validate()).To(BeTrue())
		})
	})
})
",CWE-22,66.0,0
"package config_test
import (
	""testing""
	. ""github.com/onsi/ginkgo/v2""
	. ""github.com/onsi/gomega""
)
func TestConfig(t *testing.T) {
	RegisterFailHandler(Fail)
	RunSpecs(t, ""Config test suite"")
}
",CWE-78,14.0,0
"package config_test
import (
	""testing""
	. ""github.com/onsi/ginkgo/v2""
	. ""github.com/onsi/gomega""
)
func TestConfig(t *testing.T) {
	RegisterFailHandler(Fail)
	RunSpecs(t, ""Config test suite"")
}
",CWE-22,14.0,0
"package config_test
import (
	""os""
	. ""github.com/go-skynet/LocalAI/core/config""
	. ""github.com/onsi/ginkgo/v2""
	. ""github.com/onsi/gomega""
)
var _ = Describe(""Test cases for config related functions"", func() {
	var (
		configFile string
	)
	Context(""Test Read configuration functions"", func() {
		configFile = os.Getenv(""CONFIG_FILE"")
		It(""Test ReadConfigFile"", func() {
			config, err := ReadBackendConfigFile(configFile)
			Expect(err).To(BeNil())
			Expect(config).ToNot(BeNil())
			// two configs in config.yaml
			Expect(config[0].Name).To(Equal(""list1""))
			Expect(config[1].Name).To(Equal(""list2""))
		})
		It(""Test LoadConfigs"", func() {
			cm := NewBackendConfigLoader()
			err := cm.LoadBackendConfigsFromPath(os.Getenv(""MODELS_PATH""))
			Expect(err).To(BeNil())
			Expect(cm.ListBackendConfigs()).ToNot(BeNil())
			Expect(cm.ListBackendConfigs()).To(ContainElements(""code-search-ada-code-001""))
			// config should includes text-embedding-ada-002 models's api.config
			Expect(cm.ListBackendConfigs()).To(ContainElements(""text-embedding-ada-002""))
			// config should includes rwkv_test models's api.config
			Expect(cm.ListBackendConfigs()).To(ContainElements(""rwkv_test""))
			// config should includes whisper-1 models's api.config
			Expect(cm.ListBackendConfigs()).To(ContainElements(""whisper-1""))
		})
	})
})
",CWE-78,48.0,0
"package config_test
import (
	""os""
	. ""github.com/go-skynet/LocalAI/core/config""
	. ""github.com/onsi/ginkgo/v2""
	. ""github.com/onsi/gomega""
)
var _ = Describe(""Test cases for config related functions"", func() {
	var (
		configFile string
	)
	Context(""Test Read configuration functions"", func() {
		configFile = os.Getenv(""CONFIG_FILE"")
		It(""Test ReadConfigFile"", func() {
			config, err := ReadBackendConfigFile(configFile)
			Expect(err).To(BeNil())
			Expect(config).ToNot(BeNil())
			// two configs in config.yaml
			Expect(config[0].Name).To(Equal(""list1""))
			Expect(config[1].Name).To(Equal(""list2""))
		})
		It(""Test LoadConfigs"", func() {
			cm := NewBackendConfigLoader()
			err := cm.LoadBackendConfigsFromPath(os.Getenv(""MODELS_PATH""))
			Expect(err).To(BeNil())
			Expect(cm.ListBackendConfigs()).ToNot(BeNil())
			Expect(cm.ListBackendConfigs()).To(ContainElements(""code-search-ada-code-001""))
			// config should includes text-embedding-ada-002 models's api.config
			Expect(cm.ListBackendConfigs()).To(ContainElements(""text-embedding-ada-002""))
			// config should includes rwkv_test models's api.config
			Expect(cm.ListBackendConfigs()).To(ContainElements(""rwkv_test""))
			// config should includes whisper-1 models's api.config
			Expect(cm.ListBackendConfigs()).To(ContainElements(""whisper-1""))
		})
	})
})
",CWE-22,48.0,0
"package model
import (
	""errors""
	""fmt""
	""os""
	""os/signal""
	""strconv""
	""strings""
	""syscall""
	""time""
	""github.com/hpcloud/tail""
	process ""github.com/mudler/go-processmanager""
	""github.com/rs/zerolog/log""
)
func (ml *ModelLoader) StopAllExcept(s string) error {
	return ml.StopGRPC(func(id string, p *process.Process) bool {
		if id != s {
			for ml.models[id].GRPC(false, ml.wd).IsBusy() {
				log.Debug().Msgf(""%s busy. Waiting."", id)
				time.Sleep(2 * time.Second)
			}
			log.Debug().Msgf(""[single-backend] Stopping %s"", id)
			return true
		}
		return false
	})
}
func (ml *ModelLoader) deleteProcess(s string) error {
	if _, exists := ml.grpcProcesses[s]; exists {
		if err := ml.grpcProcesses[s].Stop(); err != nil {
			return err
		}
	}
	delete(ml.grpcProcesses, s)
	delete(ml.models, s)
	return nil
}
type GRPCProcessFilter = func(id string, p *process.Process) bool
func includeAllProcesses(_ string, _ *process.Process) bool {
	return true
}
func (ml *ModelLoader) StopGRPC(filter GRPCProcessFilter) error {
	var err error = nil
	for k, p := range ml.grpcProcesses {
		if filter(k, p) {
			e := ml.deleteProcess(k)
			err = errors.Join(err, e)
		}
	}
	return err
}
func (ml *ModelLoader) StopAllGRPC() error {
	return ml.StopGRPC(includeAllProcesses)
}
func (ml *ModelLoader) GetGRPCPID(id string) (int, error) {
	p, exists := ml.grpcProcesses[id]
	if !exists {
		return -1, fmt.Errorf(""no grpc backend found for %s"", id)
	}
	return strconv.Atoi(p.PID)
}
func (ml *ModelLoader) startProcess(grpcProcess, id string, serverAddress string) error {
	// Make sure the process is executable
	if err := os.Chmod(grpcProcess, 0700); err != nil {
		return err
	}
	log.Debug().Msgf(""Loading GRPC Process: %s"", grpcProcess)
	log.Debug().Msgf(""GRPC Service for %s will be running at: '%s'"", id, serverAddress)
	grpcControlProcess := process.New(
		process.WithTemporaryStateDir(),
		process.WithName(grpcProcess),
		process.WithArgs(""--addr"", serverAddress),
		process.WithEnvironment(os.Environ()...),
	)
	if ml.wd != nil {
		ml.wd.Add(serverAddress, grpcControlProcess)
		ml.wd.AddAddressModelMap(serverAddress, id)
	}
	ml.grpcProcesses[id] = grpcControlProcess
	if err := grpcControlProcess.Run(); err != nil {
		return err
	}
	log.Debug().Msgf(""GRPC Service state dir: %s"", grpcControlProcess.StateDir())
	// clean up process
	go func() {
		c := make(chan os.Signal, 1)
		signal.Notify(c, os.Interrupt, syscall.SIGTERM)
		<-c
		grpcControlProcess.Stop()
	}()
	go func() {
		t, err := tail.TailFile(grpcControlProcess.StderrPath(), tail.Config{Follow: true})
		if err != nil {
			log.Debug().Msgf(""Could not tail stderr"")
		}
		for line := range t.Lines {
			log.Debug().Msgf(""GRPC(%s): stderr %s"", strings.Join([]string{id, serverAddress}, ""-""), line.Text)
		}
	}()
	go func() {
		t, err := tail.TailFile(grpcControlProcess.StdoutPath(), tail.Config{Follow: true})
		if err != nil {
			log.Debug().Msgf(""Could not tail stdout"")
		}
		for line := range t.Lines {
			log.Debug().Msgf(""GRPC(%s): stdout %s"", strings.Join([]string{id, serverAddress}, ""-""), line.Text)
		}
	}()
	return nil
}
",CWE-78,130.0,0
"package model
import (
	""errors""
	""fmt""
	""os""
	""os/signal""
	""strconv""
	""strings""
	""syscall""
	""time""
	""github.com/hpcloud/tail""
	process ""github.com/mudler/go-processmanager""
	""github.com/rs/zerolog/log""
)
func (ml *ModelLoader) StopAllExcept(s string) error {
	return ml.StopGRPC(func(id string, p *process.Process) bool {
		if id != s {
			for ml.models[id].GRPC(false, ml.wd).IsBusy() {
				log.Debug().Msgf(""%s busy. Waiting."", id)
				time.Sleep(2 * time.Second)
			}
			log.Debug().Msgf(""[single-backend] Stopping %s"", id)
			return true
		}
		return false
	})
}
func (ml *ModelLoader) deleteProcess(s string) error {
	if _, exists := ml.grpcProcesses[s]; exists {
		if err := ml.grpcProcesses[s].Stop(); err != nil {
			return err
		}
	}
	delete(ml.grpcProcesses, s)
	delete(ml.models, s)
	return nil
}
type GRPCProcessFilter = func(id string, p *process.Process) bool
func includeAllProcesses(_ string, _ *process.Process) bool {
	return true
}
func (ml *ModelLoader) StopGRPC(filter GRPCProcessFilter) error {
	var err error = nil
	for k, p := range ml.grpcProcesses {
		if filter(k, p) {
			e := ml.deleteProcess(k)
			err = errors.Join(err, e)
		}
	}
	return err
}
func (ml *ModelLoader) StopAllGRPC() error {
	return ml.StopGRPC(includeAllProcesses)
}
func (ml *ModelLoader) GetGRPCPID(id string) (int, error) {
	p, exists := ml.grpcProcesses[id]
	if !exists {
		return -1, fmt.Errorf(""no grpc backend found for %s"", id)
	}
	return strconv.Atoi(p.PID)
}
func (ml *ModelLoader) startProcess(grpcProcess, id string, serverAddress string) error {
	// Make sure the process is executable
	if err := os.Chmod(grpcProcess, 0700); err != nil {
		return err
	}
	log.Debug().Msgf(""Loading GRPC Process: %s"", grpcProcess)
	log.Debug().Msgf(""GRPC Service for %s will be running at: '%s'"", id, serverAddress)
	grpcControlProcess := process.New(
		process.WithTemporaryStateDir(),
		process.WithName(grpcProcess),
		process.WithArgs(""--addr"", serverAddress),
		process.WithEnvironment(os.Environ()...),
	)
	if ml.wd != nil {
		ml.wd.Add(serverAddress, grpcControlProcess)
		ml.wd.AddAddressModelMap(serverAddress, id)
	}
	ml.grpcProcesses[id] = grpcControlProcess
	if err := grpcControlProcess.Run(); err != nil {
		return err
	}
	log.Debug().Msgf(""GRPC Service state dir: %s"", grpcControlProcess.StateDir())
	// clean up process
	go func() {
		c := make(chan os.Signal, 1)
		signal.Notify(c, os.Interrupt, syscall.SIGTERM)
		<-c
		grpcControlProcess.Stop()
	}()
	go func() {
		t, err := tail.TailFile(grpcControlProcess.StderrPath(), tail.Config{Follow: true})
		if err != nil {
			log.Debug().Msgf(""Could not tail stderr"")
		}
		for line := range t.Lines {
			log.Debug().Msgf(""GRPC(%s): stderr %s"", strings.Join([]string{id, serverAddress}, ""-""), line.Text)
		}
	}()
	go func() {
		t, err := tail.TailFile(grpcControlProcess.StdoutPath(), tail.Config{Follow: true})
		if err != nil {
			log.Debug().Msgf(""Could not tail stdout"")
		}
		for line := range t.Lines {
			log.Debug().Msgf(""GRPC(%s): stdout %s"", strings.Join([]string{id, serverAddress}, ""-""), line.Text)
		}
	}()
	return nil
}
",CWE-22,130.0,0
"package embedded
import (
	""embed""
	""fmt""
	""slices""
	""strings""
	""github.com/go-skynet/LocalAI/pkg/downloader""
	""github.com/rs/zerolog/log""
	""github.com/go-skynet/LocalAI/pkg/assets""
	""gopkg.in/yaml.v3""
)
var modelShorteners map[string]string
//go:embed model_library.yaml
var modelLibrary []byte
//go:embed models/*
var embeddedModels embed.FS
func ModelShortURL(s string) string {
	if _, ok := modelShorteners[s]; ok {
		s = modelShorteners[s]
	}
	return s
}
func init() {
	err := yaml.Unmarshal(modelLibrary, &modelShorteners)
	if err != nil {
		log.Error().Err(err).Msg(""error while unmarshalling embedded modelLibrary"")
	}
}
func GetRemoteLibraryShorteners(url string, basePath string) (map[string]string, error) {
	remoteLibrary := map[string]string{}
	err := downloader.GetURI(url, basePath, func(_ string, i []byte) error {
		return yaml.Unmarshal(i, &remoteLibrary)
	})
	if err != nil {
		return nil, fmt.Errorf(""error downloading remote library: %s"", err.Error())
	}
	return remoteLibrary, err
}
// ExistsInModelsLibrary checks if a model exists in the embedded models library
func ExistsInModelsLibrary(s string) bool {
	f := fmt.Sprintf(""%s.yaml"", s)
	a := []string{}
	for _, j := range assets.ListFiles(embeddedModels) {
		a = append(a, strings.TrimPrefix(j, ""models/""))
	}
	return slices.Contains(a, f)
}
// ResolveContent returns the content in the embedded model library
func ResolveContent(s string) ([]byte, error) {
	if ExistsInModelsLibrary(s) {
		return embeddedModels.ReadFile(fmt.Sprintf(""models/%s.yaml"", s))
	}
	return nil, fmt.Errorf(""cannot find model %s"", s)
}
",CWE-918,73.0,0
"package downloader_test
import (
	. ""github.com/go-skynet/LocalAI/pkg/downloader""
	. ""github.com/onsi/ginkgo/v2""
	. ""github.com/onsi/gomega""
)
var _ = Describe(""Gallery API tests"", func() {
	Context(""URI"", func() {
		It(""parses github with a branch"", func() {
			Expect(
				GetURI(""github:go-skynet/model-gallery/gpt4all-j.yaml"", """", func(url string, i []byte) error {
					Expect(url).To(Equal(""https://raw.githubusercontent.com/go-skynet/model-gallery/main/gpt4all-j.yaml""))
					return nil
				}),
			).ToNot(HaveOccurred())
		})
		It(""parses github without a branch"", func() {
			Expect(
				GetURI(""github:go-skynet/model-gallery/gpt4all-j.yaml@main"", """", func(url string, i []byte) error {
					Expect(url).To(Equal(""https://raw.githubusercontent.com/go-skynet/model-gallery/main/gpt4all-j.yaml""))
					return nil
				}),
			).ToNot(HaveOccurred())
		})
		It(""parses github with urls"", func() {
			Expect(
				GetURI(""https://raw.githubusercontent.com/go-skynet/model-gallery/main/gpt4all-j.yaml"", """", func(url string, i []byte) error {
					Expect(url).To(Equal(""https://raw.githubusercontent.com/go-skynet/model-gallery/main/gpt4all-j.yaml""))
					return nil
				}),
			).ToNot(HaveOccurred())
		})
	})
})
",CWE-918,37.0,0
"package gallery_test
import (
	. ""github.com/go-skynet/LocalAI/pkg/gallery""
	. ""github.com/onsi/ginkgo/v2""
	. ""github.com/onsi/gomega""
)
var _ = Describe(""Gallery API tests"", func() {
	Context(""requests"", func() {
		It(""parses github with a branch"", func() {
			req := GalleryModel{URL: ""github:go-skynet/model-gallery/gpt4all-j.yaml@main""}
			e, err := GetGalleryConfigFromURL(req.URL, """")
			Expect(err).ToNot(HaveOccurred())
			Expect(e.Name).To(Equal(""gpt4all-j""))
		})
	})
})
",CWE-918,19.0,0
"package startup
import (
	""errors""
	""os""
	""path/filepath""
	""github.com/go-skynet/LocalAI/embedded""
	""github.com/go-skynet/LocalAI/pkg/downloader""
	""github.com/go-skynet/LocalAI/pkg/utils""
	""github.com/rs/zerolog/log""
)
// PreloadModelsConfigurations will preload models from the given list of URLs
// It will download the model if it is not already present in the model path
// It will also try to resolve if the model is an embedded model YAML configuration
func PreloadModelsConfigurations(modelLibraryURL string, modelPath string, models ...string) {
	for _, url := range models {
		// As a best effort, try to resolve the model from the remote library
		// if it's not resolved we try with the other method below
		if modelLibraryURL != """" {
			lib, err := embedded.GetRemoteLibraryShorteners(modelLibraryURL, modelPath)
			if err == nil {
				if lib[url] != """" {
					log.Debug().Msgf(""[startup] model configuration is defined remotely: %s (%s)"", url, lib[url])
					url = lib[url]
				}
			}
		}
		url = embedded.ModelShortURL(url)
		switch {
		case embedded.ExistsInModelsLibrary(url):
			modelYAML, err := embedded.ResolveContent(url)
			// If we resolve something, just save it to disk and continue
			if err != nil {
				log.Error().Err(err).Msg(""error resolving model content"")
				continue
			}
			log.Debug().Msgf(""[startup] resolved embedded model: %s"", url)
			md5Name := utils.MD5(url)
			modelDefinitionFilePath := filepath.Join(modelPath, md5Name) + "".yaml""
			if err := os.WriteFile(modelDefinitionFilePath, modelYAML, os.ModePerm); err != nil {
				log.Error().Err(err).Str(""filepath"", modelDefinitionFilePath).Msg(""error writing model definition"")
			}
		case downloader.LooksLikeURL(url):
			log.Debug().Msgf(""[startup] resolved model to download: %s"", url)
			// md5 of model name
			md5Name := utils.MD5(url)
			// check if file exists
			if _, err := os.Stat(filepath.Join(modelPath, md5Name)); errors.Is(err, os.ErrNotExist) {
				modelDefinitionFilePath := filepath.Join(modelPath, md5Name) + "".yaml""
				err := downloader.DownloadFile(url, modelDefinitionFilePath, """", 0, 0, func(fileName, current, total string, percent float64) {
					utils.DisplayDownloadFunction(fileName, current, total, percent)
				})
				if err != nil {
					log.Error().Err(err).Str(""url"", url).Str(""filepath"", modelDefinitionFilePath).Msg(""error downloading model"")
				}
			}
		default:
			if _, err := os.Stat(url); err == nil {
				log.Debug().Msgf(""[startup] resolved local model: %s"", url)
				// copy to modelPath
				md5Name := utils.MD5(url)
				modelYAML, err := os.ReadFile(url)
				if err != nil {
					log.Error().Err(err).Str(""filepath"", url).Msg(""error reading model definition"")
					continue
				}
				modelDefinitionFilePath := filepath.Join(modelPath, md5Name) + "".yaml""
				if err := os.WriteFile(modelDefinitionFilePath, modelYAML, os.ModePerm); err != nil {
					log.Error().Err(err).Str(""filepath"", modelDefinitionFilePath).Msg(""error loading model: %s"")
				}
			} else {
				log.Warn().Msgf(""[startup] failed resolving model '%s'"", url)
			}
		}
	}
}
",CWE-918,86.0,0
"package system
import (
	""github.com/0xJacky/Nginx-UI/api""
	""github.com/0xJacky/Nginx-UI/settings""
	""github.com/gin-gonic/gin""
	""net/http""
	""reflect""
)
func GetSettings(c *gin.Context) {
	c.JSON(http.StatusOK, gin.H{
		""server"": settings.ServerSettings,
		""nginx"":  settings.NginxSettings,
		""openai"": settings.OpenAISettings,
	})
}
func SaveSettings(c *gin.Context) {
	var json struct {
		Server settings.Server `json:""server""`
		Nginx  settings.Nginx  `json:""nginx""`
		Openai settings.OpenAI `json:""openai""`
	}
	if !api.BindAndValid(c, &json) {
		return
	}
	// todo: omit protected fields when binding
	fillSettings(&settings.ServerSettings, &json.Server)
	fillSettings(&settings.NginxSettings, &json.Nginx)
	fillSettings(&settings.OpenAISettings, &json.Openai)
	settings.ReflectFrom()
	err := settings.Save()
	if err != nil {
		api.ErrHandler(c, err)
		return
	}
	GetSettings(c)
}
func fillSettings(targetSettings interface{}, newSettings interface{}) {
	s := reflect.TypeOf(targetSettings).Elem()
	vt := reflect.ValueOf(targetSettings).Elem()
	vn := reflect.ValueOf(newSettings).Elem()
	// copy the values from new to target settings if it is not protected
	for i := 0; i < s.NumField(); i++ {
		if s.Field(i).Tag.Get(""protected"") != ""true"" {
			vt.Field(i).Set(vn.Field(i))
		}
	}
}
",CWE-77,58.0,0
"package settings
type Nginx struct {
	AccessLogPath string `json:""access_log_path""`
	ErrorLogPath  string `json:""error_log_path""`
	ConfigDir     string `json:""config_dir"" protected:""true""`
	PIDPath       string `json:""pid_path"" protected:""true""`
	TestConfigCmd string `json:""test_config_cmd"" protected:""true""`
	ReloadCmd     string `json:""reload_cmd"" protected:""true""`
	RestartCmd    string `json:""restart_cmd"" protected:""true""`
}
var NginxSettings = Nginx{
	AccessLogPath: """",
	ErrorLogPath:  """",
}
",CWE-77,17.0,0
"package settings
type Server struct {
	HttpHost          string `json:""http_host"" protected:""true""`
	HttpPort          string `json:""http_port"" protected:""true""`
	RunMode           string `json:""run_mode"" protected:""true""`
	JwtSecret         string `json:""jwt_secret"" protected:""true""`
	NodeSecret        string `json:""node_secret"" protected:""true""`
	HTTPChallengePort string `json:""http_challenge_port""`
	Email             string `json:""email"" protected:""true""`
	Database          string `json:""database"" protected:""true""`
	StartCmd          string `json:""start_cmd"" protected:""true""`
	CADir             string `json:""ca_dir""`
	Demo              bool   `json:""demo"" protected:""true""`
	PageSize          int    `json:""page_size"" protected:""true""`
	GithubProxy       string `json:""github_proxy""`
}
var ServerSettings = Server{
	HttpHost:          ""0.0.0.0"",
	HttpPort:          ""9000"",
	RunMode:           ""debug"",
	HTTPChallengePort: ""9180"",
	Database:          ""database"",
	StartCmd:          ""login"",
	Demo:              false,
	PageSize:          10,
	CADir:             """",
	GithubProxy:       """",
}
",CWE-77,31.0,0
"package cosy
import (
	""fmt""
	""github.com/0xJacky/Nginx-UI/internal/logger""
	""github.com/gin-gonic/gin""
	""gorm.io/gorm""
	""gorm.io/gorm/schema""
	""sync""
)
func (c *Ctx[T]) SortOrder() func(db *gorm.DB) *gorm.DB {
	return func(db *gorm.DB) *gorm.DB {
		sort := c.ctx.DefaultQuery(""order"", ""desc"")
		if sort != ""desc"" && sort != ""asc"" {
			sort = ""desc""
		}
		// check if the order field is valid
		// todo: maybe we can use more generic way to check if the sort_by is valid
		order := DefaultQuery(c.ctx, ""sort_by"", c.itemKey)
		s, _ := schema.Parse(c.Model, &sync.Map{}, schema.NamingStrategy{})
		if _, ok := s.FieldsByDBName[order]; ok {
			order = fmt.Sprintf(""%s %s"", order, sort)
			return db.Order(order)
		} else {
			logger.Error(""invalid order field:"", order)
		}
		return db
	}
}
func (c *Ctx[T]) OrderAndPaginate() func(db *gorm.DB) *gorm.DB {
	return func(db *gorm.DB) *gorm.DB {
		db = c.SortOrder()(db)
		_, offset, pageSize := GetPagingParams(c.ctx)
		return db.Offset(offset).Limit(pageSize)
	}
}
func DefaultValue(c *gin.Context, key string, defaultValue any) any {
	if value, ok := c.Get(key); ok {
		return value
	}
	return defaultValue
}
func DefaultQuery(c *gin.Context, key string, defaultValue any) string {
	return c.DefaultQuery(key, DefaultValue(c, key, defaultValue).(string))
}
",CWE-89,52.0,0
"{
	""name"": ""@tablepress/tablepress"",
	""version"": ""2.2.5"",
	""description"": ""Embed beautiful and feature-rich tables into your posts and pages, without having to write code."",
	""author"": ""Tobias Bäthge"",
	""license"": ""GPL-2.0-only"",
	""private"": true,
	""keywords"": [
		""wordpress"",
		""plugin"",
		""table""
	],
	""homepage"": ""https://tablepress.org/"",
	""funding"": ""https://tablepress.org/donate/"",
	""repository"": ""github:TablePress/TablePress"",
	""bugs"": ""https://github.com/TablePress/TablePress/issues"",
	""devDependencies"": {
		""@wordpress/icons"": ""^9.36.0"",
		""@wordpress/scripts"": ""^26.16.0"",
		""autoprefixer"": ""^9.8.8"",
		""grunt"": ""^1.6.1"",
		""grunt-contrib-csslint"": ""^2.0.0"",
		""grunt-contrib-jshint"": ""^3.2.0"",
		""grunt-jsonlint"": ""^2.1.3"",
		""grunt-postcss"": ""^0.9.0"",
		""matchdep"": ""^2.0.0"",
		""webpack-remove-empty-scripts"": ""^1.0.4""
	},
	""scripts"": {
		""grunt"": ""grunt"",
		""prebuild"": ""grunt lint && wp-scripts lint-js && wp-scripts lint-style"",
		""build"": ""wp-scripts build"",
		""postbuild"": ""find ./admin/css/build/ ./css/build/ -type f -name \""*.css\"" -exec sed -i '' 's||\\\\f053|g;s||\\\\f054|g;s||\\\\f0dc|g;s||\\\\f0d8|g;s||\\\\f0d7|g;s|●|\\\\25cf|g;s|✓|\\\\2713|g' {} +"",
		""build:block"": ""wp-scripts build --config-name tablepress-block"",
		""build:css"": ""wp-scripts build --config-name tablepress-admin-css && wp-scripts build --config-name tablepress-frontend-css"",
		""build:js"": ""wp-scripts build --config-name tablepress-admin-js"",
		""build-dev"": ""DEVELOP=true npm run build"",
		""format"": ""wp-scripts format"",
		""lint:css"": ""wp-scripts lint-style"",
		""lint:js"": ""wp-scripts lint-js"",
		""start"": ""DEVELOP=true wp-scripts start"",
		""packages-update"": ""wp-scripts packages-update""
	}
}
",CWE-918,45.0,0
"package shell
import (
	""bytes""
	""fmt""
	""io""
	""os/exec""
	""strings""
	""github.com/caarlos0/log""
	""github.com/charmbracelet/x/exp/ordered""
	""github.com/goreleaser/goreleaser/internal/gio""
	""github.com/goreleaser/goreleaser/internal/logext""
	""github.com/goreleaser/goreleaser/pkg/context""
)
// Run a shell command with given arguments and envs
func Run(ctx *context.Context, dir string, command, env []string, output bool) error {
	log := log.
		WithField(""cmd"", command).
		WithField(""dir"", dir)
	/* 
	cmd := exec.CommandContext(ctx, command[0], command[1:]...)
	cmd.Env = env
	var b bytes.Buffer
	w := gio.Safe(&b)
	cmd.Stderr = io.MultiWriter(logext.NewConditionalWriter(output), w)
	cmd.Stdout = io.MultiWriter(logext.NewConditionalWriter(output), w)
	if dir != """" {
		cmd.Dir = dir
	}
	log.Debug(""running"")
	if err := cmd.Run(); err != nil {
		return fmt.Errorf(
			""shell: '%s': %w: %s"",
			strings.Join(command, "" ""),
			err,
			ordered.First(
				strings.TrimSpace(b.String()),
				""[no output]"",
			),
		)
	}
	return nil
}
",CWE-532,52.0,0
"package file
import (
	""archive/tar""
	""fmt""
	""io""
	""os""
	""path/filepath""
	""strings""
	""github.com/pkg/errors""
	""github.com/spf13/afero""
	""github.com/anchore/stereoscope/internal/log""
)
const perFileReadLimit = 2 * GB
var ErrTarStopIteration = fmt.Errorf(""halt iterating tar"")
// tarFile is a ReadCloser of a tar file on disk.
type tarFile struct {
	io.Reader
	io.Closer
}
// TarFileEntry represents the header, contents, and list position of an entry within a tar file.
type TarFileEntry struct {
	Sequence int64
	Header   tar.Header
	Reader   io.Reader
}
// TarFileVisitor is a visitor function meant to be used in conjunction with the IterateTar.
type TarFileVisitor func(TarFileEntry) error
// ErrFileNotFound returned from ReaderFromTar if a file is not found in the given archive.
type ErrFileNotFound struct {
	Path string
}
func (e *ErrFileNotFound) Error() string {
	return fmt.Sprintf(""file not found (path=%s)"", e.Path)
}
// IterateTar is a function that reads across a tar and invokes a visitor function for each entry discovered. The iterator
// stops when there are no more entries to read, if there is an error in the underlying reader or visitor function,
// or if the visitor function returns a ErrTarStopIteration sentinel error.
func IterateTar(reader io.Reader, visitor TarFileVisitor) error {
	tarReader := tar.NewReader(reader)
	var sequence int64 = -1
	for {
		sequence++
		hdr, err := tarReader.Next()
		if errors.Is(err, io.EOF) {
			break
		}
		if err != nil {
			return err
		}
		if hdr == nil {
			continue
		}
		if err := visitor(TarFileEntry{
			Sequence: sequence,
			Header:   *hdr,
			Reader:   tarReader,
		}); err != nil {
			if errors.Is(err, ErrTarStopIteration) {
				return nil
			}
			return fmt.Errorf(""failed to visit tar entry=%q : %w"", hdr.Name, err)
		}
	}
	return nil
}
// ReaderFromTar returns a io.ReadCloser for the Path within a tar file.
func ReaderFromTar(reader io.ReadCloser, tarPath string) (io.ReadCloser, error) {
	var result io.ReadCloser
	visitor := func(entry TarFileEntry) error {
		if entry.Header.Name == tarPath {
			result = &tarFile{
				Reader: entry.Reader,
				Closer: reader,
			}
			return ErrTarStopIteration
		}
		return nil
	}
	if err := IterateTar(reader, visitor); err != nil {
		return nil, err
	}
	if result == nil {
		return nil, &ErrFileNotFound{tarPath}
	}
	return result, nil
}
// MetadataFromTar returns the tar metadata from the header info.
func MetadataFromTar(reader io.ReadCloser, tarPath string) (Metadata, error) {
	var metadata *Metadata
	visitor := func(entry TarFileEntry) error {
		if entry.Header.Name == tarPath {
			var content io.Reader
			if entry.Header.Size > 0 {
				content = reader
			}
			m := NewMetadata(entry.Header, content)
			metadata = &m
			return ErrTarStopIteration
		}
		return nil
	}
	if err := IterateTar(reader, visitor); err != nil {
		return Metadata{}, err
	}
	if metadata == nil {
		return Metadata{}, &ErrFileNotFound{tarPath}
	}
	return *metadata, nil
}
// UntarToDirectory writes the contents of the given tar reader to the given destination. Note: this is meant to handle
// archives for images (not image contents) thus intentionally does not handle links or any kinds of special files.
func UntarToDirectory(reader io.Reader, dst string) error {
	return IterateTar(
		reader,
		tarVisitor{
			fs:          afero.NewOsFs(),
			destination: dst,
		}.visit,
	)
}
type tarVisitor struct {
	fs          afero.Fs
	destination string
}
func (v tarVisitor) visit(entry TarFileEntry) error {
	target := filepath.Join(v.destination, entry.Header.Name)
	// we should not allow for any destination path to be outside of where we are unarchiving to
	if !strings.HasPrefix(target, v.destination) {
		return fmt.Errorf(""potential path traversal attack with entry: %q"", entry.Header.Name)
	}
	switch entry.Header.Typeflag {
	case tar.TypeSymlink, tar.TypeLink:
		// we don't handle this is to prevent any potential traversal attacks
		log.WithFields(""path"", entry.Header.Name).Trace(""skipping symlink/link entry in image tar"")
	case tar.TypeDir:
		if _, err := v.fs.Stat(target); err != nil {
			if err := v.fs.MkdirAll(target, 0755); err != nil {
				return err
			}
		}
	case tar.TypeReg:
		f, err := v.fs.OpenFile(target, os.O_CREATE|os.O_RDWR, os.FileMode(entry.Header.Mode))
		if err != nil {
			return err
		}
		// limit the reader on each file read to prevent decompression bomb attacks
		numBytes, err := io.Copy(f, io.LimitReader(entry.Reader, perFileReadLimit))
		if numBytes >= perFileReadLimit || errors.Is(err, io.EOF) {
			return fmt.Errorf(""zip read limit hit (potential decompression bomb attack)"")
		}
		if err != nil {
			return fmt.Errorf(""unable to copy file: %w"", err)
		}
		if err = f.Close(); err != nil {
			log.Errorf(""failed to close file during untar of path=%q: %w"", f.Name(), err)
		}
	}
	return nil
}
",CWE-22,187.0,0
"package proxyprotocol
import (
	""bufio""
	""bytes""
	""testing""
	""github.com/stretchr/testify/assert""
)
func TestParse_Malformed(t *testing.T) {
	data := []byte{
		// PROXY protocol v2 magic header
		0x0D, 0x0A, 0x0D, 0x0A, 0x00, 0x0D, 0x0A, 0x51, 0x55, 0x49, 0x54, 0x0A,
		// v2 version, PROXY cmd
		0x21,
		// TCP, IPv4 (also works with 0x13,0x21,0x22,0x31,0x32)
		0x12,
		// Length
		0x00, 0x00,
		// src/dest address data _should_ be here but is omitted.
	}
	_, err := Parse(
		bufio.NewReader(
			bytes.NewReader(data)))
	assert.Error(t, err)
}
",CWE-20,29.0,0
"package dtls
import (
	""context""
	""testing""
	""time""
	""github.com/pion/dtls/v2/internal/ciphersuite""
	""github.com/pion/dtls/v2/pkg/protocol/alert""
	""github.com/pion/dtls/v2/pkg/protocol/handshake""
	""github.com/pion/transport/test""
)
type flight4TestMockFlightConn struct{}
func (f *flight4TestMockFlightConn) notify(ctx context.Context, level alert.Level, desc alert.Description) error {
	return nil
}
func (f *flight4TestMockFlightConn) writePackets(context.Context, []*packet) error { return nil }
func (f *flight4TestMockFlightConn) recvHandshake() <-chan chan struct{}           { return nil }
func (f *flight4TestMockFlightConn) setLocalEpoch(epoch uint16)                    {}
func (f *flight4TestMockFlightConn) handleQueuedPackets(context.Context) error     { return nil }
func (f *flight4TestMockFlightConn) sessionKey() []byte                            { return nil }
type flight4TestMockCipherSuite struct {
	ciphersuite.TLSEcdheEcdsaWithAes128GcmSha256
	t *testing.T
}
func (f *flight4TestMockCipherSuite) IsInitialized() bool {
	f.t.Fatal(""IsInitialized called with Certificate but not CertificateVerify"")
	return true
}
// Assert that if a Client sends a certificate they
// must also send a CertificateVerify message.
// The flight4handler must not interact with the CipherSuite
// if the CertificateVerify is missing
func TestFlight4_Process_CertificateVerify(t *testing.T) {
	// Limit runtime in case of deadlocks
	lim := test.TimeOut(5 * time.Second)
	defer lim.Stop()
	// Check for leaking routines
	report := test.CheckRoutines(t)
	defer report()
	mockConn := &flight4TestMockFlightConn{}
	state := &State{
		cipherSuite: &flight4TestMockCipherSuite{t: t},
	}
	cache := newHandshakeCache()
	cfg := &handshakeConfig{}
	rawCertificate := []byte{
		0x0b, 0x00, 0x01, 0x9b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x01, 0x9b, 0x00, 0x01, 0x98, 0x00, 0x01, 0x95, 0x30, 0x82,
		0x01, 0x91, 0x30, 0x82, 0x01, 0x38, 0xa0, 0x03, 0x02, 0x01,
		0x02, 0x02, 0x11, 0x01, 0x65, 0x03, 0x3f, 0x4d, 0x0b, 0x9a,
		0x62, 0x91, 0xdb, 0x4d, 0x28, 0x2c, 0x1f, 0xd6, 0x73, 0x32,
		0x30, 0x0a, 0x06, 0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x04,
		0x03, 0x02, 0x30, 0x00, 0x30, 0x1e, 0x17, 0x0d, 0x32, 0x32,
		0x30, 0x35, 0x31, 0x35, 0x31, 0x38, 0x34, 0x33, 0x35, 0x35,
		0x5a, 0x17, 0x0d, 0x32, 0x32, 0x30, 0x36, 0x31, 0x35, 0x31,
		0x38, 0x34, 0x33, 0x35, 0x35, 0x5a, 0x30, 0x00, 0x30, 0x59,
		0x30, 0x13, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02,
		0x01, 0x06, 0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x03, 0x01,
		0x07, 0x03, 0x42, 0x00, 0x04, 0xc3, 0xb7, 0x13, 0x1a, 0x0a,
		0xfc, 0xd0, 0x82, 0xf8, 0x94, 0x5e, 0xc0, 0x77, 0x07, 0x81,
		0x28, 0xc9, 0xcb, 0x08, 0x84, 0x50, 0x6b, 0xf0, 0x22, 0xe8,
		0x79, 0xb9, 0x15, 0x33, 0xc4, 0x56, 0xa1, 0xd3, 0x1b, 0x24,
		0xe3, 0x61, 0xbd, 0x4d, 0x65, 0x80, 0x6b, 0x5d, 0x96, 0x48,
		0xa2, 0x44, 0x9e, 0xce, 0xe8, 0x65, 0xd6, 0x3c, 0xe0, 0x9b,
		0x6b, 0xa1, 0x36, 0x34, 0xb2, 0x39, 0xe2, 0x03, 0x00, 0xa3,
		0x81, 0x92, 0x30, 0x81, 0x8f, 0x30, 0x0e, 0x06, 0x03, 0x55,
		0x1d, 0x0f, 0x01, 0x01, 0xff, 0x04, 0x04, 0x03, 0x02, 0x02,
		0xa4, 0x30, 0x1d, 0x06, 0x03, 0x55, 0x1d, 0x25, 0x04, 0x16,
		0x30, 0x14, 0x06, 0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07,
		0x03, 0x02, 0x06, 0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07,
		0x03, 0x01, 0x30, 0x0f, 0x06, 0x03, 0x55, 0x1d, 0x13, 0x01,
		0x01, 0xff, 0x04, 0x05, 0x30, 0x03, 0x01, 0x01, 0xff, 0x30,
		0x1d, 0x06, 0x03, 0x55, 0x1d, 0x0e, 0x04, 0x16, 0x04, 0x14,
		0xb1, 0x1a, 0xe3, 0xeb, 0x6f, 0x7c, 0xc3, 0x8f, 0xba, 0x6f,
		0x1c, 0xe8, 0xf0, 0x23, 0x08, 0x50, 0x8d, 0x3c, 0xea, 0x31,
		0x30, 0x2e, 0x06, 0x03, 0x55, 0x1d, 0x11, 0x01, 0x01, 0xff,
		0x04, 0x24, 0x30, 0x22, 0x82, 0x20, 0x30, 0x30, 0x30, 0x30,
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x0a,
		0x06, 0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x04, 0x03, 0x02,
		0x03, 0x47, 0x00, 0x30, 0x44, 0x02, 0x20, 0x06, 0x31, 0x43,
		0xac, 0x03, 0x45, 0x79, 0x3c, 0xd7, 0x5f, 0x6e, 0x6a, 0xf8,
		0x0e, 0xfd, 0x35, 0x49, 0xee, 0x1b, 0xbc, 0x47, 0xce, 0xe3,
		0x39, 0xec, 0xe4, 0x62, 0xe1, 0x30, 0x1a, 0xa1, 0x89, 0x02,
		0x20, 0x35, 0xcd, 0x7a, 0x15, 0x68, 0x09, 0x50, 0x49, 0x9e,
		0x3e, 0x05, 0xd7, 0xc2, 0x69, 0x3f, 0x9c, 0x0c, 0x98, 0x92,
		0x65, 0xec, 0xae, 0x44, 0xfe, 0xe5, 0x68, 0xb8, 0x09, 0x78,
		0x7f, 0x6b, 0x77,
	}
	rawClientKeyExchange := []byte{
		0x10, 0x00, 0x00, 0x21, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x21, 0x20, 0x96, 0xed, 0x0c, 0xee, 0xf3, 0x11, 0xb1,
		0x9d, 0x8b, 0x1c, 0x02, 0x7f, 0x06, 0x7c, 0x57, 0x7a, 0x14,
		0xa6, 0x41, 0xde, 0x63, 0x57, 0x9e, 0xcd, 0x34, 0x54, 0xba,
		0x37, 0x4d, 0x34, 0x15, 0x18,
	}
	cache.push(rawCertificate, 0, 0, handshake.TypeCertificate, true)
	cache.push(rawClientKeyExchange, 0, 1, handshake.TypeClientKeyExchange, true)
	if _, _, err := flight4Parse(context.TODO(), mockConn, state, cache, cfg); err != nil {
		t.Fatal(err)
	}
}
",CWE-295,117.0,0
"package consensus
import (
	""testing""
	""github.com/tendermint/tendermint/libs/bytes""
	""github.com/tendermint/tendermint/libs/log""
	tmrand ""github.com/tendermint/tendermint/libs/rand""
	""github.com/tendermint/tendermint/p2p""
	tmproto ""github.com/tendermint/tendermint/proto/tendermint/types""
	""github.com/tendermint/tendermint/types""
)
//----------------------------------------------
// byzantine failures
// one byz val sends a precommit for a random block at each height
// Ensure a testnet makes blocks
func TestReactorInvalidPrecommit(t *testing.T) {
	N := 4
	css, cleanup := randConsensusNet(N, ""consensus_reactor_test"", newMockTickerFunc(true), newCounter)
	defer cleanup()
	for i := 0; i < 4; i++ {
		ticker := NewTimeoutTicker()
		ticker.SetLogger(css[i].Logger)
		css[i].SetTimeoutTicker(ticker)
	}
	reactors, blocksSubs, eventBuses := startConsensusNet(t, css, N)
	// this val sends a random precommit at each height
	byzValIdx := 0
	byzVal := css[byzValIdx]
	byzR := reactors[byzValIdx]
	// update the doPrevote function to just send a valid precommit for a random block
	// and otherwise disable the priv validator
	byzVal.mtx.Lock()
	pv := byzVal.privValidator
	byzVal.doPrevote = func(height int64, round int32) {
		invalidDoPrevoteFunc(t, height, round, byzVal, byzR.Switch, pv)
	}
	byzVal.mtx.Unlock()
	defer stopConsensusNet(log.TestingLogger(), reactors, eventBuses)
	// wait for a bunch of blocks
	// TODO: make this tighter by ensuring the halt happens by block 2
	for i := 0; i < 10; i++ {
		timeoutWaitGroup(t, N, func(j int) {
			<-blocksSubs[j].Out()
		}, css)
	}
}
func invalidDoPrevoteFunc(t *testing.T, height int64, round int32, cs *State, sw *p2p.Switch, pv types.PrivValidator) {
	// routine to:
	// - precommit for a random block
	// - send precommit to all peers
	// - disable privValidator (so we don't do normal precommits)
	go func() {
		cs.mtx.Lock()
		cs.privValidator = pv
		pubKey, err := cs.privValidator.GetPubKey()
		if err != nil {
			panic(err)
		}
		addr := pubKey.Address()
		valIndex, _ := cs.Validators.GetByAddress(addr)
		// precommit a random block
		blockHash := bytes.HexBytes(tmrand.Bytes(32))
		precommit := &types.Vote{
			ValidatorAddress: addr,
			ValidatorIndex:   valIndex,
			Height:           cs.Height,
			Round:            cs.Round,
			Timestamp:        cs.voteTime(),
			Type:             tmproto.PrecommitType,
			BlockID: types.BlockID{
				Hash:          blockHash,
				PartSetHeader: types.PartSetHeader{Total: 1, Hash: tmrand.Bytes(32)}},
		}
		p := precommit.ToProto()
		cs.privValidator.SignVote(cs.state.ChainID, p)
		precommit.Signature = p.Signature
		cs.privValidator = nil // disable priv val so we don't do normal votes
		cs.mtx.Unlock()
		peers := sw.Peers().List()
		for _, peer := range peers {
			cs.Logger.Info(""Sending bad vote"", ""block"", blockHash, ""peer"", peer)
			peer.Send(VoteChannel, MustEncode(&VoteMessage{precommit}))
		}
	}()
}
",CWE-347,98.0,0
"package application
import (
	""encoding/json""
	""github.com/gorilla/websocket""
	""github.com/stretchr/testify/assert""
	""net/http""
	""net/http/httptest""
	""strings""
	""testing""
)
func reconnect(w http.ResponseWriter, r *http.Request) {
	var upgrader = websocket.Upgrader{}
	c, err := upgrader.Upgrade(w, r, nil)
	if err != nil {
		return
	}
	ts := terminalSession{wsConn: c}
	_, _ = ts.reconnect()
}
func TestReconnect(t *testing.T) {
	s := httptest.NewServer(http.HandlerFunc(reconnect))
	defer s.Close()
	u := ""ws"" + strings.TrimPrefix(s.URL, ""http"")
	// Connect to the server
	ws, _, err := websocket.DefaultDialer.Dial(u, nil)
	assert.NoError(t, err)
	defer ws.Close()
	_, p, _ := ws.ReadMessage()
	var message TerminalMessage
	err = json.Unmarshal(p, &message)
	assert.NoError(t, err)
	assert.Equal(t, message.Data, ReconnectMessage)
}
",CWE-613,47.0,0
"// compares the inventory of package items in the tree
// that is about to be installed (idealTree) with the inventory
// of items stored in the package-lock file (virtualTree)
//
// Returns empty array if no errors found or an array populated
// with an entry for each validation error found.
function validateLockfile (virtualTree, idealTree) {
  const errors = []
  // loops through the inventory of packages resulted by ideal tree,
  // for each package compares the versions with the version stored in the
  // package-lock and adds an error to the list in case of mismatches
  for (const [key, entry] of idealTree.entries()) {
    const lock = virtualTree.get(key)
    if (!lock) {
      errors.push(`Missing: ${entry.name}@${entry.version} from lock file`)
      continue
    }
    if (entry.version !== lock.version) {
      errors.push(`Invalid: lock file's ${lock.name}@${lock.version} does ` +
      `not satisfy ${entry.name}@${entry.version}`)
    }
  }
  return errors
}
module.exports = validateLockfile
",CWE-345,30.0,0
"package api
import (
	""net/http""
	""testing""
	""github.com/stretchr/testify/assert""
	""github.com/stretchr/testify/require""
)
func Test_safePrefix(t *testing.T) {
	testCases := []struct {
		desc     string
		value    string
		expected string
	}{
		{
			desc:     ""host"",
			value:    ""https://example.com"",
			expected: """",
		},
		{
			desc:     ""host with path"",
			value:    ""https://example.com/foo/bar?test"",
			expected: """",
		},
		{
			desc:     ""path"",
			value:    ""/foo/bar"",
			expected: ""/foo/bar"",
		},
		{
			desc:     ""path without leading slash"",
			value:    ""foo/bar"",
			expected: ""foo/bar"",
		},
	}
	for _, test := range testCases {
		test := test
		t.Run(test.desc, func(t *testing.T) {
			t.Parallel()
			req, err := http.NewRequest(http.MethodGet, ""http://localhost"", nil)
			require.NoError(t, err)
			req.Header.Set(""X-Forwarded-Prefix"", test.value)
			prefix := safePrefix(req)
			assert.Equal(t, test.expected, prefix)
		})
	}
}
",CWE-601,55.0,0
"/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
// RUN: %hermes -g --lazy --Xhermes-internal-test-methods -O %s | %FileCheck %s
// RUN: %hermes -g --lazy --Xhermes-internal-test-methods -O0 %s | %FileCheck %s
""use strict"";
// isLazy should be able to handle native functions.
print(HermesInternal.isLazy(print));
// CHECK: false
// isLazy should be able to handle non-callables.
print(HermesInternal.isLazy(10));
// CHECK: false
function lazyFunc() {}
print(HermesInternal.isLazy(lazyFunc));
// CHECK: true
print(JSON.stringify(HermesInternal.getFunctionLocation(lazyFunc)));
// CHECK: {""isNative"":false,""lineNumber"":21,""columnNumber"":1}
lazyFunc();
print(HermesInternal.isLazy(lazyFunc));
// CHECK: false
print(JSON.stringify(HermesInternal.getFunctionLocation(lazyFunc)));
// CHECK: {""isNative"":false,""lineNumber"":21,""columnNumber"":1,""fileName"":""{{.*}}regress-hermes-internal-get-lazy-function-location.js""}
",CWE-476,36.0,0
"package api
import (
	""bytes""
	""encoding/json""
	""fmt""
	""net/http""
	""net/http/httptest""
	""strings""
	""testing""
	""github.com/gophish/gophish/dialer""
	""github.com/gophish/gophish/models""
)
func makeImportRequest(ctx *testContext, allowedHosts []string, url string) *httptest.ResponseRecorder {
	orig := dialer.DefaultDialer.AllowedHosts()
	dialer.SetAllowedHosts(allowedHosts)
	req := httptest.NewRequest(http.MethodPost, ""/api/import/site"",
		bytes.NewBuffer([]byte(fmt.Sprintf(`
			{
				""url"" : ""%s""
			}
		`, url))))
	req.Header.Set(""Content-Type"", ""application/json"")
	response := httptest.NewRecorder()
	ctx.apiServer.ImportSite(response, req)
	dialer.SetAllowedHosts(orig)
	return response
}
func TestDefaultDeniedImport(t *testing.T) {
	ctx := setupTest(t)
	metadataURL := ""http://169.254.169.254/latest/meta-data/""
	response := makeImportRequest(ctx, []string{}, metadataURL)
	expectedCode := http.StatusBadRequest
	if response.Code != expectedCode {
		t.Fatalf(""incorrect status code received. expected %d got %d"", expectedCode, response.Code)
	}
	got := &models.Response{}
	err := json.NewDecoder(response.Body).Decode(got)
	if err != nil {
		t.Fatalf(""error decoding body: %v"", err)
	}
	if !strings.Contains(got.Message, ""upstream connection denied"") {
		t.Fatalf(""incorrect response error provided: %s"", got.Message)
	}
}
func TestDefaultAllowedImport(t *testing.T) {
	ctx := setupTest(t)
	h := ""<html><head></head><body><img src=\""/test.png\""/></body></html>""
	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintln(w, h)
	}))
	defer ts.Close()
	response := makeImportRequest(ctx, []string{}, ts.URL)
	expectedCode := http.StatusOK
	if response.Code != expectedCode {
		t.Fatalf(""incorrect status code received. expected %d got %d"", expectedCode, response.Code)
	}
}
func TestCustomDeniedImport(t *testing.T) {
	ctx := setupTest(t)
	h := ""<html><head></head><body><img src=\""/test.png\""/></body></html>""
	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintln(w, h)
	}))
	defer ts.Close()
	response := makeImportRequest(ctx, []string{""192.168.1.1""}, ts.URL)
	expectedCode := http.StatusBadRequest
	if response.Code != expectedCode {
		t.Fatalf(""incorrect status code received. expected %d got %d"", expectedCode, response.Code)
	}
	got := &models.Response{}
	err := json.NewDecoder(response.Body).Decode(got)
	if err != nil {
		t.Fatalf(""error decoding body: %v"", err)
	}
	if !strings.Contains(got.Message, ""upstream connection denied"") {
		t.Fatalf(""incorrect response error provided: %s"", got.Message)
	}
}
",CWE-918,85.0,0
"package dialer
import (
	""fmt""
	""net""
	""syscall""
	""time""
)
// RestrictedDialer is used to create a net.Dialer which restricts outbound
// connections to only allowlisted IP ranges.
type RestrictedDialer struct {
	allowedHosts []*net.IPNet
}
// DefaultDialer is a global instance of a RestrictedDialer
var DefaultDialer = &RestrictedDialer{}
// SetAllowedHosts sets the list of allowed hosts or IP ranges for the default
// dialer.
func SetAllowedHosts(allowed []string) {
	DefaultDialer.SetAllowedHosts(allowed)
}
// AllowedHosts returns the configured hosts that are allowed for the dialer.
func (d *RestrictedDialer) AllowedHosts() []string {
	ranges := []string{}
	for _, ipRange := range d.allowedHosts {
		ranges = append(ranges, ipRange.String())
	}
	return ranges
}
// SetAllowedHosts sets the list of allowed hosts or IP ranges for the dialer.
func (d *RestrictedDialer) SetAllowedHosts(allowed []string) error {
	for _, ipRange := range allowed {
		// For flexibility, try to parse as an IP first since this will
		// undoubtedly cause issues. If it works, then just append the
		// appropriate subnet mask, then parse as CIDR
		if singleIP := net.ParseIP(ipRange); singleIP != nil {
			if singleIP.To4() != nil {
				ipRange += ""/32""
			} else {
				ipRange += ""/128""
			}
		}
		_, parsed, err := net.ParseCIDR(ipRange)
		if err != nil {
			return fmt.Errorf(""provided ip range is not valid CIDR notation: %v"", err)
		}
		d.allowedHosts = append(d.allowedHosts, parsed)
	}
	return nil
}
// Dialer returns a net.Dialer that restricts outbound connections to only the
// addresses allowed by the DefaultDialer.
func Dialer() *net.Dialer {
	return DefaultDialer.Dialer()
}
// Dialer returns a net.Dialer that restricts outbound connections to only the
// allowed addresses over TCP.
//
// By default, since Gophish anticipates connections originating to hosts on
// the local network, we only deny access to the link-local addresses at
// 169.254.0.0/16.
//
// If hosts are provided, then Gophish blocks access to all local addresses
// except the ones provided.
//
// This implementation is based on the blog post by Andrew Ayer at
// https://www.agwa.name/blog/post/preventing_server_side_request_forgery_in_golang
func (d *RestrictedDialer) Dialer() *net.Dialer {
	return &net.Dialer{
		Timeout:   30 * time.Second,
		KeepAlive: 30 * time.Second,
		Control:   restrictedControl(d.allowedHosts),
	}
}
// defaultDeny represents the list of IP ranges that we want to block unless
// explicitly overriden.
var defaultDeny = []string{
	""169.254.0.0/16"", // Link-local (used for VPS instance metadata)
}
// allInternal represents all internal hosts such that the only connections
// allowed are external ones.
var allInternal = []string{
	""0.0.0.0/8"",
	""127.0.0.0/8"",        // IPv4 loopback
	""10.0.0.0/8"",         // RFC1918
	""100.64.0.0/10"",      // CGNAT
	""172.16.0.0/12"",      // RFC1918
	""169.254.0.0/16"",     // RFC3927 link-local
	""192.88.99.0/24"",     // IPv6 to IPv4 Relay
	""192.168.0.0/16"",     // RFC1918
	""198.51.100.0/24"",    // TEST-NET-2
	""203.0.113.0/24"",     // TEST-NET-3
	""224.0.0.0/4"",        // Multicast
	""240.0.0.0/4"",        // Reserved
	""255.255.255.255/32"", // Broadcast
	""::/0"",               // Default route
	""::/128"",             // Unspecified address
	""::1/128"",            // IPv6 loopback
	""::ffff:0:0/96"",      // IPv4 mapped addresses.
	""::ffff:0:0:0/96"",    // IPv4 translated addresses.
	""fe80::/10"",          // IPv6 link-local
	""fc00::/7"",           // IPv6 unique local addr
}
type dialControl = func(network, address string, c syscall.RawConn) error
type restrictedDialer struct {
	*net.Dialer
	allowed []string
}
func restrictedControl(allowed []*net.IPNet) dialControl {
	return func(network string, address string, conn syscall.RawConn) error {
		if !(network == ""tcp4"" || network == ""tcp6"") {
			return fmt.Errorf(""%s is not a safe network type"", network)
		}
		host, _, err := net.SplitHostPort(address)
		if err != nil {
			return fmt.Errorf(""%s is not a valid host/port pair: %s"", address, err)
		}
		ip := net.ParseIP(host)
		if ip == nil {
			return fmt.Errorf(""%s is not a valid IP address"", host)
		}
		denyList := defaultDeny
		if len(allowed) > 0 {
			denyList = allInternal
		}
		for _, ipRange := range allowed {
			if ipRange.Contains(ip) {
				return nil
			}
		}
		for _, ipRange := range denyList {
			_, parsed, err := net.ParseCIDR(ipRange)
			if err != nil {
				return fmt.Errorf(""error parsing denied range: %v"", err)
			}
			if parsed.Contains(ip) {
				return fmt.Errorf(""upstream connection denied to internal host"")
			}
		}
		return nil
	}
}
",CWE-918,159.0,0
"package dialer
import (
	""fmt""
	""net""
	""strings""
	""syscall""
	""testing""
)
func TestDefaultDeny(t *testing.T) {
	control := restrictedControl([]*net.IPNet{})
	host := ""169.254.169.254""
	expected := fmt.Errorf(""upstream connection denied to internal host at %s"", host)
	conn := new(syscall.RawConn)
	got := control(""tcp4"", fmt.Sprintf(""%s:80"", host), *conn)
	if !strings.Contains(got.Error(), ""upstream connection denied"") {
		t.Fatalf(""unexpected error dialing denylisted host. expected %v got %v"", expected, got)
	}
}
func TestDefaultAllow(t *testing.T) {
	control := restrictedControl([]*net.IPNet{})
	host := ""1.1.1.1""
	conn := new(syscall.RawConn)
	got := control(""tcp4"", fmt.Sprintf(""%s:80"", host), *conn)
	if got != nil {
		t.Fatalf(""error dialing allowed host. got %v"", got)
	}
}
func TestCustomAllow(t *testing.T) {
	host := ""127.0.0.1""
	_, ipRange, _ := net.ParseCIDR(fmt.Sprintf(""%s/32"", host))
	allowed := []*net.IPNet{ipRange}
	control := restrictedControl(allowed)
	conn := new(syscall.RawConn)
	got := control(""tcp4"", fmt.Sprintf(""%s:80"", host), *conn)
	if got != nil {
		t.Fatalf(""error dialing allowed host. got %v"", got)
	}
}
func TestCustomDeny(t *testing.T) {
	host := ""127.0.0.1""
	_, ipRange, _ := net.ParseCIDR(fmt.Sprintf(""%s/32"", host))
	allowed := []*net.IPNet{ipRange}
	control := restrictedControl(allowed)
	conn := new(syscall.RawConn)
	expected := fmt.Errorf(""upstream connection denied to internal host at %s"", host)
	got := control(""tcp4"", ""192.168.1.2:80"", *conn)
	if !strings.Contains(got.Error(), ""upstream connection denied"") {
		t.Fatalf(""unexpected error dialing denylisted host. expected %v got %v"", expected, got)
	}
}
func TestSingleIP(t *testing.T) {
	orig := DefaultDialer.AllowedHosts()
	host := ""127.0.0.1""
	DefaultDialer.SetAllowedHosts([]string{host})
	control := DefaultDialer.Dialer().Control
	conn := new(syscall.RawConn)
	expected := fmt.Errorf(""upstream connection denied to internal host at %s"", host)
	got := control(""tcp4"", ""192.168.1.2:80"", *conn)
	if !strings.Contains(got.Error(), ""upstream connection denied"") {
		t.Fatalf(""unexpected error dialing denylisted host. expected %v got %v"", expected, got)
	}
	host = ""::1""
	DefaultDialer.SetAllowedHosts([]string{host})
	control = DefaultDialer.Dialer().Control
	conn = new(syscall.RawConn)
	expected = fmt.Errorf(""upstream connection denied to internal host at %s"", host)
	got = control(""tcp4"", ""192.168.1.2:80"", *conn)
	if !strings.Contains(got.Error(), ""upstream connection denied"") {
		t.Fatalf(""unexpected error dialing denylisted host. expected %v got %v"", expected, got)
	}
	// Test an allowed connection
	got = control(""tcp4"", fmt.Sprintf(""[%s]:80"", host), *conn)
	if got != nil {
		t.Fatalf(""error dialing allowed host. got %v"", got)
	}
	DefaultDialer.SetAllowedHosts(orig)
}
",CWE-918,86.0,0
"// Copyright Istio Authors
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package authenticate
import (
	""context""
	""fmt""
	""net""
	""net/http""
	""strings""
	""github.com/alecholmes/xfccparser""
	""google.golang.org/grpc/metadata""
	""google.golang.org/grpc/peer""
	""istio.io/istio/pilot/pkg/features""
	""istio.io/istio/pkg/security""
)
const (
	XfccAuthenticatorType = ""XfccAuthenticator""
)
// XfccAuthenticator extracts identities from Xfcc header.
type XfccAuthenticator struct{}
var _ security.Authenticator = &XfccAuthenticator{}
func (xff XfccAuthenticator) AuthenticatorType() string {
	return XfccAuthenticatorType
}
// Authenticate extracts identities from Xfcc Header.
func (xff XfccAuthenticator) Authenticate(ctx context.Context) (*security.Caller, error) {
	peerInfo, _ := peer.FromContext(ctx)
	// First check if client is trusted client so that we can ""trust"" the Xfcc Header.
	if !isTrustedAddress(peerInfo.Addr.String(), features.TrustedGatewayCIDR) {
		return nil, fmt.Errorf(""caller from %s is not in the trusted network. XfccAuthenticator can not be used"", peerInfo.Addr.String())
	}
	meta, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(meta.Get(xfccparser.ForwardedClientCertHeader)) == 0 {
		return nil, nil
	}
	xfccHeader := meta.Get(xfccparser.ForwardedClientCertHeader)[0]
	return buildSecurityCaller(xfccHeader)
}
// AuthenticateRequest validates Xfcc Header.
func (xff XfccAuthenticator) AuthenticateRequest(req *http.Request) (*security.Caller, error) {
	xfccHeader := req.Header.Get(xfccparser.ForwardedClientCertHeader)
	if len(xfccHeader) == 0 {
		return nil, nil
	}
	return buildSecurityCaller(xfccHeader)
}
func buildSecurityCaller(xfccHeader string) (*security.Caller, error) {
	clientCerts, err := xfccparser.ParseXFCCHeader(xfccHeader)
	if err != nil {
		message := fmt.Sprintf(""error in parsing xfcc header: %v"", err)
		return nil, fmt.Errorf(message)
	}
	if len(clientCerts) == 0 {
		message := ""xfcc header does not have atleast one client certs""
		return nil, fmt.Errorf(message)
	}
	ids := []string{}
	for _, cc := range clientCerts {
		ids = append(ids, cc.URI)
		ids = append(ids, cc.DNS...)
		if cc.Subject != nil {
			ids = append(ids, cc.Subject.CommonName)
		}
	}
	return &security.Caller{
		AuthSource: security.AuthSourceClientCertificate,
		Identities: ids,
	}, nil
}
func isTrustedAddress(addr string, trustedCidrs []string) bool {
	for _, cidr := range trustedCidrs {
		if isInRange(addr, cidr) {
			return true
		}
	}
	// Always trust local host addresses.
	return net.ParseIP(addr).IsLoopback()
}
func isInRange(addr, cidr string) bool {
	if strings.Contains(cidr, ""/"") {
		ip, ipnet, err := net.ParseCIDR(cidr)
		if err != nil {
			return false
		}
		if ip.To4() == nil && ip.To16() == nil {
			return false
		}
		return ipnet.Contains(net.ParseIP(addr))
	}
	return false
}
",CWE-863,118.0,0
"// Copyright Istio Authors
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package authenticate
import (
	""net""
	""reflect""
	""strings""
	""testing""
	""github.com/alecholmes/xfccparser""
	""golang.org/x/net/context""
	""google.golang.org/grpc/metadata""
	""google.golang.org/grpc/peer""
	""istio.io/istio/pkg/security""
)
func TestIsTrustedAddress(t *testing.T) {
	cases := []struct {
		name    string
		cidr    string
		peer    string
		trusted bool
	}{
		{
			name:    ""localhost client"",
			cidr:    """",
			peer:    ""127.0.0.1"",
			trusted: true,
		},
		{
			name:    ""external client without trusted cidr"",
			cidr:    """",
			peer:    ""172.0.0.1"",
			trusted: false,
		},
		{
			name:    ""cidr in range"",
			cidr:    ""172.17.0.0/16,192.17.0.0/16"",
			peer:    ""172.17.0.2"",
			trusted: true,
		},
		{
			name:    ""cidr in range with both ipv6 and ipv4"",
			cidr:    ""172.17.0.0/16,2001:db8:1234:1a00::/56"",
			peer:    ""2001:0db8:1234:1aff:ffff:ffff:ffff:ffff"",
			trusted: true,
		},
		{
			name:    ""cidr outside range"",
			cidr:    ""172.17.0.0/16,172.17.0.0/16"",
			peer:    ""110.17.0.2"",
			trusted: false,
		},
	}
	for _, tt := range cases {
		t.Run(tt.name, func(t *testing.T) {
			if result := isTrustedAddress(tt.peer, strings.Split(tt.cidr, "","")); result != tt.trusted {
				t.Errorf(""Unexpected authentication result: want %v but got %v"",
					tt.trusted, result)
			}
		})
	}
}
func TestXfccAuthenticator(t *testing.T) {
	cases := []struct {
		name               string
		xfccHeader         string
		caller             *security.Caller
		authenticateErrMsg string
	}{
		{
			name:       ""No xfcc header"",
			xfccHeader: """",
			caller:     nil,
		},
		{
			name:               ""junk xfcc header"",
			xfccHeader:         `junk xfcc header`,
			authenticateErrMsg: `error in parsing xfcc header: invalid header format: unexpected token ""junk xfcc header""`,
		},
		{
			name: ""Xfcc Header single hop"",
			// nolint lll
			xfccHeader: `Hash=meshclient;Subject="""";URI=spiffe://mesh.example.com/ns/otherns/sa/othersa`,
			caller: &security.Caller{
				AuthSource: security.AuthSourceClientCertificate,
				Identities: []string{
					""spiffe://mesh.example.com/ns/otherns/sa/othersa"",
				},
			},
		},
		{
			name: ""Xfcc Header multiple hops"",
			// nolint lll
			xfccHeader: `Hash=hash;Cert=""-----BEGIN%20CERTIFICATE-----%0cert%0A-----END%20CERTIFICATE-----%0A"";Subject=""CN=hello,OU=hello,O=Acme\, Inc."";URI=spiffe://mesh.example.com/ns/firstns/sa/firstsa;DNS=hello.west.example.com;DNS=hello.east.example.com,By=spiffe://mesh.example.com/ns/hellons/sa/hellosa;Hash=again;Subject="""";URI=spiffe://mesh.example.com/ns/otherns/sa/othersa`,
			caller: &security.Caller{
				AuthSource: security.AuthSourceClientCertificate,
				Identities: []string{
					""spiffe://mesh.example.com/ns/firstns/sa/firstsa"",
					""hello.west.example.com"",
					""hello.east.example.com"",
					""hello"",
					""spiffe://mesh.example.com/ns/otherns/sa/othersa"",
				},
			},
		},
	}
	auth := &XfccAuthenticator{}
	for _, tt := range cases {
		t.Run(tt.name, func(t *testing.T) {
			md := metadata.MD{}
			if len(tt.xfccHeader) > 0 {
				md.Append(xfccparser.ForwardedClientCertHeader, tt.xfccHeader)
			}
			ctx := peer.NewContext(context.Background(), &peer.Peer{Addr: &net.IPAddr{IP: net.ParseIP(""127.0.0.1"").To4()}})
			ctx = metadata.NewIncomingContext(ctx, md)
			result, err := auth.Authenticate(ctx)
			if len(tt.authenticateErrMsg) > 0 {
				if err == nil {
					t.Errorf(""Succeeded. Error expected: %v"", err)
				} else if err.Error() != tt.authenticateErrMsg {
					t.Errorf(""Incorrect error message: want %s but got %s"",
						tt.authenticateErrMsg, err.Error())
				}
			} else if err != nil {
				t.Fatalf(""Unexpected Error: %v"", err)
			}
			if !reflect.DeepEqual(tt.caller, result) {
				t.Errorf(""Unexpected authentication result: want %v but got %v"",
					tt.caller, result)
			}
		})
	}
}
",CWE-863,154.0,0
"package authz
import (
	""testing""
	""time""
	// banktypes ""github.com/cosmos/cosmos-sdk/x/bank/types""
	""github.com/stretchr/testify/require""
)
func expecError(r *require.Assertions, expected string, received error) {
	if expected == """" {
		r.NoError(received)
	} else {
		r.Error(received)
		r.Contains(received.Error(), expected)
	}
}
func TestNewGrant(t *testing.T) {
	// ba := banktypes.NewSendAuthorization(sdk.NewCoins(sdk.NewInt64Coin(""foo"", 123)))
	a := NewGenericAuthorization(""some-type"")
	var tcs = []struct {
		title     string
		a         Authorization
		blockTime time.Time
		expire    time.Time
		err       string
	}{
		// {""wrong expire time (1)"", a, time.Unix(10, 0), time.Unix(8, 0), ""expiration must be after""},
		// {""wrong expire time (2)"", a, time.Unix(10, 0), time.Unix(10, 0), ""expiration must be after""},
		{""good expire time (1)"", a, time.Unix(10, 0), time.Unix(10, 1), """"},
		{""good expire time (2)"", a, time.Unix(10, 0), time.Unix(11, 0), """"},
	}
	for _, tc := range tcs {
		t.Run(tc.title, func(t *testing.T) {
			// _, err := NewGrant(tc.blockTime, tc.a, tc.expire)
			_, err := NewGrant(tc.a, tc.expire)
			expecError(require.New(t), tc.err, err)
		})
	}
}
",CWE-754,45.0,0
"package etm
import (
	""bytes""
	""crypto/cipher""
	""crypto/rand""
	""encoding/hex""
	""fmt""
	""io""
	""regexp""
	""testing""
)
var _ cipher.AEAD = &etmAEAD{}
var whitespace = regexp.MustCompile(`[\s]+`)
func decode(s string) []byte {
	b, err := hex.DecodeString(whitespace.ReplaceAllString(s, """"))
	if err != nil {
		panic(err)
	}
	return b
}
func TestOverhead(t *testing.T) {
	aead, err := NewAES256SHA512(make([]byte, 64))
	if err != nil {
		t.Fatal(err)
	}
	expected := 72
	actual := aead.Overhead()
	if actual != expected {
		t.Errorf(""Expected %v but was %v"", expected, actual)
	}
}
func TestNonceSize(t *testing.T) {
	aead, err := NewAES256SHA512(make([]byte, 64))
	if err != nil {
		t.Fatal(err)
	}
	expected := 16
	actual := aead.NonceSize()
	if actual != expected {
		t.Errorf(""Expected %v but was %v"", expected, actual)
	}
}
func TestBadKeySizes(t *testing.T) {
	aead, err := NewAES256SHA512(nil)
	if err == nil {
		t.Errorf(""No error for 256/512, got %v instead"", aead)
	}
}
func TestBadMessage(t *testing.T) {
	aead, err := NewAES256SHA512(make([]byte, 64))
	if err != nil {
		t.Fatal(err)
	}
	input := make([]byte, 100)
	output := aead.Seal(nil, make([]byte, aead.NonceSize()), input, nil)
	output[91] ^= 3
	b, err := aead.Open(nil, make([]byte, aead.NonceSize()), output, nil)
	if err == nil {
		t.Errorf(""Expected error but got %v"", b)
	}
}
func TestAEAD_AES_256_CBC_HMAC_SHA_512(t *testing.T) {
	aead, err := NewAES256SHA512(decode(`
20 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f
30 31 32 33 34 35 36 37 38 39 3a 3b 3c 3d 3e 3f
00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f
10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f
`))
	if err != nil {
		t.Fatal(err)
	}
	p := decode(`
41 20 63 69 70 68 65 72 20 73 79 73 74 65 6d 20
6d 75 73 74 20 6e 6f 74 20 62 65 20 72 65 71 75
69 72 65 64 20 74 6f 20 62 65 20 73 65 63 72 65
74 2c 20 61 6e 64 20 69 74 20 6d 75 73 74 20 62
65 20 61 62 6c 65 20 74 6f 20 66 61 6c 6c 20 69
6e 74 6f 20 74 68 65 20 68 61 6e 64 73 20 6f 66
20 74 68 65 20 65 6e 65 6d 79 20 77 69 74 68 6f
75 74 20 69 6e 63 6f 6e 76 65 6e 69 65 6e 63 65
`)
	iv := decode(`
1a f3 8c 2d c2 b9 6f fd d8 66 94 09 23 41 bc 04
`)
	a := decode(`
54 68 65 20 73 65 63 6f 6e 64 20 70 72 69 6e 63
69 70 6c 65 20 6f 66 20 41 75 67 75 73 74 65 20
4b 65 72 63 6b 68 6f 66 66 73
`)
	expected := decode(`
1a f3 8c 2d c2 b9 6f fd d8 66 94 09 23 41 bc 04
4a ff aa ad b7 8c 31 c5 da 4b 1b 59 0d 10 ff bd
3d d8 d5 d3 02 42 35 26 91 2d a0 37 ec bc c7 bd
82 2c 30 1d d6 7c 37 3b cc b5 84 ad 3e 92 79 c2
e6 d1 2a 13 74 b7 7f 07 75 53 df 82 94 10 44 6b
36 eb d9 70 66 29 6a e6 42 7e a7 5c 2e 08 46 a1
1a 09 cc f5 37 0d c8 0b fe cb ad 28 c7 3f 09 b3
a3 b7 5e 66 2a 25 94 41 0a e4 96 b2 e2 e6 60 9e
31 e6 e0 2c c8 37 f0 53 d2 1f 37 ff 4f 51 95 0b
be 26 38 d0 9d d7 a4 93 09 30 80 6d 07 03 b1 f6
4d d3 b4 c0 88 a7 f4 5c 21 68 39 64 5b 20 12 bf
2e 62 69 a8 c5 6a 81 6d bc 1b 26 77 61 95 5b c5
`)
	c := aead.Seal(nil, iv, p, a)
	if !bytes.Equal(expected, c) {
		t.Errorf(""Expected \n%x\n but was \n%x"", expected, c)
	}
	p2, err := aead.Open(nil, iv, c, a)
	if err != nil {
		t.Fatal(err)
	}
	if !bytes.Equal(p, p2) {
		t.Error(""Bad round-trip"")
	}
}
func Example() {
	key := []byte(""yellow submarine was a love song hunt for red october was a film"")
	plaintext := []byte(""this is a secret value"")
	data := []byte(""this is a public value"")
	aead, err := NewAES256SHA512(key)
	if err != nil {
		fmt.Println(err)
		return
	}
	nonce := make([]byte, aead.NonceSize())
	_, _ = io.ReadFull(rand.Reader, nonce)
	ciphertext := aead.Seal(nil, nonce, plaintext, data)
	secret, err := aead.Open(nil, nil, ciphertext, data)
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Println(string(secret))
	// Output:
	// this is a secret value
}
",CWE-327,163.0,0
"//
// Copyright (c) 2021 One Track Consulting
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package transforms
import (
	""crypto/rand""
	""encoding/base64""
	""encoding/hex""
	""fmt""
	""github.com/edgexfoundry/app-functions-sdk-go/v2/internal/etm""
	""github.com/edgexfoundry/app-functions-sdk-go/v2/pkg/interfaces""
	""github.com/edgexfoundry/app-functions-sdk-go/v2/pkg/util""
	""github.com/edgexfoundry/go-mod-core-contracts/v2/common""
)
type AESProtection struct {
	SecretPath    string
	SecretName    string
	EncryptionKey string
}
// NewAESProtection creates, initializes and returns a new instance of AESProtection configured
// to retrieve the encryption key from the Secret Store
func NewAESProtection(secretPath string, secretName string) AESProtection {
	return AESProtection{
		SecretPath: secretPath,
		SecretName: secretName,
	}
}
// Encrypt encrypts a string, []byte, or json.Marshaller type using AES 256 encryption.
// It also signs the data using a SHA512 hash.
// It will return a Base64 encode []byte of the encrypted data.
func (protection AESProtection) Encrypt(ctx interfaces.AppFunctionContext, data interface{}) (bool, interface{}) {
	if data == nil {
		return false, fmt.Errorf(""function Encrypt in pipeline '%s': No Data Received"", ctx.PipelineId())
	}
	ctx.LoggingClient().Debugf(""Encrypting with AES256 in pipeline '%s'"", ctx.PipelineId())
	byteData, err := util.CoerceType(data)
	if err != nil {
		return false, err
	}
	key, err := protection.getKey(ctx)
	if err != nil {
		return false, err
	}
	if len(key) == 0 {
		return false, fmt.Errorf(""AES256 encryption key not set in pipeline '%s'"", ctx.PipelineId())
	}
	aead, err := etm.NewAES256SHA512(key)
	if err != nil {
		return false, err
	}
	nonce := make([]byte, aead.NonceSize())
	_, err = rand.Read(nonce)
	if err != nil {
		return false, err
	}
	dst := make([]byte, 0)
	encrypted := aead.Seal(dst, nonce, byteData, nil)
	clearKey(key)
	encodedData := []byte(base64.StdEncoding.EncodeToString(encrypted))
	// Set response ""content-type"" header to ""text/plain""
	ctx.SetResponseContentType(common.ContentTypeText)
	return true, encodedData
}
func (protection *AESProtection) getKey(ctx interfaces.AppFunctionContext) ([]byte, error) {
	// If using Secret Store for the encryption key
	if len(protection.SecretPath) != 0 && len(protection.SecretName) != 0 {
		// Note secrets are cached so this call doesn't result in unneeded calls to SecretStore Service and
		// the cache is invalidated when StoreSecrets is used.
		secretData, err := ctx.GetSecret(protection.SecretPath, protection.SecretName)
		if err != nil {
			return nil, fmt.Errorf(
				""unable to retieve encryption key at secret path=%s and name=%s in pipeline '%s'"",
				protection.SecretPath,
				protection.SecretName,
				ctx.PipelineId())
		}
		key, ok := secretData[protection.SecretName]
		if !ok {
			return nil, fmt.Errorf(
				""unable find encryption key in secret data for name=%s in pipeline '%s'"",
				protection.SecretName,
				ctx.PipelineId())
		}
		ctx.LoggingClient().Debugf(
			""Using encryption key from Secret Store at path=%s & name=%s in pipeline '%s'"",
			protection.SecretPath,
			protection.SecretName,
			ctx.PipelineId())
		return hex.DecodeString(key)
	}
	return nil, fmt.Errorf(""No key configured"")
}
func clearKey(key []byte) {
	for i := range key {
		key[i] = 0
	}
}
",CWE-327,136.0,0
"//
// Copyright (c) 2021 One Track Consulting
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package transforms
import (
	""encoding/base64""
	""encoding/hex""
	""fmt""
	""github.com/edgexfoundry/app-functions-sdk-go/v2/internal/etm""
	""github.com/edgexfoundry/app-functions-sdk-go/v2/pkg/interfaces/mocks""
	""github.com/edgexfoundry/app-functions-sdk-go/v2/pkg/util""
	""github.com/edgexfoundry/go-mod-core-contracts/v2/clients/logger""
	""github.com/edgexfoundry/go-mod-core-contracts/v2/common""
	""github.com/google/uuid""
	""github.com/stretchr/testify/assert""
	""github.com/stretchr/testify/require""
	""testing""
)
func TestNewAESProtection(t *testing.T) {
	secretPath := uuid.NewString()
	secretName := uuid.NewString()
	sut := NewAESProtection(secretPath, secretName)
	assert.Equal(t, secretPath, sut.SecretPath)
	assert.Equal(t, secretName, sut.SecretName)
}
func TestAESProtection_clearKey(t *testing.T) {
	key := []byte(uuid.NewString())
	clearKey(key)
	for _, v := range key {
		assert.Equal(t, byte(0), v)
	}
}
func TestAESProtection_getKey(t *testing.T) {
	secretPath := uuid.NewString()
	secretName := uuid.NewString()
	pipelineId := uuid.NewString()
	key := ""217A24432646294A404E635266556A586E3272357538782F413F442A472D4B6150645367566B59703373367639792442264529482B4D6251655468576D5A7134""
	type fields struct {
		SecretPath    string
		SecretName    string
		EncryptionKey string
	}
	tests := []struct {
		name     string
		fields   fields
		ctxSetup func(ctx *mocks.AppFunctionContext)
		wantErr  bool
	}{
		{name: ""no key"", wantErr: true},
		{
			name:   ""secret error"",
			fields: fields{SecretPath: secretPath, SecretName: secretName},
			ctxSetup: func(ctx *mocks.AppFunctionContext) {
				ctx.On(""GetSecret"", secretPath, secretName).Return(nil, fmt.Errorf(""secret error""))
			},
			wantErr: true,
		},
		{
			name:   ""secret not in map"",
			fields: fields{SecretPath: secretPath, SecretName: secretName},
			ctxSetup: func(ctx *mocks.AppFunctionContext) {
				ctx.On(""GetSecret"", secretPath, secretName).Return(map[string]string{}, nil)
			},
			wantErr: true,
		},
		{
			name:   ""happy"",
			fields: fields{SecretPath: secretPath, SecretName: secretName},
			ctxSetup: func(ctx *mocks.AppFunctionContext) {
				ctx.On(""SetResponsesContentType"", common.ContentTypeText).Return()
				ctx.On(""GetSecret"", secretPath, secretName).Return(map[string]string{secretName: key}, nil)
			},
			wantErr: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			aesData := &AESProtection{
				SecretPath:    tt.fields.SecretPath,
				SecretName:    tt.fields.SecretName,
				EncryptionKey: tt.fields.EncryptionKey,
			}
			ctx := &mocks.AppFunctionContext{}
			ctx.On(""PipelineId"").Return(pipelineId)
			ctx.On(""LoggingClient"").Return(logger.NewMockClient())
			if tt.ctxSetup != nil {
				tt.ctxSetup(ctx)
			}
			if k, err := aesData.getKey(ctx); (err != nil) != tt.wantErr {
				t.Errorf(""getKey() error = %v, wantErr %v"", err, tt.wantErr)
				if !tt.wantErr {
					assert.Equal(t, key, k)
				}
			}
		})
	}
}
func TestAESProtection_Encrypt(t *testing.T) {
	secretPath := uuid.NewString()
	secretName := uuid.NewString()
	key := ""217A24432646294A404E635266556A586E3272357538782F413F442A472D4B6150645367566B59703373367639792442264529482B4D6251655468576D5A7134""
	ctx := &mocks.AppFunctionContext{}
	ctx.On(""SetResponseContentType"", common.ContentTypeText).Return()
	ctx.On(""PipelineId"").Return(""pipeline-id"")
	ctx.On(""LoggingClient"").Return(logger.NewMockClient())
	ctx.On(""GetSecret"", secretPath, secretName).Return(map[string]string{secretName: key}, nil)
	enc := NewAESProtection(secretPath, secretName)
	continuePipeline, encrypted := enc.Encrypt(ctx, []byte(plainString))
	assert.True(t, continuePipeline)
	ebytes, err := util.CoerceType(encrypted)
	require.NoError(t, err)
	//output is base64 encoded
	dbytes, err := base64.StdEncoding.DecodeString(string(ebytes))
	if err != nil {
		panic(err)
	}
	decrypted := aes256Decrypt(t, dbytes, key)
	assert.Equal(t, plainString, string(decrypted))
}
func aes256Decrypt(t *testing.T, dbytes []byte, key string) []byte {
	k, err := hex.DecodeString(key)
	if err != nil {
		panic(err)
	}
	//internally we are leaning heavily on ETM logic
	//do not want to re-implement here
	etm, err := etm.NewAES256SHA512(k)
	require.NoError(t, err)
	dst := make([]byte, 0)
	res, err := etm.Open(dst, nil, dbytes, nil)
	require.NoError(t, err)
	return res
}
",CWE-327,178.0,0
"// Copyright 2022 The Nakama Authors
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package server
import (
	""context""
	""sync""
	""time""
)
type LockoutType uint8
const (
	LockoutTypeNone LockoutType = iota
	LockoutTypeAccount
	LockoutTypeIp
)
const (
	maxAttemptsAccount   = 5
	lockoutPeriodAccount = time.Minute * 1
	maxAttemptsIp   = 10
	lockoutPeriodIp = time.Minute * 10
)
type LoginAttemptCache interface {
	Stop()
	// Allow checks whether account or IP is locked out or should be allowed to attempt to authenticate.
	Allow(account, ip string) bool
	// Add a failed attempt and return current lockout status.
	Add(account, ip string) (LockoutType, time.Time)
	// Reset account attempts on successful login.
	Reset(account string)
}
type lockoutStatus struct {
	lockedUntil time.Time
	attempts    []time.Time
}
func (ls *lockoutStatus) trim(now time.Time, retentionPeriod time.Duration) bool {
	if ls.lockedUntil.Before(now) {
		ls.lockedUntil = time.Time{}
	}
	for i := len(ls.attempts) - 1; i >= 0; i-- {
		if now.Sub(ls.attempts[i]) >= retentionPeriod {
			ls.attempts = ls.attempts[i+1:]
			break
		}
	}
	return ls.lockedUntil.IsZero() && len(ls.attempts) == 0
}
type LocalLoginAttemptCache struct {
	sync.RWMutex
	ctx         context.Context
	ctxCancelFn context.CancelFunc
	accountCache map[string]*lockoutStatus
	ipCache      map[string]*lockoutStatus
}
func NewLocalLoginAttemptCache() LoginAttemptCache {
	ctx, ctxCancelFn := context.WithCancel(context.Background())
	c := &LocalLoginAttemptCache{
		accountCache: make(map[string]*lockoutStatus),
		ipCache:      make(map[string]*lockoutStatus),
		ctx:         ctx,
		ctxCancelFn: ctxCancelFn,
	}
	go func() {
		ticker := time.NewTicker(10 * time.Minute)
		for {
			select {
			case <-c.ctx.Done():
				ticker.Stop()
				return
			case t := <-ticker.C:
				now := t.UTC()
				c.Lock()
				for account, status := range c.accountCache {
					if status.trim(now, lockoutPeriodAccount) {
						delete(c.accountCache, account)
					}
				}
				for ip, status := range c.ipCache {
					if status.trim(now, lockoutPeriodIp) {
						delete(c.ipCache, ip)
					}
				}
				c.Unlock()
			}
		}
	}()
	return c
}
func (c *LocalLoginAttemptCache) Stop() {
	c.ctxCancelFn()
}
func (c *LocalLoginAttemptCache) Allow(account, ip string) bool {
	now := time.Now().UTC()
	c.RLock()
	defer c.RUnlock()
	if status, found := c.accountCache[account]; found && !status.lockedUntil.IsZero() && status.lockedUntil.After(now) {
		return false
	}
	if status, found := c.ipCache[ip]; found && !status.lockedUntil.IsZero() && status.lockedUntil.After(now) {
		return false
	}
	return true
}
func (c *LocalLoginAttemptCache) Reset(account string) {
	c.Lock()
	delete(c.accountCache, account)
	c.Unlock()
}
func (c *LocalLoginAttemptCache) Add(account, ip string) (LockoutType, time.Time) {
	now := time.Now().UTC()
	var lockoutType LockoutType
	var lockedUntil time.Time
	c.Lock()
	defer c.Unlock()
	if account != """" {
		status, found := c.accountCache[account]
		if !found {
			status = &lockoutStatus{}
			c.accountCache[account] = status
		}
		status.attempts = append(status.attempts, now)
		_ = status.trim(now, lockoutPeriodAccount)
		if len(status.attempts) >= maxAttemptsAccount {
			status.lockedUntil = now.Add(lockoutPeriodAccount)
			lockedUntil = status.lockedUntil
			lockoutType = LockoutTypeAccount
		}
	}
	if ip != """" {
		status, found := c.ipCache[ip]
		if !found {
			status = &lockoutStatus{}
			c.ipCache[ip] = status
		}
		status.attempts = append(status.attempts, now)
		_ = status.trim(now, lockoutPeriodIp)
		if len(status.attempts) >= maxAttemptsIp {
			status.lockedUntil = now.Add(lockoutPeriodIp)
			lockedUntil = status.lockedUntil
			lockoutType = LockoutTypeIp
		}
	}
	return lockoutType, lockedUntil
}
",CWE-307,175.0,0
"/*
 * Copyright 2022 Snyk Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package server
import (
	""context""
	""fmt""
	""github.com/creachadair/jrpc2""
	""github.com/pkg/errors""
	""github.com/rs/zerolog/log""
	""github.com/snyk/snyk-ls/application/server/lsp""
	""github.com/snyk/snyk-ls/domain/ide/workspace""
)
const doTrust = ""Trust folders and continue""
const dontTrust = ""Don't trust folders""
func handleUntrustedFolders(ctx context.Context, srv *jrpc2.Server) {
	w := workspace.Get()
	// debounce requests from overzealous clients (Eclipse, I'm looking at you)
	if w.IsTrustRequestOngoing() {
		return
	}
	w.StartRequestTrustCommunication()
	defer w.EndRequestTrustCommunication()
	_, untrusted := w.GetFolderTrust()
	if len(untrusted) > 0 {
		decision, err := showTrustDialog(srv, untrusted, doTrust, dontTrust)
		if err != nil {
			return
		}
		if decision.Title == doTrust {
			w.TrustFoldersAndScan(ctx, untrusted)
		}
	}
}
func showTrustDialog(srv *jrpc2.Server, untrusted []*workspace.Folder, dontTrust string, doTrust string) (lsp.MessageActionItem, error) {
	method := ""showTrustDialog""
	result, err := srv.Callback(context.Background(), ""window/showMessageRequest"", lsp.ShowMessageRequestParams{
		Type:    lsp.Warning,
		Message: getTrustMessage(untrusted),
		Actions: []lsp.MessageActionItem{{Title: dontTrust}, {Title: doTrust}},
	})
	if err != nil {
		log.Err(errors.Wrap(err, ""couldn't show trust message"")).Str(""method"", method).Send()
		return lsp.MessageActionItem{Title: dontTrust}, err
	}
	var trust lsp.MessageActionItem
	if result != nil {
		err = result.UnmarshalResult(&trust)
		if err != nil {
			log.Err(errors.Wrap(err, ""couldn't unmarshal trust message"")).Str(""method"", method).Send()
			return lsp.MessageActionItem{Title: dontTrust}, err
		}
	}
	return trust, err
}
func getTrustMessage(untrusted []*workspace.Folder) string {
	var untrustedFolderString string
	for _, folder := range untrusted {
		untrustedFolderString += folder.Path() + ""\n""
	}
	return fmt.Sprintf(""When scanning for vulnerabilities, Snyk may automatically execute code such as invoking ""+
		""the package manager to get dependency information. You should only scan folders you trust.""+
		""\n\nUntrusted Folders: \n%s\n\n"", untrustedFolderString)
}
",CWE-78,89.0,0
"/*
 * Copyright 2022 Snyk Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package server
import (
	""context""
	""testing""
	""time""
	""github.com/creachadair/jrpc2""
	""github.com/stretchr/testify/assert""
	""github.com/snyk/snyk-ls/application/config""
	""github.com/snyk/snyk-ls/application/di""
	""github.com/snyk/snyk-ls/application/server/lsp""
	""github.com/snyk/snyk-ls/domain/ide/workspace""
	""github.com/snyk/snyk-ls/domain/snyk""
	""github.com/snyk/snyk-ls/internal/uri""
)
func Test_handleUntrustedFolders_shouldTriggerTrustRequestAndNotScan(t *testing.T) {
	loc := setupServer(t)
	w := workspace.Get()
	scanner := &snyk.TestScanner{}
	config.CurrentConfig().SetTrustedFolderFeatureEnabled(true)
	w.AddFolder(workspace.NewFolder(""dummy"", ""dummy"", scanner, di.HoverService()))
	handleUntrustedFolders(context.Background(), loc.Server)
	assert.True(t, checkTrustMessageRequest())
	assert.Equal(t, scanner.Calls(), 0)
}
func Test_handleUntrustedFolders_shouldNotTriggerTrustRequestWhenAlreadyRequesting(t *testing.T) {
	loc := setupServer(t)
	w := workspace.Get()
	scanner := &snyk.TestScanner{}
	config.CurrentConfig().SetTrustedFolderFeatureEnabled(true)
	w.AddFolder(workspace.NewFolder(""dummy"", ""dummy"", scanner, di.HoverService()))
	w.StartRequestTrustCommunication()
	handleUntrustedFolders(context.Background(), loc.Server)
	assert.Len(t, jsonRPCRecorder.FindCallbacksByMethod(""window/showMessageRequest""), 0)
	assert.Equal(t, scanner.Calls(), 0)
}
func Test_handleUntrustedFolders_shouldTriggerTrustRequestAndScanAfterConfirmation(t *testing.T) {
	loc := setupCustomServer(t, func(_ context.Context, _ *jrpc2.Request) (interface{}, error) {
		return lsp.MessageActionItem{
			Title: doTrust,
		}, nil
	})
	registerNotifier(loc.Server)
	w := workspace.Get()
	scanner := &snyk.TestScanner{}
	config.CurrentConfig().SetTrustedFolderFeatureEnabled(true)
	w.AddFolder(workspace.NewFolder(""/trusted/dummy"", ""dummy"", scanner, di.HoverService()))
	handleUntrustedFolders(context.Background(), loc.Server)
	assert.Eventually(t, func() bool {
		addTrustedSent := len(jsonRPCRecorder.FindNotificationsByMethod(""$/snyk.addTrustedFolders"")) == 1
		return scanner.Calls() == 1 && addTrustedSent
	}, time.Second, time.Millisecond)
}
func Test_handleUntrustedFolders_shouldTriggerTrustRequestAndNotScanAfterNegativeConfirmation(t *testing.T) {
	loc := setupCustomServer(t, func(_ context.Context, _ *jrpc2.Request) (interface{}, error) {
		return lsp.MessageActionItem{
			Title: dontTrust,
		}, nil
	})
	registerNotifier(loc.Server)
	w := workspace.Get()
	scanner := &snyk.TestScanner{}
	w.AddFolder(workspace.NewFolder(""/trusted/dummy"", ""dummy"", scanner, di.HoverService()))
	config.CurrentConfig().SetTrustedFolderFeatureEnabled(true)
	handleUntrustedFolders(context.Background(), loc.Server)
	assert.Equal(t, scanner.Calls(), 0)
}
func Test_initializeHandler_shouldCallHandleUntrustedFolders(t *testing.T) {
	loc := setupServer(t)
	config.CurrentConfig().SetTrustedFolderFeatureEnabled(true)
	_, err := loc.Client.Call(context.Background(), ""initialize"", lsp.InitializeParams{
		RootURI: uri.PathToUri(""/untrusted/dummy""),
	})
	if err != nil {
		t.Fatal(err, ""couldn't send initialized"")
	}
	_, err = loc.Client.Call(ctx, ""initialized"", nil)
	if err != nil {
		t.Fatal(err, ""couldn't send initialized"")
	}
	assert.NoError(t, err)
	assert.Eventually(t, func() bool { return checkTrustMessageRequest() }, time.Second, time.Millisecond)
}
func Test_DidWorkspaceFolderChange_shouldCallHandleUntrustedFolders(t *testing.T) {
	loc := setupServer(t)
	config.CurrentConfig().SetTrustedFolderFeatureEnabled(true)
	_, err := loc.Client.Call(context.Background(), ""workspace/didChangeWorkspaceFolders"", lsp.DidChangeWorkspaceFoldersParams{
		Event: lsp.WorkspaceFoldersChangeEvent{
			Added: []lsp.WorkspaceFolder{
				{Uri: uri.PathToUri(""/untrusted/dummy""), Name: ""dummy""},
			},
			Removed: []lsp.WorkspaceFolder{},
		},
	})
	assert.NoError(t, err)
	assert.Eventually(t, func() bool { return checkTrustMessageRequest() }, time.Second, time.Millisecond)
}
func checkTrustMessageRequest() bool {
	callbacks := jsonRPCRecorder.FindCallbacksByMethod(""window/showMessageRequest"")
	if len(callbacks) == 0 {
		return false
	}
	var params lsp.ShowMessageRequestParams
	_ = callbacks[0].UnmarshalParams(&params)
	_, untrusted := workspace.Get().GetFolderTrust()
	return params.Type == lsp.Warning && params.Message == getTrustMessage(untrusted)
}
",CWE-78,146.0,0
"/*
 * Copyright 2022 Snyk Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package workspace
import (
	""context""
	""testing""
	""time""
	""github.com/stretchr/testify/assert""
	""github.com/snyk/snyk-ls/application/config""
	""github.com/snyk/snyk-ls/application/server/lsp""
	""github.com/snyk/snyk-ls/domain/observability/performance""
	""github.com/snyk/snyk-ls/domain/snyk""
	""github.com/snyk/snyk-ls/internal/testutil""
	""github.com/snyk/snyk-ls/internal/uri""
)
func Test_GetFolderTrust_shouldReturnTrustedAndUntrustedFolders(t *testing.T) {
	testutil.UnitTest(t)
	const trustedDummy = ""trustedDummy""
	const untrustedDummy = ""untrustedDummy""
	scanner := &snyk.TestScanner{}
	w := New(performance.NewTestInstrumentor(), scanner, nil)
	config.CurrentConfig().SetTrustedFolderFeatureEnabled(true)
	config.CurrentConfig().SetTrustedFolders([]string{trustedDummy})
	w.AddFolder(NewFolder(trustedDummy, trustedDummy, scanner, nil))
	w.AddFolder(NewFolder(untrustedDummy, untrustedDummy, scanner, nil))
	trusted, untrusted := w.GetFolderTrust()
	assert.Equal(t, trustedDummy, trusted[0].path)
	assert.Equal(t, untrustedDummy, untrusted[0].path)
}
func Test_TrustFoldersAndScan_shouldAddFoldersToTrustedFoldersAndTriggerScan(t *testing.T) {
	testutil.UnitTest(t)
	const trustedDummy = ""trustedDummy""
	const untrustedDummy = ""untrustedDummy""
	scanner := &snyk.TestScanner{}
	w := New(performance.NewTestInstrumentor(), scanner, nil)
	config.CurrentConfig().SetTrustedFolderFeatureEnabled(true)
	trustedFolder := NewFolder(trustedDummy, trustedDummy, scanner, nil)
	w.AddFolder(trustedFolder)
	untrustedFolder := NewFolder(untrustedDummy, untrustedDummy, scanner, nil)
	w.AddFolder(untrustedFolder)
	w.TrustFoldersAndScan(context.Background(), []*Folder{trustedFolder})
	assert.Contains(t, config.CurrentConfig().TrustedFolders(), trustedFolder.path)
	assert.NotContains(t, config.CurrentConfig().TrustedFolders(), untrustedFolder.path)
	assert.Eventually(t, func() bool {
		return scanner.Calls() == 1
	}, time.Second, time.Millisecond, ""scanner should be called after trust is granted"")
}
func Test_AddAndRemoveFoldersAndTriggerScan(t *testing.T) {
	testutil.UnitTest(t)
	const trustedDummy = ""trustedDummy""
	const untrustedDummy = ""untrustedDummy""
	const toBeRemoved = ""toBeRemoved""
	trustedPathAfterConversions := uri.PathFromUri(uri.PathToUri(trustedDummy))
	toBeRemovedAbsolutePathAfterConversions := uri.PathFromUri(uri.PathToUri(toBeRemoved))
	scanner := &snyk.TestScanner{}
	w := New(performance.NewTestInstrumentor(), scanner, nil)
	toBeRemovedFolder := NewFolder(toBeRemovedAbsolutePathAfterConversions, toBeRemoved, scanner, nil)
	w.AddFolder(toBeRemovedFolder)
	config.CurrentConfig().SetTrustedFolderFeatureEnabled(true)
	config.CurrentConfig().SetTrustedFolders([]string{trustedPathAfterConversions})
	params := lsp.DidChangeWorkspaceFoldersParams{Event: lsp.WorkspaceFoldersChangeEvent{
		Added: []lsp.WorkspaceFolder{
			{Name: trustedDummy, Uri: uri.PathToUri(trustedDummy)},
			{Name: untrustedDummy, Uri: uri.PathToUri(untrustedDummy)},
		},
		Removed: []lsp.WorkspaceFolder{
			{Name: toBeRemoved, Uri: uri.PathToUri(toBeRemoved)},
		},
	}}
	w.AddAndRemoveFoldersAndTriggerScan(context.Background(), params)
	assert.Nil(t, w.GetFolderContaining(toBeRemoved))
	// one call for one trusted folder
	assert.Eventually(t, func() bool {
		return scanner.Calls() == 1
	}, time.Second, time.Millisecond, ""scanner should be called after trust is granted"")
}
func Test_Get(t *testing.T) {
	New(nil, nil, nil)
	assert.Equal(t, instance, Get())
}
func Test_Set(t *testing.T) {
	w := New(nil, nil, nil)
	Set(w)
	assert.Equal(t, w, instance)
}
",CWE-78,118.0,0
"/*
 * Copyright 2022 Snyk Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package workspace
func (w *Workspace) StartRequestTrustCommunication() {
	w.trustMutex.Lock()
	w.trustRequestOngoing = true
	w.trustMutex.Unlock()
}
func (w *Workspace) EndRequestTrustCommunication() {
	w.trustMutex.Lock()
	w.trustRequestOngoing = false
	w.trustMutex.Unlock()
}
func (w *Workspace) IsTrustRequestOngoing() bool {
	w.trustMutex.Lock()
	defer w.trustMutex.Unlock()
	return w.trustRequestOngoing
}
",CWE-78,36.0,0
"/*
 * Copyright 2022 Snyk Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package workspace
import (
	""testing""
	""github.com/stretchr/testify/assert""
	""github.com/snyk/snyk-ls/internal/testutil""
)
func TestWorkspace_TrustRequests(t *testing.T) {
	testutil.UnitTest(t)
	w := New(nil, nil, nil)
	w.StartRequestTrustCommunication()
	w.IsTrustRequestOngoing()
	assert.True(t, w.IsTrustRequestOngoing())
	w.EndRequestTrustCommunication()
	assert.False(t, w.IsTrustRequestOngoing())
}
",CWE-78,36.0,0
"package s3crypto
import (
	""strings""
	""github.com/aws/aws-sdk-go/aws""
	""github.com/aws/aws-sdk-go/aws/client""
	""github.com/aws/aws-sdk-go/aws/request""
	""github.com/aws/aws-sdk-go/service/kms""
	""github.com/aws/aws-sdk-go/service/s3""
	""github.com/aws/aws-sdk-go/service/s3/s3iface""
)
// DecryptionClientV2 is an S3 crypto client. The decryption client
// will handle all get object requests from Amazon S3.
// Supported key wrapping algorithms:
//	* AWS KMS
//	* AWS KMS + Context
//
// Supported content ciphers:
//	* AES/GCM
//	* AES/CBC
type DecryptionClientV2 struct {
	options DecryptionClientOptions
}
// DecryptionClientOptions is the configuration options for DecryptionClientV2.
type DecryptionClientOptions struct {
	S3Client s3iface.S3API
	// LoadStrategy is used to load the metadata either from the metadata of the object
	// or from a separate file in s3.
	//
	// Defaults to our default load strategy.
	LoadStrategy LoadStrategy
	WrapRegistry   map[string]WrapEntry
	CEKRegistry    map[string]CEKEntry
	PadderRegistry map[string]Padder
}
// NewDecryptionClientV2 instantiates a new V2 S3 crypto client. The returned DecryptionClientV2 will be able to decrypt
// object encrypted by both the V1 and V2 clients.
//
// Example:
//	sess := session.Must(session.NewSession())
//	svc := s3crypto.NewDecryptionClientV2(sess, func(svc *s3crypto.DecryptionClientOptions{
//		// Custom client options here
//	}))
func NewDecryptionClientV2(prov client.ConfigProvider, options ...func(clientOptions *DecryptionClientOptions)) *DecryptionClientV2 {
	s3client := s3.New(prov)
	s3client.Handlers.Build.PushBack(func(r *request.Request) {
		request.AddToUserAgent(r, ""S3CryptoV2"")
	})
	kmsClient := kms.New(prov)
	clientOptions := &DecryptionClientOptions{
		S3Client: s3client,
		LoadStrategy: defaultV2LoadStrategy{
			client: s3client,
		},
		WrapRegistry: map[string]WrapEntry{
			KMSWrap:        NewKMSWrapEntry(kmsClient),
			KMSContextWrap: NewKMSContextWrapEntry(kmsClient),
		},
		CEKRegistry: map[string]CEKEntry{
			AESGCMNoPadding: newAESGCMContentCipher,
			strings.Join([]string{AESCBC, AESCBCPadder.Name()}, ""/""): newAESCBCContentCipher,
		},
		PadderRegistry: map[string]Padder{
			strings.Join([]string{AESCBC, AESCBCPadder.Name()}, ""/""): AESCBCPadder,
			""NoPadding"": NoPadder,
		},
	}
	for _, option := range options {
		option(clientOptions)
	}
	return &DecryptionClientV2{options: *clientOptions}
}
// GetObjectRequest will make a request to s3 and retrieve the object. In this process
// decryption will be done. The SDK only supports V2 reads of KMS and GCM.
//
// Example:
//  sess := session.Must(session.NewSession())
//	svc := s3crypto.NewDecryptionClientV2(sess)
//	req, out := svc.GetObjectRequest(&s3.GetObjectInput {
//	  Key: aws.String(""testKey""),
//	  Bucket: aws.String(""testBucket""),
//	})
//	err := req.Send()
func (c *DecryptionClientV2) GetObjectRequest(input *s3.GetObjectInput) (*request.Request, *s3.GetObjectOutput) {
	return getObjectRequest(c.options, input)
}
// GetObject is a wrapper for GetObjectRequest
func (c *DecryptionClientV2) GetObject(input *s3.GetObjectInput) (*s3.GetObjectOutput, error) {
	req, out := getObjectRequest(c.options, input)
	return out, req.Send()
}
// GetObjectWithContext is a wrapper for GetObjectRequest with the additional
// context, and request options support.
//
// GetObjectWithContext is the same as GetObject with the additional support for
// Context input parameters. The Context must not be nil. A nil Context will
// cause a panic. Use the Context to add deadlining, timeouts, etc. In the future
// this may create sub-contexts for individual underlying requests.
func (c *DecryptionClientV2) GetObjectWithContext(ctx aws.Context, input *s3.GetObjectInput, opts ...request.Option) (*s3.GetObjectOutput, error) {
	req, out := getObjectRequest(c.options, input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}
",CWE-326,116.0,0
"package s3crypto_test
import (
	""testing""
	""github.com/aws/aws-sdk-go/awstesting/unit""
	""github.com/aws/aws-sdk-go/service/kms""
	""github.com/aws/aws-sdk-go/service/s3/s3crypto""
)
func TestDecryptionClientV2_CheckDeprecatedFeatures(t *testing.T) {
	// AES/GCM/NoPadding with kms+context => allowed
	builder := s3crypto.AESGCMContentCipherBuilder(s3crypto.NewKMSContextKeyGenerator(kms.New(unit.Session), ""cmkID""))
	_, err := s3crypto.NewEncryptionClientV2(unit.Session, builder)
	if err != nil {
		t.Errorf(""expected no error, got %v"", err)
	}
	// AES/GCM/NoPadding with kms => not allowed
	builder = s3crypto.AESGCMContentCipherBuilder(s3crypto.NewKMSKeyGenerator(kms.New(unit.Session), ""cmkID""))
	_, err = s3crypto.NewEncryptionClientV2(unit.Session, builder)
	if err == nil {
		t.Error(""expected error, but got nil"")
	}
	// AES/CBC/PKCS5Padding with kms => not allowed
	builder = s3crypto.AESCBCContentCipherBuilder(s3crypto.NewKMSKeyGenerator(kms.New(unit.Session), ""cmkID""), s3crypto.NewPKCS7Padder(128))
	_, err = s3crypto.NewEncryptionClientV2(unit.Session, builder)
	if err == nil {
		t.Error(""expected error, but got nil"")
	}
	// AES/CBC/PKCS5Padding with kms+context => not allowed
	builder = s3crypto.AESCBCContentCipherBuilder(s3crypto.NewKMSContextKeyGenerator(kms.New(unit.Session), ""cmkID""), s3crypto.NewPKCS7Padder(128))
	_, err = s3crypto.NewEncryptionClientV2(unit.Session, builder)
	if err == nil {
		t.Error(""expected error, but got nil"")
	}
}
",CWE-326,40.0,0
"package s3crypto
import (
	""testing""
	""github.com/aws/aws-sdk-go/service/kms/kmsiface""
)
type mockKMS struct {
	kmsiface.KMSAPI
}
func TestAESGCMContentCipherBuilder_isUsingDeprecatedFeatures(t *testing.T) {
	builder := AESGCMContentCipherBuilder(NewKMSKeyGenerator(mockKMS{}, ""cmkID""))
	features, ok := builder.(deprecatedFeatures)
	if !ok {
		t.Errorf(""expected to implement deprecatedFeatures interface"")
	}
	err := features.isUsingDeprecatedFeatures()
	if err == nil {
		t.Errorf(""expected to recieve error for using deprecated features"")
	}
	builder = AESGCMContentCipherBuilder(NewKMSContextKeyGenerator(mockKMS{}, ""cmkID""))
	features, ok = builder.(deprecatedFeatures)
	if !ok {
		t.Errorf(""expected to implement deprecatedFeatures interface"")
	}
	err = features.isUsingDeprecatedFeatures()
	if err != nil {
		t.Errorf(""expected no error, got %v"", err)
	}
}
func TestAESCBCContentCipherBuilder_isUsingDeprecatedFeatures(t *testing.T) {
	builder := AESCBCContentCipherBuilder(nil, nil)
	features, ok := builder.(deprecatedFeatures)
	if !ok {
		t.Errorf(""expected to implement deprecatedFeatures interface"")
	}
	err := features.isUsingDeprecatedFeatures()
	if err == nil {
		t.Errorf(""expected to recieve error for using deprecated features"")
	}
}
",CWE-326,52.0,0
"package s3crypto
import (
	""github.com/aws/aws-sdk-go/aws""
	""github.com/aws/aws-sdk-go/aws/client""
	""github.com/aws/aws-sdk-go/aws/request""
	""github.com/aws/aws-sdk-go/service/s3""
	""github.com/aws/aws-sdk-go/service/s3/s3iface""
)
// EncryptionClientV2 is an S3 crypto client. By default the SDK will use Authentication mode which
// will use KMS for key wrapping and AES GCM for content encryption.
// AES GCM will load all data into memory. However, the rest of the content algorithms
// do not load the entire contents into memory.
type EncryptionClientV2 struct {
	options EncryptionClientOptions
}
// EncryptionClientOptions is the configuration options for EncryptionClientV2
type EncryptionClientOptions struct {
	S3Client             s3iface.S3API
	ContentCipherBuilder ContentCipherBuilder
	// SaveStrategy will dictate where the envelope is saved.
	//
	// Defaults to the object's metadata
	SaveStrategy SaveStrategy
	// TempFolderPath is used to store temp files when calling PutObject.
	// Temporary files are needed to compute the X-Amz-Content-Sha256 header.
	TempFolderPath string
	// MinFileSize is the minimum size for the content to write to a
	// temporary file instead of using memory.
	MinFileSize int64
}
// NewEncryptionClientV2 instantiates a new S3 crypto client. An error will be returned to the caller if the provided
// contentCipherBuilder has been deprecated, or if it uses other deprecated components.
//
// Example:
//	cmkID := ""arn:aws:kms:region:000000000000:key/00000000-0000-0000-0000-000000000000""
//  sess := session.Must(session.NewSession())
//	handler := s3crypto.NewKMSContextKeyGenerator(kms.New(sess), cmkID)
//	svc := s3crypto.NewEncryptionClientV2(sess, s3crypto.AESGCMContentCipherBuilder(handler))
func NewEncryptionClientV2(prov client.ConfigProvider, contentCipherBuilder ContentCipherBuilder, options ...func(clientOptions *EncryptionClientOptions),
) (
	client *EncryptionClientV2, err error,
) {
	s3client := s3.New(prov)
	s3client.Handlers.Build.PushBack(func(r *request.Request) {
		request.AddToUserAgent(r, ""S3CryptoV2"")
	})
	clientOptions := &EncryptionClientOptions{
		S3Client:             s3client,
		ContentCipherBuilder: contentCipherBuilder,
		SaveStrategy:         HeaderV2SaveStrategy{},
		MinFileSize:          DefaultMinFileSize,
	}
	for _, option := range options {
		option(clientOptions)
	}
	if feature, ok := contentCipherBuilder.(deprecatedFeatures); ok {
		if err := feature.isUsingDeprecatedFeatures(); err != nil {
			return nil, err
		}
	}
	client = &EncryptionClientV2{
		*clientOptions,
	}
	return client, err
}
// PutObjectRequest creates a temp file to encrypt the contents into. It then streams
// that data to S3.
//
// Example:
//  sess := session.Must(session.NewSession())
//	handler := s3crypto.NewKMSContextKeyGenerator(kms.New(sess), ""cmkID"")
//	svc := s3crypto.NewEncryptionClientV2(sess, s3crypto.AESGCMContentCipherBuilder(handler))
//	req, out := svc.PutObjectRequest(&s3.PutObjectInput {
//	  Key: aws.String(""testKey""),
//	  Bucket: aws.String(""testBucket""),
//	  Body: strings.NewReader(""test data""),
//	})
//	err := req.Send()
func (c *EncryptionClientV2) PutObjectRequest(input *s3.PutObjectInput) (*request.Request, *s3.PutObjectOutput) {
	return putObjectRequest(c.options, input)
}
// PutObject is a wrapper for PutObjectRequest
func (c *EncryptionClientV2) PutObject(input *s3.PutObjectInput) (*s3.PutObjectOutput, error) {
	return putObject(c.options, input)
}
// PutObjectWithContext is a wrapper for PutObjectRequest with the additional
// context, and request options support.
//
// PutObjectWithContext is the same as PutObject with the additional support for
// Context input parameters. The Context must not be nil. A nil Context will
// cause a panic. Use the Context to add deadlining, timeouts, etc. In the future
// this may create sub-contexts for individual underlying requests.
func (c *EncryptionClientV2) PutObjectWithContext(ctx aws.Context, input *s3.PutObjectInput, opts ...request.Option) (*s3.PutObjectOutput, error) {
	return putObjectWithContext(c.options, ctx, input, opts...)
}
",CWE-326,109.0,0
"// +build integration,go1.14
package integration
import (
	""bytes""
	""crypto/rand""
	""flag""
	""io""
	""io/ioutil""
	""log""
	""os""
	""testing""
	""github.com/aws/aws-sdk-go/aws""
	""github.com/aws/aws-sdk-go/aws/session""
	""github.com/aws/aws-sdk-go/awstesting/integration""
	""github.com/aws/aws-sdk-go/service/kms""
	""github.com/aws/aws-sdk-go/service/kms/kmsiface""
	""github.com/aws/aws-sdk-go/service/s3""
	""github.com/aws/aws-sdk-go/service/s3/s3crypto""
	""github.com/aws/aws-sdk-go/service/s3/s3iface""
)
var config = &struct {
	Enabled  bool
	Region   string
	KMSKeyID string
	Bucket   string
	Session  *session.Session
	Clients  struct {
		KMS kmsiface.KMSAPI
		S3  s3iface.S3API
	}
}{}
func init() {
	flag.BoolVar(&config.Enabled, ""enable"", false, ""enable integration testing"")
	flag.StringVar(&config.Region, ""region"", ""us-west-2"", ""integration test region"")
	flag.StringVar(&config.KMSKeyID, ""kms-key-id"", """", ""KMS CMK Key ID"")
	flag.StringVar(&config.Bucket, ""bucket"", """", ""S3 Bucket Name"")
}
func TestMain(m *testing.M) {
	flag.Parse()
	if !config.Enabled {
		log.Println(""skipping s3crypto integration tests"")
		os.Exit(0)
	}
	if len(config.Bucket) == 0 {
		log.Fatal(""bucket name must be provided"")
	}
	if len(config.KMSKeyID) == 0 {
		log.Fatal(""kms cmk key id must be provided"")
	}
	config.Session = session.Must(session.NewSession(&aws.Config{Region: &config.Region}))
	config.Clients.KMS = kms.New(config.Session)
	config.Clients.S3 = s3.New(config.Session)
	m.Run()
}
func TestEncryptionV1_WithV2Interop(t *testing.T) {
	kmsKeyGenerator := s3crypto.NewKMSKeyGenerator(config.Clients.KMS, config.KMSKeyID)
	// 1020 is chosen here as it is not cleanly divisible by the AES-256 block size
	testData := make([]byte, 1020)
	_, err := rand.Read(testData)
	if err != nil {
		t.Fatalf(""failed to read random data: %v"", err)
	}
	v1DC := s3crypto.NewDecryptionClient(config.Session, func(client *s3crypto.DecryptionClient) {
		client.S3Client = config.Clients.S3
	})
	v2DC := s3crypto.NewDecryptionClientV2(config.Session, func(options *s3crypto.DecryptionClientOptions) {
		options.S3Client = config.Clients.S3
	})
	cases := map[string]s3crypto.ContentCipherBuilder{
		""AES/GCM/NoPadding"":    s3crypto.AESGCMContentCipherBuilder(kmsKeyGenerator),
		""AES/CBC/PKCS5Padding"": s3crypto.AESCBCContentCipherBuilder(kmsKeyGenerator, s3crypto.AESCBCPadder),
	}
	for name, ccb := range cases {
		t.Run(name, func(t *testing.T) {
			ec := s3crypto.NewEncryptionClient(config.Session, ccb, func(client *s3crypto.EncryptionClient) {
				client.S3Client = config.Clients.S3
			})
			id := integration.UniqueID()
			// PutObject with V1 Client
			putObject(t, ec, id, bytes.NewReader(testData))
			// Verify V1 Decryption Client
			getObjectAndCompare(t, v1DC, id, testData)
			// Verify V2 Decryption Client
			getObjectAndCompare(t, v2DC, id, testData)
		})
	}
}
func TestEncryptionV2(t *testing.T) {
	kmsKeyGenerator := s3crypto.NewKMSContextKeyGenerator(config.Clients.KMS, config.KMSKeyID)
	gcmContentCipherBuilder := s3crypto.AESGCMContentCipherBuilder(kmsKeyGenerator)
	ec, err := s3crypto.NewEncryptionClientV2(config.Session, gcmContentCipherBuilder, func(options *s3crypto.EncryptionClientOptions) {
		options.S3Client = config.Clients.S3
	})
	if err != nil {
		t.Fatalf(""failed to construct encryption client: %v"", err)
	}
	dc := s3crypto.NewDecryptionClientV2(config.Session, func(options *s3crypto.DecryptionClientOptions) {
		options.S3Client = config.Clients.S3
	})
	// 1020 is chosen here as it is not cleanly divisible by the AES-256 block size
	testData := make([]byte, 1020)
	_, err = rand.Read(testData)
	if err != nil {
		t.Fatalf(""failed to read random data: %v"", err)
	}
	keyId := integration.UniqueID()
	// Upload V2 Objects with Encryption Client
	putObject(t, ec, keyId, bytes.NewReader(testData))
	// Verify V2 Object with Decryption Client
	getObjectAndCompare(t, dc, keyId, testData)
}
type Encryptor interface {
	PutObject(input *s3.PutObjectInput) (*s3.PutObjectOutput, error)
}
func putObject(t *testing.T, client Encryptor, key string, reader io.ReadSeeker) {
	t.Helper()
	_, err := client.PutObject(&s3.PutObjectInput{
		Bucket: &config.Bucket,
		Key:    &key,
		Body:   reader,
	})
	if err != nil {
		t.Fatalf(""failed to upload object: %v"", err)
	}
	t.Cleanup(doKeyCleanup(key))
}
type Decryptor interface {
	GetObject(input *s3.GetObjectInput) (*s3.GetObjectOutput, error)
}
func getObjectAndCompare(t *testing.T, client Decryptor, key string, expected []byte) {
	t.Helper()
	output, err := client.GetObject(&s3.GetObjectInput{
		Bucket: &config.Bucket,
		Key:    &key,
	})
	if err != nil {
		t.Fatalf(""failed to get object: %v"", err)
	}
	actual, err := ioutil.ReadAll(output.Body)
	if err != nil {
		t.Fatalf(""failed to read body response: %v"", err)
	}
	if bytes.Compare(expected, actual) != 0 {
		t.Errorf(""expected bytes did not match actual"")
	}
}
func doKeyCleanup(key string) func() {
	return func() {
		_, err := config.Clients.S3.DeleteObject(&s3.DeleteObjectInput{
			Bucket: &config.Bucket,
			Key:    &key,
		})
		if err != nil {
			log.Printf(""failed to delete %s: %v"", key, err)
		}
	}
}
",CWE-326,188.0,0
"package s3crypto_test
import (
	""bytes""
	""fmt""
	""io/ioutil""
	""github.com/aws/aws-sdk-go/aws""
	""github.com/aws/aws-sdk-go/aws/session""
	""github.com/aws/aws-sdk-go/service/kms""
	""github.com/aws/aws-sdk-go/service/s3""
	""github.com/aws/aws-sdk-go/service/s3/s3crypto""
)
// ExampleNewEncryptionClientV2_migration00 provides a migration example for how users can migrate from the V1
// encryption client to the V2 encryption client. This example demonstrates how an application using  the `kms` key wrap
// algorithm with `AES/CBC/PKCS5Padding` can migrate their application to `kms+context` key wrapping with
// `AES/GCM/NoPadding` content encryption.
func ExampleNewEncryptionClientV2_migration00() {
	sess := session.Must(session.NewSession())
	kmsClient := kms.New(sess)
	cmkID := ""1234abcd-12ab-34cd-56ef-1234567890ab""
	// Usage of NewKMSKeyGenerator (kms) key wrapping algorithm must be migrated to NewKMSContextKeyGenerator (kms+context) key wrapping algorithm
	//
	// cipherDataGenerator := s3crypto.NewKMSKeyGenerator(kmsClient, cmkID)
	cipherDataGenerator := s3crypto.NewKMSContextKeyGenerator(kmsClient, cmkID)
	// Usage of AESCBCContentCipherBuilder (AES/CBC/PKCS5Padding) must be migrated to AESGCMContentCipherBuilder (AES/GCM/NoPadding)
	//
	// contentCipherBuilder := s3crypto.AESCBCContentCipherBuilder(cipherDataGenerator, s3crypto.AESCBCPadder)
	contentCipherBuilder := s3crypto.AESGCMContentCipherBuilder(cipherDataGenerator)
	// Construction of an encryption client should be done using NewEncryptionClientV2
	//
	// encryptionClient := s3crypto.NewEncryptionClient(sess, contentCipherBuilder)
	encryptionClient, err := s3crypto.NewEncryptionClientV2(sess, contentCipherBuilder)
	if err != nil {
		fmt.Printf(""failed to construct encryption client: %v"", err)
		return
	}
	_, err = encryptionClient.PutObject(&s3.PutObjectInput{
		Bucket: aws.String(""your_bucket""),
		Key:    aws.String(""your_key""),
		Body:   bytes.NewReader([]byte(""your content"")),
	})
	if err != nil {
		fmt.Printf(""put object error: %v\n"", err)
		return
	}
	fmt.Println(""put object completed"")
}
// ExampleNewEncryptionClientV2_migration01 provides a more advanced migration example for how users can
// migrate from the V1 encryption client to the V2 encryption client using more complex client construction.
func ExampleNewEncryptionClientV2_migration01() {
	sess := session.Must(session.NewSession())
	kmsClient := kms.New(sess)
	cmkID := ""1234abcd-12ab-34cd-56ef-1234567890ab""
	cipherDataGenerator := s3crypto.NewKMSContextKeyGenerator(kmsClient, cmkID)
	contentCipherBuilder := s3crypto.AESGCMContentCipherBuilder(cipherDataGenerator)
	// Overriding of the encryption client options is possible by passing in functional arguments that override the
	// provided EncryptionClientOptions.
	//
	// encryptionClient := s3crypto.NewEncryptionClient(cipherDataGenerator, contentCipherBuilder, func(o *s3crypto.EncryptionClient) {
	//	 o.S3Client = s3.New(sess, &aws.Config{Region: aws.String(""us-west-2"")}),
	// })
	encryptionClient, err := s3crypto.NewEncryptionClientV2(sess, contentCipherBuilder, func(o *s3crypto.EncryptionClientOptions) {
		o.S3Client = s3.New(sess, &aws.Config{Region: aws.String(""us-west-2"")})
	})
	if err != nil {
		fmt.Printf(""failed to construct encryption client: %v"", err)
		return
	}
	_, err = encryptionClient.PutObject(&s3.PutObjectInput{
		Bucket: aws.String(""your_bucket""),
		Key:    aws.String(""your_key""),
		Body:   bytes.NewReader([]byte(""your content"")),
	})
	if err != nil {
		fmt.Printf(""put object error: %v\n"", err)
		return
	}
	fmt.Println(""put object completed"")
}
// ExampleNewDecryptionClientV2_migration00 provides a migration example for how users can migrate
// from the V1 Decryption Clients to the V2 Decryption Clients.
func ExampleNewDecryptionClientV2_migration00() {
	sess := session.Must(session.NewSession())
	// Construction of an decryption client must be done using NewDecryptionClientV2
	// The V2 decryption client is able to decrypt object encrypted by the V1 client.
	//
	// decryptionClient := s3crypto.NewDecryptionClient(sess)
	decryptionClient := s3crypto.NewDecryptionClientV2(sess)
	getObject, err := decryptionClient.GetObject(&s3.GetObjectInput{
		Bucket: aws.String(""your_bucket""),
		Key:    aws.String(""your_key""),
	})
	if err != nil {
		fmt.Printf(""get object error: %v\n"", err)
		return
	}
	_, err = ioutil.ReadAll(getObject.Body)
	if err != nil {
		fmt.Printf(""error reading object: %v\n"", err)
	}
	fmt.Println(""get object completed"")
}
// ExampleNewDecryptionClientV2_migration01 provides a more advanced migration example for how users can
// migrate from the V1 decryption client to the V2 decryption client using more complex client construction.
func ExampleNewDecryptionClientV2_migration01() {
	sess := session.Must(session.NewSession())
	// Construction of an decryption client must be done using NewDecryptionClientV2
	// The V2 decryption client is able to decrypt object encrypted by the V1 client.
	//
	// decryptionClient := s3crypto.NewDecryptionClient(sess, func(o *s3crypto.DecryptionClient) {
	//	 o.S3Client = s3.New(sess, &aws.Config{Region: aws.String(""us-west-2"")})
	//})
	decryptionClient := s3crypto.NewDecryptionClientV2(sess, func(o *s3crypto.DecryptionClientOptions) {
		o.S3Client = s3.New(sess, &aws.Config{Region: aws.String(""us-west-2"")})
	})
	getObject, err := decryptionClient.GetObject(&s3.GetObjectInput{
		Bucket: aws.String(""your_bucket""),
		Key:    aws.String(""your_key""),
	})
	if err != nil {
		fmt.Printf(""get object error: %v\n"", err)
		return
	}
	_, err = ioutil.ReadAll(getObject.Body)
	if err != nil {
		fmt.Printf(""error reading object: %v\n"", err)
	}
	fmt.Println(""get object completed"")
}
",CWE-326,149.0,0
"package version
import ""testing""
func TestIsVersionGreaterOrEqualThan(t *testing.T) {
	tests := []struct {
		version string
		target  string
		want    bool
	}{
		{
			version: ""0.9.1"",
			target:  ""0.9.1"",
			want:    true,
		},
		{
			version: ""0.10.0"",
			target:  ""0.9.1"",
			want:    true,
		},
		{
			version: ""0.9.0"",
			target:  ""0.9.1"",
			want:    false,
		},
	}
	for _, test := range tests {
		result := IsVersionGreaterOrEqualThan(test.version, test.target)
		if result != test.want {
			t.Errorf(""got result %v, want %v."", result, test.want)
		}
	}
}
",CWE-79,34.0,0
"package gocvss20_test
import (
	""testing""
	gocvss20 ""github.com/pandatix/go-cvss/20""
)
var Gcvss20 *gocvss20.CVSS20
var Gerr error
func BenchmarkParseVector_Base(b *testing.B) {
	benchmarkParseVector(""AV:N/AC:L/Au:N/C:P/I:P/A:C"", b)
}
func BenchmarkParseVector_WithTempAndEnv(b *testing.B) {
	benchmarkParseVector(""AV:N/AC:L/Au:N/C:P/I:P/A:C/E:U/RL:OF/RC:C/CDP:MH/TD:H/CR:M/IR:M/AR:M"", b)
}
func benchmarkParseVector(vector string, b *testing.B) {
	var cvss20 *gocvss20.CVSS20
	var err error
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		cvss20, err = gocvss20.ParseVector(vector)
	}
	Gcvss20 = cvss20
	Gerr = err
}
var Gstr string
func BenchmarkCVSS20Vector(b *testing.B) {
	cvss20, _ := gocvss20.ParseVector(""AV:N/AC:L/Au:N/C:P/I:P/A:C/E:U/RL:OF/RC:C/CDP:MH/TD:H/CR:M/IR:M/AR:M"")
	var str string
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		str = cvss20.Vector()
	}
	Gstr = str
}
var Gget string
func BenchmarkCVSS20Get(b *testing.B) {
	const abv = ""Au""
	cvss20, _ := gocvss20.ParseVector(""AV:N/AC:L/Au:N/C:P/I:P/A:C/E:U/RL:OF/RC:C/CDP:MH/TD:H/CR:M/IR:M/AR:M"")
	var get string
	var err error
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		get, err = cvss20.Get(abv)
	}
	Gget = get
	Gerr = err
}
func BenchmarkCVSS20Set(b *testing.B) {
	const abv = ""Au""
	const value = ""S""
	cvss20, _ := gocvss20.ParseVector(""AV:N/AC:L/Au:N/C:P/I:P/A:C/E:U/RL:OF/RC:C/CDP:MH/TD:H/CR:M/IR:M/AR:M"")
	var err error
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		err = cvss20.Set(abv, value)
	}
	Gerr = err
}
var Gscore float64
func BenchmarkCVSS20BaseScore(b *testing.B) {
	var score float64
	cvss20, _ := gocvss20.ParseVector(""AV:N/AC:L/Au:N/C:P/I:P/A:C/E:U/RL:OF/RC:C/CDP:MH/TD:H/CR:M/IR:M/AR:M"")
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		score = cvss20.BaseScore()
	}
	Gscore = score
}
func BenchmarkCVSS20TemporalScore(b *testing.B) {
	var score float64
	cvss20, _ := gocvss20.ParseVector(""AV:N/AC:L/Au:N/C:P/I:P/A:C/E:U/RL:OF/RC:C/CDP:MH/TD:H/CR:M/IR:M/AR:M"")
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		score = cvss20.TemporalScore()
	}
	Gscore = score
}
func BenchmarkCVSS20EnvironmentalScore(b *testing.B) {
	var score float64
	cvss20, _ := gocvss20.ParseVector(""AV:N/AC:L/Au:N/C:P/I:P/A:C/E:U/RL:OF/RC:C/CDP:MH/TD:H/CR:M/IR:M/AR:M"")
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		score = cvss20.EnvironmentalScore()
	}
	Gscore = score
}
",CWE-125,101.0,0
"package saml
import (
	""compress/flate""
	""fmt""
	""io""
)
const flateUncompressLimit = 10 * 1024 * 1024 // 10MB
func newSaferFlateReader(r io.Reader) io.ReadCloser {
	return &saferFlateReader{r: flate.NewReader(r)}
}
type saferFlateReader struct {
	r     io.ReadCloser
	count int
}
func (r *saferFlateReader) Read(p []byte) (n int, err error) {
	if r.count+len(p) > flateUncompressLimit {
		return 0, fmt.Errorf(""flate: uncompress limit exceeded (%d bytes)"", flateUncompressLimit)
	}
	n, err = r.r.Read(p)
	r.count += n
	return n, err
}
func (r *saferFlateReader) Close() error {
	return r.r.Close()
}
",CWE-770,32.0,0
"// Copyright 2020-2021 Clastix Labs
// SPDX-License-Identifier: Apache-2.0
package utils
import (
	""fmt""
	""sort""
	""strings""
	capsulev1beta1 ""github.com/clastix/capsule/api/v1beta1""
)
const (
	NodeSelectorAnnotation = ""scheduler.alpha.kubernetes.io/node-selector""
)
func BuildNodeSelector(tnt *capsulev1beta1.Tenant, nsAnnotations map[string]string) map[string]string {
	if nsAnnotations == nil {
		nsAnnotations = make(map[string]string)
	}
	selector := make([]string, 0, len(tnt.Spec.NodeSelector))
	for k, v := range tnt.Spec.NodeSelector {
		selector = append(selector, fmt.Sprintf(""%s=%s"", k, v))
	}
	// Sorting the resulting slice: iterating over maps is randomized, and we could end-up
	// in multiple reconciliations upon multiple node selectors.
	sort.Strings(selector)
	nsAnnotations[NodeSelectorAnnotation] = strings.Join(selector, "","")
	return nsAnnotations
}
",CWE-863,36.0,0
"// Copyright 2020-2021 Clastix Labs
// SPDX-License-Identifier: Apache-2.0
package namespace
import (
	""context""
	""fmt""
	""net/http""
	corev1 ""k8s.io/api/core/v1""
	""k8s.io/client-go/tools/record""
	""sigs.k8s.io/controller-runtime/pkg/client""
	""sigs.k8s.io/controller-runtime/pkg/webhook/admission""
	capsulewebhook ""github.com/clastix/capsule/pkg/webhook""
	""github.com/clastix/capsule/pkg/webhook/utils""
)
type ownerReferenceHandler struct{}
func OwnerReferenceHandler() capsulewebhook.Handler {
	return &ownerReferenceHandler{}
}
func (r *ownerReferenceHandler) OnCreate(client.Client, *admission.Decoder, record.EventRecorder) capsulewebhook.Func {
	return func(ctx context.Context, req admission.Request) *admission.Response {
		return nil
	}
}
func (r *ownerReferenceHandler) OnDelete(client.Client, *admission.Decoder, record.EventRecorder) capsulewebhook.Func {
	return func(ctx context.Context, req admission.Request) *admission.Response {
		return nil
	}
}
func (r *ownerReferenceHandler) OnUpdate(_ client.Client, decoder *admission.Decoder, _ record.EventRecorder) capsulewebhook.Func {
	return func(ctx context.Context, req admission.Request) *admission.Response {
		oldNs := &corev1.Namespace{}
		if err := decoder.DecodeRaw(req.OldObject, oldNs); err != nil {
			return utils.ErroredResponse(err)
		}
		newNs := &corev1.Namespace{}
		if err := decoder.Decode(req, newNs); err != nil {
			return utils.ErroredResponse(err)
		}
		if len(newNs.OwnerReferences) == 0 {
			response := admission.Errored(http.StatusBadRequest, fmt.Errorf(""the OwnerReference cannot be removed""))
			return &response
		}
		if oldNs.GetOwnerReferences()[0].UID != newNs.GetOwnerReferences()[0].UID {
			response := admission.Errored(http.StatusBadRequest, fmt.Errorf(""the OwnerReference cannot be changed""))
			return &response
		}
		return nil
	}
}
",CWE-863,65.0,0
"//go:build e2e
// Copyright 2020-2021 Clastix Labs
// SPDX-License-Identifier: Apache-2.0
package e2e
import (
	""context""
	""fmt""
	""time""
	. ""github.com/onsi/ginkgo""
	. ""github.com/onsi/gomega""
	rbacv1 ""k8s.io/api/rbac/v1""
	metav1 ""k8s.io/apimachinery/pkg/apis/meta/v1""
	""k8s.io/apimachinery/pkg/types""
	""k8s.io/apimachinery/pkg/util/uuid""
	""k8s.io/client-go/kubernetes""
	""sigs.k8s.io/controller-runtime/pkg/client/config""
	capsulev1beta1 ""github.com/clastix/capsule/api/v1beta1""
)
var _ = Describe(""trying to escalate from a Tenant Namespace ServiceAccount"", func() {
	tnt := &capsulev1beta1.Tenant{
		ObjectMeta: metav1.ObjectMeta{
			Name: ""sa-privilege-escalation"",
		},
		Spec: capsulev1beta1.TenantSpec{
			Owners: capsulev1beta1.OwnerListSpec{
				{
					Name: ""mario"",
					Kind: ""User"",
				},
			},
			NodeSelector: map[string]string{
				""kubernetes.io/os"": ""linux"",
			},
		},
	}
	ns := NewNamespace(""attack"")
	JustBeforeEach(func() {
		EventuallyCreation(func() error {
			return k8sClient.Create(context.TODO(), tnt)
		}).Should(Succeed())
		NamespaceCreation(ns, tnt.Spec.Owners[0], defaultTimeoutInterval).Should(Succeed())
		TenantNamespaceList(tnt, defaultTimeoutInterval).Should(ContainElement(ns.GetName()))
	})
	JustAfterEach(func() {
		Expect(k8sClient.Delete(context.TODO(), tnt)).Should(Succeed())
	})
	It(""should block Namespace changes"", func() {
		role := rbacv1.Role{
			ObjectMeta: metav1.ObjectMeta{
				Name:      ""ns-update-role"",
				Namespace: ns.GetName(),
			},
			Rules: []rbacv1.PolicyRule{
				{
					Verbs:         []string{""update""},
					APIGroups:     []string{""""},
					Resources:     []string{""namespaces""},
					ResourceNames: []string{ns.GetName()},
				},
			},
		}
		EventuallyCreation(func() error {
			return k8sClient.Create(context.Background(), &role)
		}).Should(Succeed())
		rolebinding := rbacv1.RoleBinding{
			ObjectMeta: metav1.ObjectMeta{
				Name:      ""attacker-rolebinding"",
				Namespace: ns.GetName(),
			},
			Subjects: []rbacv1.Subject{
				{
					Kind:      ""ServiceAccount"",
					Name:      ""attacker"",
					Namespace: ns.GetName(),
				},
			},
			RoleRef: rbacv1.RoleRef{
				APIGroup: ""rbac.authorization.k8s.io"",
				Kind:     ""Role"",
				Name:     role.GetName(),
			},
		}
		EventuallyCreation(func() error {
			return k8sClient.Create(context.Background(), &rolebinding)
		}).Should(Succeed())
		c, err := config.GetConfig()
		Expect(err).ToNot(HaveOccurred())
		c.Impersonate.Groups = []string{""system:serviceaccounts""}
		c.Impersonate.UserName = fmt.Sprintf(""system:serviceaccount:%s:%s"", rolebinding.Subjects[0].Namespace, rolebinding.Subjects[0].Name)
		saClient, err := kubernetes.NewForConfig(c)
		Expect(err).ToNot(HaveOccurred())
		// Changing Owner Reference is forbidden
		Consistently(func() error {
			if err := k8sClient.Get(context.Background(), types.NamespacedName{Name: ns.GetName()}, ns); err != nil {
				return err
			}
			ns.OwnerReferences[0].UID = uuid.NewUUID()
			_, err = saClient.CoreV1().Namespaces().Update(context.Background(), ns, metav1.UpdateOptions{})
			return err
		}, 10*time.Second, time.Second).ShouldNot(Succeed())
		// Removing Owner Reference is forbidden
		Consistently(func() error {
			if err := k8sClient.Get(context.Background(), types.NamespacedName{Name: ns.GetName()}, ns); err != nil {
				return err
			}
			ns.SetOwnerReferences(nil)
			_, err = saClient.CoreV1().Namespaces().Update(context.Background(), ns, metav1.UpdateOptions{})
			return err
		}, 10*time.Second, time.Second).ShouldNot(Succeed())
		// Breaking nodeSelector is forbidden
		Consistently(func() error {
			if err := k8sClient.Get(context.Background(), types.NamespacedName{Name: ns.GetName()}, ns); err != nil {
				return err
			}
			ns.SetAnnotations(map[string]string{
				""scheduler.alpha.kubernetes.io/node-selector"": ""kubernetes.io/os=forbidden"",
			})
			_, err = saClient.CoreV1().Namespaces().Update(context.Background(), ns, metav1.UpdateOptions{})
			return err
		}, 10*time.Second, time.Second).ShouldNot(Succeed())
	})
})
",CWE-863,147.0,0
"//go:build ocr
// +build ocr
package docconv
import (
	""os""
	""testing""
)
func TestPDFHasImage_CannotExecuteCode(t *testing.T) {
	// Try to inject code by passing a bad file path.
	// If the code was successful it will create a file called foo in the working directory
	badFilePath := ""$(id >> foo).pdf""
	if got, want := PDFHasImage(badFilePath), false; got != want {
		t.Errorf(""got %v, want %v"", got, want)
	}
	if got, want := fileExists(""foo""), false; got != want {
		t.Errorf(""got bad file exists, want not file to exist"")
	}
}
func fileExists(filename string) bool {
	info, err := os.Stat(filename)
	if os.IsNotExist(err) {
		return false
	}
	return !info.IsDir()
}
",CWE-78,31.0,0
"package migrations
import (
	""fmt""
	""github.com/answerdev/answer/internal/entity""
	""github.com/segmentfault/pacman/log""
	""xorm.io/xorm""
)
func updateAcceptAnswerRank(x *xorm.Engine) error {
	c := &entity.Config{ID: 44, Key: ""rank.answer.accept"", Value: `-1`}
	if _, err := x.Update(c, &entity.Config{ID: 44, Key: ""rank.answer.accept""}); err != nil {
		log.Errorf(""update %+v config failed: %s"", c, err)
		return fmt.Errorf(""update config failed: %w"", err)
	}
	return nil
}
",CWE-862,19.0,0
"package kubelet
import (
	""github.com/pkg/errors""
	""k8s.io/client-go/kubernetes""
	""k8s.io/client-go/tools/clientcmd""
)
// InitNodeAuthorizedClient initializes node authorized client with kubelet's kube config.
// This is now an available workaround to implement a node-scoped daemonset.
// See discussion https://github.com/kubernetes/enhancements/pull/944
func InitNodeAuthorizedClient(kubeletKubeConfigPath string) (*kubernetes.Clientset, error) {
	config, err := clientcmd.BuildConfigFromFlags("""", kubeletKubeConfigPath)
	if err != nil {
		return nil, errors.Wrapf(err, ""fail to build kubelet config"")
	}
	client, err := kubernetes.NewForConfig(config)
	if err != nil {
		return nil, errors.Wrap(err, ""fail to build client-go client from kubelet kubeconfig"")
	}
	return client, nil
}
",CWE-863,25.0,0
"// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package filtergen
import (
	ci ""github.com/GoogleCloudPlatform/esp-v2/src/go/configinfo""
	hspb ""github.com/GoogleCloudPlatform/esp-v2/src/go/proto/api/envoy/v11/http/header_sanitizer""
	""github.com/GoogleCloudPlatform/esp-v2/src/go/util""
	""github.com/GoogleCloudPlatform/esp-v2/src/go/util/httppattern""
	hcmpb ""github.com/envoyproxy/go-control-plane/envoy/extensions/filters/network/http_connection_manager/v3""
	""github.com/golang/protobuf/ptypes""
	anypb ""github.com/golang/protobuf/ptypes/any""
)
type HeaderSanitizerGenerator struct{}
func (g *HeaderSanitizerGenerator) FilterName() string {
	return util.HeaderSanitizerScrubber
}
func (g *HeaderSanitizerGenerator) IsEnabled() bool {
	return true
}
func (g *HeaderSanitizerGenerator) GenFilterConfig(serviceInfo *ci.ServiceInfo) (*hcmpb.HttpFilter, error) {
	a, err := ptypes.MarshalAny(&hspb.FilterConfig{})
	if err != nil {
		return nil, err
	}
	return &hcmpb.HttpFilter{
		Name:       g.FilterName(),
		ConfigType: &hcmpb.HttpFilter_TypedConfig{TypedConfig: a},
	}, nil
}
func (g *HeaderSanitizerGenerator) GenPerRouteConfig(method *ci.MethodInfo, httpRule *httppattern.Pattern) (*anypb.Any, error) {
	return nil, nil
}
",CWE-287,51.0,0
"/*
Copyright 2022 labring.
Licensed under the Apache License, Version 2.0 (the ""License"");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an ""AS IS"" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package controllers
import (
	""context""
	""github.com/go-logr/logr""
	""github.com/labring/sealos/controllers/user/controllers/helper""
	v1 ""k8s.io/api/core/v1""
	""k8s.io/apimachinery/pkg/runtime""
	""k8s.io/client-go/tools/record""
	""k8s.io/client-go/util/retry""
	ctrl ""sigs.k8s.io/controller-runtime""
	""sigs.k8s.io/controller-runtime/pkg/builder""
	""sigs.k8s.io/controller-runtime/pkg/client""
	""sigs.k8s.io/controller-runtime/pkg/controller/controllerutil""
	""sigs.k8s.io/controller-runtime/pkg/predicate""
	""strings""
)
// NamespaceReconciler reconciles a Namespace object
type NamespaceReconciler struct {
	Logger   logr.Logger
	Recorder record.EventRecorder
	*runtime.Scheme
	client.Client
}
// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the cluster closer to the desired state.
// TODO(user): Modify the Reconcile function to compare the state specified by
// the User object against the actual cluster state, and then
// perform operations to make the cluster state reflect the state specified by
// the user.
//
// For more details, check Reconcile and its Result here:
// - https://pkg.go.dev/sigs.k8s.io/controller-runtime@v0.12.2/pkg/reconcile
func (r *NamespaceReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	r.Logger.V(1).Info(""start reconcile for ns"")
	ns := &v1.Namespace{}
	if err := r.Get(ctx, req.NamespacedName, ns); err != nil {
		return ctrl.Result{}, client.IgnoreNotFound(err)
	}
	if strings.HasPrefix(ns.Name, ""ns-"") {
		err := retry.RetryOnConflict(retry.DefaultRetry, func() error {
			change, err := controllerutil.CreateOrUpdate(ctx, r.Client, ns, func() error {
				if ns.Labels == nil {
					ns.Labels = map[string]string{}
				}
				ns.Labels = helper.SetPodSecurity(ns.Labels)
				return nil
			})
			if err != nil {
				return err
			}
			r.Logger.V(1).Info(""create or update ns"", ""change"", change, ""ns"", ns.Name)
			return nil
		})
		if err != nil {
			r.Logger.Error(err, ""create or update ns error"", ""ns"", ns.Name)
			return ctrl.Result{}, err
		}
	}
	return ctrl.Result{}, nil
}
// SetupWithManager sets up the controller with the Manager.
func (r *NamespaceReconciler) SetupWithManager(mgr ctrl.Manager) error {
	const controllerName = ""namespace_controller""
	if r.Client == nil {
		r.Client = mgr.GetClient()
	}
	r.Logger = ctrl.Log.WithName(controllerName)
	if r.Recorder == nil {
		r.Recorder = mgr.GetEventRecorderFor(controllerName)
	}
	r.Scheme = mgr.GetScheme()
	r.Logger.V(1).Info(""init reconcile controller namespace"")
	return ctrl.NewControllerManagedBy(mgr).
		For(&v1.Namespace{}, builder.WithPredicates(
			predicate.Or(predicate.AnnotationChangedPredicate{}, predicate.LabelChangedPredicate{}))).
		Complete(r)
}
",CWE-863,100.0,0
"package gosnowflake
import (
	""net/url""
	""regexp""
)
var (
	matcher, _ = regexp.Compile(`^http(s?)\:\/\/[0-9a-zA-Z]([-.\w]*[0-9a-zA-Z@:])*(:(0-9)*)*(\/?)([a-zA-Z0-9\-\.\?\,\&\(\)\/\\\+&%\$
)
func isValidURL(targetURL string) bool {
	if !matcher.MatchString(targetURL) {
		logger.Infof("" The provided URL is not a valid URL - "" + targetURL)
		return false
	}
	return true
}
func urlEncode(targetString string) string {
	// We use QueryEscape instead of PathEscape here
	// for consistency across Drivers. For example:
	// QueryEscape escapes space as ""+"" whereas PE
	// it as %20F. PE also does not escape @ or &
	// either but QE does.
	// The behavior of QE in Golang is more in sync
	// with URL encoders in Python and Java hence the choice
	return url.QueryEscape(targetString)
}
",CWE-77,30.0,0
"// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @file ReaderHistory.h
 */
namespace eprosima {
namespace fastrtps {
namespace rtps {
class ReaderHistory
{
    public:
        ReaderHistory(const HistoryAttributes& /*att*/){}
};
} // namespace rtps
} // namespace fastrtps
} // namespace eprosima
",CWE-284,40.0,0
"// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @file WriterHistory.h
 */
namespace eprosima {
namespace fastrtps {
namespace rtps {
class WriterHistory
{
    public:
        WriterHistory(const HistoryAttributes& /*att*/){}
};
} // namespace rtps
} // namespace fastrtps
} // namespace eprosima
",CWE-284,41.0,0
"package regressiontests
import (
	""fmt""
	""math/big""
	""testing""
	""github.com/consensys/gnark/constraint/solver""
	""github.com/consensys/gnark/frontend""
	""github.com/consensys/gnark/std/math/cmp""
	""github.com/consensys/gnark/test""
)
type CmpCircuit struct {
	Left      frontend.Variable
	Right     frontend.Variable
	ExpCmpRes frontend.Variable
}
func (c *CmpCircuit) Define(api frontend.API) error {
	r := api.Cmp(c.Left, c.Right)
	api.AssertIsEqual(r, c.ExpCmpRes)
	return nil
}
type AssertIsLessOrEqCircuit struct {
	Smaller, Bigger frontend.Variable
}
func (c *AssertIsLessOrEqCircuit) Define(api frontend.API) error {
	api.AssertIsLessOrEqual(c.Smaller, c.Bigger)
	return nil
}
type MathCmpAssertIsLessOrEqCircuitBounded struct {
	Left  frontend.Variable
	Right frontend.Variable
}
func (c *MathCmpAssertIsLessOrEqCircuitBounded) Define(api frontend.API) error {
	cmper := cmp.NewBoundedComparator(api, big.NewInt(6), false)
	cmper.AssertIsLessEq(c.Left, c.Right)
	return nil
}
type MathCmpAssertIsLessOrEqCircuitFull struct {
	Left  frontend.Variable
	Right frontend.Variable
}
func (c *MathCmpAssertIsLessOrEqCircuitFull) Define(api frontend.API) error {
	api.AssertIsEqual(1, cmp.IsLessOrEqual(api, c.Left, c.Right))
	return nil
}
func getNBitsHint() (solver.HintID, error) {
	for _, v := range solver.GetRegisteredHints() {
		if solver.GetHintName(v) == ""github.com/consensys/gnark/std/math/bits.nBits"" {
			return solver.GetHintID(v), nil
		}
	}
	return 0, fmt.Errorf(""nBits hint not found"")
}
func TestIssue836Cmp(t *testing.T) {
	assert := test.NewAssert(t)
	assignmentNoHintGood := CmpCircuit{
		Left:      10,
		Right:     5,
		ExpCmpRes: 1,
	}
	assignmentNoHintBad := CmpCircuit{
		Left:      5,
		Right:     10,
		ExpCmpRes: 1,
	}
	assignmentHintBad := CmpCircuit{
		Left:      10,
		Right:     5,
		ExpCmpRes: -1,
	}
	toReplaceHint, err := getNBitsHint()
	if err != nil {
		t.Fatalf(""couldn't find hint to replace: %v"", err)
	}
	assert.CheckCircuit(&CmpCircuit{}, test.WithValidAssignment(&assignmentNoHintGood), test.WithInvalidAssignment(&assignmentNoHintBad))
	assert.CheckCircuit(&CmpCircuit{}, test.WithInvalidAssignment(&assignmentHintBad), test.NoTestEngine(), test.WithSolverOpts(solver.OverrideHint(toReplaceHint, maliciousNbitsHint)))
}
func TestIssue836AssertIsLess(t *testing.T) {
	assert := test.NewAssert(t)
	assignmentNoHintGood := AssertIsLessOrEqCircuit{
		Smaller: 5,
		Bigger:  10,
	}
	assignmentNoHintBad := AssertIsLessOrEqCircuit{
		Smaller: 11,
		Bigger:  10,
	}
	assignmentHintBad := AssertIsLessOrEqCircuit{
		Smaller: 10,
		Bigger:  5,
	}
	toReplaceHint, err := getNBitsHint()
	if err != nil {
		t.Fatalf(""couldn't find hint to replace: %v"", err)
	}
	assert.CheckCircuit(&AssertIsLessOrEqCircuit{}, test.WithValidAssignment(&assignmentNoHintGood), test.WithInvalidAssignment(&assignmentNoHintBad))
	assert.CheckCircuit(&AssertIsLessOrEqCircuit{}, test.WithInvalidAssignment(&assignmentHintBad), test.NoTestEngine(), test.WithSolverOpts(solver.OverrideHint(toReplaceHint, maliciousNbitsHint)))
}
func TestIssue836MathCmpAssertIsLessEqBounded(t *testing.T) {
	assert := test.NewAssert(t)
	assignmentNoHintGood := MathCmpAssertIsLessOrEqCircuitBounded{
		Left:  5,
		Right: 10,
	}
	assignmentNoHintBad := MathCmpAssertIsLessOrEqCircuitBounded{
		Left:  11,
		Right: 10,
	}
	assignmentHintBad := MathCmpAssertIsLessOrEqCircuitBounded{
		Left:  10,
		Right: 5,
	}
	toReplaceHint, err := getNBitsHint()
	if err != nil {
		t.Fatalf(""couldn't find hint to replace: %v"", err)
	}
	assert.CheckCircuit(&MathCmpAssertIsLessOrEqCircuitBounded{}, test.WithValidAssignment(&assignmentNoHintGood), test.WithInvalidAssignment(&assignmentNoHintBad))
	assert.CheckCircuit(&MathCmpAssertIsLessOrEqCircuitBounded{}, test.WithInvalidAssignment(&assignmentHintBad), test.NoTestEngine(), test.WithSolverOpts(solver.OverrideHint(toReplaceHint, maliciousNbitsHint)))
}
func TestIssueXXXMathCmpAssertIsLessEqFull(t *testing.T) {
	assert := test.NewAssert(t)
	assignmentNoHintGood := MathCmpAssertIsLessOrEqCircuitFull{
		Left:  5,
		Right: 10,
	}
	assignmentNoHintBad := MathCmpAssertIsLessOrEqCircuitFull{
		Left:  11,
		Right: 10,
	}
	assignmentHintBad := MathCmpAssertIsLessOrEqCircuitFull{
		Left:  10,
		Right: 5,
	}
	toReplaceHint, err := getNBitsHint()
	if err != nil {
		t.Fatalf(""couldn't find hint to replace: %v"", err)
	}
	assert.CheckCircuit(&MathCmpAssertIsLessOrEqCircuitFull{}, test.WithValidAssignment(&assignmentNoHintGood), test.WithInvalidAssignment(&assignmentNoHintBad))
	assert.CheckCircuit(&MathCmpAssertIsLessOrEqCircuitFull{}, test.WithInvalidAssignment(&assignmentHintBad), test.NoTestEngine(), test.WithSolverOpts(solver.OverrideHint(toReplaceHint, maliciousNbitsHint)))
}
func maliciousNbitsHint(mod *big.Int, inputs []*big.Int, results []*big.Int) error {
	n := inputs[0]
	// This is a malicious hint. If n is less equal than 5, then add the
	// modulus. This creates a non-unique binary decomposition of the value.
	if n.Cmp(big.NewInt(5)) <= 0 {
		n = n.Add(n, mod)
	}
	for i := 0; i < len(results); i++ {
		results[i].SetUint64(uint64(n.Bit(i)))
	}
	return nil
}
",CWE-191,168.0,0
"package regressiontests
import (
	""fmt""
	""math/big""
	""testing""
	""github.com/consensys/gnark/constraint/solver""
	""github.com/consensys/gnark/frontend""
	""github.com/consensys/gnark/std/math/cmp""
	""github.com/consensys/gnark/test""
)
type CmpCircuit struct {
	Left      frontend.Variable
	Right     frontend.Variable
	ExpCmpRes frontend.Variable
}
func (c *CmpCircuit) Define(api frontend.API) error {
	r := api.Cmp(c.Left, c.Right)
	api.AssertIsEqual(r, c.ExpCmpRes)
	return nil
}
type AssertIsLessOrEqCircuit struct {
	Smaller, Bigger frontend.Variable
}
func (c *AssertIsLessOrEqCircuit) Define(api frontend.API) error {
	api.AssertIsLessOrEqual(c.Smaller, c.Bigger)
	return nil
}
type MathCmpAssertIsLessOrEqCircuitBounded struct {
	Left  frontend.Variable
	Right frontend.Variable
}
func (c *MathCmpAssertIsLessOrEqCircuitBounded) Define(api frontend.API) error {
	cmper := cmp.NewBoundedComparator(api, big.NewInt(6), false)
	cmper.AssertIsLessEq(c.Left, c.Right)
	return nil
}
type MathCmpAssertIsLessOrEqCircuitFull struct {
	Left  frontend.Variable
	Right frontend.Variable
}
func (c *MathCmpAssertIsLessOrEqCircuitFull) Define(api frontend.API) error {
	api.AssertIsEqual(1, cmp.IsLessOrEqual(api, c.Left, c.Right))
	return nil
}
func getNBitsHint() (solver.HintID, error) {
	for _, v := range solver.GetRegisteredHints() {
		if solver.GetHintName(v) == ""github.com/consensys/gnark/std/math/bits.nBits"" {
			return solver.GetHintID(v), nil
		}
	}
	return 0, fmt.Errorf(""nBits hint not found"")
}
func TestIssue836Cmp(t *testing.T) {
	assert := test.NewAssert(t)
	assignmentNoHintGood := CmpCircuit{
		Left:      10,
		Right:     5,
		ExpCmpRes: 1,
	}
	assignmentNoHintBad := CmpCircuit{
		Left:      5,
		Right:     10,
		ExpCmpRes: 1,
	}
	assignmentHintBad := CmpCircuit{
		Left:      10,
		Right:     5,
		ExpCmpRes: -1,
	}
	toReplaceHint, err := getNBitsHint()
	if err != nil {
		t.Fatalf(""couldn't find hint to replace: %v"", err)
	}
	assert.CheckCircuit(&CmpCircuit{}, test.WithValidAssignment(&assignmentNoHintGood), test.WithInvalidAssignment(&assignmentNoHintBad))
	assert.CheckCircuit(&CmpCircuit{}, test.WithInvalidAssignment(&assignmentHintBad), test.NoTestEngine(), test.WithSolverOpts(solver.OverrideHint(toReplaceHint, maliciousNbitsHint)))
}
func TestIssue836AssertIsLess(t *testing.T) {
	assert := test.NewAssert(t)
	assignmentNoHintGood := AssertIsLessOrEqCircuit{
		Smaller: 5,
		Bigger:  10,
	}
	assignmentNoHintBad := AssertIsLessOrEqCircuit{
		Smaller: 11,
		Bigger:  10,
	}
	assignmentHintBad := AssertIsLessOrEqCircuit{
		Smaller: 10,
		Bigger:  5,
	}
	toReplaceHint, err := getNBitsHint()
	if err != nil {
		t.Fatalf(""couldn't find hint to replace: %v"", err)
	}
	assert.CheckCircuit(&AssertIsLessOrEqCircuit{}, test.WithValidAssignment(&assignmentNoHintGood), test.WithInvalidAssignment(&assignmentNoHintBad))
	assert.CheckCircuit(&AssertIsLessOrEqCircuit{}, test.WithInvalidAssignment(&assignmentHintBad), test.NoTestEngine(), test.WithSolverOpts(solver.OverrideHint(toReplaceHint, maliciousNbitsHint)))
}
func TestIssue836MathCmpAssertIsLessEqBounded(t *testing.T) {
	assert := test.NewAssert(t)
	assignmentNoHintGood := MathCmpAssertIsLessOrEqCircuitBounded{
		Left:  5,
		Right: 10,
	}
	assignmentNoHintBad := MathCmpAssertIsLessOrEqCircuitBounded{
		Left:  11,
		Right: 10,
	}
	assignmentHintBad := MathCmpAssertIsLessOrEqCircuitBounded{
		Left:  10,
		Right: 5,
	}
	toReplaceHint, err := getNBitsHint()
	if err != nil {
		t.Fatalf(""couldn't find hint to replace: %v"", err)
	}
	assert.CheckCircuit(&MathCmpAssertIsLessOrEqCircuitBounded{}, test.WithValidAssignment(&assignmentNoHintGood), test.WithInvalidAssignment(&assignmentNoHintBad))
	assert.CheckCircuit(&MathCmpAssertIsLessOrEqCircuitBounded{}, test.WithInvalidAssignment(&assignmentHintBad), test.NoTestEngine(), test.WithSolverOpts(solver.OverrideHint(toReplaceHint, maliciousNbitsHint)))
}
func TestIssueXXXMathCmpAssertIsLessEqFull(t *testing.T) {
	assert := test.NewAssert(t)
	assignmentNoHintGood := MathCmpAssertIsLessOrEqCircuitFull{
		Left:  5,
		Right: 10,
	}
	assignmentNoHintBad := MathCmpAssertIsLessOrEqCircuitFull{
		Left:  11,
		Right: 10,
	}
	assignmentHintBad := MathCmpAssertIsLessOrEqCircuitFull{
		Left:  10,
		Right: 5,
	}
	toReplaceHint, err := getNBitsHint()
	if err != nil {
		t.Fatalf(""couldn't find hint to replace: %v"", err)
	}
	assert.CheckCircuit(&MathCmpAssertIsLessOrEqCircuitFull{}, test.WithValidAssignment(&assignmentNoHintGood), test.WithInvalidAssignment(&assignmentNoHintBad))
	assert.CheckCircuit(&MathCmpAssertIsLessOrEqCircuitFull{}, test.WithInvalidAssignment(&assignmentHintBad), test.NoTestEngine(), test.WithSolverOpts(solver.OverrideHint(toReplaceHint, maliciousNbitsHint)))
}
func maliciousNbitsHint(mod *big.Int, inputs []*big.Int, results []*big.Int) error {
	n := inputs[0]
	// This is a malicious hint. If n is less equal than 5, then add the
	// modulus. This creates a non-unique binary decomposition of the value.
	if n.Cmp(big.NewInt(5)) <= 0 {
		n = n.Add(n, mod)
	}
	for i := 0; i < len(results); i++ {
		results[i].SetUint64(uint64(n.Bit(i)))
	}
	return nil
}
",CWE-697,168.0,0
"//
// Copyright 2023 The Sigstore Authors.
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package rekor
import (
	""context""
	""github.com/sigstore/cosign/v2/pkg/cosign""
	""github.com/sigstore/rekor/pkg/client""
)
type Option func(*options)
type options struct {
	rekorPublicKeys CosignRekorKeyProvider
	clientOpts      []client.Option
}
// CosignRekorKeyProvider is a function that returns the Rekor public keys in cosign's specialized format.
type CosignRekorKeyProvider func(ctx context.Context) (*cosign.TrustedTransparencyLogPubKeys, error)
func WithCosignRekorKeyProvider(f CosignRekorKeyProvider) Option {
	return func(o *options) {
		o.rekorPublicKeys = f
	}
}
func WithClientOption(opts ...client.Option) Option {
	return func(o *options) {
		o.clientOpts = opts
	}
}
",CWE-347,46.0,0
"package config_test
import (
	""testing""
	. ""github.com/onsi/ginkgo/v2""
	. ""github.com/onsi/gomega""
)
func TestConfig(t *testing.T) {
	RegisterFailHandler(Fail)
	RunSpecs(t, ""Config test suite"")
}
",CWE-78,14.0,0
"package config_test
import (
	""testing""
	. ""github.com/onsi/ginkgo/v2""
	. ""github.com/onsi/gomega""
)
func TestConfig(t *testing.T) {
	RegisterFailHandler(Fail)
	RunSpecs(t, ""Config test suite"")
}
",CWE-22,14.0,0
